\hypertarget{classMaxOS_1_1processes_1_1Elf64}{}\doxysection{Max\+OS\+::processes\+::Elf64 Class Reference}
\label{classMaxOS_1_1processes_1_1Elf64}\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}


{\ttfamily \#include $<$elf.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_afe12878773ede304094c21c8b82284dc}{Elf64}} (uintptr\+\_\+t elf\+\_\+header\+\_\+address)
\begin{DoxyCompactList}\small\item\em Constructor for the \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64}{Elf64}} class. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a8a834ce8cc8c24eaf4ad0c9d6b08b16b}{$\sim$\+Elf64}} ()
\begin{DoxyCompactList}\small\item\em Destructor for the \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64}{Elf64}} class. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a911f91e8c53705ab6309c8aff83fe2d0}{load}} ()
\begin{DoxyCompactList}\small\item\em Loads the elf program into memory if a valid elf file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a3cd39d79f5b60621dc69839866fe3bd4}{is\+\_\+valid}} ()
\begin{DoxyCompactList}\small\item\em Checks if the elf file is valid for \mbox{\hyperlink{namespaceMaxOS}{Max\+OS}} runtime. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__header__t}{elf\+\_\+64\+\_\+header\+\_\+t}} $\ast$ \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\+\_\+header}} ()
\begin{DoxyCompactList}\small\item\em Gets the header of the elf file. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__program__header__t}{elf\+\_\+64\+\_\+program\+\_\+header\+\_\+t}} $\ast$ \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a35e3a6dfa311be974070e47e5ba541e2}{get\+\_\+program\+\_\+header}} (size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Gets a program header from the elf file. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__section__header__t}{elf\+\_\+64\+\_\+section\+\_\+header\+\_\+t}} $\ast$ \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a9e08e709ae22eef3fd316c1ea43d2e9b}{get\+\_\+section\+\_\+header}} (size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Gets a section header from the elf file. \end{DoxyCompactList}\item 
uint64\+\_\+t \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a9bad9143e7d3667895a6659ec7a37c95}{to\+\_\+vmm\+\_\+flags}} (uint32\+\_\+t \mbox{\hyperlink{icmp_8h_a1d127017fb298b889f4ba24752d08b8e}{type}})
\begin{DoxyCompactList}\small\item\em Converts elf flags to vmm flags. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line 149 of file elf.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_afe12878773ede304094c21c8b82284dc}\label{classMaxOS_1_1processes_1_1Elf64_afe12878773ede304094c21c8b82284dc}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!Elf64@{Elf64}}
\index{Elf64@{Elf64}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{Elf64()}{Elf64()}}
{\footnotesize\ttfamily Elf64\+::\+Elf64 (\begin{DoxyParamCaption}\item[{uintptr\+\_\+t}]{elf\+\_\+header\+\_\+address }\end{DoxyParamCaption})}



Constructor for the \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64}{Elf64}} class. 


\begin{DoxyParams}{Parameters}
{\em elf\+\_\+header\+\_\+address} & The address of the elf header, this must be mapped to memory before uses \\
\hline
\end{DoxyParams}


Definition at line 19 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{20 : m\_elf\_header\_address(elf\_header\_address)}
\DoxyCodeLine{21 \{}
\DoxyCodeLine{22 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a8a834ce8cc8c24eaf4ad0c9d6b08b16b}\label{classMaxOS_1_1processes_1_1Elf64_a8a834ce8cc8c24eaf4ad0c9d6b08b16b}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!````~Elf64@{$\sim$Elf64}}
\index{````~Elf64@{$\sim$Elf64}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{$\sim$Elf64()}{~Elf64()}}
{\footnotesize\ttfamily Elf64\+::$\sim$\+Elf64 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Destructor for the \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64}{Elf64}} class. 



Definition at line 27 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{28 \{}
\DoxyCodeLine{29 \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}\label{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!get\_header@{get\_header}}
\index{get\_header@{get\_header}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{get\_header()}{get\_header()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__header__t}{elf\+\_\+64\+\_\+header\+\_\+t}} $\ast$ Elf64\+::get\+\_\+header (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Gets the header of the elf file. 

\begin{DoxyReturn}{Returns}
The header of the elf file 
\end{DoxyReturn}


Definition at line 49 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{49                                    \{}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{comment}{// Return the header}}
\DoxyCodeLine{52   \textcolor{keywordflow}{return} (\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__header__t}{elf\_64\_header\_t}}*)m\_elf\_header\_address;}
\DoxyCodeLine{53 \}}

\end{DoxyCode}


Referenced by get\+\_\+program\+\_\+header(), get\+\_\+section\+\_\+header(), and is\+\_\+valid().

\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a35e3a6dfa311be974070e47e5ba541e2}\label{classMaxOS_1_1processes_1_1Elf64_a35e3a6dfa311be974070e47e5ba541e2}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!get\_program\_header@{get\_program\_header}}
\index{get\_program\_header@{get\_program\_header}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{get\_program\_header()}{get\_program\_header()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__program__header__t}{elf\+\_\+64\+\_\+program\+\_\+header\+\_\+t}} $\ast$ Elf64\+::get\+\_\+program\+\_\+header (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}



Gets a program header from the elf file. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the program header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The program header at that index or nullptr if out of bounds 
\end{DoxyReturn}


Definition at line 61 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{61                                                                \{}
\DoxyCodeLine{62 }
\DoxyCodeLine{63   \textcolor{comment}{// Check if within bounds}}
\DoxyCodeLine{64   \textcolor{keywordflow}{if}(index >= \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> program\_header\_count) \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{65 }
\DoxyCodeLine{66   \textcolor{comment}{// Get the address of the program headers}}
\DoxyCodeLine{67   \mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__program__header__t}{elf\_64\_program\_header\_t}}* program\_headers = (\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__program__header__t}{elf\_64\_program\_header\_t}}*)(m\_elf\_header\_address + \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> program\_header\_offset);}
\DoxyCodeLine{68 }
\DoxyCodeLine{69   \textcolor{comment}{// Return the requested program header}}
\DoxyCodeLine{70   \textcolor{keywordflow}{return} \&program\_headers[index];}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \}}

\end{DoxyCode}


References get\+\_\+header().

\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a9e08e709ae22eef3fd316c1ea43d2e9b}\label{classMaxOS_1_1processes_1_1Elf64_a9e08e709ae22eef3fd316c1ea43d2e9b}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!get\_section\_header@{get\_section\_header}}
\index{get\_section\_header@{get\_section\_header}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{get\_section\_header()}{get\_section\_header()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__section__header__t}{elf\+\_\+64\+\_\+section\+\_\+header\+\_\+t}} $\ast$ Elf64\+::get\+\_\+section\+\_\+header (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}



Gets a section header from the elf file. 


\begin{DoxyParams}{Parameters}
{\em index} & The index of the section header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The section header at that index or nullptr if out of bounds 
\end{DoxyReturn}


Definition at line 80 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{80                                                                \{}
\DoxyCodeLine{81 }
\DoxyCodeLine{82   \textcolor{comment}{// Check if within bounds}}
\DoxyCodeLine{83   \textcolor{keywordflow}{if}(index >= \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> section\_header\_count) \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{84 }
\DoxyCodeLine{85   \textcolor{comment}{// Get the address of the section headers}}
\DoxyCodeLine{86   \mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__section__header__t}{elf\_64\_section\_header\_t}}* section\_headers = (\mbox{\hyperlink{structMaxOS_1_1processes_1_1elf__64__section__header__t}{elf\_64\_section\_header\_t}}*)(m\_elf\_header\_address + \mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> section\_header\_offset);}
\DoxyCodeLine{87 }
\DoxyCodeLine{88   \textcolor{comment}{// Return the requested section header}}
\DoxyCodeLine{89   \textcolor{keywordflow}{return} \&section\_headers[index];}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \}}

\end{DoxyCode}


References get\+\_\+header().

\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a3cd39d79f5b60621dc69839866fe3bd4}\label{classMaxOS_1_1processes_1_1Elf64_a3cd39d79f5b60621dc69839866fe3bd4}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!is\_valid@{is\_valid}}
\index{is\_valid@{is\_valid}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{is\_valid()}{is\_valid()}}
{\footnotesize\ttfamily bool Elf64\+::is\+\_\+valid (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Checks if the elf file is valid for \mbox{\hyperlink{namespaceMaxOS}{Max\+OS}} runtime. 



Definition at line 96 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{96                      \{}
\DoxyCodeLine{97 }
\DoxyCodeLine{98   \textcolor{comment}{// Validate the magic number}}
\DoxyCodeLine{99   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}} = 0; \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}} < 4; \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}++)}
\DoxyCodeLine{100     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> identification[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}] != elf\_magic[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}])}
\DoxyCodeLine{101       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \textcolor{comment}{// Check if the elf is 64 bit}}
\DoxyCodeLine{104   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> identification[\mbox{\hyperlink{namespaceMaxOS_1_1processes_a734e55c04254d19fb5117cd0d67ded73a629d6929d6eed45b50b150e235afe8c3}{Class}}] != \mbox{\hyperlink{namespaceMaxOS_1_1processes_a06110beb02e2bb6271a458e94d1e0a70a06f3477f6458906b9074a7c8e6fbc9da}{Class64}})}
\DoxyCodeLine{105     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{106 }
\DoxyCodeLine{107   \textcolor{comment}{// Check if the elf is little endian}}
\DoxyCodeLine{108   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> identification[\mbox{\hyperlink{namespaceMaxOS_1_1processes_a734e55c04254d19fb5117cd0d67ded73aadc0e69bbc3bf0b0cf40b7faad4c4d5a}{Data}}] != \mbox{\hyperlink{namespaceMaxOS_1_1processes_a464343547d01dc27b11ddda3139f260da9fa25f727aab6deabda2bf123ed7a85c}{LittleEndian}})}
\DoxyCodeLine{109     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{110 }
\DoxyCodeLine{111   \textcolor{comment}{// Check if the elf is version 1}}
\DoxyCodeLine{112   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> identification[\mbox{\hyperlink{namespaceMaxOS_1_1processes_a734e55c04254d19fb5117cd0d67ded73a87ab82cbc7d8d1849fd362927f696eb2}{Version}}] != \mbox{\hyperlink{namespaceMaxOS_1_1processes_ac1d3d25a34353241f191e2d7f9b308c2ac9c0c29ffeed24f6b8ecffca107510a7}{Current}})}
\DoxyCodeLine{113     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{114 }
\DoxyCodeLine{115   \textcolor{comment}{// Check if the elf is for the MaxOS platform}}
\DoxyCodeLine{116   \textcolor{comment}{//  if(get\_header() -\/> identification[OSABI] != MaxOSABI)}}
\DoxyCodeLine{117   \textcolor{comment}{//      return false; TODO: Would be nice to have an OSABI}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119   \textcolor{comment}{// Check if the elf is executable}}
\DoxyCodeLine{120   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> \mbox{\hyperlink{apic_8h_a1d127017fb298b889f4ba24752d08b8e}{type}} != \mbox{\hyperlink{namespaceMaxOS_1_1processes_a8f63cd8e5a34555b82702be420300163ae95fbb73118f1bb73936fdd1dc32abde}{Executable}})}
\DoxyCodeLine{121     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{122 }
\DoxyCodeLine{123   \textcolor{comment}{// Check if the elf is for the x86\_64 platform}}
\DoxyCodeLine{124   \textcolor{keywordflow}{if}(\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_abafc5f724426bd9aa71e34120aac271e}{get\_header}}() -\/> machine != \mbox{\hyperlink{namespaceMaxOS_1_1processes_ac453fd96e7e31d6aa7a874864dfc684baf2bcc51507b2a03525cc0b08b975179f}{x86\_64}})}
\DoxyCodeLine{125     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127   \textcolor{comment}{// LGTM}}
\DoxyCodeLine{128   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \}}

\end{DoxyCode}


References Max\+O\+S\+::processes\+::\+Class, Max\+O\+S\+::processes\+::\+Class64, Max\+O\+S\+::processes\+::\+Current, Max\+O\+S\+::processes\+::\+Data, Max\+O\+S\+::processes\+::\+Executable, get\+\_\+header(), Max\+O\+S\+::drivers\+::peripherals\+::i, Max\+O\+S\+::processes\+::\+Little\+Endian, type, Max\+O\+S\+::processes\+::\+Version, and Max\+O\+S\+::processes\+::x86\+\_\+64.



Referenced by load(), and Max\+O\+S\+::processes\+::\+Scheduler\+::load\+\_\+multiboot\+\_\+elfs().

\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a911f91e8c53705ab6309c8aff83fe2d0}\label{classMaxOS_1_1processes_1_1Elf64_a911f91e8c53705ab6309c8aff83fe2d0}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!load@{load}}
\index{load@{load}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{load()}{load()}}
{\footnotesize\ttfamily void Elf64\+::load (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Loads the elf program into memory if a valid elf file. 



Definition at line 34 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{34                  \{}
\DoxyCodeLine{35 }
\DoxyCodeLine{36   \textcolor{comment}{// Check if valid}}
\DoxyCodeLine{37   \textcolor{keywordflow}{if}(!\mbox{\hyperlink{classMaxOS_1_1processes_1_1Elf64_a3cd39d79f5b60621dc69839866fe3bd4}{is\_valid}}()) \textcolor{keywordflow}{return}; \textcolor{comment}{//TODO: error handling}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39   \textcolor{comment}{// Load the program headers}}
\DoxyCodeLine{40   load\_program\_headers();}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \}}

\end{DoxyCode}


References is\+\_\+valid().

\mbox{\Hypertarget{classMaxOS_1_1processes_1_1Elf64_a9bad9143e7d3667895a6659ec7a37c95}\label{classMaxOS_1_1processes_1_1Elf64_a9bad9143e7d3667895a6659ec7a37c95}} 
\index{MaxOS::processes::Elf64@{MaxOS::processes::Elf64}!to\_vmm\_flags@{to\_vmm\_flags}}
\index{to\_vmm\_flags@{to\_vmm\_flags}!MaxOS::processes::Elf64@{MaxOS::processes::Elf64}}
\doxysubsubsection{\texorpdfstring{to\_vmm\_flags()}{to\_vmm\_flags()}}
{\footnotesize\ttfamily uint64\+\_\+t Elf64\+::to\+\_\+vmm\+\_\+flags (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{type }\end{DoxyParamCaption})}



Converts elf flags to vmm flags. 


\begin{DoxyParams}{Parameters}
{\em type} & The elf flags of the program header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vmm flags 
\end{DoxyReturn}


Definition at line 175 of file elf.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{175                                           \{}
\DoxyCodeLine{176 }
\DoxyCodeLine{177   \textcolor{comment}{// Conversion}}
\DoxyCodeLine{178   \textcolor{comment}{// ELF   |   VMM}}
\DoxyCodeLine{179   \textcolor{comment}{// 0x0   |   Executable (not used)}}
\DoxyCodeLine{180   \textcolor{comment}{// 0x1   |   Write}}
\DoxyCodeLine{181   \textcolor{comment}{// 0x2   |   Read}}
\DoxyCodeLine{182 }
\DoxyCodeLine{183   uint64\_t \mbox{\hyperlink{amd__am79c973_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags}} = 0;}
\DoxyCodeLine{184 }
\DoxyCodeLine{185   \textcolor{keywordflow}{if}(\mbox{\hyperlink{apic_8h_a1d127017fb298b889f4ba24752d08b8e}{type}} \& \mbox{\hyperlink{namespaceMaxOS_1_1processes_a26e554e107e27bd8e0d15d6a80261f2da9b0db3e6d06c9d71fcee2cffa5138a9d}{ElfWrite}})}
\DoxyCodeLine{186       \mbox{\hyperlink{amd__am79c973_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags}} |= \mbox{\hyperlink{namespaceMaxOS_1_1memory_ae0e83b5743a37b4d0d2a93bb3bbe84ebabc3cb78aef6a50841121fd08c2a49151}{Write}};}
\DoxyCodeLine{187 }
\DoxyCodeLine{188 \textcolor{comment}{//  if(type \& ElfProgramFlags::Execute)}}
\DoxyCodeLine{189 \textcolor{comment}{//      flags |= PageFlags::Execute;}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191 }
\DoxyCodeLine{192   \textcolor{keywordflow}{return} \mbox{\hyperlink{amd__am79c973_8h_a1e87af3c18a2fd36c61faf89949bdc3f}{flags}};}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \}}

\end{DoxyCode}


References Max\+O\+S\+::processes\+::\+Elf\+Write, flags, type, and Max\+O\+S\+::memory\+::\+Write.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/runner/work/\+Max\+O\+S/\+Max\+O\+S/kernel/include/processes/\mbox{\hyperlink{elf_8h}{elf.\+h}}\item 
/home/runner/work/\+Max\+O\+S/\+Max\+O\+S/kernel/src/processes/\mbox{\hyperlink{elf_8cpp}{elf.\+cpp}}\end{DoxyCompactItemize}

\hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973}{}\doxysection{Max\+OS\+::drivers\+::ethernet\+::amd\+\_\+am79c973 Class Reference}
\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973}\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}


{\ttfamily \#include $<$amd\+\_\+am79c973.\+h$>$}

Inheritance diagram for Max\+OS\+::drivers\+::ethernet\+::amd\+\_\+am79c973\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.609195cm]{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a9d91b4bc93271b315f6dd713fac388fe}{amd\+\_\+am79c973}} (\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1PeripheralComponentInterconnectDeviceDescriptor}{hardwarecommunication\+::\+Peripheral\+Component\+Interconnect\+Device\+Descriptor}} $\ast$device\+Descriptor, \mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1InterruptManager}{hardwarecommunication\+::\+Interrupt\+Manager}} $\ast$interrupt\+Manager, \mbox{\hyperlink{classMaxOS_1_1common_1_1OutputStream}{common\+::\+Output\+Stream}} $\ast$amd\+Net\+Message\+Stream=0)
\item 
\mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_aacbc48386a4b5f36a63dc53b2f1bae2f}{$\sim$amd\+\_\+am79c973}} ()
\item 
uint32\+\_\+t \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acf6d4a68e3e74a4b23d5811f536cf26f}{reset}} ()
\begin{DoxyCompactList}\small\item\em This function resets the device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_af343f26c6a53c4336c68103a7425ef15}{activate}} ()
\begin{DoxyCompactList}\small\item\em This function activates the device and starts it (Runs when the driver-\/manger calls activate\+All()) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a087d7785cb300529b700522460a62751}{deactivate}} ()
\begin{DoxyCompactList}\small\item\em deactivate the driver \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceMaxOS_afa22b691550d34d82dd6a5e3f77b31cb}{string}} \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a013e544525f4aef5a4dc3aa7b0a682c2}{get\+\_\+vendor\+\_\+name}} ()
\begin{DoxyCompactList}\small\item\em Get the vendor name of the driver. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceMaxOS_afa22b691550d34d82dd6a5e3f77b31cb}{string}} \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a177e151fa19903dc2c733664883ac603}{get\+\_\+device\+\_\+name}} ()
\begin{DoxyCompactList}\small\item\em Get the device name of the driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_ac925036cea408af2cd3d120c639985d2}{handle\+\_\+interrupt}} ()
\begin{DoxyCompactList}\small\item\em This function handles the interrupt for the device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a47ce3c94382939df1c248c3a2ba206b6}{Do\+Send}} (uint8\+\_\+t $\ast$buffer, uint32\+\_\+t \mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}})
\begin{DoxyCompactList}\small\item\em This function sends a package. \end{DoxyCompactList}\item 
uint64\+\_\+t \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acd69d1f0897713631d40cf073926fed7}{Get\+Media\+Access\+Control\+Address}} ()
\begin{DoxyCompactList}\small\item\em This function gets the M\+AC address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}


Definition at line 28 of file amd\+\_\+am79c973.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a9d91b4bc93271b315f6dd713fac388fe}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a9d91b4bc93271b315f6dd713fac388fe}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!amd\_am79c973@{amd\_am79c973}}
\index{amd\_am79c973@{amd\_am79c973}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{amd\_am79c973()}{amd\_am79c973()}}
{\footnotesize\ttfamily amd\+\_\+am79c973\+::amd\+\_\+am79c973 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1PeripheralComponentInterconnectDeviceDescriptor}{hardwarecommunication\+::\+Peripheral\+Component\+Interconnect\+Device\+Descriptor}} $\ast$}]{device\+Descriptor,  }\item[{\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1InterruptManager}{hardwarecommunication\+::\+Interrupt\+Manager}} $\ast$}]{interrupt\+Manager,  }\item[{\mbox{\hyperlink{classMaxOS_1_1common_1_1OutputStream}{common\+::\+Output\+Stream}} $\ast$}]{amd\+Net\+Message\+Stream = {\ttfamily 0} }\end{DoxyParamCaption})}



Definition at line 14 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{15         :   \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1EthernetDriver_a2085e867decce4d6346ff21cb8215f31}{EthernetDriver}}(amdNetMessageStream),}
\DoxyCodeLine{16             \mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1InterruptHandler_a23513de3e722d6f7183a9b51b1d86c48}{InterruptHandler}}(dev -\/> interrupt + interrupts-\/>hardware\_interrupt\_offset(), interrupts),}
\DoxyCodeLine{17             MACAddress0Port(dev -\/>port\_base),}
\DoxyCodeLine{18             MACAddress2Port(dev -\/>port\_base + 0x02),}
\DoxyCodeLine{19             MACAddress4Port(dev -\/>port\_base + 0x04),}
\DoxyCodeLine{20             registerDataPort(dev -\/>port\_base + 0x10),}
\DoxyCodeLine{21             registerAddressPort(dev -\/>port\_base + 0x12),}
\DoxyCodeLine{22             busControlRegisterDataPort(dev -\/>port\_base + 0x16),}
\DoxyCodeLine{23             resetPort(dev -\/>port\_base + 0x14)}
\DoxyCodeLine{24 \{}
\DoxyCodeLine{25     \textcolor{comment}{// No active buffer at the start}}
\DoxyCodeLine{26     currentSendBuffer = 0;}
\DoxyCodeLine{27     currentRecvBuffer = 0;}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{comment}{//Not active or intialized}}
\DoxyCodeLine{30     active = \textcolor{keyword}{false};}
\DoxyCodeLine{31     initDone = \textcolor{keyword}{false};}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     \textcolor{comment}{// Get the MAC adresses (split up in little endian order)}}
\DoxyCodeLine{34     uint64\_t MAC0 = MACAddress0Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() \% 256;}
\DoxyCodeLine{35     uint64\_t MAC1 = MACAddress0Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() / 256;}
\DoxyCodeLine{36     uint64\_t MAC2 = MACAddress2Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() \% 256;}
\DoxyCodeLine{37     uint64\_t MAC3 = MACAddress2Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() / 256;}
\DoxyCodeLine{38     uint64\_t MAC4 = MACAddress4Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() \% 256;}
\DoxyCodeLine{39     uint64\_t MAC5 = MACAddress4Port.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}() / 256;}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{comment}{// Combine MAC addresses into one 48 bit number}}
\DoxyCodeLine{42     ownMAC = MAC5 << 40}
\DoxyCodeLine{43              | MAC4 << 32}
\DoxyCodeLine{44              | MAC3 << 24}
\DoxyCodeLine{45              | MAC2 << 16}
\DoxyCodeLine{46              | MAC1 << 8}
\DoxyCodeLine{47              | MAC0;}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     \textcolor{comment}{// Set the device to 32 bit mode}}
\DoxyCodeLine{50     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(20);              \textcolor{comment}{// Tell device to write to register 20}}
\DoxyCodeLine{51     busControlRegisterDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0x102);    \textcolor{comment}{// write desired data}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53     \textcolor{comment}{// Reset the stop bit (tell device it's not supposed to be reset now)}}
\DoxyCodeLine{54     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);               \textcolor{comment}{// Tell device to write to register 0}}
\DoxyCodeLine{55     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0x04);               \textcolor{comment}{// write desired data}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57     \textcolor{comment}{// Set the initialization block}}
\DoxyCodeLine{58     initBlock.mode = 0x0000;                         \textcolor{comment}{// Promiscuous mode = false   ( promiscuous mode tells it to receive all packets, not just broadcasts and those for its own MAC address)}}
\DoxyCodeLine{59     initBlock.reserved1 = 0;                         \textcolor{comment}{// Reserved}}
\DoxyCodeLine{60     initBlock.numSendBuffers = 3;                    \textcolor{comment}{// Means 8 because 2\string^8 (number of bits used)}}
\DoxyCodeLine{61     initBlock.reserved2 = 0;                         \textcolor{comment}{// Reserved}}
\DoxyCodeLine{62     initBlock.numRecvBuffers = 3;                    \textcolor{comment}{// Means 8 because 2\string^8 (number of bits used)}}
\DoxyCodeLine{63     initBlock.physicalAddress = ownMAC;              \textcolor{comment}{// Set the physical address to the MAC address}}
\DoxyCodeLine{64     initBlock.reserved3 = 0;                         \textcolor{comment}{// Reserverd}}
\DoxyCodeLine{65     initBlock.logicalAddress = 0;                    \textcolor{comment}{// None for now}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 }
\DoxyCodeLine{68     \textcolor{comment}{//TODO: Use malloc?}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     \textcolor{comment}{// Set Buffer descriptors memory}}
\DoxyCodeLine{71     sendBufferDescr = (BufferDescriptor*)(MemoryManager::s\_active\_memory\_manager-\/>malloc((\textcolor{keyword}{sizeof}(BufferDescriptor) * 8) + 15));  \textcolor{comment}{// Allocate memory for 8 buffer descriptors}}
\DoxyCodeLine{72     initBlock.sendBufferDescrAddress = (uint32\_t)sendBufferDescr;}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     recvBufferDescr = (BufferDescriptor*)(MemoryManager::s\_active\_memory\_manager-\/>malloc((\textcolor{keyword}{sizeof}(BufferDescriptor) * 8) + 15));  \textcolor{comment}{// Allocate memory for 8 buffer descriptors}}
\DoxyCodeLine{75     initBlock.recvBufferDescrAddress = (uint32\_t)recvBufferDescr;}
\DoxyCodeLine{76 }
\DoxyCodeLine{77     \textcolor{keywordflow}{for}(uint8\_t \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}} = 0; \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}} < 8; \mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}++)}
\DoxyCodeLine{78     \{}
\DoxyCodeLine{79 }
\DoxyCodeLine{80         \textcolor{comment}{// Send buffer descriptors}}
\DoxyCodeLine{81         sendBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].address = (((uint32\_t)\&sendBuffers[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}]) + 15 ) \& \string~(uint32\_t)0xF;       \textcolor{comment}{// Same as above}}
\DoxyCodeLine{82         sendBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].flags = 0x7FF                                                         \textcolor{comment}{// Legnth of descriptor}}
\DoxyCodeLine{83                                    | 0xF000;                                                     \textcolor{comment}{// Set it to send buffer}}
\DoxyCodeLine{84         sendBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].flags2 = 0;                                                           \textcolor{comment}{// "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive}}
\DoxyCodeLine{85         sendBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].avail = 0;                                                            \textcolor{comment}{// IF it is in use}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87         \textcolor{comment}{// Receive}}
\DoxyCodeLine{88         recvBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].address = (((uint32\_t)\&recvBuffers[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}]) + 15 ) \& \string~(uint32\_t)0xF;   \textcolor{comment}{// Same as above}}
\DoxyCodeLine{89         recvBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].flags = 0xF7FF                                                        \textcolor{comment}{// Length of descriptor        (This 0xF7FF is what was causing the problem, it used to be 0x7FF)}}
\DoxyCodeLine{90                                    | 0x80000000;                                                 \textcolor{comment}{// Set it to receive buffer}}
\DoxyCodeLine{91         recvBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].flags2 = 0;                                                           \textcolor{comment}{// "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive}}
\DoxyCodeLine{92         recvBufferDescr[\mbox{\hyperlink{namespaceMaxOS_1_1drivers_1_1peripherals_a891861cdf457ecedb7e3a5fa56515ebcaf552e09750e0ce71af8fc4fa0b32b8ff}{i}}].avail = 0;                                                            \textcolor{comment}{// IF it is in use}}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95     \textcolor{comment}{// Move initialization block into device}}
\DoxyCodeLine{96     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(1);                                     \textcolor{comment}{// Tell device to write to register 1}}
\DoxyCodeLine{97     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}((uint32\_t)(\&initBlock) \&}
\DoxyCodeLine{98                            0xFFFF);             \textcolor{comment}{// write address data}}
\DoxyCodeLine{99     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(2);                                     \textcolor{comment}{// Tell device to write to register 2}}
\DoxyCodeLine{100     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(((uint32\_t)(\&initBlock) >> 16) \&}
\DoxyCodeLine{101                            0xFFFF);     \textcolor{comment}{// write shifted address data}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \}}

\end{DoxyCode}


References Max\+O\+S\+::drivers\+::peripherals\+::i, Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::read(), and Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::write().

\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_aacbc48386a4b5f36a63dc53b2f1bae2f}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_aacbc48386a4b5f36a63dc53b2f1bae2f}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!````~amd\_am79c973@{$\sim$amd\_am79c973}}
\index{````~amd\_am79c973@{$\sim$amd\_am79c973}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{$\sim$amd\_am79c973()}{~amd\_am79c973()}}
{\footnotesize\ttfamily amd\+\_\+am79c973\+::$\sim$amd\+\_\+am79c973 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 106 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{107 \{}
\DoxyCodeLine{108 \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_af343f26c6a53c4336c68103a7425ef15}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_af343f26c6a53c4336c68103a7425ef15}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!activate@{activate}}
\index{activate@{activate}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{activate()}{activate()}}
{\footnotesize\ttfamily void amd\+\_\+am79c973\+::activate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



This function activates the device and starts it (Runs when the driver-\/manger calls activate\+All()) 



Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_a92276c08d77279b6a86c900190ef797b}{Max\+O\+S\+::drivers\+::\+Driver}}.



Definition at line 115 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{116 \{}
\DoxyCodeLine{117 }
\DoxyCodeLine{118     \textcolor{comment}{// TODO: Have a look at re -\/ implementing this again someday}}
\DoxyCodeLine{119     \textcolor{keywordflow}{return};}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     initDone = \textcolor{keyword}{false};                                            \textcolor{comment}{// Set initDone to false}}
\DoxyCodeLine{122     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);                           \textcolor{comment}{// Tell device to write to register 0}}
\DoxyCodeLine{123     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0x41);                           \textcolor{comment}{// Enable Interrupts and start the device}}
\DoxyCodeLine{124     \textcolor{keywordflow}{while}(!initDone);                                            \textcolor{comment}{// Wait for initDone to be set to true}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(4);                           \textcolor{comment}{// Tell device to read from register 4}}
\DoxyCodeLine{127     uint32\_t temp = registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}();                     \textcolor{comment}{// Get current data}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(4);                           \textcolor{comment}{// Tell device to write to register 4}}
\DoxyCodeLine{130     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(temp | 0xC00);                   \textcolor{comment}{// Bitwise OR function on data (This automatically enlarges packets smaller than 64 bytes to that size and removes some relatively superfluous information from received packets.)}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);                           \textcolor{comment}{// Tell device to write to register 0}}
\DoxyCodeLine{133     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0x42);                           \textcolor{comment}{// Tell device that it is initialised and can begin operating}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135     active = \textcolor{keyword}{true};                                               \textcolor{comment}{// Set active to true}}
\DoxyCodeLine{136 \}}

\end{DoxyCode}


References Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::read(), and Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::write().

\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a087d7785cb300529b700522460a62751}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a087d7785cb300529b700522460a62751}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!deactivate@{deactivate}}
\index{deactivate@{deactivate}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{deactivate()}{deactivate()}}
{\footnotesize\ttfamily void amd\+\_\+am79c973\+::deactivate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



deactivate the driver 



Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_aa8d91fd440659b56c4ecf5c877925210}{Max\+O\+S\+::drivers\+::\+Driver}}.



Definition at line 292 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{292                               \{}
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a47ce3c94382939df1c248c3a2ba206b6}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a47ce3c94382939df1c248c3a2ba206b6}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!DoSend@{DoSend}}
\index{DoSend@{DoSend}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{DoSend()}{DoSend()}}
{\footnotesize\ttfamily void amd\+\_\+am79c973\+::\+Do\+Send (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{buffer,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



This function sends a package. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer to send \\
\hline
{\em size} & The size of the buffer \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1EthernetDriver_acae51a237ae1975705a2f831f851cca0}{Max\+O\+S\+::drivers\+::ethernet\+::\+Ethernet\+Driver}}.



Definition at line 203 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{203                                                         \{}
\DoxyCodeLine{204 }
\DoxyCodeLine{205     \textcolor{keywordflow}{while}(!active);}
\DoxyCodeLine{206 }
\DoxyCodeLine{207     \textcolor{keywordtype}{int} sendDescriptor = currentSendBuffer;              \textcolor{comment}{// Get where data has been written to}}
\DoxyCodeLine{208     currentSendBuffer = (currentSendBuffer + 1) \% 8;    \textcolor{comment}{// Move send buffer to next send buffer (div by 8 so that it is cycled) (this allows for data to be sent from different m\_tasks in parallel)}}
\DoxyCodeLine{209 }
\DoxyCodeLine{210     \textcolor{keywordflow}{if}(\mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}} > 1518)\{                                    \textcolor{comment}{// If attempt to send more than 1518 bytes at once it will be too large}}
\DoxyCodeLine{211         \mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}} = 1518;                                    \textcolor{comment}{// Discard all data after that  (Generally if data is bigger than that at driver level then a higher up network layer must have made a mistake)}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213     \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215     \textcolor{comment}{// What this loop does is copy the information passed as the parameter buffer (src) to the send buffer in the ram (dst) which the card will then use to send the data}}
\DoxyCodeLine{216     \textcolor{keywordflow}{for} (uint8\_t *src = buffer + \mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}} -\/1,                                                   \textcolor{comment}{// Set src pointer to the end of the data that is being sent}}
\DoxyCodeLine{217          *dst = (uint8\_t*)(sendBufferDescr[sendDescriptor].address + \mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}} -\/1);       \textcolor{comment}{// Take the buffer that has been slected}}
\DoxyCodeLine{218          src >= buffer;                                                             \textcolor{comment}{// While there is still information in the buffer that hasnt been written to src}}
\DoxyCodeLine{219          src-\/-\/,dst-\/-\/                                                                \textcolor{comment}{// Move 2 pointers to the end of the buffers}}
\DoxyCodeLine{220             )}
\DoxyCodeLine{221     \{}
\DoxyCodeLine{222         *dst = *src;                                                                        \textcolor{comment}{// Copy data from source buffer to destiantion buffer}}
\DoxyCodeLine{223     \}}
\DoxyCodeLine{224 }
\DoxyCodeLine{225 }
\DoxyCodeLine{226     sendBufferDescr[sendDescriptor].avail = 0;                               \textcolor{comment}{// Set that this buffer is in use}}
\DoxyCodeLine{227     sendBufferDescr[sendDescriptor].flags2 = 0;                              \textcolor{comment}{// Clear any previous error messages}}
\DoxyCodeLine{228     sendBufferDescr[sendDescriptor].flags = 0x8300F000                       \textcolor{comment}{// Encode the size of what is being sent}}
\DoxyCodeLine{229                                             | ((uint16\_t)((-\/\mbox{\hyperlink{fat32_8h_ab2c6b258f02add8fdf4cfc7c371dd772}{size}}) \& 0xFFF));;}
\DoxyCodeLine{230 }
\DoxyCodeLine{231     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);                           \textcolor{comment}{// Tell device to write to register 0}}
\DoxyCodeLine{232     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(}
\DoxyCodeLine{233         0x48);                           \textcolor{comment}{// Tell device to send the data currently in the buffer}}
\DoxyCodeLine{234 \}}

\end{DoxyCode}


References size, and Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::write().

\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a177e151fa19903dc2c733664883ac603}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a177e151fa19903dc2c733664883ac603}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!get\_device\_name@{get\_device\_name}}
\index{get\_device\_name@{get\_device\_name}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{get\_device\_name()}{get\_device\_name()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceMaxOS_afa22b691550d34d82dd6a5e3f77b31cb}{string}} amd\+\_\+am79c973\+::get\+\_\+device\+\_\+name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the device name of the driver. 

\begin{DoxyReturn}{Returns}
The device name of the driver 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_a65b06f2917f7a781e68f3748e81806b6}{Max\+O\+S\+::drivers\+::\+Driver}}.



Definition at line 300 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{300                                      \{}
\DoxyCodeLine{301     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PCnet-\/Fast III (Am79C973)"};}
\DoxyCodeLine{302 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a013e544525f4aef5a4dc3aa7b0a682c2}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_a013e544525f4aef5a4dc3aa7b0a682c2}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!get\_vendor\_name@{get\_vendor\_name}}
\index{get\_vendor\_name@{get\_vendor\_name}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{get\_vendor\_name()}{get\_vendor\_name()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceMaxOS_afa22b691550d34d82dd6a5e3f77b31cb}{string}} amd\+\_\+am79c973\+::get\+\_\+vendor\+\_\+name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the vendor name of the driver. 

\begin{DoxyReturn}{Returns}
The vendor name of the driver 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_a7ad761c929a49cfebd8c443f5af788f6}{Max\+O\+S\+::drivers\+::\+Driver}}.



Definition at line 296 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{296                                      \{}
\DoxyCodeLine{297     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"AMD"};}
\DoxyCodeLine{298 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acd69d1f0897713631d40cf073926fed7}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acd69d1f0897713631d40cf073926fed7}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!GetMediaAccessControlAddress@{GetMediaAccessControlAddress}}
\index{GetMediaAccessControlAddress@{GetMediaAccessControlAddress}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{GetMediaAccessControlAddress()}{GetMediaAccessControlAddress()}}
{\footnotesize\ttfamily uint64\+\_\+t amd\+\_\+am79c973\+::\+Get\+Media\+Access\+Control\+Address (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



This function gets the M\+AC address. 

\begin{DoxyReturn}{Returns}
The M\+AC address 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1ethernet_1_1EthernetDriver_a3bf68668c69f6b300888ad189a67006a}{Max\+O\+S\+::drivers\+::ethernet\+::\+Ethernet\+Driver}}.



Definition at line 287 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{287                                                     \{}
\DoxyCodeLine{288     \textcolor{keywordflow}{while}(ownMAC == 0);}
\DoxyCodeLine{289     \textcolor{keywordflow}{return} ownMAC;}
\DoxyCodeLine{290 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_ac925036cea408af2cd3d120c639985d2}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_ac925036cea408af2cd3d120c639985d2}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!handle\_interrupt@{handle\_interrupt}}
\index{handle\_interrupt@{handle\_interrupt}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{handle\_interrupt()}{handle\_interrupt()}}
{\footnotesize\ttfamily void amd\+\_\+am79c973\+::handle\+\_\+interrupt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



This function handles the interrupt for the device. 


\begin{DoxyParams}{Parameters}
{\em esp} & The stack pointer (where to return to) \\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1InterruptHandler_abd792bc53ec7dd1b70c8386853cc3c33}{Max\+O\+S\+::hardwarecommunication\+::\+Interrupt\+Handler}}.



Definition at line 158 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{158                                     \{}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 }
\DoxyCodeLine{161 }
\DoxyCodeLine{162 }
\DoxyCodeLine{163     \textcolor{comment}{// Similar to PIC, data needs to be read when a interrupt is sent, or it hangs}}
\DoxyCodeLine{164     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);                           \textcolor{comment}{// Tell device to read from register 0}}
\DoxyCodeLine{165     uint32\_t temp = registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}();                     \textcolor{comment}{// Get current data}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     \textcolor{comment}{// Note: Cant be switch case as multiple errors can occur at the same time}}
\DoxyCodeLine{168 }
\DoxyCodeLine{169     \textcolor{comment}{// Errors}}
\DoxyCodeLine{170     \textcolor{keywordflow}{if}((temp \& 0x8000) == 0x8000)}
\DoxyCodeLine{171       \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_aceaadfd977efff51ee4e851e362b993a}{error\_message}}(\textcolor{stringliteral}{"AMD am79c973 ERROR: "});}
\DoxyCodeLine{172     \textcolor{keywordflow}{if}((temp \& 0x2000) == 0x2000)}
\DoxyCodeLine{173       \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_aceaadfd977efff51ee4e851e362b993a}{error\_message}}(\textcolor{stringliteral}{"COLLISION ERROR\(\backslash\)n"});}
\DoxyCodeLine{174     \textcolor{keywordflow}{if}((temp \& 0x1000) == 0x1000)}
\DoxyCodeLine{175       \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_aceaadfd977efff51ee4e851e362b993a}{error\_message}}(\textcolor{stringliteral}{"MISSED FRAME\(\backslash\)n"});}
\DoxyCodeLine{176     \textcolor{keywordflow}{if}((temp \& 0x0800) == 0x0800)}
\DoxyCodeLine{177       \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_aceaadfd977efff51ee4e851e362b993a}{error\_message}}(\textcolor{stringliteral}{"MEMORY ERROR\(\backslash\)n"});}
\DoxyCodeLine{178 }
\DoxyCodeLine{179 }
\DoxyCodeLine{180     \textcolor{comment}{// Responses}}
\DoxyCodeLine{181     \textcolor{keywordflow}{if}((temp \& 0x0400) == 0x0400) FetchDataReceived();}
\DoxyCodeLine{182     \textcolor{keywordflow}{if}((temp \& 0x0200) == 0x0200) FetchDataSent();}
\DoxyCodeLine{183     \textcolor{keywordflow}{if}((temp \& 0x0100) == 0x0100) initDone = \textcolor{keyword}{true};\textcolor{comment}{//}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185     \textcolor{comment}{// Reply that it was received}}
\DoxyCodeLine{186     registerAddressPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);                           \textcolor{comment}{// Tell device to write to register 0}}
\DoxyCodeLine{187     registerDataPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(temp);                           \textcolor{comment}{// Tell device that the interrupt was received}}
\DoxyCodeLine{188 \}}

\end{DoxyCode}


References Max\+O\+S\+::drivers\+::\+Driver\+::error\+\_\+message(), Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::read(), and Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::write().

\mbox{\Hypertarget{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acf6d4a68e3e74a4b23d5811f536cf26f}\label{classMaxOS_1_1drivers_1_1ethernet_1_1amd__am79c973_acf6d4a68e3e74a4b23d5811f536cf26f}} 
\index{MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}!reset@{reset}}
\index{reset@{reset}!MaxOS::drivers::ethernet::amd\_am79c973@{MaxOS::drivers::ethernet::amd\_am79c973}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily uint32\+\_\+t amd\+\_\+am79c973\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



This function resets the device. 

\begin{DoxyReturn}{Returns}
The amount of ms to wait 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{classMaxOS_1_1drivers_1_1Driver_a2371d6b69c1bf351e9c80bde265ac8be}{Max\+O\+S\+::drivers\+::\+Driver}}.



Definition at line 143 of file amd\+\_\+am79c973.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{143                              \{}
\DoxyCodeLine{144 }
\DoxyCodeLine{145   resetPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a5147c7c28ca813536015969ae6ba6bb6}{read}}();}
\DoxyCodeLine{146   resetPort.\mbox{\hyperlink{classMaxOS_1_1hardwarecommunication_1_1Port16Bit_a24f6a288e57d4c01634926ca3580324d}{write}}(0);}
\DoxyCodeLine{147   \textcolor{keywordflow}{return} 10;                      \textcolor{comment}{// 10 means wait for 10ms}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \}}

\end{DoxyCode}


References Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::read(), and Max\+O\+S\+::hardwarecommunication\+::\+Port16\+Bit\+::write().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/runner/work/\+Max\+O\+S/\+Max\+O\+S/kernel/include/drivers/ethernet/\mbox{\hyperlink{amd__am79c973_8h}{amd\+\_\+am79c973.\+h}}\item 
/home/runner/work/\+Max\+O\+S/\+Max\+O\+S/kernel/src/drivers/ethernet/\mbox{\hyperlink{amd__am79c973_8cpp}{amd\+\_\+am79c973.\+cpp}}\end{DoxyCompactItemize}

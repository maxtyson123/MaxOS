.TH "MaxOS::filesystem::format::Fat32Directory" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::format::Fat32Directory \- Handles the directory operations on the FAT32 filesystem\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fat32\&.h>\fP
.PP
Inherits \fBMaxOS::filesystem::Directory\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFat32Directory\fP (\fBFat32Volume\fP *\fBvolume\fP, \fBlba_t\fP \fBcluster\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.ti -1c
.RI "\fB~Fat32Directory\fP ()"
.br
.ti -1c
.RI "\fBvoid\fP \fBread_from_disk\fP () \fBfinal\fP"
.br
.RI "Read the directory from the disk\&. "
.ti -1c
.RI "\fBFile\fP * \fBcreate_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Create a new file in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Delete a file from the subdirectory\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBcreate_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Create a new directory in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Remove a directory entry from the directory\&. "
.ti -1c
.RI "\fBlba_t\fP \fBfirst_cluster\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBMaxOS::filesystem::Directory\fP
.in +1c
.ti -1c
.RI "\fBDirectory\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fB~Directory\fP ()"
.br
.ti -1c
.RI "\fBcommon::Vector\fP< \fBFile\fP * > \fBfiles\fP ()"
.br
.RI "Get the files in the directory\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBDirectory\fP * > \fBsubdirectories\fP ()"
.br
.RI "Get the subdirectories in the directory\&. "
.ti -1c
.RI "\fBFile\fP * \fBopen_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Open a file in the directory\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBopen_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Open a directory in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBrename_file\fP (\fBFile\fP *file, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a file in the directory\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrename_file\fP (\fBconst\fP \fBstring\fP &\fBold_name\fP, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a file in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBrename_subdirectory\fP (\fBDirectory\fP *directory, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a subdirectory in the directory\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrename_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBold_name\fP, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a subdirectory in the directory\&. "
.ti -1c
.RI "\fBstring\fP \fBname\fP ()"
.br
.RI "Get the name of the directory\&. "
.ti -1c
.RI "\fBsize_t\fP \fBsize\fP ()"
.br
.RI "Get the size of the directory\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_t \fBMAX_NAME_LENGTH\fP = 255"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBsave_entry_to_disk\fP (\fBdir_entry_t\fP *entry)"
.br
.RI "Writes an updated directory entry to the disk\&. "
.ti -1c
.RI "\fBvoid\fP \fBupdate_entry_on_disk\fP (\fBint\fP index)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBFat32File\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Attributes inherited from \fBMaxOS::filesystem::Directory\fP
.in +1c
.ti -1c
.RI "\fBcommon::Vector\fP< \fBFile\fP * > \fBm_files\fP"
.br
.ti -1c
.RI "\fBcommon::Vector\fP< \fBDirectory\fP * > \fBm_subdirectories\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBm_name\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles the directory operations on the FAT32 filesystem\&. 
.PP
Definition at line \fB228\fP of file \fBfat32\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Fat32Directory::Fat32Directory (\fBFat32Volume\fP * volume, \fBlba_t\fP cluster, \fBconst\fP \fBstring\fP & name)"

.PP
Definition at line \fB399\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
400 : m_volume(volume),
401   m_first_cluster(cluster)
402 {
403     m_name = name;
404 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::m_name\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "Fat32Directory::~Fat32Directory ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBFile\fP * Fat32Directory::create_file (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Create a new file in the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to create 
.RE
.PP
\fBReturns\fP
.RS 4
The new file object or null if it could not be created 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB862\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
862                                                     {
863 
864     // Check if the file already exists
865     for (auto &file: m_files)
866         if (file\->name() == name)
867             return nullptr;
868 
869     // Check if the name is too long
870     if (name\&.length() > MAX_NAME_LENGTH)
871         return nullptr;
872 
873     // Create the file
874     auto file = new Fat32File(m_volume, this, create_entry(name, false), name);
875     m_files\&.push_back(file);
876     return file;
877 }
.fi

.PP
References \fBFat32File\fP, \fBMaxOS::String::length()\fP, \fBMaxOS::filesystem::Directory::m_files\fP, \fBMAX_NAME_LENGTH\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBDirectory\fP * Fat32Directory::create_subdirectory (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Create a new directory in the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the directory to create 
.RE
.PP
\fBReturns\fP
.RS 4
The new directory object or null if it could not be created 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB905\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
905                                                                  {
906 
907     // Check if the directory already exists
908     for (auto &subdirectory: m_subdirectories)
909         if (subdirectory\->name() == name)
910             return nullptr;
911 
912     // Check if the name is too long
913     if (name\&.length() > MAX_NAME_LENGTH)
914         return nullptr;
915 
916     // Create the directory
917     auto entry = create_entry(name, true);
918     uint32_t cluster = ((entry\->first_cluster_high << 16) | entry\->first_cluster_low);
919 
920     // Store the directory
921     auto directory = new Fat32Directory(m_volume, cluster, name);
922     m_subdirectories\&.push_back(directory);
923     return directory;
924 }
.fi

.PP
References \fBMaxOS::String::length()\fP, \fBMaxOS::filesystem::Directory::m_subdirectories\fP, \fBMAX_NAME_LENGTH\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Directory::first_cluster () const\fC [inline]\fP"

.PP
Definition at line \fB271\fP of file \fBfat32\&.h\fP\&..PP
.nf
271 { return m_first_cluster; }
.fi

.PP
Referenced by \fBremove_file()\fP, and \fBremove_subdirectory()\fP\&.
.SS "\fBvoid\fP Fat32Directory::read_from_disk ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Read the directory from the disk\&. 
.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB801\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
801                                     {
802 
803     for (auto &file: m_files)
804         delete file;
805     m_files\&.clear();
806 
807     for (auto &directory: m_subdirectories)
808         delete directory;
809     m_subdirectories\&.clear();
810 
811     // Load the entries from the disk into memory
812     read_all_entries();
813 
814     // Parse the entries
815     string long_name = "";
816     for (auto &entry: m_entries) {
817 
818         // Skip free entries and volume labels
819         if (entry\&.name[0] == (uint8_t) DirectoryEntryType::FREE
820             || entry\&.attributes == (uint8_t) DirectoryEntryAttributes::FREE
821             || entry\&.attributes == (uint8_t) DirectoryEntryAttributes::VOLUME_ID)
822             continue;
823 
824         // Extract the long name
825         if (entry\&.attributes == (uint8_t) DirectoryEntryAttributes::LONG_NAME) {
826             long_name = parse_long_filename((long_file_name_entry_t *) &entry, long_name);
827             continue;
828         }
829 
830         bool is_directory = entry\&.attributes == (uint8_t) DirectoryEntryAttributes::DIRECTORY;
831 
832         // Get the name of the entry
833         string name = long_name;
834         if (long_name == "") {
835             name = string(entry\&.name, 8);
836 
837             // Add the extension
838             if (!is_directory)
839                 name = name\&.strip() + "\&." + string(entry\&.extension, 3);
840         }
841 
842         long_name = "";
843 
844         // Get the starting cluster
845         uint32_t start_cluster = (entry\&.first_cluster_high << 16) | entry\&.first_cluster_low;
846 
847         // Store the file or directory
848         if (is_directory)
849             m_subdirectories\&.push_back(new Fat32Directory(m_volume, start_cluster, name\&.strip()));
850         else
851             m_files\&.push_back(new Fat32File(m_volume, this, &entry, name));
852 
853     }
854 }
.fi

.PP
References \fBMaxOS::filesystem::format::DIRECTORY\fP, \fBFat32File\fP, \fBMaxOS::filesystem::format::FREE\fP, \fBMaxOS::filesystem::format::LONG_NAME\fP, \fBMaxOS::filesystem::Directory::m_files\fP, \fBMaxOS::filesystem::Directory::m_subdirectories\fP, \fBMaxOS::filesystem::Directory::name()\fP, \fBMaxOS::String::strip()\fP, and \fBMaxOS::filesystem::format::VOLUME_ID\fP\&.
.SS "\fBvoid\fP Fat32Directory::remove_file (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Delete a file from the subdirectory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to delete 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB884\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
884                                                    {
885     // Find the file if it exists
886     for (auto &file: m_files)
887         if (file\->name() == name) {
888 
889             // Remove the file from the directory
890             m_files\&.erase(file);
891             remove_entry(((Fat32File *) file)\->first_cluster(), name);
892 
893             // Delete the file reference
894             delete file;
895             return;
896         }
897 }
.fi

.PP
References \fBfirst_cluster()\fP, \fBMaxOS::filesystem::Directory::m_files\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBvoid\fP Fat32Directory::remove_subdirectory (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Remove a directory entry from the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the entry to remove 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB931\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
931                                                            {
932     // Find the directory if it exists
933     for (auto &subdirectory: m_subdirectories) {
934         if (subdirectory\->name() != name)
935             continue;
936 
937         // Remove all the files in the directory
938         for (auto &file: subdirectory\->files())
939             subdirectory\->remove_file(file\->name());
940 
941         // Remove all the subdirectories in the directory
942         for (auto &subdirectory: subdirectory\->subdirectories())
943             subdirectory\->remove_subdirectory(subdirectory\->name());
944 
945         // Remove the entry
946         m_subdirectories\&.erase(subdirectory);
947         remove_entry(((Fat32Directory *) subdirectory)\->first_cluster(), name);
948 
949         // Delete the directory
950         delete subdirectory;
951         return;
952     }
953 }
.fi

.PP
References \fBfirst_cluster()\fP, \fBMaxOS::filesystem::Directory::m_subdirectories\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBvoid\fP Fat32Directory::save_entry_to_disk (\fBdir_entry_t\fP * entry)\fC [protected]\fP"

.PP
Writes an updated directory entry to the disk\&. 
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The entry to write 
.RE
.PP

.PP
Definition at line \fB566\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
566                                                              {
567 
568     int index = 0;
569     for (auto &m_entry: m_entries) {
570         if (&m_entry == entry)
571             break;
572         index++;
573     }
574 
575     update_entry_on_disk(index);
576 }
.fi

.PP
References \fBupdate_entry_on_disk()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBvoid\fP Fat32Directory::update_entry_on_disk (\fBint\fP index)\fC [protected]\fP"

.PP
Definition at line \fB578\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
578                                                    {
579 
580     // Get the entry
581     auto entry = m_entries[index];
582 
583     // Determine sector offset and in\-sector byte offset
584     uint32_t bytes_per_sector = m_volume\->bpb\&.bytes_per_sector;
585     uint32_t entry_offset = index * sizeof(dir_entry_t);
586     uint32_t sector_offset = entry_offset / bytes_per_sector;
587     uint32_t in_sector_offset = entry_offset % bytes_per_sector;
588 
589     // Find which cluster has the entry
590     uint32_t cluster = m_first_cluster;
591     for (uint32_t offset_remaining = entry_offset;
592          offset_remaining >= bytes_per_sector; offset_remaining \-= bytes_per_sector)
593         cluster = m_volume\->next_cluster(cluster);
594 
595     // Read the full sector into a buffer
596     lba_t base_lba = m_volume\->data_lba + (cluster \- 2) * m_volume\->bpb\&.sectors_per_cluster;
597     buffer_t sector_buffer(bytes_per_sector, false);
598     m_volume\->disk\->read(base_lba + sector_offset, &sector_buffer);
599 
600     // Update the entry in the buffer
601     sector_buffer\&.copy_from(&entry, sizeof(dir_entry_t), in_sector_offset);
602     m_volume\->disk\->write(base_lba + sector_offset, &sector_buffer);
603 }
.fi

.PP
References \fBMaxOS::filesystem::format::Fat32Volume::bpb\fP, \fBbytes_per_sector\fP, \fBMaxOS::filesystem::format::Fat32Volume::data_lba\fP, \fBMaxOS::filesystem::format::Fat32Volume::disk\fP, \fBMaxOS::filesystem::format::Fat32Volume::next_cluster()\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.PP
Referenced by \fBsave_entry_to_disk()\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBFat32File\fP\fC [friend]\fP"

.PP
Definition at line \fB230\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBcreate_file()\fP, and \fBread_from_disk()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "const size_t MaxOS::filesystem::format::Fat32Directory::MAX_NAME_LENGTH = 255\fC [static]\fP"

.PP
Definition at line \fB261\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBcreate_file()\fP, and \fBcreate_subdirectory()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

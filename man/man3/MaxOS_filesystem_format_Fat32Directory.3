.TH "MaxOS::filesystem::format::Fat32Directory" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::format::Fat32Directory \- Handles the directory operations on the FAT32 filesystem\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fat32\&.h>\fP
.PP
Inherits \fBMaxOS::filesystem::Directory\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFat32Directory\fP (\fBFat32Volume\fP *\fBvolume\fP, lba_t \fBcluster\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Construct a new Fat32 \fBDirectory\fP object\&. "
.ti -1c
.RI "\fBvoid\fP \fBread_from_disk\fP () \fBfinal\fP"
.br
.RI "Read the directory from the disk\&. "
.ti -1c
.RI "\fBFile\fP * \fBcreate_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Create a new file in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Delete a file from the subdirectory\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBcreate_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Create a new directory in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP) \fBfinal\fP"
.br
.RI "Remove a directory entry from the directory\&. "
.ti -1c
.RI "lba_t \fBfirst_cluster\fP () const"
.br
.RI "Get the first cluster of the directory\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::filesystem::Directory\fP
.in +1c
.ti -1c
.RI "\fBcommon::Vector\fP< \fBFile\fP * > \fBfiles\fP ()"
.br
.RI "Get the files in the directory\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBDirectory\fP * > \fBsubdirectories\fP ()"
.br
.RI "Get the subdirectories in the directory\&. "
.ti -1c
.RI "\fBFile\fP * \fBopen_file\fP (\fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Open a file in the directory\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBopen_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Open a directory in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBrename_file\fP (\fBFile\fP *file, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a file in the directory\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrename_file\fP (\fBconst\fP \fBstring\fP &\fBold_name\fP, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a file in the directory\&. "
.ti -1c
.RI "\fBvoid\fP \fBrename_subdirectory\fP (\fBDirectory\fP *directory, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a subdirectory in the directory\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrename_subdirectory\fP (\fBconst\fP \fBstring\fP &\fBold_name\fP, \fBconst\fP \fBstring\fP &\fBnew_name\fP)"
.br
.RI "Rename a subdirectory in the directory\&. "
.ti -1c
.RI "\fBstring\fP \fBname\fP ()"
.br
.RI "Get the name of the directory\&. "
.ti -1c
.RI "\fBsize_t\fP \fBsize\fP ()"
.br
.RI "Get the size of the directory\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBsave_entry_to_disk\fP (\fBdir_entry_t\fP *entry)"
.br
.RI "Writes an updated directory entry to the disk\&. "
.ti -1c
.RI "\fBvoid\fP \fBupdate_entry_on_disk\fP (\fBint\fP index)"
.br
.RI "Save the directory entry at the given index to the disk\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBFat32File\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Attributes inherited from \fBMaxOS::filesystem::Directory\fP
.in +1c
.ti -1c
.RI "\fBcommon::Vector\fP< \fBFile\fP * > \fBm_files\fP"
.br
.RI "The files in this directory\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBDirectory\fP * > \fBm_subdirectories\fP"
.br
.RI "The subdirectories in this directory\&. "
.ti -1c
.RI "\fBstring\fP \fBm_name\fP"
.br
.RI "The name of this directory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the directory operations on the FAT32 filesystem\&. 
.PP
Definition at line \fB219\fP of file \fBfat32\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Fat32Directory::Fat32Directory (\fBFat32Volume\fP * volume, lba_t cluster, \fBconst\fP \fBstring\fP & name)"

.PP
Construct a new Fat32 \fBDirectory\fP object\&. 
.PP
\fBParameters\fP
.RS 4
\fIvolume\fP The FAT32 volume 
.br
\fIcluster\fP The cluster of the directory 
.br
\fIname\fP The name of the directory 
.RE
.PP

.PP
Definition at line \fB426\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
427 : m_volume(volume),
428   m_first_cluster(cluster)
429 {
430     m_name = name;
431 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::m_name\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBFile\fP * Fat32Directory::create_file (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Create a new file in the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to create 
.RE
.PP
\fBReturns\fP
.RS 4
The new file object or null if it could not be created 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB893\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
893                                                     {
894 
895     // Check if the file already exists
896     for (auto &file: m_files)
897         if (file\->name() == name)
898             return nullptr;
899 
900     // Check if the name is too long
901     if (name\&.length() > MAX_NAME_LENGTH)
902         return nullptr;
903 
904     // Create the file
905     auto file = new Fat32File(m_volume, this, create_entry(name, false), name);
906     m_files\&.push_back(file);
907     return file;
908 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::m_files\fP, \fBMaxOS::filesystem::format::MAX_NAME_LENGTH\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBDirectory\fP * Fat32Directory::create_subdirectory (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Create a new directory in the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the directory to create 
.RE
.PP
\fBReturns\fP
.RS 4
The new directory object or null if it could not be created 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB936\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
936                                                                  {
937 
938     // Check if the directory already exists
939     for (auto &subdirectory: m_subdirectories)
940         if (subdirectory\->name() == name)
941             return nullptr;
942 
943     // Check if the name is too long
944     if (name\&.length() > MAX_NAME_LENGTH)
945         return nullptr;
946 
947     // Create the directory
948     auto entry = create_entry(name, true);
949     uint32_t cluster = ((entry\->first_cluster_high << 16) | entry\->first_cluster_low);
950 
951     // Store the directory
952     auto directory = new Fat32Directory(m_volume, cluster, name);
953     m_subdirectories\&.push_back(directory);
954     return directory;
955 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::m_subdirectories\fP, \fBMaxOS::filesystem::format::MAX_NAME_LENGTH\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "lba_t MaxOS::filesystem::format::Fat32Directory::first_cluster () const\fC [inline]\fP"

.PP
Get the first cluster of the directory\&. 
.PP
Definition at line \fB259\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBremove_file()\fP, and \fBremove_subdirectory()\fP\&.
.SS "\fBvoid\fP Fat32Directory::read_from_disk ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Read the directory from the disk\&. 
.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB832\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
832                                     {
833 
834     for (auto &file: m_files)
835         delete file;
836     m_files\&.clear();
837 
838     for (auto &directory: m_subdirectories)
839         delete directory;
840     m_subdirectories\&.clear();
841 
842     // Load the entries from the disk into memory
843     read_all_entries();
844 
845     // Parse the entries
846     string long_name = "";
847     for (auto &entry: m_entries) {
848 
849         // Skip free entries and volume labels
850         if (entry\&.name[0] == (uint8_t) DirectoryEntryType::FREE
851             || entry\&.attributes == (uint8_t) DirectoryEntryAttributes::FREE
852             || entry\&.attributes == (uint8_t) DirectoryEntryAttributes::VOLUME_ID)
853             continue;
854 
855         // Extract the long name
856         if (entry\&.attributes == (uint8_t) DirectoryEntryAttributes::LONG_NAME) {
857             long_name = parse_long_filename((long_file_name_entry_t *) &entry, long_name);
858             continue;
859         }
860 
861         bool is_directory = entry\&.attributes == (uint8_t) DirectoryEntryAttributes::DIRECTORY;
862 
863         // Get the name of the entry
864         string name = long_name;
865         if (long_name == "") {
866             name = string(entry\&.name, 8);
867 
868             // Add the extension
869             if (!is_directory)
870                 name = name\&.strip() + "\&." + string(entry\&.extension, 3);
871         }
872 
873         long_name = "";
874 
875         // Get the starting cluster
876         uint32_t start_cluster = (entry\&.first_cluster_high << 16) | entry\&.first_cluster_low;
877 
878         // Store the file or directory
879         if (is_directory)
880             m_subdirectories\&.push_back(new Fat32Directory(m_volume, start_cluster, name\&.strip()));
881         else
882             m_files\&.push_back(new Fat32File(m_volume, this, &entry, name));
883 
884     }
885 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::m_files\fP, \fBMaxOS::filesystem::Directory::m_subdirectories\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBvoid\fP Fat32Directory::remove_file (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Delete a file from the subdirectory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the file to delete 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB915\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
915                                                    {
916     // Find the file if it exists
917     for (auto &file: m_files)
918         if (file\->name() == name) {
919 
920             // Remove the file from the directory
921             m_files\&.erase(file);
922             remove_entry(((Fat32File *) file)\->first_cluster(), name);
923 
924             // Delete the file reference
925             delete file;
926             return;
927         }
928 }
.fi

.PP
References \fBfirst_cluster()\fP, \fBMaxOS::filesystem::Directory::m_files\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBvoid\fP Fat32Directory::remove_subdirectory (\fBconst\fP \fBstring\fP & name)\fC [final]\fP, \fC [virtual]\fP"

.PP
Remove a directory entry from the directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the entry to remove 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::filesystem::Directory\fP\&.
.PP
Definition at line \fB962\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
962                                                            {
963     // Find the directory if it exists
964     for (auto &subdirectory: m_subdirectories) {
965         if (subdirectory\->name() != name)
966             continue;
967 
968         // Remove all the files in the directory
969         for (auto &file: subdirectory\->files())
970             subdirectory\->remove_file(file\->name());
971 
972         // Remove all the subdirectories in the directory
973         for (auto &subdirectory: subdirectory\->subdirectories())
974             subdirectory\->remove_subdirectory(subdirectory\->name());
975 
976         // Remove the entry
977         m_subdirectories\&.erase(subdirectory);
978         remove_entry(((Fat32Directory *) subdirectory)\->first_cluster(), name);
979 
980         // Delete the directory
981         delete subdirectory;
982         return;
983     }
984 }
.fi

.PP
References \fBfirst_cluster()\fP, \fBMaxOS::filesystem::Directory::m_subdirectories\fP, and \fBMaxOS::filesystem::Directory::name()\fP\&.
.SS "\fBvoid\fP Fat32Directory::save_entry_to_disk (\fBdir_entry_t\fP * entry)\fC [protected]\fP"

.PP
Writes an updated directory entry to the disk\&. 
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The entry to write 
.RE
.PP

.PP
Definition at line \fB593\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
593                                                              {
594 
595     int index = 0;
596     for (auto &m_entry: m_entries) {
597         if (&m_entry == entry)
598             break;
599         index++;
600     }
601 
602     update_entry_on_disk(index);
603 }
.fi

.PP
References \fBupdate_entry_on_disk()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBvoid\fP Fat32Directory::update_entry_on_disk (\fBint\fP index)\fC [protected]\fP"

.PP
Save the directory entry at the given index to the disk\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the entry to update 
.RE
.PP

.PP
Definition at line \fB609\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
609                                                    {
610 
611     // Get the entry
612     auto entry = m_entries[index];
613 
614     // Determine sector offset and in\-sector byte offset
615     uint32_t bytes_per_sector = m_volume\->bpb\&.bytes_per_sector;
616     uint32_t entry_offset = index * sizeof(dir_entry_t);
617     uint32_t sector_offset = entry_offset / bytes_per_sector;
618     uint32_t in_sector_offset = entry_offset % bytes_per_sector;
619 
620     // Find which cluster has the entry
621     uint32_t cluster = m_first_cluster;
622     for (uint32_t offset_remaining = entry_offset;
623          offset_remaining >= bytes_per_sector; offset_remaining \-= bytes_per_sector)
624         cluster = m_volume\->next_cluster(cluster);
625 
626     // Read the full sector into a buffer
627     lba_t base_lba = m_volume\->data_lba + (cluster \- 2) * m_volume\->bpb\&.sectors_per_cluster;
628     buffer_t sector_buffer(bytes_per_sector, false);
629     m_volume\->disk\->read(base_lba + sector_offset, &sector_buffer);
630 
631     // Update the entry in the buffer
632     sector_buffer\&.copy_from(&entry, sizeof(dir_entry_t), in_sector_offset);
633     m_volume\->disk\->write(base_lba + sector_offset, &sector_buffer);
634 }
.fi

.PP
References \fBMaxOS::filesystem::format::Fat32Volume::bpb\fP, \fBbytes_per_sector\fP, \fBMaxOS::filesystem::format::Fat32Volume::data_lba\fP, \fBMaxOS::filesystem::format::Fat32Volume::disk\fP, \fBMaxOS::filesystem::format::Fat32Volume::next_cluster()\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.PP
Referenced by \fBsave_entry_to_disk()\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBFat32File\fP\fC [friend]\fP"

.PP
Definition at line \fB220\fP of file \fBfat32\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

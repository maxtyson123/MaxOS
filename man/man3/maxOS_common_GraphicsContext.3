.TH "maxOS::common::GraphicsContext" 3 "Mon Jan 8 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBmaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.ti -1c
.RI "\fB~GraphicsContext\fP ()"
.br
.ti -1c
.RI "uint32_t \fBcolour_to_int\fP (\fBColour\fP)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (uint32_t)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "uint32_t \fBget_width\fP ()"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "uint32_t \fBget_height\fP ()"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "void \fBput_pixel\fP (int32_t x, int32_t y, \fBColour\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "void \fBputPixel\fP (int32_t x, int32_t y, int32_t colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "void \fBinvert_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "void \fBdraw_line\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdrawLine\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBfill_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfillCircle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBrender_pixel\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_8_bit\fP (uint32_t x, uint32_t y, uint8_t colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_16_bit\fP (uint32_t x, uint32_t y, uint16_t colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_24_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_32_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "virtual uint8_t \fBget_rendered_pixel_8_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual uint16_t \fBget_rendered_pixel_16_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_24_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_32_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBmirror_y_axis\fP { false }"
.br
.ti -1c
.RI "uint32_t \fBm_width\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_height\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_color_depth\fP { 0 }"
.br
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line 19 of file graphicsContext\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Definition at line 9 of file graphicsContext\&.cpp\&.
.PP
.nf
10 {
11 
12 
13     // VirtualBox VGA palette
14     m_colour_pallet[0x00] = Colour(0x00,0x00,0x00);    // Black
15     m_colour_pallet[0x01] = Colour(0x00,0x00,0xA8);    // Duke Blue
16     m_colour_pallet[0x02] = Colour(0x00,0xA8,0x00);    // Islamic Green
17     m_colour_pallet[0x03] = Colour(0x00,0xA8,0xA8);    // Persian Green
18     m_colour_pallet[0x04] = Colour(0xA8,0x00,0x00);    // Dark Candy Apple Red
19     m_colour_pallet[0x05] = Colour(0xA8,0x00,0xA8);    // Heliotrope Magenta
20 
21     m_colour_pallet[0x06] = Colour(0xA8,0xA8,0x00);    // Light Gold
22     m_colour_pallet[0x07] = Colour(0xA8,0xA8,0xA8);    // Dark Gray (X11)
23     m_colour_pallet[0x08] = Colour(0x00,0x00,0x57);    // Cetacean Blue
24     m_colour_pallet[0x09] = Colour(0x00,0x00,0xFF);    // Blue
25     m_colour_pallet[0x0A] = Colour(0x00,0xA8,0x57);    // Green (Pigment)
26     m_colour_pallet[0x0B] = Colour(0x00,0xA8,0xFF);    // Vivid Cerulean
27     m_colour_pallet[0x0C] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
28     m_colour_pallet[0x0D] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
29     m_colour_pallet[0x0E] = Colour(0xA8,0xA8,0x57);    // Olive Green
30     m_colour_pallet[0x0F] = Colour(0xA8,0xA8,0xFF);    // Maximum Blue Purple
31 
32     m_colour_pallet[0x10] = Colour(0x00,0x57,0x00);    // Dark Green (X11)
33     m_colour_pallet[0x11] = Colour(0x00,0x57,0xA8);    // Cobalt Blue
34     m_colour_pallet[0x12] = Colour(0x00,0xFF,0x00);    // Electric Green
35     m_colour_pallet[0x13] = Colour(0x00,0xFF,0xA8);    // Medium Spring Green
36     m_colour_pallet[0x14] = Colour(0xA8,0x57,0x00);    // Windsor Tan
37     m_colour_pallet[0x15] = Colour(0xA8,0x57,0xA8);    // Purpureus
38     m_colour_pallet[0x16] = Colour(0xA8,0xFF,0x00);    // Spring Bud
39     m_colour_pallet[0x17] = Colour(0xA8,0xFF,0xA8);    // Mint Green
40     m_colour_pallet[0x18] = Colour(0x00,0x57,0x57);    // Midnight Green (Eagle Green)
41     m_colour_pallet[0x19] = Colour(0x00,0x57,0xFF);    // Blue (RYB)
42     m_colour_pallet[0x1A] = Colour(0x00,0xFF,0x57);    // Malachite
43     m_colour_pallet[0x1B] = Colour(0x00,0xFF,0xFF);    // Aqua
44     m_colour_pallet[0x1C] = Colour(0xA8,0x57,0x57);    // Middle Red Purple
45     m_colour_pallet[0x1D] = Colour(0xA8,0x57,0xFF);    // Lavender Indigo
46     m_colour_pallet[0x1E] = Colour(0xA8,0xFF,0x57);    // Olive Green
47     m_colour_pallet[0x1F] = Colour(0xA8,0xFF,0xFF);    // Celeste
48 
49     m_colour_pallet[0x20] = Colour(0x57,0x00,0x00);    // Blood Red
50     m_colour_pallet[0x21] = Colour(0x57,0x00,0xA8);    // Metallic Violet
51     m_colour_pallet[0x22] = Colour(0x57,0xA8,0x00);    // Kelly Green
52     m_colour_pallet[0x23] = Colour(0x57,0xA8,0xA8);    // Cadet Blue
53     m_colour_pallet[0x24] = Colour(0xFF,0x00,0x00);    // Red
54     m_colour_pallet[0x25] = Colour(0xFF,0x00,0xA8);    // Fashion Fuchsia
55     m_colour_pallet[0x26] = Colour(0xFF,0xA8,0x00);    // Chrome Yellow
56     m_colour_pallet[0x27] = Colour(0xFF,0xA8,0xA8);    // Light Salmon Pink
57     m_colour_pallet[0x28] = Colour(0x57,0x00,0x57);    // Imperial Purple
58     m_colour_pallet[0x29] = Colour(0x57,0x00,0xFF);    // Electric Indigo
59     m_colour_pallet[0x2A] = Colour(0x57,0xA8,0x57);    // Apple
60     m_colour_pallet[0x2B] = Colour(0x57,0xA8,0xFF);    // Blue Jeans
61     m_colour_pallet[0x2C] = Colour(0xFF,0x00,0x57);    // Folly
62     m_colour_pallet[0x2D] = Colour(0xFF,0x00,0xFF);    // Fuchsia
63     m_colour_pallet[0x2E] = Colour(0xFF,0xA8,0x57);    // Rajah
64     m_colour_pallet[0x2F] = Colour(0xFF,0xA8,0xFF);    // Rich Brilliant Lavender
65 
66     m_colour_pallet[0x30] = Colour(0x57,0x57,0x00);    // Dark Bronze (Coin)
67     m_colour_pallet[0x31] = Colour(0x57,0x57,0xA8);    // Liberty
68     m_colour_pallet[0x32] = Colour(0x57,0xFF,0x00);    // Chlorophyll Green
69     m_colour_pallet[0x33] = Colour(0x57,0xFF,0xA8);    // Medium Aquamarine
70     m_colour_pallet[0x34] = Colour(0xFF,0x57,0x00);    // Orange (Pantone)
71     m_colour_pallet[0x35] = Colour(0xFF,0x57,0xA8);    // Brilliant Rose
72     m_colour_pallet[0x36] = Colour(0xFF,0xFF,0x00);    // Yellow
73     m_colour_pallet[0x37] = Colour(0xFF,0xFF,0xA8);    // Calamansi
74     m_colour_pallet[0x38] = Colour(0x57,0x57,0x57);    // Davy's Grey
75     m_colour_pallet[0x39] = Colour(0x57,0x57,0xFF);    // Very Light Blue
76     m_colour_pallet[0x3A] = Colour(0x57,0xFF,0x57);    // Screamin' Green
77     m_colour_pallet[0x3B] = Colour(0x57,0xFF,0xFF);    // Electric Blue
78     m_colour_pallet[0x3C] = Colour(0xFF,0x57,0x57);    // Sunset Orange
79     m_colour_pallet[0x3D] = Colour(0xFF,0x57,0xFF);    // Shocking Pink (Crayola)
80     m_colour_pallet[0x3E] = Colour(0xFF,0xFF,0x57);    // Shocking Pink (Crayola)
81     m_colour_pallet[0x3F] = Colour(0xFF,0xFF,0xFF);    // White
82 
83 
84     // Set the rest of the palette to black
85     for(uint8_t color_code = 255; color_code >= 0x40; --color_code)
86       m_colour_pallet[color_code] = Colour(0,0,0);
87 
88 
89 }
.fi
.PP
References m_colour_pallet\&.
.SS "GraphicsContext::~GraphicsContext ()"

.PP
Definition at line 91 of file graphicsContext\&.cpp\&.
.PP
.nf
91                                   {
92 
93 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "uint32_t GraphicsContext::colour_to_int (\fBColour\fP colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line 240 of file graphicsContext\&.cpp\&.
.PP
.nf
240                                                      {
241 
242     switch(m_color_depth)
243     {
244         case 8:
245         {
246             uint32_t result = 0;
247             int mindistance = 0xfffffff;
248             for(uint32_t i = 0; i <= 255; ++i)
249             {
250                 Colour* c = &m_colour_pallet[i];
251                 int distance =
252                         ((int)colour\&.red-(int)c->red)*((int)colour\&.red-(int)c->red)
253                         +((int)colour\&.green-(int)c->green)*((int)colour\&.green-(int)c->green)
254                         +((int)colour\&.blue-(int)c->blue)*((int)colour\&.blue-(int)c->blue);
255                 if(distance < mindistance)
256                 {
257                     mindistance = distance;
258                     result = i;
259                 }
260             }
261             return result;
262         }
263         case 16:
264         {
265             // 16-Bit colours RRRRRGGGGGGBBBBB
266             return ((uint16_t)(colour\&.red   & 0xF8)) << 8
267                    | ((uint16_t)(colour\&.green & 0xFC)) << 3
268                    | ((uint16_t)(colour\&.blue  & 0xF8) >> 3);
269         }
270         case 24:
271         {
272             return (uint32_t)colour\&.red   << 16
273                    | (uint32_t)colour\&.green << 8
274                    | (uint32_t)colour\&.blue;
275         }
276         default:
277         case 32:
278         {
279             uint32_t red_hex = ((uint32_t)colour\&.red & 0xFF) << 16;
280             uint32_t green_hex = ((uint32_t)colour\&.green & 0xFF) << 8;
281             uint32_t blue_hex = (uint32_t)colour\&.blue & 0xFF;
282             uint32_t alpha_hex = ((uint32_t)colour\&.alpha & 0xFF) << 24;
283 
284             uint32_t hexValue = red_hex | green_hex | blue_hex | alpha_hex;
285 
286 
287             return hexValue;
288         }
289     }
290 }
.fi
.PP
References maxOS::common::Colour::alpha, maxOS::common::Colour::blue, maxOS::drivers::peripherals::c, maxOS::common::Colour::green, maxOS::drivers::peripherals::i, m_color_depth, m_colour_pallet, and maxOS::common::Colour::red\&.
.PP
Referenced by draw_circle(), draw_line(), draw_rectangle(), maxOS::gui::Font::draw_text(), fill_circle(), fill_rectangle(), get_rendered_pixel(), and put_pixel()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 660 of file graphicsContext\&.cpp\&.
.PP
.nf
660                                                                                       {
661   draw_circle(x0, y0, radius, colour_to_int(colour));
662 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 672 of file graphicsContext\&.cpp\&.
.PP
.nf
672                                                                                          {
673 
674     // Make sure the circle is with in the width and height of the screen
675     if(x0 < 0) x0 = 0;
676     if((uint32_t)x0 > m_width) x0 = m_width;
677     if(y0 < 0) y0 = 0;
678     if((uint32_t)y0 > m_height) y0 = m_height;
679 
680     // Mirror the Y axis as directly calling put_pixel will not do this
681     if(mirror_y_axis)
682         y0 = m_height -y0-1;
683 
684 
685     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
686     for(int32_t x = -radius; x <= radius; ++x){
687 
688         // Draw a line from the top most point of the circle to the bottom most point of the circle
689         for(int32_t y = -radius; y <= radius; ++y){
690 
691             // If the point is within the circle, draw it but make sure it is only part of the outline
692             if(x*x + y*y <= radius*radius && x*x + y*y >= (radius-1)*(radius-1))
693                 putPixel(x0+x,y0+y,colour);
694         }
695     }
696 
697 
698 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::draw_line (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 457 of file graphicsContext\&.cpp\&.
.PP
.nf
457                                                                                              {
458     drawLine(x0,y0,x1,y1, colour_to_int(colour));
459 }
.fi
.PP
References colour_to_int(), and drawLine()\&.
.PP
Referenced by maxOS::gui::widgets::InputBox::draw(), and maxOS::gui::widgets::Button::draw()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 564 of file graphicsContext\&.cpp\&.
.PP
.nf
564                                                                                                   {
565   draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
566 
567 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 578 of file graphicsContext\&.cpp\&.
.PP
.nf
578                                                                                                     {
579 
580     // Ensure x and y 0 is smaller than x and y 1
581     --y0;
582     --x0;
583 
584     // Draw the rectangle
585     drawLine(x0,y0,x1,y0,colour); // Top
586     drawLine(x0,y1,x1,y1,colour); // Bottom
587     drawLine(x0,y0,x0,y1,colour); // Left
588     drawLine(x1,y0,x1,y1,colour); // Right
589 
590 }
.fi
.PP
References drawLine()\&.
.SS "void GraphicsContext::drawLine (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 470 of file graphicsContext\&.cpp\&.
.PP
.nf
470                                                                                               {
471 
472     // Store the minimum and maximum y values
473     bool y_0_is_smaller = y0 < y1;
474     int32_t y_min = y_0_is_smaller ? y0 : y1;
475     int32_t y_max = y_0_is_smaller ? y1 : y0;
476 
477     //Reverse the points to draw from left to right
478     if(x1 < x0){
479         drawLine(x1,y1,x0,y0,colour);
480         return;
481     }
482 
483     // Vertical line
484     if(x1 == x0)
485     {
486         // Force the line to be within the screen
487         if(y_min < 0) y_min = 0;
488         if((uint32_t)y_max >= m_height)
489           y_max = m_height - 1;
490 
491         // Mirror the Y axis as directly calling put_pixel will not do this
492         if(mirror_y_axis)
493         {
494             int32_t temp = y_max;
495             y_max = m_height - y_min - 1;
496             y_min = m_height - temp - 1;
497         }
498 
499         // Check that the line is within the screen
500         if (0 > x0 || (uint32_t) x0 >= m_width) {
501             return;
502         }
503 
504         // Draw the line
505         for(int32_t y = y_min; y <= y_max; ++y)
506             putPixel(x0, y, colour);
507 
508         return;
509     }
510 
511     // Horizontal line
512     if(y1 == y0)
513     {
514         // Ensure the line is within the screen
515         if(x0 < 0) x0 = 0;
516         if((uint32_t)x1 >= m_width) x1 = m_width -1;
517 
518         // Mirror the Y axis as directly calling put_pixel will not do this
519         if(mirror_y_axis)
520             y0 = m_height -y0-1;
521 
522         // Check that the line is within the screen
523         if (0 > y0 || (uint32_t) y0 >= m_height)
524             return;
525 
526         // Draw the line
527         for(int32_t x = x0; x <= x1; ++x)
528             putPixel(x,y0,colour);
529     }
530 
531     // If the line is not horizontal or vertical then it must be a diagonal line
532     // Find the slope of the line
533     float slope = ((float)(y1-y0))/(x1-x0);
534 
535     // A slope that is more horizontal should be drawn by incrementing x
536     if(-1 <= slope && slope <= 1)
537     {
538         float y = y0;
539         for(int32_t x = x0; x <= x1; x++, y+=slope)
540             putPixel(x, (int32_t)y, colour);
541     }
542 
543     // A slope that is more vertical should be drawn by incrementing y
544     else
545     {
546         // Invert the slope
547         slope = 1\&.0f/slope;
548 
549         float x = x0;
550         for(int32_t y = y_min; y <= y_max; x+=slope, y++)
551             putPixel((int32_t)x, y, colour);
552     }
553 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_line(), and draw_rectangle()\&.
.SS "void GraphicsContext::fill_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 708 of file graphicsContext\&.cpp\&.
.PP
.nf
708                                                                                        {
709     fillCircle(x0,y0,radius, colour_to_int(colour));
710 
711 }
.fi
.PP
References colour_to_int(), and fillCircle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 601 of file graphicsContext\&.cpp\&.
.PP
.nf
601                                                                                                   {
602   fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
603 }
.fi
.PP
References colour_to_int()\&.
.PP
Referenced by maxOS::gui::widgets::Text::draw(), maxOS::gui::widgets::InputBox::draw(), maxOS::gui::widgets::Button::draw(), maxOS::gui::Desktop::draw_self(), maxOS::gui::Window::draw_self(), and fill_rectangle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 614 of file graphicsContext\&.cpp\&.
.PP
.nf
614                                                                                                     {
615 
616     // Draw from left to right
617     if(y1 < y0){
618       fill_rectangle(x1, y1, x0, y0, colour);
619         return;
620     }
621 
622     // Make sure the rectangle is within the height of the screen
623     if(y0 < 0) y0 = 0;
624     if((uint32_t)y1 > m_height) y1 = m_height;
625 
626     // Make sure the rectangle is within the width of the screen
627     bool x_0_is_smaller = x0 < x1;
628     int32_t x_min = x_0_is_smaller ? x0 : x1;
629     int32_t x_max = x_0_is_smaller ? x1 : x0;
630 
631     if(x_min < 0) x_min = 0;
632     if((uint32_t)x_max > m_width)
633       x_max = m_width;
634 
635     // Mirror the Y axis as directly calling put_pixel will not do this
636     if(mirror_y_axis)
637     {
638         uint32_t temp = y1;
639         y1 = m_height - y0 - 1;
640         y0 = m_height - temp - 1;
641     }
642 
643     // Draw the rectangle
644     for(int32_t y = y0; y < y1; ++y){
645         for (int32_t x = x_min; x < x_max; ++x) {
646             putPixel(x, y, colour);
647         }
648     }
649 
650 }
.fi
.PP
References fill_rectangle(), m_height, m_width, mirror_y_axis, putPixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::fillCircle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 721 of file graphicsContext\&.cpp\&.
.PP
.nf
721                                                                                         {
722 
723         // Make sure the circle is with in the width and height of the screen
724         if(x0 < 0) x0 = 0;
725         if((uint32_t)x0 > m_width) x0 = m_width;
726         if(y0 < 0) y0 = 0;
727         if((uint32_t)y0 > m_height) y0 = m_height;
728 
729         // Mirror the Y axis as directly calling put_pixel will not do this
730         if(mirror_y_axis)
731             y0 = m_height -y0-1;
732 
733         // Draw the circle
734 
735         // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
736         for(int32_t x = -radius; x <= radius; ++x){
737 
738             // Draw a line from the top most point of the circle to the bottom most point of the circle
739             for(int32_t y = -radius; y <= radius; ++y){
740 
741                 // Only draw the pixel if it is within the circle
742                 if(x*x + y*y <= radius*radius)
743                     putPixel(x0+x,y0+y,colour);
744             }
745         }
746 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by fill_circle()\&.
.SS "uint32_t GraphicsContext::get_height ()"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line 362 of file graphicsContext\&.cpp\&.
.PP
.nf
362                                      {
363     return m_height;
364 }
.fi
.PP
References m_height\&.
.PP
Referenced by maxOS::gui::Desktop::Desktop(), and maxOS::drivers::console::VESABootConsole::height()\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (int32_t x, int32_t y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line 409 of file graphicsContext\&.cpp\&.
.PP
.nf
409                                                       {
410 
411     // Check if the pixel is within the m_width of the screen
412     if (0 > x || (uint32_t)x >= m_width) {
413         return Colour(0,0,0);
414     }
415 
416     // Check if the pixel is within the m_height of the screen
417     if (0 > y || (uint32_t) y >= m_height) {
418         return Colour(0,0,0);
419     }
420 
421     // Get the pixel and convert it to a colour
422     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height - y - 1 : y);
423     return int_to_colour(translated_color);
424 
425 
426 }
.fi
.PP
References get_rendered_pixel(), int_to_colour(), m_height, m_width, mirror_y_axis, maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line 174 of file graphicsContext\&.cpp\&.
.PP
.nf
174                                                                    {
175     // Call the correct get_pixel function based on the color depth
176     switch (m_color_depth) {
177         case 8:
178             return get_rendered_pixel_8_bit(x, y);
179         case 16:
180             return get_rendered_pixel_16_bit(x, y);
181         case 24:
182             return get_rendered_pixel_24_bit(x, y);
183         case 32:
184             return get_rendered_pixel_32_bit(x, y);
185     }
186 
187     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
188 }
.fi
.PP
References colour_to_int(), get_rendered_pixel_16_bit(), get_rendered_pixel_24_bit(), get_rendered_pixel_32_bit(), get_rendered_pixel_8_bit(), m_color_depth, maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by get_pixel()\&.
.SS "uint16_t GraphicsContext::get_rendered_pixel_16_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 208 of file graphicsContext\&.cpp\&.
.PP
.nf
208                                                                       {
209     return 0;
210 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_24_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 219 of file graphicsContext\&.cpp\&.
.PP
.nf
219                                                                       {
220     return 0;
221 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_32_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBmaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 230 of file graphicsContext\&.cpp\&.
.PP
.nf
230                                                                       {
231     return 0;
232 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint8_t GraphicsContext::get_rendered_pixel_8_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBmaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 197 of file graphicsContext\&.cpp\&.
.PP
.nf
197                                                                     {
198     return 0;
199 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_width ()"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line 353 of file graphicsContext\&.cpp\&.
.PP
.nf
353                                     {
354     return m_width;
355 }
.fi
.PP
References m_width\&.
.PP
Referenced by maxOS::gui::Desktop::Desktop(), and maxOS::drivers::console::VESABootConsole::width()\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (uint32_t colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line 298 of file graphicsContext\&.cpp\&.
.PP
.nf
298                                                      {
299     switch (m_color_depth) {
300 
301         case 8:
302         {
303             // Return the colour from the palette
304             return m_colour_pallet[colour & 0xFF];
305         }
306 
307         case 16:
308         {
309             // 16-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
310             Colour result;
311 
312             result\&.red = (colour & 0xF800) >> 8;
313             result\&.green = (colour & 0x07E0) >> 3;
314             result\&.blue = (colour & 0x001F) << 3;
315 
316             return result;
317         }
318 
319         case 24:
320         {
321             // 24-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
322             Colour result;
323 
324             result\&.red = (colour & 0xFF0000) >> 16;
325             result\&.green = (colour & 0x00FF00) >> 8;
326             result\&.blue = (colour & 0x0000FF);
327 
328             return result;
329         }
330 
331         default:
332         case 32:
333         {
334             Colour result;
335 
336             uint32_t hex_value = colour;
337             result\&.red = (hex_value >> 16) & 0xFF;
338             result\&.green = (hex_value >> 8) & 0xFF;
339             result\&.blue = hex_value & 0xFF;
340             result\&.alpha = (hex_value >> 24) & 0xFF;
341 
342             return result;
343 
344         }
345     }
346 }
.fi
.PP
References maxOS::common::Colour::alpha, maxOS::common::Colour::blue, maxOS::common::Colour::green, m_color_depth, m_colour_pallet, and maxOS::common::Colour::red\&.
.PP
Referenced by get_pixel()\&.
.SS "void GraphicsContext::invert_pixel (int32_t x, int32_t y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line 434 of file graphicsContext\&.cpp\&.
.PP
.nf
434                                                        {
435     // Get the pixel
436     Colour colour = get_pixel(x, y);
437 
438     // Invert the pixel
439     colour\&.red = 255 - colour\&.red;
440     colour\&.green = 255 - colour\&.green;
441     colour\&.blue = 255 - colour\&.blue;
442 
443     // Render the pixel
444     put_pixel(x, y, colour);
445 }
.fi
.PP
References maxOS::common::Colour::blue, get_pixel(), maxOS::common::Colour::green, put_pixel(), maxOS::common::Colour::red, maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by maxOS::gui::Desktop::invert_mouse_cursor()\&.
.SS "void GraphicsContext::put_pixel (int32_t x, int32_t y, \fBColour\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 373 of file graphicsContext\&.cpp\&.
.PP
.nf
373                                                                    {
374 
375     // Convert the colour to an integer and then print it
376     putPixel(x,y, colour_to_int(colour));
377 }
.fi
.PP
References colour_to_int(), putPixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "void GraphicsContext::putPixel (int32_t x, int32_t y, int32_t colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 386 of file graphicsContext\&.cpp\&.
.PP
.nf
386                                                                    {
387 
388     if (0 > x || (uint32_t)x >= m_width) {
389         return;
390     }
391 
392     // Check if the pixel is within the m_height of the screen
393     if (0 > y || (uint32_t) y >= m_height) {
394         return;
395     }
396 
397     // Render the pixel
398     render_pixel(x, mirror_y_axis ? m_height - y - 1 : y, colour);
399 
400 }
.fi
.PP
References m_height, m_width, mirror_y_axis, render_pixel(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), and put_pixel()\&.
.SS "void GraphicsContext::render_pixel (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 102 of file graphicsContext\&.cpp\&.
.PP
.nf
102                                                                           {
103 
104     // Call the correct put_pixel function based on the color depth
105     switch (m_color_depth) {
106         case 8:
107           render_pixel_8_bit(x, y, colour);
108             break;
109         case 16:
110           render_pixel_16_bit(x, y, colour);
111             break;
112         case 24:
113           render_pixel_24_bit(x, y, colour);
114             break;
115         case 32:
116           render_pixel_32_bit(x, y, colour);
117             break;
118     }
119 
120 
121 }
.fi
.PP
References m_color_depth, render_pixel_16_bit(), render_pixel_24_bit(), render_pixel_32_bit(), render_pixel_8_bit(), maxOS::drivers::peripherals::x, and maxOS::drivers::peripherals::y\&.
.PP
Referenced by putPixel()\&.
.SS "void GraphicsContext::render_pixel_16_bit (uint32_t x, uint32_t y, uint16_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 141 of file graphicsContext\&.cpp\&.
.PP
.nf
141                                                                       {
142 
143 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_24_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 152 of file graphicsContext\&.cpp\&.
.PP
.nf
152                                                                       {
153 
154 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_32_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBmaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 163 of file graphicsContext\&.cpp\&.
.PP
.nf
163                                                                       {
164 
165 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_8_bit (uint32_t x, uint32_t y, uint8_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBmaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 130 of file graphicsContext\&.cpp\&.
.PP
.nf
130                                                                     {
131 
132 }
.fi
.PP
Referenced by render_pixel()\&.
.SH "Member Data Documentation"
.PP 
.SS "uint32_t maxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
Definition at line 26 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), get_rendered_pixel(), int_to_colour(), render_pixel(), and maxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "\fBColour\fP maxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
Definition at line 28 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), GraphicsContext(), and int_to_colour()\&.
.SS "uint32_t maxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
Definition at line 25 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_height(), get_pixel(), putPixel(), and maxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "uint32_t maxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
Definition at line 24 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), get_width(), putPixel(), and maxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "bool maxOS::common::GraphicsContext::mirror_y_axis { false }\fC [protected]\fP"

.PP
Definition at line 22 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), and putPixel()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

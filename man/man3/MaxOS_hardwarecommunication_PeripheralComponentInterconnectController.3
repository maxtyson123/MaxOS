.TH "MaxOS::hardwarecommunication::PeripheralComponentInterconnectController" 3 "Mon Jan 29 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::PeripheralComponentInterconnectController \- Handles the selecting and loading of drivers for PCI devices\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <pci\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::DriverSelector\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPeripheralComponentInterconnectController\fP (\fBcommon::OutputStream\fP *)"
.br
.RI "__CONTROLLER___ "
.ti -1c
.RI "\fB~PeripheralComponentInterconnectController\fP ()"
.br
.ti -1c
.RI "void \fBselect_drivers\fP (\fBdrivers::DriverSelectorEventHandler\fP *handler, \fBhardwarecommunication::InterruptManager\fP *interrupt_manager) override"
.br
.RI "Select the driver for the device\&. "
.ti -1c
.RI "\fBdrivers::Driver\fP * \fBget_driver\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev, \fBInterruptManager\fP *interrupt_manager)"
.br
.RI "Get the driver for the device\&. "
.ti -1c
.RI "void \fBlist_known_deivce\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles the selecting and loading of drivers for PCI devices\&. 
.PP
Definition at line 77 of file pci\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PeripheralComponentInterconnectController::PeripheralComponentInterconnectController (\fBcommon::OutputStream\fP * stream)"

.PP
__CONTROLLER___ 
.PP
Definition at line 80 of file pci\&.cpp\&.
.PP
.nf
81 : m_data_port(0xCFC),
82   m_command_port(0xCF8),
83   m_debug_messages_stream(stream)
84 {
85 
86 }
.fi
.SS "PeripheralComponentInterconnectController::~PeripheralComponentInterconnectController ()"

.PP
Definition at line 88 of file pci\&.cpp\&.
.PP
.nf
88                                                                                       {
89 
90 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBDriver\fP * PeripheralComponentInterconnectController::get_driver (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev, \fBInterruptManager\fP * interrupt_manager)"

.PP
Get the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdev\fP Device descriptor 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device, 0 if there is no driver 
.RE
.PP

.PP
Definition at line 238 of file pci\&.cpp\&.
.PP
.nf
238                                                                                                                                                      {
239 
240     // Dont use new here, manually allocate memory instead
241 
242     Driver* driver = 0;
243     switch (dev\&.vendor_id)
244     {
245         case 0x1022:    //AMD
246         {
247             switch (dev\&.device_id)
248             {
249                 case 0x2000:    //am79c971
250                 {
251                     amd_am79c973* result = (amd_am79c973*)MemoryManager::s_active_memory_manager ->malloc(sizeof(amd_am79c973));
252                     new (result) amd_am79c973(&dev, interrupt_manager);
253                     return result;
254 
255                 }
256                 default:
257                     break;
258             }
259             break;
260         }
261         case 0x8086:  //Intel
262         {
263             switch (dev\&.device_id)
264             {
265                 case 0x100E: //i217 (Ethernet Controller)
266                 {
267                     intel_i217* result = (intel_i217*)MemoryManager::s_active_memory_manager
268                           ->malloc(sizeof(intel_i217));
269                     new (result) intel_i217(&dev, interrupt_manager);
270                     return result;
271                 }
272                 default:
273                     break;
274             }
275             break;
276         }//End Intel
277     }
278 
279     //If there is no driver for the particular device, go into generic devices
280     switch (dev\&.class_id)
281     {
282         case 0x03: //Graphics
283         {
284 
285             switch (dev\&.subclass_id)
286             {
287                 case 0x00:  //VGA
288                 {
289                     VideoGraphicsArray* result = (VideoGraphicsArray*)MemoryManager::s_active_memory_manager->malloc(sizeof(VideoGraphicsArray));
290                     new (result) VideoGraphicsArray();
291                     return result;
292                 }
293             }
294             break;
295         }
296     }
297 
298     return driver;
299 }
.fi
.PP
References MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::class_id, MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::device_id, MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::subclass_id, and MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id\&.
.PP
Referenced by select_drivers()\&.
.SS "void PeripheralComponentInterconnectController::list_known_deivce (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)"

.PP
Definition at line 302 of file pci\&.cpp\&.
.PP
.nf
302                                                                                                                      {
303     switch (dev\&.vendor_id)
304     {
305         case 0x1022:
306         {
307             // The vendor is AMD
308             m_debug_messages_stream->write("AMD ");
309 
310             // List the device
311             switch (dev\&.device_id)
312             {
313                 default:
314                   m_debug_messages_stream->write_hex(dev\&.device_id);
315                   break;
316             }
317             break;
318         }
319 
320         case 0x106B:
321         {
322             // The vendor is Apple
323             m_debug_messages_stream->write("Apple ");
324 
325             // List the device
326             switch (dev\&.device_id)
327             {
328                 case 0x003F:
329                 {
330                   m_debug_messages_stream->write("KeyLargo/Intrepid USB");
331                   break;
332                 }
333 
334                 default:
335                   m_debug_messages_stream->write_hex(dev\&.device_id);
336                     break;
337             }
338             break;
339         }
340 
341         case 1234:
342         {
343             // The vendor is QEMU
344             m_debug_messages_stream->write("QEMU ");
345 
346             // List the device
347             switch (dev\&.device_id)
348             {
349 
350                 case 0x1111:
351                 {
352                   m_debug_messages_stream->write("Virtual Video Controller");
353                     break;
354                 }
355             }
356             break;
357         }
358 
359         case 0x8086:
360         {
361             // The vendor is Intel
362             m_debug_messages_stream->write("Intel ");
363 
364             // List the device
365             switch (dev\&.device_id)
366             {
367 
368                 case 0x1237:
369                 {
370                   m_debug_messages_stream->write("440FX");
371                     break;
372                 }
373 
374                 case 0x2415:
375                 {
376                   m_debug_messages_stream->write("AC'97");
377                     break;
378                 }
379 
380                 case 0x7000:
381                 {
382                   m_debug_messages_stream->write("PIIX3");
383                     break;
384 
385                 }
386 
387                 case 0x7010:
388                 {
389                   m_debug_messages_stream->write("PIIX4");
390                     break;
391 
392                 }
393 
394                 case 0x7111:
395                 {
396                   m_debug_messages_stream->write("PIIX3");
397                     break;
398                 }
399 
400                 case 0x7113:
401                 {
402                   m_debug_messages_stream->write("PIIX4 ACPI");
403                     break;
404                 }
405 
406                 default:
407                     break;
408 
409             }
410             break;
411         }
412 
413         case 0x80EE: {
414 
415             // The vendor is VirtualBox
416             m_debug_messages_stream->write("VirtualBox ");
417 
418             // List the device
419             switch (dev\&.device_id) {
420 
421                 case 0xBEEF: {
422                   m_debug_messages_stream->write("Graphics Adapter");
423                     break;
424                 }
425 
426                 case 0xCAFE: {
427                   m_debug_messages_stream->write("Guest Service");
428                     break;
429                 }
430             }
431             break;
432         }
433 
434         default:    // Unknown
435           m_debug_messages_stream->write_hex(dev\&.vendor_id);
436           m_debug_messages_stream->write(" ");
437           m_debug_messages_stream->write_hex(dev\&.device_id);
438           break;
439 
440     }
441 }
.fi
.PP
References MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::device_id, MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id, MaxOS::common::OutputStream::write(), and MaxOS::common::OutputStream::write_hex()\&.
.PP
Referenced by select_drivers()\&.
.SS "void PeripheralComponentInterconnectController::select_drivers (\fBdrivers::DriverSelectorEventHandler\fP * handler, \fBhardwarecommunication::InterruptManager\fP * interrupt_manager)\fC [override]\fP, \fC [virtual]\fP"

.PP
Select the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdriverManager\fP device driver manager 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::DriverSelector\fP\&.
.PP
Definition at line 159 of file pci\&.cpp\&.
.PP
.nf
160 {
161     for (int bus = 0; bus < 8; ++bus) {
162         for (int device = 0; device < 32; ++device) {
163 
164             int numFunctions = (device_has_functions(bus, device)) ? 8 : 1;
165 
166             for (int function = 0; function < numFunctions; ++function) {
167 
168                 // Get the device descriptor, if the vendor id is 0x0000 or 0xFFFF, the device is not present/ready
169                 PeripheralComponentInterconnectDeviceDescriptor deviceDescriptor = get_device_descriptor(bus, device, function);
170                 if(deviceDescriptor\&.vendor_id == 0x0000 || deviceDescriptor\&.vendor_id == 0x0001 || deviceDescriptor\&.vendor_id == 0xFFFF)
171                     continue;
172 
173 
174                 // Get port number
175                 for(int barNum = 5; barNum >= 0; barNum--){
176                     BaseAddressRegister bar = get_base_address_register(bus, device, function, barNum);
177                     if(bar\&.address && (bar\&.type == InputOutput))
178                         deviceDescriptor\&.port_base = (uint32_t)bar\&.address;
179                 }
180 
181                 // write to the debug stream
182                 m_debug_messages_stream->write(deviceDescriptor\&.get_type());
183                 m_debug_messages_stream->write(": ");
184 
185                 // Select the driver and print information about the device
186                 Driver* driver = get_driver(deviceDescriptor, interrupt_manager);
187                 if(driver != 0){
188                   handler->on_driver_selected(driver);
189                   m_debug_messages_stream->write(driver->get_vendor_name());
190                   m_debug_messages_stream->write(" ");
191                   m_debug_messages_stream->write(driver->get_device_name());
192                 }else{
193                   list_known_deivce(deviceDescriptor);
194                 }
195 
196                 // New line
197                 m_debug_messages_stream->write("\n");
198             }
199         }
200     }
201 }
.fi
.PP
References MaxOS::hardwarecommunication::BaseAddressRegister::address, bus, MaxOS::drivers::Driver::get_device_name(), get_driver(), MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::get_type(), MaxOS::drivers::Driver::get_vendor_name(), MaxOS::hardwarecommunication::InputOutput, list_known_deivce(), MaxOS::drivers::DriverSelectorEventHandler::on_driver_selected(), MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::port_base, MaxOS::hardwarecommunication::BaseAddressRegister::type, MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id, and MaxOS::common::OutputStream::write()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

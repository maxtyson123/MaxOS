.TH "MaxOS::hardwarecommunication::PeripheralComponentInterconnectController" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::PeripheralComponentInterconnectController \- Handles the selecting and loading of drivers for PCI devices\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <pci\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::DriverSelector\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBselect_drivers\fP (\fBdrivers::DriverSelectorEventHandler\fP *\fBhandler\fP) \fBoverride\fP"
.br
.RI "Select the driver for the device\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBdrivers::Driver\fP * \fBget_driver\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP \fBdev\fP)"
.br
.RI "Get the driver for the device\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBlist_known_device\fP (\fBconst\fP \fBPeripheralComponentInterconnectDeviceDescriptor\fP &\fBdev\fP)"
.br
.RI "Print the vednor and device id of known devices, or 'Unknown' + their ids if not known\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the selecting and loading of drivers for PCI devices\&. 
.PP
Definition at line \fB89\fP of file \fBpci\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PeripheralComponentInterconnectController::PeripheralComponentInterconnectController ()"

.PP
Definition at line \fB96\fP of file \fBpci\&.cpp\fP\&..PP
.nf
97 : m_data_port(0xCFC),
98   m_command_port(0xCF8)
99 {
100 
101 
102 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBDriver\fP * PeripheralComponentInterconnectController::get_driver (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)\fC [static]\fP"

.PP
Get the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdev\fP Device descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device, null pointer if there is no driver 
.RE
.PP

.PP
Definition at line \fB248\fP of file \fBpci\&.cpp\fP\&..PP
.nf
248                                                                                                                  {
249 
250     switch (dev\&.vendor_id) {
251         case 0x1022:    //AMD
252         {
253             switch (dev\&.device_id) {
254                 case 0x2000: {
255                     return new AMD_AM79C973(&dev);
256 
257                 }
258                 default:
259                     break;
260             }
261             break;
262         }
263         case 0x8086:  //Intel
264         {
265             switch (dev\&.device_id) {
266 
267                 case 0x100E: //i217 (Ethernet Controller)
268                 {
269                     return new IntelI217(&dev);
270                 }
271 
272                 case 0x7010: // PIIX4 (IDE Controller)
273                 {
274                     return new IntegratedDriveElectronicsController(&dev);
275                 }
276 
277                 default:
278                     break;
279             }
280             break;
281         }//End Intel
282     }
283 
284     //If there is no driver for the particular device, go into generic devices
285     switch (dev\&.class_id) {
286         case 0x03: //Graphics
287         {
288 
289             switch (dev\&.subclass_id) {
290                 case 0x00:  //VGA
291                 {
292                     return new VideoGraphicsArray();
293                 }
294             }
295             break;
296         }
297     }
298 
299     return nullptr;
300 }
.fi

.PP
Referenced by \fBselect_drivers()\fP\&.
.SS "\fBvoid\fP PeripheralComponentInterconnectController::list_known_device (\fBconst\fP \fBPeripheralComponentInterconnectDeviceDescriptor\fP & dev)\fC [static]\fP"

.PP
Print the vednor and device id of known devices, or 'Unknown' + their ids if not known\&. 
.PP
\fBParameters\fP
.RS 4
\fIdev\fP The device to print 
.RE
.PP

.PP
Definition at line \fB307\fP of file \fBpci\&.cpp\fP\&..PP
.nf
307                                                                                                                              {
308 
309     switch (dev\&.vendor_id) {
310         case 0x1022: {
311             // The vendor is AMD
312             Logger::Out() << "AMD ";
313 
314             // List the device
315             switch (dev\&.device_id) {
316                 default:
317                     Logger::Out() << "0x%x" << dev\&.device_id;
318                     break;
319             }
320             break;
321         }
322 
323         case 0x106B: {
324             // The vendor is Apple
325             Logger::Out() << "Apple ";
326 
327             // List the device
328             switch (dev\&.device_id) {
329                 case 0x003F: {
330                     Logger::Out() << "KeyLargo/Intrepid USB";
331                     break;
332                 }
333 
334                 default:
335                     Logger::Out() << "0x%x" << dev\&.device_id;
336                     break;
337             }
338             break;
339         }
340 
341         case 1234: {
342             // The vendor is QEMU
343             Logger::Out() << "QEMU ";
344 
345             // List the device
346             switch (dev\&.device_id) {
347 
348                 case 0x1111: {
349                     Logger::Out() << "Virtual Video Controller";
350                     break;
351                 }
352             }
353             break;
354         }
355 
356         case 0x8086: {
357             // The vendor is Intel
358             Logger::Out() << "Intel ";
359 
360             // List the device
361             switch (dev\&.device_id) {
362 
363                 case 0x1237: {
364                     Logger::Out() << "440FX";
365                     break;
366                 }
367 
368                 case 0x2415: {
369                     Logger::Out() << "AC'97";
370                     break;
371                 }
372 
373                 case 0x7000: {
374                     Logger::Out() << "PIIX3";
375                     break;
376 
377                 }
378 
379                 case 0x7111: {
380                     Logger::Out() << "PIIX3 ACPI";
381                     break;
382                 }
383 
384                 case 0x7113: {
385                     Logger::Out() << "PIIX4 ACPI";
386                     break;
387                 }
388 
389                 default:
390                     Logger::Out() << "0x%x" << dev\&.device_id;
391                     break;
392 
393             }
394             break;
395         }
396 
397         case 0x80EE: {
398 
399             // The vendor is VirtualBox
400             Logger::Out() << "VirtualBox ";
401 
402             // List the device
403             switch (dev\&.device_id) {
404 
405                 case 0xBEEF: {
406                     Logger::Out() << "Graphics Adapter";
407                     break;
408                 }
409 
410                 case 0xCAFE: {
411                     Logger::Out() << "Guest Service";
412                     break;
413                 }
414             }
415             break;
416         }
417 
418             // Unknown
419         default:
420             Logger::Out() << "Unknown (0x" << dev\&.vendor_id << ":0x" << dev\&.device_id << ")";
421             break;
422 
423     }
424 }
.fi

.PP
References \fBLogger::Out()\fP\&.
.PP
Referenced by \fBselect_drivers()\fP\&.
.SS "\fBvoid\fP PeripheralComponentInterconnectController::select_drivers (\fBdrivers::DriverSelectorEventHandler\fP * handler)\fC [override]\fP, \fC [virtual]\fP"

.PP
Select the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandler\fP device driver event manager 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::DriverSelector\fP\&.
.PP
Definition at line \fB173\fP of file \fBpci\&.cpp\fP\&..PP
.nf
173                                                                                                   {
174 
175     for (int bus = 0; bus < 8; ++bus) {
176         for (int device = 0; device < 32; ++device) {
177 
178             int numFunctions = (device_has_functions(bus, device)) ? 8 : 1;
179 
180             for (int function = 0; function < numFunctions; ++function) {
181 
182                 // Get the device descriptor, if the vendor id is 0x0000 or 0xFFFF, the device is not present/ready
183                 PeripheralComponentInterconnectDeviceDescriptor deviceDescriptor = get_device_descriptor(bus, device,
184                                                                                                          function);
185                 if (deviceDescriptor\&.vendor_id == 0x0000 || deviceDescriptor\&.vendor_id == 0x0001 ||
186                     deviceDescriptor\&.vendor_id == 0xFFFF)
187                     continue;
188 
189                 // Get the earliest port number
190                 for (int barNum = 5; barNum >= 0; barNum\-\-) {
191                     BaseAddressRegister bar = get_base_address_register(bus, device, function, barNum);
192                     if (bar\&.address && (bar\&.type == BaseAddressRegisterType::InputOutput))
193                         deviceDescriptor\&.port_base = (uint64_t) bar\&.address;
194                 }
195 
196                 Logger::DEBUG() << "DEVICE FOUND: " << deviceDescriptor\&.get_type() << " \- ";
197 
198                 // Select the driver and print information about the device
199                 Driver* driver = get_driver(deviceDescriptor);
200                 if (driver != nullptr) {
201                     handler\->on_driver_selected(driver);
202                     Logger::Out() << driver\->vendor_name() << " " << driver\->device_name();
203                 } else {
204                     list_known_device(deviceDescriptor);
205                 }
206 
207                 Logger::Out() << "\\n";
208             }
209         }
210     }
211 }
.fi

.PP
References \fBbus\fP, \fBLogger::DEBUG()\fP, \fBget_driver()\fP, \fBlist_known_device()\fP, and \fBLogger::Out()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

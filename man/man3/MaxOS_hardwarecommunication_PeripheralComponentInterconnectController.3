.TH "MaxOS::hardwarecommunication::PeripheralComponentInterconnectController" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::PeripheralComponentInterconnectController \- Handles the selecting and loading of drivers for PCI devices\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <pci\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::DriverSelector\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPeripheralComponentInterconnectController\fP ()"
.br
.ti -1c
.RI "\fB~PeripheralComponentInterconnectController\fP ()"
.br
.ti -1c
.RI "\fBvoid\fP \fBselect_drivers\fP (\fBdrivers::DriverSelectorEventHandler\fP *\fBhandler\fP) \fBoverride\fP"
.br
.RI "Select the driver for the device\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::DriverSelector\fP
.in +1c
.ti -1c
.RI "\fBDriverSelector\fP ()"
.br
.ti -1c
.RI "\fB~DriverSelector\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBdrivers::Driver\fP * \fBget_driver\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP \fBdev\fP)"
.br
.RI "Get the driver for the device\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBlist_known_device\fP (\fBconst\fP \fBPeripheralComponentInterconnectDeviceDescriptor\fP &\fBdev\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles the selecting and loading of drivers for PCI devices\&. 
.PP
Definition at line \fB77\fP of file \fBpci\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PeripheralComponentInterconnectController::PeripheralComponentInterconnectController ()"

.PP
Definition at line \fB89\fP of file \fBpci\&.cpp\fP\&..PP
.nf
90 : m_data_port(0xCFC),
91   m_command_port(0xCF8)
92 {
93 
94 
95 }
.fi

.SS "PeripheralComponentInterconnectController::~PeripheralComponentInterconnectController ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBDriver\fP * PeripheralComponentInterconnectController::get_driver (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)\fC [static]\fP"

.PP
Get the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdev\fP Device descriptor 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device, null pointer if there is no driver 
.RE
.PP

.PP
Definition at line \fB244\fP of file \fBpci\&.cpp\fP\&..PP
.nf
244                                                                                                                  {
245 
246     switch (dev\&.vendor_id) {
247         case 0x1022:    //AMD
248         {
249             switch (dev\&.device_id) {
250                 case 0x2000: {
251                     return new AMD_AM79C973(&dev);
252 
253                 }
254                 default:
255                     break;
256             }
257             break;
258         }
259         case 0x8086:  //Intel
260         {
261             switch (dev\&.device_id) {
262 
263                 case 0x100E: //i217 (Ethernet Controller)
264                 {
265                     return new intel_i217(&dev);
266                 }
267 
268                 case 0x7010: // PIIX4 (IDE Controller)
269                 {
270                     return new IntegratedDriveElectronicsController(&dev);
271                 }
272 
273                 default:
274                     break;
275             }
276             break;
277         }//End Intel
278     }
279 
280     //If there is no driver for the particular device, go into generic devices
281     switch (dev\&.class_id) {
282         case 0x03: //Graphics
283         {
284 
285             switch (dev\&.subclass_id) {
286                 case 0x00:  //VGA
287                 {
288                     return new VideoGraphicsArray();
289                 }
290             }
291             break;
292         }
293     }
294 
295     return nullptr;
296 }
.fi

.PP
Referenced by \fBselect_drivers()\fP\&.
.SS "\fBvoid\fP PeripheralComponentInterconnectController::list_known_device (\fBconst\fP \fBPeripheralComponentInterconnectDeviceDescriptor\fP & dev)\fC [static]\fP"

.PP
Definition at line \fB299\fP of file \fBpci\&.cpp\fP\&..PP
.nf
300                                                                     {
301 
302     switch (dev\&.vendor_id) {
303         case 0x1022: {
304             // The vendor is AMD
305             Logger::Out() << "AMD ";
306 
307             // List the device
308             switch (dev\&.device_id) {
309                 default:
310                     Logger::Out() << "0x%x" << dev\&.device_id;
311                     break;
312             }
313             break;
314         }
315 
316         case 0x106B: {
317             // The vendor is Apple
318             Logger::Out() << "Apple ";
319 
320             // List the device
321             switch (dev\&.device_id) {
322                 case 0x003F: {
323                     Logger::Out() << "KeyLargo/Intrepid USB";
324                     break;
325                 }
326 
327                 default:
328                     Logger::Out() << "0x%x" << dev\&.device_id;
329                     break;
330             }
331             break;
332         }
333 
334         case 1234: {
335             // The vendor is QEMU
336             Logger::Out() << "QEMU ";
337 
338             // List the device
339             switch (dev\&.device_id) {
340 
341                 case 0x1111: {
342                     Logger::Out() << "Virtual Video Controller";
343                     break;
344                 }
345             }
346             break;
347         }
348 
349         case 0x8086: {
350             // The vendor is Intel
351             Logger::Out() << "Intel ";
352 
353             // List the device
354             switch (dev\&.device_id) {
355 
356                 case 0x1237: {
357                     Logger::Out() << "440FX";
358                     break;
359                 }
360 
361                 case 0x2415: {
362                     Logger::Out() << "AC'97";
363                     break;
364                 }
365 
366                 case 0x7000: {
367                     Logger::Out() << "PIIX3";
368                     break;
369 
370                 }
371 
372                 case 0x7111: {
373                     Logger::Out() << "PIIX3 ACPI";
374                     break;
375                 }
376 
377                 case 0x7113: {
378                     Logger::Out() << "PIIX4 ACPI";
379                     break;
380                 }
381 
382                 default:
383                     Logger::Out() << "0x%x" << dev\&.device_id;
384                     break;
385 
386             }
387             break;
388         }
389 
390         case 0x80EE: {
391 
392             // The vendor is VirtualBox
393             Logger::Out() << "VirtualBox ";
394 
395             // List the device
396             switch (dev\&.device_id) {
397 
398                 case 0xBEEF: {
399                     Logger::Out() << "Graphics Adapter";
400                     break;
401                 }
402 
403                 case 0xCAFE: {
404                     Logger::Out() << "Guest Service";
405                     break;
406                 }
407             }
408             break;
409         }
410 
411             // Unknown
412         default:
413             Logger::Out() << "Unknown (0x" << dev\&.vendor_id << ":0x" << dev\&.device_id << ")";
414             break;
415 
416     }
417 }
.fi

.PP
References \fBLogger::Out()\fP\&.
.PP
Referenced by \fBselect_drivers()\fP\&.
.SS "\fBvoid\fP PeripheralComponentInterconnectController::select_drivers (\fBdrivers::DriverSelectorEventHandler\fP * handler)\fC [override]\fP, \fC [virtual]\fP"

.PP
Select the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdriverManager\fP device driver manager 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::DriverSelector\fP\&.
.PP
Definition at line \fB168\fP of file \fBpci\&.cpp\fP\&..PP
.nf
168                                                                                                   {
169 
170     for (int bus = 0; bus < 8; ++bus) {
171         for (int device = 0; device < 32; ++device) {
172 
173             int numFunctions = (device_has_functions(bus, device)) ? 8 : 1;
174 
175             for (int function = 0; function < numFunctions; ++function) {
176 
177                 // Get the device descriptor, if the vendor id is 0x0000 or 0xFFFF, the device is not present/ready
178                 PeripheralComponentInterconnectDeviceDescriptor deviceDescriptor = get_device_descriptor(bus, device,
179                                                                                                          function);
180                 if (deviceDescriptor\&.vendor_id == 0x0000 || deviceDescriptor\&.vendor_id == 0x0001 ||
181                     deviceDescriptor\&.vendor_id == 0xFFFF)
182                     continue;
183 
184                 // Get the earliest port number
185                 for (int barNum = 5; barNum >= 0; barNum\-\-) {
186                     BaseAddressRegister bar = get_base_address_register(bus, device, function, barNum);
187                     if (bar\&.address && (bar\&.type == BaseAddressRegisterType::InputOutput))
188                         deviceDescriptor\&.port_base = (uint64_t) bar\&.address;
189                 }
190 
191                 Logger::DEBUG() << "DEVICE FOUND: " << deviceDescriptor\&.get_type() << " \- ";
192 
193                 // Select the driver and print information about the device
194                 Driver* driver = get_driver(deviceDescriptor);
195                 if (driver != nullptr) {
196                     handler\->on_driver_selected(driver);
197                     Logger::Out() << driver\->vendor_name() << " " << driver\->device_name();
198                 } else {
199                     list_known_device(deviceDescriptor);
200                 }
201 
202                 Logger::Out() << "\\n";
203             }
204         }
205     }
206 }
.fi

.PP
References \fBbus\fP, \fBLogger::DEBUG()\fP, \fBget_driver()\fP, \fBMaxOS::hardwarecommunication::InputOutput\fP, \fBlist_known_device()\fP, and \fBLogger::Out()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::drivers::video::VideoElectronicsStandardsAssociation" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::video::VideoElectronicsStandardsAssociation \- \fBDriver\fP for the VESA video controller, handles the rendering of pixels to the screen using VESA\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vesa\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVideoElectronicsStandardsAssociation\fP (\fBmultiboot_tag_framebuffer\fP *framebuffer_info)"
.br
.ti -1c
.RI "\fB~VideoElectronicsStandardsAssociation\fP ()"
.br
.ti -1c
.RI "bool \fBsupports_mode\fP (uint32_t width, uint32_t height, uint32_t) final"
.br
.RI "Checks if the VESA driver supports the given mode\&. "
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP () final"
.br
.RI "Renders a pixel on the screen in 16 bit mode\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP () final"
.br
.RI "Gets the colour of a pixel on the screen in 16 bit mode\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBinternal_set_mode\fP (uint32_t width, uint32_t height, uint32_t) final"
.br
.RI "Sets the mode of the VESA driver\&. "
.ti -1c
.RI "void \fBrender_pixel_32_bit\fP (uint32_t x, uint32_t y, uint32_t colour) final"
.br
.RI "Renders a pixel on the screen in 32 bit mode\&. "
.ti -1c
.RI "uint32_t \fBget_rendered_pixel_32_bit\fP (uint32_t x, uint32_t y) final"
.br
.RI "Gets the colour of a pixel on the screen in 32 bit mode\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBm_framebuffer_size\fP"
.br
.ti -1c
.RI "\fBmultiboot_tag_framebuffer\fP * \fBm_framebuffer_info\fP"
.br
.ti -1c
.RI "uint8_t \fBm_bpp\fP"
.br
.ti -1c
.RI "uint16_t \fBm_pitch\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
\fBDriver\fP for the VESA video controller, handles the rendering of pixels to the screen using VESA\&. 
.PP
Definition at line 26 of file vesa\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation (\fBmultiboot_tag_framebuffer\fP * framebuffer_info)"

.PP
Definition at line 15 of file vesa\&.cpp\&.
.PP
.nf
16 : VideoDriver(),
17   m_framebuffer_info(framebuffer_info)
18 {
19   // Get the framebuffer info
20   _kprintf("Framebuffer info: 0x%x\n", m_framebuffer_info);
21 
22   // Set the framebuffer address, bpp and pitch
23   m_bpp = m_framebuffer_info->common\&.framebuffer_bpp;
24   m_pitch = m_framebuffer_info->common\&.framebuffer_pitch;
25   m_framebuffer_size = m_framebuffer_info->common\&.framebuffer_height * m_pitch;
26 
27   _kprintf("Framebuffer: bpp=%d, pitch=%d, size=%d\n", m_bpp, m_pitch, m_framebuffer_size);
28 
29   // Get the framebuffer address
30   uint64_t physical_address = (uint64_t)m_framebuffer_info->common\&.framebuffer_addr;
31   uint64_t virtual_address = (uint64_t)MemoryManager::to_dm_region(physical_address);
32   uint64_t end = physical_address + m_framebuffer_size;
33   m_framebuffer_address = (uint64_t*)virtual_address;
34 
35   _kprintf("Framebuffer address: physical=0x%x, virtual=0x%x\n", physical_address, virtual_address);
36 
37   // Map the framebuffer
38   while (physical_address < end) {
39 
40     PhysicalMemoryManager::s_current_manager->map((physical_address_t*)physical_address, (virtual_address_t*)virtual_address, Write | Present);
41     physical_address += PhysicalMemoryManager::s_page_size;
42     virtual_address += PhysicalMemoryManager::s_page_size;
43   }
44 
45   size_t pages = PhysicalMemoryManager::size_to_frames(virtual_address - (uint64_t)m_framebuffer_address);
46   _kprintf("Framebuffer mapped: 0x%x - 0x%x (pages: %d)\n", m_framebuffer_address, virtual_address, pages);
47 
48   // Reserve the physical memory
49   PhysicalMemoryManager::s_current_manager->reserve(m_framebuffer_info->common\&.framebuffer_addr, pages);
50 }
.fi
.PP
References _kprintf, multiboot_tag_framebuffer::common, MaxOS::drivers::peripherals::end, multiboot_tag_framebuffer_common::framebuffer_addr, multiboot_tag_framebuffer_common::framebuffer_bpp, multiboot_tag_framebuffer_common::framebuffer_height, multiboot_tag_framebuffer_common::framebuffer_pitch, m_bpp, MaxOS::common::GraphicsContext::m_framebuffer_address, m_framebuffer_info, m_framebuffer_size, m_pitch, physical_address, MaxOS::memory::Present, and MaxOS::memory::Write\&.
.SS "VideoElectronicsStandardsAssociation::~VideoElectronicsStandardsAssociation ()"

.PP
Definition at line 52 of file vesa\&.cpp\&.
.PP
.nf
52                                                                            {
53 
54 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBstring\fP VideoElectronicsStandardsAssociation::get_device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen in 16 bit mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16bit colour of the pixel 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 151 of file vesa\&.cpp\&.
.PP
.nf
151                                                              {
152     return "VESA compatible graphics card";
153 }
.fi
.SS "uint32_t VideoElectronicsStandardsAssociation::get_rendered_pixel_32_bit (uint32_t x, uint32_t y)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen in 32 bit mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32bit colour of the pixel 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::common::GraphicsContext\fP\&.
.PP
Definition at line 124 of file vesa\&.cpp\&.
.PP
.nf
124                                                                                                {
125 
126     // Get the address of the pixel
127     uint32_t*pixel_address = (uint32_t*)((uint8_t *)m_framebuffer_address + m_pitch * (y) + m_bpp * (x) / 8);
128 
129     // Return the pixel
130     return *pixel_address;
131 }
.fi
.PP
References m_bpp, MaxOS::common::GraphicsContext::m_framebuffer_address, m_pitch, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "\fBstring\fP VideoElectronicsStandardsAssociation::get_vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Renders a pixel on the screen in 16 bit mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16bit colour of the pixel 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 140 of file vesa\&.cpp\&.
.PP
.nf
140                                                              {
141     return "NEC Home Electronics";  // Creator of the VESA standard
142 }
.fi
.SS "bool VideoElectronicsStandardsAssociation::internal_set_mode (uint32_t width, uint32_t height, uint32_t)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Sets the mode of the VESA driver\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP Width of the screen 
.br
\fIheight\fP Height of the screen 
.br
\fIcolor_depth\fP Color depth of the screen 
.RE
.PP
\fBReturns\fP
.RS 4
True if the mode was set successfully, false otherwise 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::video::VideoDriver\fP\&.
.PP
Definition at line 75 of file vesa\&.cpp\&.
.PP
.nf
75                                                                                          {
76 
77     // Best mode is set by the bootloader
78     return true;
79 
80 
81 }
.fi
.SS "void VideoElectronicsStandardsAssociation::render_pixel_32_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel on the screen in 32 bit mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32bit colour of the pixel 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::common::GraphicsContext\fP\&.
.PP
Definition at line 107 of file vesa\&.cpp\&.
.PP
.nf
107                                                                                                       {
108 
109     // Get the address of the pixel
110     uint32_t*pixel_address = (uint32_t*)((uint8_t *)m_framebuffer_address + m_pitch * (y) + m_bpp * (x) / 8);
111 
112     // Set the pixel
113     *pixel_address = colour;
114 
115 }
.fi
.PP
References m_bpp, MaxOS::common::GraphicsContext::m_framebuffer_address, m_pitch, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "bool VideoElectronicsStandardsAssociation::supports_mode (uint32_t width, uint32_t height, uint32_t color_depth)\fC [final]\fP, \fC [virtual]\fP"

.PP
Checks if the VESA driver supports the given mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP The m_width of the screen 
.br
\fIheight\fP The m_height of the screen 
.br
\fIcolor_depth\fP The color depth of the screen 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::video::VideoDriver\fP\&.
.PP
Definition at line 91 of file vesa\&.cpp\&.
.PP
.nf
91                                                                                                               {
92 
93     // Check if the mode is supported
94     if(width == (uint32_t)m_framebuffer_info->common\&.framebuffer_width && height == (uint32_t)m_framebuffer_info->common\&.framebuffer_height && color_depth == (uint32_t)m_framebuffer_info->common\&.framebuffer_bpp) {
95         return true;
96     }
97     return false;
98 }
.fi
.PP
References multiboot_tag_framebuffer::common, multiboot_tag_framebuffer_common::framebuffer_bpp, multiboot_tag_framebuffer_common::framebuffer_height, multiboot_tag_framebuffer_common::framebuffer_width, and m_framebuffer_info\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t MaxOS::drivers::video::VideoElectronicsStandardsAssociation::m_bpp\fC [protected]\fP"

.PP
Definition at line 42 of file vesa\&.h\&.
.PP
Referenced by get_rendered_pixel_32_bit(), render_pixel_32_bit(), and VideoElectronicsStandardsAssociation()\&.
.SS "\fBmultiboot_tag_framebuffer\fP* MaxOS::drivers::video::VideoElectronicsStandardsAssociation::m_framebuffer_info\fC [protected]\fP"

.PP
Definition at line 41 of file vesa\&.h\&.
.PP
Referenced by supports_mode(), and VideoElectronicsStandardsAssociation()\&.
.SS "size_t MaxOS::drivers::video::VideoElectronicsStandardsAssociation::m_framebuffer_size\fC [protected]\fP"

.PP
Definition at line 38 of file vesa\&.h\&.
.PP
Referenced by VideoElectronicsStandardsAssociation()\&.
.SS "uint16_t MaxOS::drivers::video::VideoElectronicsStandardsAssociation::m_pitch\fC [protected]\fP"

.PP
Definition at line 43 of file vesa\&.h\&.
.PP
Referenced by get_rendered_pixel_32_bit(), render_pixel_32_bit(), and VideoElectronicsStandardsAssociation()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::drivers::video::VideoElectronicsStandardsAssociation" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::video::VideoElectronicsStandardsAssociation \- \fBDriver\fP for the VESA video controller, handles the rendering of pixels to the screen using VESA\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vesa\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVideoElectronicsStandardsAssociation\fP (\fBmultiboot_tag_framebuffer\fP *\fBframebuffer_info\fP)"
.br
.RI "Constructs a new VESA driver object\&. Maps the framebuffer into the higher half\&. "
.ti -1c
.RI "\fBbool\fP \fBsupports_mode\fP (\fBuint32_t\fP \fBwidth\fP, \fBuint32_t\fP \fBheight\fP, \fBuint32_t\fP) \fBfinal\fP"
.br
.RI "Checks if the VESA driver supports the given mode\&. "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBfinal\fP"
.br
.RI "The name of the vendor of the VESA standard\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBfinal\fP"
.br
.RI "The name of the device\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::video::VideoDriver\fP
.in +1c
.ti -1c
.RI "\fBbool\fP \fBset_mode\fP (\fBuint32_t\fP \fBwidth\fP, \fBuint32_t\fP \fBheight\fP, \fBuint32_t\fP \fBcolor_depth\fP)"
.br
.RI "Set the mode of the video driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBactivate\fP ()"
.br
.RI "Activate the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "Deactivate the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::GraphicsContext\fP
.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.RI "Constructs a \fBGraphicsContext\fP object and initializes the color palette\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolour_to_int\fP (\fBconst\fP \fBColour\fP &)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (\fBuint32_t\fP)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBwidth\fP () \fBconst\fP"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBheight\fP () \fBconst\fP"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolor_depth\fP () \fBconst\fP"
.br
.RI "Gets the current color depth (bits per pixel) "
.ti -1c
.RI "\fBuint64_t\fP * \fBframebuffer_address\fP ()"
.br
.RI "Gets the address of the context's framebuffer to draw on\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvert_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBMaxOS::common::GraphicsContext\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint8_t\fP \fBget_rendered_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint16_t\fP \fBget_rendered_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::common::GraphicsContext\fP
.in +1c
.ti -1c
.RI "\fBbool\fP \fBmirror_y_axis\fP"
.br
.RI "Should the y axis be mirrored (0,0 is top left if false, bottom left if true) "
.ti -1c
.RI "\fBuint32_t\fP \fBm_width\fP { 0 }"
.br
.RI "The width of the screen in pixels\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_height\fP { 0 }"
.br
.RI "The height of the screen in pixels\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_color_depth\fP { 0 }"
.br
.RI "The color depth of the screen in bits per pixel\&. "
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.RI "The colour pallet for 8 bit color depth\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBm_framebuffer_address\fP { \fBnullptr\fP }"
.br
.RI "The address of the framebuffer\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the VESA video controller, handles the rendering of pixels to the screen using VESA\&. 
.PP
Definition at line \fB26\fP of file \fBvesa\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation (\fBmultiboot_tag_framebuffer\fP * framebuffer_info)\fC [explicit]\fP"

.PP
Constructs a new VESA driver object\&. Maps the framebuffer into the higher half\&. 
.PP
\fBParameters\fP
.RS 4
\fIframebuffer_info\fP The framebuffer information from multiboot 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBvesa\&.cpp\fP\&..PP
.nf
25 : m_framebuffer_info(framebuffer_info)
26 {
27 
28     Logger::INFO() << "Setting up VESA driver\\n";
29 
30     // Save the framebuffer info
31     m_bpp = m_framebuffer_info\->common\&.framebuffer_bpp;
32     m_pitch = m_framebuffer_info\->common\&.framebuffer_pitch;
33     m_framebuffer_size = m_framebuffer_info\->common\&.framebuffer_height * m_pitch;
34     this\->set_mode(framebuffer_info\->common\&.framebuffer_width, framebuffer_info\->common\&.framebuffer_height, framebuffer_info\->common\&.framebuffer_bpp);
35     Logger::DEBUG() << "Framebuffer: bpp=" << m_bpp << ", pitch=" << m_pitch << ", size=" << m_framebuffer_size << "\\n";
36 
37     // Map the frame buffer into the higher half
38     auto physical_address = (uint64_t) m_framebuffer_info\->common\&.framebuffer_addr;
39     m_framebuffer_address = (uint64_t *) PhysicalMemoryManager::to_dm_region(physical_address);
40     PhysicalMemoryManager::s_current_manager\->map_area((physical_address_t *) physical_address, m_framebuffer_address, m_framebuffer_size, WRITE | PRESENT);
41 
42     // Reserve the physical memory
43     size_t pages = PhysicalMemoryManager::size_to_frames(m_framebuffer_size);
44     PhysicalMemoryManager::s_current_manager\->reserve(m_framebuffer_info\->common\&.framebuffer_addr, pages, "Framebuffer");
45 
46     // Log info
47     Logger::DEBUG() << "Framebuffer address: physical=0x" << (uint64_t) physical_address << ", virtual=0x" << (uint64_t) m_framebuffer_address << "\\n";
48     Logger::DEBUG() << "Framebuffer mapped: 0x" << (uint64_t) m_framebuffer_address << " \- 0x" << (uint64_t) (m_framebuffer_address + m_framebuffer_size) << " (pages: " << pages << ")\\n";
49 
50 }
.fi

.PP
References \fBmultiboot_tag_framebuffer::common\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBMaxOS::Logger::INFO()\fP, \fBMaxOS::common::GraphicsContext::m_framebuffer_address\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::memory::PhysicalMemoryManager::size_to_frames()\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_dm_region()\fP, and \fBMaxOS::memory::WRITE\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBstring\fP VideoElectronicsStandardsAssociation::device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
The name of the device\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB130\fP of file \fBvesa\&.cpp\fP\&..PP
.nf
130                                                          {
131     return "VESA compatible graphics card";
132 }
.fi

.SS "\fBbool\fP VideoElectronicsStandardsAssociation::supports_mode (\fBuint32_t\fP width, \fBuint32_t\fP height, \fBuint32_t\fP color_depth)\fC [final]\fP, \fC [virtual]\fP"

.PP
Checks if the VESA driver supports the given mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP The m_width of the screen 
.br
\fIheight\fP The m_height of the screen 
.br
\fIcolor_depth\fP The color depth of the screen 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::video::VideoDriver\fP\&.
.PP
Definition at line \fB79\fP of file \fBvesa\&.cpp\fP\&..PP
.nf
79                                                                                                               {
80 
81     // Check if the mode is supported
82     return width == m_framebuffer_info\->common\&.framebuffer_width
83            && height == m_framebuffer_info\->common\&.framebuffer_height
84            && color_depth == m_framebuffer_info\->common\&.framebuffer_bpp;
85 }
.fi

.PP
References \fBMaxOS::common::GraphicsContext::color_depth()\fP, \fBmultiboot_tag_framebuffer::common\fP, \fBMaxOS::common::GraphicsContext::height()\fP, and \fBMaxOS::common::GraphicsContext::width()\fP\&.
.SS "\fBstring\fP VideoElectronicsStandardsAssociation::vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
The name of the vendor of the VESA standard\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB119\fP of file \fBvesa\&.cpp\fP\&..PP
.nf
119                                                          {
120 
121     // Creator of the VESA standard
122     return "NEC Home Electronics";
123 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::memory::MemoryManager" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::MemoryManager \- Handles memory allocation and deallocation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <memorymanagement\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMemoryManager\fP (\fBVirtualMemoryManager\fP *\fBvirtual_memory_manager\fP=\fBnullptr\fP)"
.br
.ti -1c
.RI "\fB~MemoryManager\fP ()"
.br
.ti -1c
.RI "\fBvoid\fP * \fBhandle_malloc\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Allocates a block of memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBhandle_free\fP (\fBvoid\fP *pointer)"
.br
.RI "Frees a block of memory\&. "
.ti -1c
.RI "\fBVirtualMemoryManager\fP * \fBvmm\fP ()"
.br
.ti -1c
.RI "\fBint\fP \fBmemory_used\fP ()"
.br
.RI "Returns the amount of memory used\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBmalloc\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Allocates a block of memory in the current USERSPACE heap\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBfree\fP (\fBvoid\fP *pointer)"
.br
.RI "Frees a block of memory using the current memory manager\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBkmalloc\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Allocates a block of memory in the KERNEL space\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBkfree\fP (\fBvoid\fP *pointer)"
.br
.RI "Frees a block of memory using the kernel memory manager\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Aligns the size to the chunk alignment\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBswitch_active_memory_manager\fP (\fBMemoryManager\fP *\fBmanager\fP)"
.br
.RI "Switches the active memory manager\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBMemoryManager\fP * \fBprevious_memory_manager\fP = nullptr"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBMemoryManager\fP * \fBs_current_memory_manager\fP = nullptr"
.br
.ti -1c
.RI "static \fBMemoryManager\fP * \fBs_kernel_memory_manager\fP = nullptr"
.br
.ti -1c
.RI "static const size_t \fBs_chunk_alignment\fP = 0x10"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles memory allocation and deallocation\&. 
.PP
Definition at line \fB35\fP of file \fBmemorymanagement\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MemoryManager::MemoryManager (\fBVirtualMemoryManager\fP * virtual_memory_manager = \fC\fBnullptr\fP\fP)"

.PP
Definition at line \fB13\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
14 : m_virtual_memory_manager(vmm)
15 {
16 
17     // Create the VMM if not provided
18     if (m_virtual_memory_manager == nullptr)
19         m_virtual_memory_manager = new VirtualMemoryManager();
20 
21     // Enable the memory manager
22     switch_active_memory_manager(this);
23 
24     // Setup the first chunk of memory
25     this\->m_first_memory_chunk = (MemoryChunk*) m_virtual_memory_manager\->allocate(PhysicalMemoryManager::s_page_size + sizeof(MemoryChunk), 0);
26     m_first_memory_chunk\->allocated = false;
27     m_first_memory_chunk\->prev = nullptr;
28     m_first_memory_chunk\->next = nullptr;
29     m_first_memory_chunk\->size = PhysicalMemoryManager::s_page_size \- sizeof(MemoryChunk);
30     m_last_memory_chunk = m_first_memory_chunk;
31 
32     // First memory manager is the kernel memory manager
33     if (s_kernel_memory_manager == nullptr)
34         s_kernel_memory_manager = this;
35 
36 }
.fi

.PP
References \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBMaxOS::memory::MemoryChunk::allocated\fP, \fBMaxOS::memory::MemoryChunk::next\fP, \fBMaxOS::memory::MemoryChunk::prev\fP, \fBs_kernel_memory_manager\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_page_size\fP, \fBMaxOS::memory::MemoryChunk::size\fP, and \fBswitch_active_memory_manager()\fP\&.
.SS "MemoryManager::~MemoryManager ()"

.PP
Definition at line \fB38\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
38                               {
39 
40     // Free the VMM (if this is not the kernel memory manager)
41     if (m_virtual_memory_manager != nullptr && s_current_memory_manager != s_kernel_memory_manager)
42         delete m_virtual_memory_manager;
43 
44     // Remove the kernel reference to this
45     if (s_kernel_memory_manager == this)
46         s_kernel_memory_manager = nullptr;
47 
48     // Remove the active reference to this
49     if (s_current_memory_manager == this)
50         s_current_memory_manager = nullptr;
51 }
.fi

.PP
References \fBs_current_memory_manager\fP, and \fBs_kernel_memory_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBsize_t\fP MemoryManager::align (\fBsize_t\fP size)\fC [static]\fP"

.PP
Aligns the size to the chunk alignment\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line \fB277\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
277                                        {
278 
279     return (size / s_chunk_alignment + 1) * s_chunk_alignment;
280 }
.fi

.PP
References \fBs_chunk_alignment\fP, and \fBsize\fP\&.
.PP
Referenced by \fBhandle_malloc()\fP\&.
.SS "\fBvoid\fP MemoryManager::free (\fBvoid\fP * pointer)\fC [static]\fP"

.PP
Frees a block of memory using the current memory manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP The pointer to the block 
.RE
.PP

.PP
Definition at line \fB147\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
147                                       {
148 
149     // Make sure there is a memory manager
150     if (s_current_memory_manager == nullptr)
151         return;
152 
153     s_current_memory_manager\->handle_free(pointer);
154 }
.fi

.PP
References \fBs_current_memory_manager\fP\&.
.PP
Referenced by \fBMaxOS::system::SyscallManager::syscall_free_memory()\fP\&.
.SS "\fBvoid\fP MemoryManager::handle_free (\fBvoid\fP * pointer)"

.PP
Frees a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP A pointer to the block 
.RE
.PP

.PP
Definition at line \fB175\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
175                                              {
176 
177     // Cant free unallocated memory
178     if (pointer == nullptr)
179         return;
180 
181     // Check bounds
182     if ((uint64_t) pointer < (uint64_t) m_first_memory_chunk || (uint64_t) pointer > (uint64_t) m_last_memory_chunk)
183         return;
184 
185     // Get the chunk information from the pointer
186     auto* chunk = (MemoryChunk*) ((size_t) pointer \- sizeof(MemoryChunk));
187     chunk\->allocated = false;
188 
189     // If there is a free chunk before this chunk then merge them
190     if (chunk\->prev != nullptr && !chunk\->prev\->allocated) {
191 
192         // Grow the chunk behind this one so that it now contains the freed one
193         chunk\->prev\->size += chunk\->size + sizeof(MemoryChunk);
194         chunk\->prev\->next = chunk\->next;
195 
196         // The chunk in front of the freed one now needs to point to the merged chunk
197         if (chunk\->next != nullptr)
198             chunk\->next\->prev = chunk\->prev;
199 
200         // Freed chunk doesn't exist anymore so now working with the merged chunk
201         chunk = chunk\->prev;
202 
203     }
204 
205     // If there is a free chunk after this chunk then merge them
206     if (chunk\->next != nullptr && !chunk\->next\->allocated) {
207 
208         // Grow this chunk so that it now contains the free chunk in front of the old (now freed) one
209         chunk\->size += chunk\->next\->size + sizeof(MemoryChunk);
210 
211         // Now that this chunk contains the next one, it has to point to the one in front of what has just been merged
212         // and that has to point to this
213         chunk\->next = chunk\->next\->next;
214         if (chunk\->next != nullptr)
215             chunk\->next\->prev = chunk;
216 
217     }
218 }
.fi

.SS "\fBvoid\fP * MemoryManager::handle_malloc (\fBsize_t\fP size)"

.PP
Allocates a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the block to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the block, or nullptr if no block is available 
.RE
.PP

.PP
Definition at line \fB89\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
89                                               {
90 
91     MemoryChunk* result = nullptr;
92 
93     // Nothing to allocate
94     if (size == 0)
95         return nullptr;
96 
97     // Add room to store the chunk information
98     size = align(size + sizeof(MemoryChunk));
99 
100     // Find the next free chunk that is big enough
101     for (MemoryChunk* chunk = m_first_memory_chunk; chunk != nullptr && result == nullptr; chunk = chunk\->next) {
102         if (chunk\->size > size && !chunk\->allocated)
103             result = chunk;
104     }
105 
106     // If there is no free chunk then make more room
107     if (result == nullptr)
108         result = expand_heap(size);
109 
110     // If there is not left over space to store extra chunks there is no need to split the chunk
111     if (result\->size < size + sizeof(MemoryChunk) + 1) {
112         result\->allocated = true;
113         void* p = (void*) (((size_t) result) + sizeof(MemoryChunk));
114         return p;
115     }
116 
117     // Split the chunk into: what was requested + free overflow space for future allocates
118     //  \- This prevents waste in the event that a big free chunk was found but the requested size would only use a portion of that
119     auto* extra = (MemoryChunk*) ((size_t) result + sizeof(MemoryChunk) + size);
120     extra\->allocated = false;
121     extra\->size = result\->size \- size \- sizeof(MemoryChunk);
122     extra\->prev = result;
123 
124     // Add to the linked list
125     extra\->next = result\->next;
126     if (extra\->next != nullptr)
127         extra\->next\->prev = extra;
128 
129     // Requested chunk is now allocated exactly to the size requested and points to the free (split) block of memory that
130     // it did not use
131     result\->size = size;
132     result\->allocated = true;
133     result\->next = extra;
134 
135     // Update the last memory chunk if necessary
136     if (result == m_last_memory_chunk)
137         m_last_memory_chunk = extra;
138 
139     return (void*) (((size_t) result) + sizeof(MemoryChunk));
140 }
.fi

.PP
References \fBalign()\fP, and \fBsize\fP\&.
.SS "\fBvoid\fP MemoryManager::kfree (\fBvoid\fP * pointer)\fC [static]\fP"

.PP
Frees a block of memory using the kernel memory manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP The pointer to the block 
.RE
.PP

.PP
Definition at line \fB161\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
161                                        {
162 
163     // Make sure there is a kernel memory manager
164     if (s_kernel_memory_manager == nullptr)
165         return;
166 
167     s_kernel_memory_manager\->handle_free(pointer);
168 }
.fi

.PP
References \fBs_kernel_memory_manager\fP\&.
.PP
Referenced by \fBMaxOS::net::TransmissionControlProtocolSocket::Connected()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::Disconnect()\fP, \fBMaxOS::net::TransmissionControlProtocolSocket::Disconnected()\fP, \fBMaxOS::net::TransmissionControlProtocolSocket::handleTransmissionControlProtocolPayload()\fP, \fBMaxOS::net::UserDatagramProtocolSocket::handleUserDatagramProtocolPayload()\fP, \fBoperator delete()\fP, \fBoperator delete()\fP, \fBoperator delete[]()\fP, \fBoperator delete[]()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::Send()\fP, \fBMaxOS::net::EthernetFrameHandler::sendEthernetFrame()\fP, \fBMaxOS::net::InternetProtocolHandler::sendInternetProtocolPacket()\fP, and \fBMaxOS::net::TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket()\fP\&.
.SS "\fBvoid\fP * MemoryManager::kmalloc (\fBsize_t\fP size)\fC [static]\fP"

.PP
Allocates a block of memory in the KERNEL space\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the block 
.RE
.PP
\fBReturns\fP
.RS 4
The pointer to the block, or nullptr if no block is available 
.RE
.PP

.PP
Definition at line \fB74\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
74                                         {
75 
76     // Make sure there is a kernel memory manager
77     if (s_kernel_memory_manager == nullptr)
78         return nullptr;
79 
80     return s_kernel_memory_manager\->handle_malloc(size);
81 }
.fi

.PP
References \fBs_kernel_memory_manager\fP, and \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::drivers::ethernet::AMD_AM79C973::AMD_AM79C973()\fP, \fBMaxOS::net::TransmissionControlProtocolHandler::Connect()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::Connect()\fP, \fBMaxOS::net::TransmissionControlProtocolHandler::Listen()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::Listen()\fP, \fBoperator new()\fP, \fBoperator new[]()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::Send()\fP, \fBMaxOS::net::EthernetFrameHandler::sendEthernetFrame()\fP, \fBMaxOS::net::InternetProtocolHandler::sendInternetProtocolPacket()\fP, \fBMaxOS::net::TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket()\fP, \fBMaxOS::processes::Thread::Thread()\fP, and \fBMaxOS::drivers::console::VESABootConsole::VESABootConsole()\fP\&.
.SS "\fBvoid\fP * MemoryManager::malloc (\fBsize_t\fP size)\fC [static]\fP"

.PP
Allocates a block of memory in the current USERSPACE heap\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP size of the block 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the block, 0 if no block is available or no memory manager is set 
.RE
.PP

.PP
Definition at line \fB59\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
59                                        {
60 
61     // Make sure there is somthing to do the allocation
62     if (s_current_memory_manager == nullptr)
63         return nullptr;
64 
65     return s_current_memory_manager\->handle_malloc(size);
66 }
.fi

.PP
References \fBs_current_memory_manager\fP, and \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::system::SyscallManager::syscall_allocate_memory()\fP, and \fBMaxOS::processes::Thread::Thread()\fP\&.
.SS "\fBint\fP MemoryManager::memory_used ()"

.PP
Returns the amount of memory used\&. 
.PP
\fBReturns\fP
.RS 4
The amount of memory used 
.RE
.PP

.PP
Definition at line \fB259\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
259                                {
260 
261     int result = 0;
262 
263     // Loop through all the chunks and add up the size of the allocated chunks
264     for (MemoryChunk* chunk = m_first_memory_chunk; chunk != nullptr; chunk = chunk\->next)
265         if (chunk\->allocated)
266             result += chunk\->size;
267 
268     return result;
269 }
.fi

.SS "\fBvoid\fP MemoryManager::switch_active_memory_manager (\fBMemoryManager\fP * manager)\fC [static]\fP"

.PP
Switches the active memory manager\&. 
.PP
\fBParameters\fP
.RS 4
\fImanager\fP The new memory manager 
.RE
.PP

.PP
Definition at line \fB288\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
288                                                                        {
289 
290     // Make sure there is a manager
291     if (manager == nullptr)
292         return;
293 
294     // Switch the address space
295     asm volatile("mov %0, %%cr3"::"r"((uint64_t) manager\->m_virtual_memory_manager\->pml4_root_address_physical()) : "memory");
296 
297     // Set the active memory manager
298     s_current_memory_manager = manager;
299 }
.fi

.PP
References \fBs_current_memory_manager\fP\&.
.PP
Referenced by \fBMemoryManager()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBVirtualMemoryManager\fP * MemoryManager::vmm ()"
Gets the active virtual memory manager
.PP
\fBReturns\fP
.RS 4
The active virtual memory manager 
.RE
.PP

.PP
Definition at line \fB306\fP of file \fBmemorymanagement\&.cpp\fP\&..PP
.nf
306                                          {
307 
308     return m_virtual_memory_manager;
309 }
.fi

.SH "Member Data Documentation"
.PP 
.SS "\fBMemoryManager\fP* MaxOS::memory::MemoryManager::previous_memory_manager = nullptr"

.PP
Definition at line \fB52\fP of file \fBmemorymanagement\&.h\fP\&.
.SS "const size_t MaxOS::memory::MemoryManager::s_chunk_alignment = 0x10\fC [static]\fP"

.PP
Definition at line \fB50\fP of file \fBmemorymanagement\&.h\fP\&.
.PP
Referenced by \fBalign()\fP\&.
.SS "\fBMemoryManager\fP* MaxOS::memory::MemoryManager::s_current_memory_manager = nullptr\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB46\fP of file \fBmemorymanagement\&.h\fP\&.
.PP
Referenced by \fBfree()\fP, \fBmalloc()\fP, \fBswitch_active_memory_manager()\fP, and \fB~MemoryManager()\fP\&.
.SS "\fBMemoryManager\fP* MaxOS::memory::MemoryManager::s_kernel_memory_manager = nullptr\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB47\fP of file \fBmemorymanagement\&.h\fP\&.
.PP
Referenced by \fBkfree()\fP, \fBkmalloc()\fP, \fBMemoryManager()\fP, \fBMaxOS::processes::Process::Process()\fP, \fBMaxOS::processes::Scheduler::Scheduler()\fP, \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP, and \fB~MemoryManager()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

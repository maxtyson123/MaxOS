.TH "MaxOS::drivers::console::VESABootConsole" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::console::VESABootConsole \- \fBDriver\fP for the VESA \fBConsole\fP during boot, handles the printing of characters and strings to the screen using VESA protocol\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vesaboot\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::Driver\fP, and \fBMaxOS::drivers::console::Console\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVESABootConsole\fP (\fBcommon::GraphicsContext\fP *)"
.br
.RI "Constructs a new VESA Boot \fBConsole\fP object, initializing the console area for text output\&. "
.ti -1c
.RI "\fBuint16_t\fP \fBwidth\fP () \fBfinal\fP"
.br
.RI "Gets the width of the console\&. "
.ti -1c
.RI "\fBuint16_t\fP \fBheight\fP () \fBfinal\fP"
.br
.RI "Gets the height of the console\&. "
.ti -1c
.RI "\fBvoid\fP \fBfinish\fP () \fBconst\fP"
.br
.RI "Cleans up the boot console\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP) \fBfinal\fP"
.br
.RI "Places a character at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_foreground_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP) \fBfinal\fP"
.br
.RI "Sets the foreground color at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_background_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP) \fBfinal\fP"
.br
.RI "Sets the background color at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBscroll_up\fP (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP \fBwidth\fP, \fBuint16_t\fP \fBheight\fP, \fBcommon::ConsoleColour\fP \fBforeground\fP, \fBcommon::ConsoleColour\fP \fBbackground\fP, \fBchar\fP \fBfill\fP) \fBfinal\fP"
.br
.RI "Scrolls the console up by 1 line\&. "
.ti -1c
.RI "\fBchar\fP \fBget_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the character at the specified location\&. "
.ti -1c
.RI "\fBcommon::ConsoleColour\fP \fBget_foreground_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the foreground color at the specified location\&. "
.ti -1c
.RI "\fBcommon::ConsoleColour\fP \fBget_background_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the background color at the specified location\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBactivate\fP ()"
.br
.RI "Activate the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "Deactivate the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBstring\fP \fBvendor_name\fP ()"
.br
.RI "Get who created the device\&. "
.ti -1c
.RI "\fBvirtual\fP \fBstring\fP \fBdevice_name\fP ()"
.br
.RI "Get the device name of the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::console::Console\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBput_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP c, \fBcommon::ConsoleColour\fP \fBforeground\fP, \fBcommon::ConsoleColour\fP \fBbackground\fP)"
.br
.RI "Put a character on the console with a given foreground and background color\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBput_string\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBstring\fP s, \fBcommon::ConsoleColour\fP \fBforeground\fP=common::ConsoleColour::LightGrey, \fBcommon::ConsoleColour\fP \fBbackground\fP=common::ConsoleColour::Black)"
.br
.RI "Put a string on the console\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBscroll_up\fP ()"
.br
.RI "Scroll the entire console up by 1 line\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBclear\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBclear\fP (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP \fBwidth\fP, \fBuint16_t\fP \fBheight\fP, \fBcommon::ConsoleColour\fP \fBforeground\fP=common::ConsoleColour::LightGrey, \fBcommon::ConsoleColour\fP \fBbackground\fP=common::ConsoleColour::Black, \fBchar\fP \fBfill\fP=' ')"
.br
.RI "Clear an area of the console\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinvert_colors\fP (\fBuint16_t\fP x, \fBuint16_t\fP y)"
.br
.RI "Invert the colors of a character on the console\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBprint_logo\fP (\fBbool\fP \fBis_panic\fP=\fBfalse\fP)"
.br
.RI "Prints the logo to the center of the screen\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBupdate_progress_bar\fP (\fBuint8_t\fP \fBpercentage\fP)"
.br
.RI "Updates the progress bar\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBConsoleStream\fP * \fBcout\fP"
.br
.RI "The boot console output stream\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the VESA \fBConsole\fP during boot, handles the printing of characters and strings to the screen using VESA protocol\&. 
.PP
Definition at line \fB30\fP of file \fBvesaboot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VESABootConsole::VESABootConsole (\fBcommon::GraphicsContext\fP * graphics_context)\fC [explicit]\fP"

.PP
Constructs a new VESA Boot \fBConsole\fP object, initializing the console area for text output\&. 
.PP
\fBParameters\fP
.RS 4
\fIgraphics_context\fP The graphics context to use for rendering 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
26         : m_font((uint8_t*) AMIGA_FONT) {
27 
28     // Set up
29     Logger::INFO() << "Setting up VESA console\\n";
30     s_graphics_context = graphics_context;
31     m_video_memory_meta = (uint16_t*) MemoryManager::kmalloc(width() * height() * sizeof(uint16_t));
32 
33     // Prepare the console
34     VESABootConsole::clear();
35     print_logo();
36     m_console_area = new ConsoleArea(this, 0, 0, width() / 2 \- 25, height(), ConsoleColour::DarkGrey, ConsoleColour::Black);
37     cout = new ConsoleStream(m_console_area);
38 
39     // Only log to the screen when debugging
40 #ifndef NDEBUG
41     Logger::active_logger()\->add_log_writer(cout);
42     Logger::INFO() << "Console Stream set up \\n";
43 #endif
44 }
.fi

.PP
References \fBMaxOS::Logger::active_logger()\fP, \fBMaxOS::drivers::console::Console::clear()\fP, \fBcout\fP, \fBheight()\fP, \fBMaxOS::Logger::INFO()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBprint_logo()\fP, and \fBwidth()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP VESABootConsole::finish () const"

.PP
Cleans up the boot console\&. 
.PP
Definition at line \fB349\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
349                                    {
350 
351     // Done
352     Logger::HEADER() << "MaxOS Kernel Successfully Booted\\n" << ANSI_COLOURS[ANSIColour::Reset];
353     cout\->set_cursor(0, 0);
354     Logger::active_logger()\->disable_log_writer(cout);
355 }
.fi

.PP
References \fBMaxOS::Logger::active_logger()\fP, \fBMaxOS::common::ANSI_COLOURS\fP, \fBcout\fP, \fBMaxOS::Logger::HEADER()\fP, and \fBMaxOS::drivers::console::ConsoleStream::set_cursor()\fP\&.
.PP
Referenced by \fBkernel_main()\fP\&.
.SS "\fBConsoleColour\fP VESABootConsole::get_background_color (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the background color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate
.RE
.PP
\fBReturns\fP
.RS 4
The background color at the specified location or black if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB229\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
229                                                                           {
230 
231     if(CPU::panic_lock\&.is_locked())
232         return ConsoleColour::Red;
233 
234     // If the coordinates are out of bounds, return
235     if(x >= width() || y >= height())
236         return ConsoleColour::Black;
237 
238     // Calculate the offset
239     int offset = (y * width() + x);
240 
241     // Return the background color at the offset, by masking the background color with the current background color (bits 12\-15)
242     return (ConsoleColour) ((m_video_memory_meta[offset] & 0xF000) >> 12);
243 }
.fi

.PP
References \fBheight()\fP, \fBMaxOS::system::CPU::panic_lock\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBput_character()\fP, and \fBscroll_up()\fP\&.
.SS "\fBchar\fP VESABootConsole::get_character (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the character at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified location or a space if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB186\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
186                                                           {
187 
188     // If the coordinates are out of bounds, return
189     if(x >= width() || y >= height())
190         return ' ';
191 
192     // Calculate the offset
193     int offset = (y * width() + x);
194 
195     // Return the character at the offset, by masking the character with the current character (last 8 bits)
196     return (char) (m_video_memory_meta[offset] & 0x00FF);
197 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.SS "\fBConsoleColour\fP VESABootConsole::get_foreground_color (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the foreground color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.RE
.PP
\fBReturns\fP
.RS 4
The foreground color at the specified location or white if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB206\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
206                                                                           {
207 
208     if(CPU::panic_lock\&.is_locked())
209         return ConsoleColour::White;
210 
211     // If the coordinates are out of bounds, return
212     if(x >= width() || y >= height())
213         return ConsoleColour::White;
214 
215     // Calculate the offset
216     int offset = (y * width() + x);
217 
218     // Return the foreground color at the offset, by masking the foreground color with the current foreground color (bits 8\-11)
219     return (ConsoleColour) ((m_video_memory_meta[offset] & 0x0F00) >> 8);
220 }
.fi

.PP
References \fBheight()\fP, \fBMaxOS::system::CPU::panic_lock\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBput_character()\fP, and \fBscroll_up()\fP\&.
.SS "\fBuint16_t\fP VESABootConsole::height ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the height of the console\&. 
.PP
\fBReturns\fP
.RS 4
The height of the console in characters 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB62\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
62                                  {
63     return s_graphics_context\->height() / FONT_HEIGHT;
64 }
.fi

.PP
References \fBMaxOS::gui::FONT_HEIGHT\fP, and \fBMaxOS::common::Rectangle< Type >::height\fP\&.
.PP
Referenced by \fBget_background_color()\fP, \fBget_character()\fP, \fBget_foreground_color()\fP, \fBput_character()\fP, \fBscroll_up()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, and \fBVESABootConsole()\fP\&.
.SS "\fBvoid\fP VESABootConsole::print_logo (\fBbool\fP is_panic = \fC\fBfalse\fP\fP)\fC [static]\fP"

.PP
Prints the logo to the center of the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIis_panic\fP Whether to print the kernel panic logo or the normal logo 
.RE
.PP

.PP
Definition at line \fB250\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
250                                               {
251 
252     // Load the logo
253     const char* logo = is_panic ? header_data_kp : header_data;
254 
255     // Find the center of the screen
256     uint32_t screen_width = s_graphics_context\->width();
257     uint32_t screen_height = s_graphics_context\->height();
258     uint32_t center_x = screen_width / 2;
259     uint32_t center_y = screen_height / 2 \- 80;
260 
261     // Fill the screen with the logo colour
262     auto col = Colour(is_panic ? ConsoleColour::Red : ConsoleColour::Black);
263     memset(s_graphics_context\->framebuffer_address(), s_graphics_context\->colour_to_int(col), screen_width * screen_height * (s_graphics_context\->color_depth() / 8));
264 
265     // Draw the logo
266     for(uint32_t logo_y = 0; logo_y < LOGO_HEIGHT; ++logo_y) {
267         for(uint32_t logo_x = 0; logo_x < LOGO_WIDTH; ++logo_x) {
268 
269             // Get the pixel from the logo
270             uint8_t pixel[3] = { 0 };
271             LOGO_HEADER_PIXEL(logo, pixel)
272 
273             // Draw the pixel
274             s_graphics_context\->put_pixel(center_x \- LOGO_WIDTH / 2 + logo_x,
275                                           center_y \- LOGO_HEIGHT / 2 + logo_y,
276                                           common::Colour(pixel[0], pixel[1], pixel[2]));
277         }
278     }
279 
280     update_progress_bar(0);
281 }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::height\fP, \fBLOGO_HEADER_PIXEL\fP, \fBLOGO_HEIGHT\fP, \fBLOGO_WIDTH\fP, \fBmemset()\fP, \fBupdate_progress_bar()\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBMaxOS::system::CPU::prepare_for_panic()\fP, and \fBVESABootConsole()\fP\&.
.SS "\fBvoid\fP VESABootConsole::put_character (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP c)\fC [final]\fP, \fC [virtual]\fP"

.PP
Places a character at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIc\fP The character to place 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB73\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
73                                                                   {
74 
75     // Parse any ansi codes
76     if(c == '\\033') {
77 
78         // Store the character
79         ansi_code_length = 0;
80         ansi_code[ansi_code_length++] = c;
81 
82         // Do not draw the escape character
83         return;
84     }
85 
86     if(ansi_code_length < 8) {
87 
88         // Add the character to the ANSI code
89         ansi_code[ansi_code_length++] = c;
90 
91         // If the ANSI code is complete
92         if(c == 'm') {
93             ansi_code[ansi_code_length] = '\\0';
94             ansi_code_length = \-1;
95 
96             if(strcmp("\\033[0m", ansi_code) != 0) {
97                 m_foreground_color = ConsoleColour::Uninitialised;
98                 m_background_color = ConsoleColour::Uninitialised;
99                 return;
100             }
101 
102             // Get the colour from the ANSI code
103             const Colour colour(ansi_code);
104 
105             // Set the colour
106             bool foreground = ansi_code[4] == '3';
107             if(foreground)
108                 m_foreground_color = colour\&.to_console_colour();
109             else
110                 m_background_color = colour\&.to_console_colour();
111 
112         }
113 
114         // Do not draw the escape character
115         return;
116     }
117 
118     // If the coordinates are out of bounds, return
119     if(x >= width() || y >= height())
120         return;
121 
122     // Calculate the offset
123     int offset = (y * width() + x);
124 
125     // Set the character at the offset, by masking the character with the current character (last 8 bits)
126     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0xFF00) | (uint16_t) c;
127 
128     // Convert the char into a string
129     char s[] = " ";
130     s[0] = c;
131 
132     Colour foreground = m_foreground_color == ConsoleColour::Uninitialised ? Colour(get_foreground_color(x, y)) : Colour(m_foreground_color);
133     Colour background = m_background_color == ConsoleColour::Uninitialised ? Colour(get_background_color(x, y)) : Colour(m_background_color);
134 
135     // Use the m_font to draw the character
136     m_font\&.draw_text(x * 8, y * FONT_HEIGHT, foreground, background, s_graphics_context, s);
137 }
.fi

.PP
References \fBMaxOS::gui::Font::draw_text()\fP, \fBMaxOS::gui::FONT_HEIGHT\fP, \fBget_background_color()\fP, \fBget_foreground_color()\fP, \fBheight()\fP, \fBstrcmp()\fP, \fBMaxOS::common::Colour::to_console_colour()\fP, and \fBwidth()\fP\&.
.SS "\fBvoid\fP VESABootConsole::scroll_up (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP width, \fBuint16_t\fP height, \fBcommon::ConsoleColour\fP foreground, \fBcommon::ConsoleColour\fP background, \fBchar\fP fill)\fC [final]\fP, \fC [virtual]\fP"

.PP
Scrolls the console up by 1 line\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP The left coordinate of the area to scroll 
.br
\fItop\fP The top coordinate of the area to scroll 
.br
\fIwidth\fP The width of the area to scroll 
.br
\fIheight\fP The height of the area to scroll 
.br
\fIforeground\fP The foreground color of the new line 
.br
\fIbackground\fP The background color of the new line 
.br
\fIfill\fP The character to fill the new line with 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB295\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
298                                                                            {
299 
300 
301     // Get the framebuffer info
302     auto* framebuffer_address = (uint8_t*) s_graphics_context\->framebuffer_address();
303     uint64_t framebuffer_width = s_graphics_context\->width();
304     uint64_t framebuffer_bpp = s_graphics_context\->color_depth(); // in bits per pixel
305     uint64_t bytes_per_pixel = framebuffer_bpp / 8;
306     uint64_t framebuffer_pitch = framebuffer_width * bytes_per_pixel;
307 
308     uint16_t line_height = FONT_HEIGHT;
309 
310     // Region conversions
311     uint16_t region_pixel_y = top * line_height;
312     uint16_t region_pixel_height = height * line_height;
313     uint16_t region_pixel_left = left * FONT_WIDTH;
314     uint16_t region_pixel_width = width * FONT_WIDTH;
315     size_t row_bytes = region_pixel_width * bytes_per_pixel;
316 
317     // Decide the colour of the pixel
318     ConsoleColour to_set_foreground = get_foreground_color(left, top + height \- 1);
319     ConsoleColour to_set_background = get_background_color(left, top + height \- 1);
320     uint32_t fill_value = s_graphics_context\->colour_to_int(Colour(to_set_background));
321 
322     // Scroll the region upward by one text line
323     for(uint16_t row = 0; row < region_pixel_height \- line_height; row++) {
324         uint8_t* src = framebuffer_address + (region_pixel_y + row + line_height) * framebuffer_pitch + region_pixel_left * bytes_per_pixel;
325         uint8_t* dest = framebuffer_address + (region_pixel_y + row) * framebuffer_pitch + region_pixel_left * bytes_per_pixel;
326         memmove(dest, src, row_bytes);
327     }
328 
329     // Clear the last line of the region
330     uint16_t clear_start_y = region_pixel_y + region_pixel_height \- line_height;
331     for(uint16_t row = 0; row < line_height; row++) {
332         auto row_add = (uint32_t*) (framebuffer_address + (clear_start_y + row) * framebuffer_pitch + region_pixel_left * 4);
333         for(uint16_t col = 0; col < region_pixel_width; col++) {
334             row_add[col] = fill_value;
335         }
336     }
337 
338     //Update any per\-pixel colour metadata
339     uint16_t text_row = top + height \- 1;
340     for(uint16_t x = left; x < left + width; x++) {
341         set_foreground_color(x, text_row, to_set_foreground);
342         set_background_color(x, text_row, to_set_background);
343     }
344 }
.fi

.PP
References \fBMaxOS::gui::FONT_HEIGHT\fP, \fBMaxOS::gui::FONT_WIDTH\fP, \fBget_background_color()\fP, \fBget_foreground_color()\fP, \fBheight()\fP, \fBmemmove()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, \fBMaxOS::common::Rectangle< Type >::width\fP, and \fBwidth()\fP\&.
.SS "\fBvoid\fP VESABootConsole::set_background_color (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP background)\fC [final]\fP, \fC [virtual]\fP"

.PP
Sets the background color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIbackground\fP The background color 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB166\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
166                                                                                            {
167 
168     // If the coordinates are out of bounds, return
169     if(x >= width() || y >= height())
170         return;
171 
172     // Calculate the offset
173     int offset = (y * width() + x);
174 
175     // Set the background color at the offset, by masking the background color with the current background color (bits 12\-15)
176     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0x0FFF) | ((uint16_t) background << 12);
177 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBscroll_up()\fP\&.
.SS "\fBvoid\fP VESABootConsole::set_foreground_color (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP foreground)\fC [final]\fP, \fC [virtual]\fP"

.PP
Sets the foreground color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIforeground\fP The foreground color 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB146\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
146                                                                                            {
147 
148     // If the coordinates are out of bounds, return
149     if(x >= width() || y >= height())
150         return;
151 
152     // Calculate the offset
153     int offset = (y * width() + x);
154 
155     // Set the foreground color at the offset, by masking the foreground color with the current foreground color (bits 8\-11)
156     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0xF0FF) | ((uint16_t) foreground << 8);
157 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBscroll_up()\fP\&.
.SS "\fBvoid\fP VESABootConsole::update_progress_bar (\fBuint8_t\fP percentage)\fC [static]\fP"

.PP
Updates the progress bar\&. 
.PP
\fBParameters\fP
.RS 4
\fIpercentage\fP The percentage to update the progress bar to (0-100) 
.RE
.PP

.PP
Definition at line \fB362\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
362                                                             {
363 
364     // Check bounds
365     if(percentage > 100)
366         percentage = 100;
367 
368     // Must have a valid graphics context
369     if(s_graphics_context == nullptr)
370         return;
371 
372     uint8_t progress_height = 15;
373     uint8_t progress_spacing = 20;
374     uint8_t progress_width_cull = 40;
375 
376     // Find the center of the screen
377     uint32_t right_x = (s_graphics_context\->width() / 2) \- LOGO_WIDTH / 2;
378     uint32_t bottom_y = (s_graphics_context\->height() / 2 \- 80) \- LOGO_HEIGHT / 2;
379 
380     // Find the bounds
381     uint32_t start_x = progress_width_cull;
382     uint32_t start_y = LOGO_HEIGHT + progress_spacing;
383     uint32_t end_x = LOGO_WIDTH \- progress_width_cull;
384     uint32_t end_y = LOGO_HEIGHT + progress_height + progress_spacing;
385 
386     // Draw the progress bar
387     for(uint32_t progress_y = start_y; progress_y < end_y; ++progress_y) {
388         for(uint32_t progress_x = start_x; progress_x < end_x; ++progress_x) {
389 
390             // Check if drawing border
391             bool is_border = (progress_y == start_y) || (progress_y == end_y \- 1) ||
392                              (progress_x == start_x) || (progress_x == end_x \- 1);
393 
394             // Only draw the border if it is the first time drawing it
395             is_border = is_border && percentage == 0;
396 
397             // If it is not within the percentage, skip it
398             uint32_t logo_progress_width = LOGO_WIDTH * percentage / 100;
399             if(progress_x > logo_progress_width && !is_border)
400                 continue;
401 
402             s_graphics_context\->put_pixel(right_x + progress_x, bottom_y + progress_y, Colour(0xFF, 0xFF, 0xFF));
403 
404         }
405     }
406 }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::height\fP, \fBLOGO_HEIGHT\fP, \fBLOGO_WIDTH\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBprint_logo()\fP, and \fBMaxOS::Logger::set_log_level()\fP\&.
.SS "\fBuint16_t\fP VESABootConsole::width ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the width of the console\&. 
.PP
\fBReturns\fP
.RS 4
The width of the console in characters 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB53\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
53                                 {
54     return s_graphics_context\->width() / FONT_WIDTH;       // 8 pixels per character
55 }
.fi

.PP
References \fBMaxOS::gui::FONT_WIDTH\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBget_background_color()\fP, \fBget_character()\fP, \fBget_foreground_color()\fP, \fBput_character()\fP, \fBscroll_up()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, and \fBVESABootConsole()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBConsoleStream\fP* MaxOS::drivers::console::VESABootConsole::cout"

.PP
The boot console output stream\&. 
.PP
Definition at line \fB51\fP of file \fBvesaboot\&.h\fP\&.
.PP
Referenced by \fBfinish()\fP, and \fBVESABootConsole()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::drivers::console::VESABootConsole" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::console::VESABootConsole \- \fBDriver\fP for the VESA \fBConsole\fP during boot, handles the printing of characters and strings to the screen using VESA protocol\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vesaboot\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::Driver\fP, and \fBMaxOS::drivers::console::Console\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVESABootConsole\fP (\fBcommon::GraphicsContext\fP *)"
.br
.RI "Constructs a new VESA Boot \fBConsole\fP object, initializing the console area for text output\&. "
.ti -1c
.RI "\fBuint16_t\fP \fBwidth\fP () \fBfinal\fP"
.br
.RI "Gets the width of the console\&. "
.ti -1c
.RI "\fBuint16_t\fP \fBheight\fP () \fBfinal\fP"
.br
.RI "Gets the height of the console\&. "
.ti -1c
.RI "\fBvoid\fP \fBfinish\fP ()"
.br
.RI "Cleans up the boot console\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP) \fBfinal\fP"
.br
.RI "Places a character at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_foreground_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP) \fBfinal\fP"
.br
.RI "Sets the foreground color at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_background_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP) \fBfinal\fP"
.br
.RI "Sets the background color at the specified location\&. "
.ti -1c
.RI "\fBvoid\fP \fBscroll_up\fP (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP \fBwidth\fP, \fBuint16_t\fP \fBheight\fP, \fBcommon::ConsoleColour\fP \fBforeground\fP, \fBcommon::ConsoleColour\fP \fBbackground\fP, \fBchar\fP \fBfill\fP) \fBfinal\fP"
.br
.RI "Scrolls the console up by 1 line\&. "
.ti -1c
.RI "\fBchar\fP \fBget_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the character at the specified location\&. "
.ti -1c
.RI "\fBcommon::ConsoleColour\fP \fBget_foreground_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the foreground color at the specified location\&. "
.ti -1c
.RI "\fBcommon::ConsoleColour\fP \fBget_background_color\fP (\fBuint16_t\fP x, \fBuint16_t\fP y) \fBfinal\fP"
.br
.RI "Gets the background color at the specified location\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBactivate\fP ()"
.br
.RI "activate the driver "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "deactivate the driver "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBstring\fP \fBvendor_name\fP ()"
.br
.RI "Get who created the device\&. "
.ti -1c
.RI "\fBvirtual\fP \fBstring\fP \fBdevice_name\fP ()"
.br
.RI "Get the device name of the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::console::Console\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBput_character\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP c, \fBcommon::ConsoleColour\fP \fBforeground\fP, \fBcommon::ConsoleColour\fP \fBbackground\fP)"
.br
.RI "Put a character on the console with a given foreground and background color\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBput_string\fP (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBstring\fP s, \fBcommon::ConsoleColour\fP \fBforeground\fP=common::ConsoleColour::LightGrey, \fBcommon::ConsoleColour\fP \fBbackground\fP=common::ConsoleColour::Black)"
.br
.RI "Put a string on the console\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBscroll_up\fP ()"
.br
.RI "Scroll the entire console up by 1 line\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBclear\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBclear\fP (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP \fBwidth\fP, \fBuint16_t\fP \fBheight\fP, \fBcommon::ConsoleColour\fP \fBforeground\fP=common::ConsoleColour::LightGrey, \fBcommon::ConsoleColour\fP \fBbackground\fP=common::ConsoleColour::Black, \fBchar\fP \fBfill\fP=' ')"
.br
.RI "Clear an area of the console\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinvert_colors\fP (\fBuint16_t\fP x, \fBuint16_t\fP y)"
.br
.RI "Invert the colors of a character on the console\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBprint_logo\fP (\fBbool\fP \fBis_panic\fP=\fBfalse\fP)"
.br
.RI "Prints the logo to the center of the screen\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBupdate_progress_bar\fP (\fBuint8_t\fP \fBpercentage\fP)"
.br
.RI "Updates the progress bar\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBConsoleStream\fP * \fBcout\fP"
.br
.RI "The boot console output stream\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the VESA \fBConsole\fP during boot, handles the printing of characters and strings to the screen using VESA protocol\&. 
.PP
Definition at line \fB33\fP of file \fBvesaboot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VESABootConsole::VESABootConsole (\fBcommon::GraphicsContext\fP * graphics_context)"

.PP
Constructs a new VESA Boot \fBConsole\fP object, initializing the console area for text output\&. 
.PP
\fBParameters\fP
.RS 4
\fIgraphics_context\fP The graphics context to use for rendering 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
26 : m_font((uint8_t *)AMIGA_FONT)
27 {
28 
29     // Set up
30     Logger::INFO() << "Setting up VESA console\\n";
31     s_graphics_context = graphics_context;
32     m_video_memory_meta = (uint16_t *) MemoryManager::kmalloc(width() * height() * sizeof(uint16_t));
33 
34     // Prepare the console
35     VESABootConsole::clear();
36     print_logo();
37     m_console_area = new ConsoleArea(this, 0, 0, width() / 2 \- 25, height(), ConsoleColour::DarkGrey, ConsoleColour::Black);
38     cout = new ConsoleStream(m_console_area);
39 
40     // Only log to the screen when debugging
41     #ifdef TARGET_DEBUG
42         Logger::active_logger()\->add_log_writer(cout);
43         Logger::INFO() << "Console Stream set up \\n";
44     #endif
45 }
.fi

.PP
References \fBLogger::active_logger()\fP, \fBMaxOS::drivers::console::Console::clear()\fP, \fBcout\fP, \fBheight()\fP, \fBLogger::INFO()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBprint_logo()\fP, and \fBwidth()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP VESABootConsole::finish ()"

.PP
Cleans up the boot console\&. 
.PP
Definition at line \fB349\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
349                              {
350 
351     // Done
352     Logger::HEADER() << "MaxOS Kernel Successfully Booted\\n" << ANSI_COLOURS[ANSIColour::Reset];
353     cout\->set_cursor(0, 0);
354     Logger::active_logger()\->disable_log_writer(cout);
355 }
.fi

.PP
References \fBLogger::active_logger()\fP, \fBMaxOS::common::ANSI_COLOURS\fP, \fBcout\fP, \fBLogger::HEADER()\fP, and \fBMaxOS::drivers::console::ConsoleStream::set_cursor()\fP\&.
.PP
Referenced by \fBkernel_main()\fP\&.
.SS "\fBConsoleColour\fP VESABootConsole::get_background_color (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the background color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate
.RE
.PP
\fBReturns\fP
.RS 4
The background color at the specified location or black if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB230\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
230                                                                           {
231 
232     if(CPU::panic_lock\&.is_locked())
233         return ConsoleColour::Red;
234 
235     // If the coordinates are out of bounds, return
236     if (x >= width() || y >= height())
237         return ConsoleColour::Black;
238 
239     // Calculate the offset
240     int offset = (y * width() + x);
241 
242     // Return the background color at the offset, by masking the background color with the current background color (bits 12\-15)
243     return (ConsoleColour) ((m_video_memory_meta[offset] & 0xF000) >> 12);
244 }
.fi

.PP
References \fBheight()\fP, \fBMaxOS::system::CPU::panic_lock\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBput_character()\fP, and \fBscroll_up()\fP\&.
.SS "\fBchar\fP VESABootConsole::get_character (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the character at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified location or a space if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB187\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
187                                                           {
188 
189     // If the coordinates are out of bounds, return
190     if (x >= width() || y >= height())
191         return ' ';
192 
193     // Calculate the offset
194     int offset = (y * width() + x);
195 
196     // Return the character at the offset, by masking the character with the current character (last 8 bits)
197     return (char) (m_video_memory_meta[offset] & 0x00FF);
198 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.SS "\fBConsoleColour\fP VESABootConsole::get_foreground_color (\fBuint16_t\fP x, \fBuint16_t\fP y)\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the foreground color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.RE
.PP
\fBReturns\fP
.RS 4
The foreground color at the specified location or white if the coordinates are out of bounds 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB207\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
207                                                                           {
208 
209     if(CPU::panic_lock\&.is_locked())
210         return ConsoleColour::White;
211 
212     // If the coordinates are out of bounds, return
213     if (x >= width() || y >= height())
214         return ConsoleColour::White;
215 
216     // Calculate the offset
217     int offset = (y * width() + x);
218 
219     // Return the foreground color at the offset, by masking the foreground color with the current foreground color (bits 8\-11)
220     return (ConsoleColour) ((m_video_memory_meta[offset] & 0x0F00) >> 8);
221 }
.fi

.PP
References \fBheight()\fP, \fBMaxOS::system::CPU::panic_lock\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBput_character()\fP, and \fBscroll_up()\fP\&.
.SS "\fBuint16_t\fP VESABootConsole::height ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the height of the console\&. 
.PP
\fBReturns\fP
.RS 4
The height of the console in characters 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB63\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
63                                  {
64     return s_graphics_context\->height() / FONT_HEIGHT;
65 }
.fi

.PP
References \fBMaxOS::gui::FONT_HEIGHT\fP, and \fBMaxOS::common::Rectangle< Type >::height\fP\&.
.PP
Referenced by \fBget_background_color()\fP, \fBget_character()\fP, \fBget_foreground_color()\fP, \fBput_character()\fP, \fBscroll_up()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, and \fBVESABootConsole()\fP\&.
.SS "\fBvoid\fP VESABootConsole::print_logo (\fBbool\fP is_panic = \fC\fBfalse\fP\fP)\fC [static]\fP"

.PP
Prints the logo to the center of the screen\&. 
.PP
Definition at line \fB249\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
249                                               {
250 
251     // Load the logo
252     const char *logo = is_panic ? header_data_kp : header_data;
253 
254     // Find the center of the screen
255     uint32_t screen_width = s_graphics_context\->width();
256     uint32_t screen_height = s_graphics_context\->height();
257     uint32_t center_x = screen_width / 2;
258     uint32_t center_y = screen_height / 2 \- 80;
259 
260     // Fill the screen with the logo colour
261     auto col = Colour(is_panic ? ConsoleColour::Red : ConsoleColour::Black);
262     memset(s_graphics_context\->framebuffer_address(), s_graphics_context\->colour_to_int(col), screen_width * screen_height * (s_graphics_context\->color_depth()/8));
263 
264     // Draw the logo
265     for (uint32_t logoY = 0; logoY < LOGO_HEIGHT; ++logoY) {
266         for (uint32_t logoX = 0; logoX < LOGO_WIDTH; ++logoX) {
267 
268             // Get the pixel from the logo
269             uint8_t pixel[3] = {0};
270             LOGO_HEADER_PIXEL(logo, pixel)
271 
272             // Draw the pixel
273             s_graphics_context\->put_pixel(center_x \- LOGO_WIDTH / 2 + logoX,
274                                           center_y \- LOGO_HEIGHT / 2 + logoY,
275                                           common::Colour(pixel[0], pixel[1], pixel[2]));
276         }
277     }
278 
279     update_progress_bar(0);
280 }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::height\fP, \fBLOGO_HEADER_PIXEL\fP, \fBLOGO_HEIGHT\fP, \fBLOGO_WIDTH\fP, \fBmemset()\fP, \fBupdate_progress_bar()\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBMaxOS::system::CPU::prepare_for_panic()\fP, and \fBVESABootConsole()\fP\&.
.SS "\fBvoid\fP VESABootConsole::put_character (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBchar\fP c)\fC [final]\fP, \fC [virtual]\fP"

.PP
Places a character at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIc\fP The character to place 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB74\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
74                                                                   {
75 
76     // Parse any ansi codes
77     if (c == '\\033') {
78 
79         // Store the character
80         ansi_code_length = 0;
81         ansi_code[ansi_code_length++] = c;
82 
83         // Do not draw the escape character
84         return;
85     }
86 
87     if (ansi_code_length < 8) {
88 
89         // Add the character to the ANSI code
90         ansi_code[ansi_code_length++] = c;
91 
92         // If the ANSI code is complete
93         if (c == 'm') {
94             ansi_code[ansi_code_length] = '\\0';
95             ansi_code_length = \-1;
96 
97             if (strcmp("\\033[0m", ansi_code) != 0) {
98                 m_foreground_color = ConsoleColour::Uninitialised;
99                 m_background_color = ConsoleColour::Uninitialised;
100                 return;
101             }
102 
103             // Get the colour from the ANSI code
104             const Colour colour(ansi_code);
105 
106             // Set the colour
107             bool foreground = ansi_code[4] == '3';
108             if (foreground)
109                 m_foreground_color = colour\&.to_console_colour();
110             else
111                 m_background_color = colour\&.to_console_colour();
112 
113         }
114 
115         // Do not draw the escape character
116         return;
117     }
118 
119     // If the coordinates are out of bounds, return
120     if (x >= width() || y >= height())
121         return;
122 
123     // Calculate the offset
124     int offset = (y * width() + x);
125 
126     // Set the character at the offset, by masking the character with the current character (last 8 bits)
127     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0xFF00) | (uint16_t) c;
128 
129     // Convert the char into a string
130     char s[] = " ";
131     s[0] = c;
132 
133     Colour foreground = m_foreground_color == ConsoleColour::Uninitialised ? get_foreground_color(x, y) : Colour(m_foreground_color);
134     Colour background = m_background_color == ConsoleColour::Uninitialised ? get_background_color(x, y) : Colour(m_background_color);
135 
136     // Use the m_font to draw the character
137     m_font\&.draw_text(x * 8, y * FONT_HEIGHT, foreground, background, s_graphics_context, s);
138 }
.fi

.PP
References \fBMaxOS::gui::Font::draw_text()\fP, \fBMaxOS::gui::FONT_HEIGHT\fP, \fBget_background_color()\fP, \fBget_foreground_color()\fP, \fBheight()\fP, \fBstrcmp()\fP, \fBMaxOS::common::Colour::to_console_colour()\fP, and \fBwidth()\fP\&.
.SS "\fBvoid\fP VESABootConsole::scroll_up (\fBuint16_t\fP left, \fBuint16_t\fP top, \fBuint16_t\fP width, \fBuint16_t\fP height, \fBcommon::ConsoleColour\fP foreground, \fBcommon::ConsoleColour\fP background, \fBchar\fP fill)\fC [final]\fP, \fC [virtual]\fP"

.PP
Scrolls the console up by 1 line\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP The left coordinate of the area to scroll 
.br
\fItop\fP The top coordinate of the area to scroll 
.br
\fIwidth\fP The width of the area to scroll 
.br
\fIheight\fP The height of the area to scroll 
.br
\fIforeground\fP The foreground color of the new line 
.br
\fIbackground\fP The background color of the new line 
.br
\fIfill\fP The character to fill the new line with 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB294\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
297                                                                            {
298 
299 
300     // Get the framebuffer info
301     auto *framebuffer_address = (uint8_t *) s_graphics_context\->framebuffer_address();
302     uint64_t framebuffer_width = s_graphics_context\->width();
303     uint64_t framebuffer_bpp = s_graphics_context\->color_depth(); // in bits per pixel
304     uint64_t bytes_per_pixel = framebuffer_bpp / 8;
305     uint64_t framebuffer_pitch = framebuffer_width * bytes_per_pixel;
306 
307     uint16_t line_height = FONT_HEIGHT;
308 
309     // Region conversions
310     uint16_t region_pixel_y = top * line_height;
311     uint16_t region_pixel_height = height * line_height;
312     uint16_t region_pixel_left = left * FONT_WIDTH;
313     uint16_t region_pixel_width = width * FONT_WIDTH;
314     size_t row_bytes = region_pixel_width * bytes_per_pixel;
315 
316     // Decide the colour of the pixel
317     ConsoleColour to_set_foreground = get_foreground_color(left, top + height \- 1);
318     ConsoleColour to_set_background = get_background_color(left, top + height \- 1);
319     Colour fill_colour = Colour(to_set_background);
320     uint32_t fill_value = s_graphics_context\->colour_to_int(to_set_background);
321 
322     // Scroll the region upward by one text line
323     for (uint16_t row = 0; row < region_pixel_height \- line_height; row++) {
324         uint8_t *src  = framebuffer_address + (region_pixel_y + row + line_height) * framebuffer_pitch + region_pixel_left * bytes_per_pixel;
325         uint8_t *dest = framebuffer_address + (region_pixel_y + row) * framebuffer_pitch + region_pixel_left * bytes_per_pixel;
326         memmove(dest, src, row_bytes);
327     }
328 
329     // Clear the last line of the region
330     uint16_t clear_start_y = region_pixel_y + region_pixel_height \- line_height;
331     for (uint16_t row = 0; row < line_height; row++) {
332         auto row_add = (uint32_t *) (framebuffer_address + (clear_start_y + row) * framebuffer_pitch + region_pixel_left * 4);
333         for (uint16_t col = 0; col < region_pixel_width; col++) {
334             row_add[col] = fill_value;
335         }
336     }
337 
338     //Update any per\-pixel colour metadata
339     uint16_t text_row = top + height \- 1;
340     for (uint16_t x = left; x < left + width; x++) {
341         set_foreground_color(x, text_row, to_set_foreground);
342         set_background_color(x, text_row, to_set_background);
343     }
344 }
.fi

.PP
References \fBMaxOS::gui::FONT_HEIGHT\fP, \fBMaxOS::gui::FONT_WIDTH\fP, \fBget_background_color()\fP, \fBget_foreground_color()\fP, \fBheight()\fP, \fBmemmove()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, \fBMaxOS::common::Rectangle< Type >::width\fP, and \fBwidth()\fP\&.
.SS "\fBvoid\fP VESABootConsole::set_background_color (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP background)\fC [final]\fP, \fC [virtual]\fP"

.PP
Sets the background color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIbackground\fP The background color 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB167\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
167                                                                                            {
168 
169     // If the coordinates are out of bounds, return
170     if (x >= width() || y >= height())
171         return;
172 
173     // Calculate the offset
174     int offset = (y * width() + x);
175 
176     // Set the background color at the offset, by masking the background color with the current background color (bits 12\-15)
177     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0x0FFF) | ((uint16_t) background << 12);
178 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBscroll_up()\fP\&.
.SS "\fBvoid\fP VESABootConsole::set_foreground_color (\fBuint16_t\fP x, \fBuint16_t\fP y, \fBcommon::ConsoleColour\fP foreground)\fC [final]\fP, \fC [virtual]\fP"

.PP
Sets the foreground color at the specified location\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate 
.br
\fIy\fP The y coordinate 
.br
\fIforeground\fP The foreground color 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB147\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
147                                                                                            {
148 
149     // If the coordinates are out of bounds, return
150     if (x >= width() || y >= height())
151         return;
152 
153     // Calculate the offset
154     int offset = (y * width() + x);
155 
156     // Set the foreground color at the offset, by masking the foreground color with the current foreground color (bits 8\-11)
157     m_video_memory_meta[offset] = (m_video_memory_meta[offset] & 0xF0FF) | ((uint16_t) foreground << 8);
158 }
.fi

.PP
References \fBheight()\fP, and \fBwidth()\fP\&.
.PP
Referenced by \fBscroll_up()\fP\&.
.SS "\fBvoid\fP VESABootConsole::update_progress_bar (\fBuint8_t\fP percentage)\fC [static]\fP"

.PP
Updates the progress bar\&. 
.PP
\fBParameters\fP
.RS 4
\fIpercentage\fP The percentage to update the progress bar to (0-100) 
.RE
.PP

.PP
Definition at line \fB362\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
362                                                             {
363 
364     // Check bounds
365     if (percentage > 100)
366         percentage = 100;
367 
368     // Must have a valid graphics context
369     if (s_graphics_context == nullptr)
370         return;
371 
372     uint8_t progress_height = 15;
373     uint8_t progress_spacing = 20;
374     uint8_t progress_width_cull = 40;
375 
376     // Find the center of the screen
377     uint32_t right_x = (s_graphics_context\->width() / 2) \- LOGO_WIDTH / 2;
378     uint32_t bottom_y = (s_graphics_context\->height() / 2 \- 80) \- LOGO_HEIGHT / 2;
379 
380     // Find the bounds
381     uint32_t start_x = progress_width_cull;
382     uint32_t start_y = LOGO_HEIGHT + progress_spacing;
383     uint32_t end_x = LOGO_WIDTH \- progress_width_cull;
384     uint32_t end_y = LOGO_HEIGHT + progress_height + progress_spacing;
385 
386     // Draw the progress bar
387     for (uint32_t progress_y = start_y; progress_y < end_y; ++progress_y) {
388         for (uint32_t progress_x = start_x; progress_x < end_x; ++progress_x) {
389 
390             // Check if drawing border
391             bool is_border = (progress_y == start_y) || (progress_y == end_y \- 1) ||
392                              (progress_x == start_x) || (progress_x == end_x \- 1);
393 
394             // Only draw the border if it is the first time drawing it
395             is_border = is_border && percentage == 0;
396 
397             // If it is not within the percentage, skip it
398             if (progress_x > LOGO_WIDTH * percentage / 100 && !is_border)
399                 continue;
400 
401             s_graphics_context\->put_pixel(right_x + progress_x, bottom_y + progress_y, Colour(0xFF, 0xFF, 0xFF));
402 
403         }
404     }
405 }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::height\fP, \fBLOGO_HEIGHT\fP, \fBLOGO_WIDTH\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBprint_logo()\fP, and \fBLogger::set_log_level()\fP\&.
.SS "\fBuint16_t\fP VESABootConsole::width ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the width of the console\&. 
.PP
\fBReturns\fP
.RS 4
The width of the console in characters 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::console::Console\fP\&.
.PP
Definition at line \fB54\fP of file \fBvesaboot\&.cpp\fP\&..PP
.nf
54                                 {
55     return s_graphics_context\->width() / FONT_WIDTH;       // 8 pixels per character
56 }
.fi

.PP
References \fBMaxOS::gui::FONT_WIDTH\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.PP
Referenced by \fBget_background_color()\fP, \fBget_character()\fP, \fBget_foreground_color()\fP, \fBput_character()\fP, \fBscroll_up()\fP, \fBset_background_color()\fP, \fBset_foreground_color()\fP, and \fBVESABootConsole()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBConsoleStream\fP* MaxOS::drivers::console::VESABootConsole::cout"

.PP
The boot console output stream\&. 
.PP
Definition at line \fB54\fP of file \fBvesaboot\&.h\fP\&.
.PP
Referenced by \fBfinish()\fP, and \fBVESABootConsole()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

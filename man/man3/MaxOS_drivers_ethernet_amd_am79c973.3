.TH "MaxOS::drivers::ethernet::amd_am79c973" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::ethernet::amd_am79c973
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <amd_am79c973\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriver\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBamd_am79c973\fP (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP *deviceDescriptor, \fBhardwarecommunication::InterruptManager\fP *interruptManager, \fBcommon::OutputStream\fP *amdNetMessageStream=0)"
.br
.ti -1c
.RI "\fB~amd_am79c973\fP ()"
.br
.ti -1c
.RI "uint32_t \fBreset\fP ()"
.br
.RI "This function resets the device\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "This function activates the device and starts it (Runs when the driver-manger calls activateAll()) "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "deactivate the driver "
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP ()"
.br
.RI "Get the vendor name of the driver\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP ()"
.br
.RI "Get the device name of the driver\&. "
.ti -1c
.RI "void \fBhandle_interrupt\fP ()"
.br
.RI "This function handles the interrupt for the device\&. "
.ti -1c
.RI "void \fBDoSend\fP (uint8_t *buffer, uint32_t \fBsize\fP)"
.br
.RI "This function sends a package\&. "
.ti -1c
.RI "uint64_t \fBGetMediaAccessControlAddress\fP ()"
.br
.RI "This function gets the MAC address\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 28 of file amd_am79c973\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "amd_am79c973::amd_am79c973 (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP * deviceDescriptor, \fBhardwarecommunication::InterruptManager\fP * interruptManager, \fBcommon::OutputStream\fP * amdNetMessageStream = \fC0\fP)"

.PP
Definition at line 14 of file amd_am79c973\&.cpp\&.
.PP
.nf
15         :   EthernetDriver(amdNetMessageStream),
16             InterruptHandler(dev -> interrupt + interrupts->hardware_interrupt_offset(), interrupts),
17             MACAddress0Port(dev ->port_base),
18             MACAddress2Port(dev ->port_base + 0x02),
19             MACAddress4Port(dev ->port_base + 0x04),
20             registerDataPort(dev ->port_base + 0x10),
21             registerAddressPort(dev ->port_base + 0x12),
22             busControlRegisterDataPort(dev ->port_base + 0x16),
23             resetPort(dev ->port_base + 0x14)
24 {
25     // No active buffer at the start
26     currentSendBuffer = 0;
27     currentRecvBuffer = 0;
28 
29     //Not active or intialized
30     active = false;
31     initDone = false;
32 
33     // Get the MAC adresses (split up in little endian order)
34     uint64_t MAC0 = MACAddress0Port\&.read() % 256;
35     uint64_t MAC1 = MACAddress0Port\&.read() / 256;
36     uint64_t MAC2 = MACAddress2Port\&.read() % 256;
37     uint64_t MAC3 = MACAddress2Port\&.read() / 256;
38     uint64_t MAC4 = MACAddress4Port\&.read() % 256;
39     uint64_t MAC5 = MACAddress4Port\&.read() / 256;
40 
41     // Combine MAC addresses into one 48 bit number
42     ownMAC = MAC5 << 40
43              | MAC4 << 32
44              | MAC3 << 24
45              | MAC2 << 16
46              | MAC1 << 8
47              | MAC0;
48 
49     // Set the device to 32 bit mode
50     registerAddressPort\&.write(20);              // Tell device to write to register 20
51     busControlRegisterDataPort\&.write(0x102);    // write desired data
52 
53     // Reset the stop bit (tell device it's not supposed to be reset now)
54     registerAddressPort\&.write(0);               // Tell device to write to register 0
55     registerDataPort\&.write(0x04);               // write desired data
56 
57     // Set the initialization block
58     initBlock\&.mode = 0x0000;                         // Promiscuous mode = false   ( promiscuous mode tells it to receive all packets, not just broadcasts and those for its own MAC address)
59     initBlock\&.reserved1 = 0;                         // Reserved
60     initBlock\&.numSendBuffers = 3;                    // Means 8 because 2^8 (number of bits used)
61     initBlock\&.reserved2 = 0;                         // Reserved
62     initBlock\&.numRecvBuffers = 3;                    // Means 8 because 2^8 (number of bits used)
63     initBlock\&.physicalAddress = ownMAC;              // Set the physical address to the MAC address
64     initBlock\&.reserved3 = 0;                         // Reserverd
65     initBlock\&.logicalAddress = 0;                    // None for now
66 
67 
68     //TODO: Use malloc?
69 
70     // Set Buffer descriptors memory
71     sendBufferDescr = (BufferDescriptor*)(MemoryManager::kmalloc((sizeof(BufferDescriptor) * 8) + 15));  // Allocate memory for 8 buffer descriptors
72     initBlock\&.sendBufferDescrAddress = (uint32_t)sendBufferDescr;
73 
74     recvBufferDescr = (BufferDescriptor*)(MemoryManager::kmalloc((sizeof(BufferDescriptor) * 8) + 15));  // Allocate memory for 8 buffer descriptors
75     initBlock\&.recvBufferDescrAddress = (uint32_t)recvBufferDescr;
76 
77     for(uint8_t i = 0; i < 8; i++)
78     {
79 
80         // Send buffer descriptors
81         sendBufferDescr[i]\&.address = (((uint32_t)&sendBuffers[i]) + 15 ) & ~(uint32_t)0xF;       // Same as above
82         sendBufferDescr[i]\&.flags = 0x7FF                                                         // Legnth of descriptor
83                                    | 0xF000;                                                     // Set it to send buffer
84         sendBufferDescr[i]\&.flags2 = 0;                                                           // "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive
85         sendBufferDescr[i]\&.avail = 0;                                                            // IF it is in use
86 
87         // Receive
88         recvBufferDescr[i]\&.address = (((uint32_t)&recvBuffers[i]) + 15 ) & ~(uint32_t)0xF;   // Same as above
89         recvBufferDescr[i]\&.flags = 0xF7FF                                                        // Length of descriptor        (This 0xF7FF is what was causing the problem, it used to be 0x7FF)
90                                    | 0x80000000;                                                 // Set it to receive buffer
91         recvBufferDescr[i]\&.flags2 = 0;                                                           // "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive
92         recvBufferDescr[i]\&.avail = 0;                                                            // IF it is in use
93     }
94 
95     // Move initialization block into device
96     registerAddressPort\&.write(1);                                     // Tell device to write to register 1
97     registerDataPort\&.write((uint32_t)(&initBlock) &
98                            0xFFFF);             // write address data
99     registerAddressPort\&.write(2);                                     // Tell device to write to register 2
100     registerDataPort\&.write(((uint32_t)(&initBlock) >> 16) &
101                            0xFFFF);     // write shifted address data
102 
103 
104 }
.fi
.PP
References MaxOS::drivers::peripherals::i, MaxOS::hardwarecommunication::Port16Bit::read(), and MaxOS::hardwarecommunication::Port16Bit::write()\&.
.SS "amd_am79c973::~amd_am79c973 ()"

.PP
Definition at line 106 of file amd_am79c973\&.cpp\&.
.PP
.nf
107 {
108 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void amd_am79c973::activate ()\fC [virtual]\fP"

.PP
This function activates the device and starts it (Runs when the driver-manger calls activateAll()) 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 115 of file amd_am79c973\&.cpp\&.
.PP
.nf
116 {
117 
118     // TODO: Have a look at re - implementing this again someday
119     return;
120 
121     initDone = false;                                            // Set initDone to false
122     registerAddressPort\&.write(0);                           // Tell device to write to register 0
123     registerDataPort\&.write(0x41);                           // Enable Interrupts and start the device
124     while(!initDone);                                            // Wait for initDone to be set to true
125 
126     registerAddressPort\&.write(4);                           // Tell device to read from register 4
127     uint32_t temp = registerDataPort\&.read();                     // Get current data
128 
129     registerAddressPort\&.write(4);                           // Tell device to write to register 4
130     registerDataPort\&.write(temp | 0xC00);                   // Bitwise OR function on data (This automatically enlarges packets smaller than 64 bytes to that size and removes some relatively superfluous information from received packets\&.)
131 
132     registerAddressPort\&.write(0);                           // Tell device to write to register 0
133     registerDataPort\&.write(0x42);                           // Tell device that it is initialised and can begin operating
134 
135     active = true;                                               // Set active to true
136 }
.fi
.PP
References MaxOS::hardwarecommunication::Port16Bit::read(), and MaxOS::hardwarecommunication::Port16Bit::write()\&.
.SS "void amd_am79c973::deactivate ()\fC [virtual]\fP"

.PP
deactivate the driver 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 292 of file amd_am79c973\&.cpp\&.
.PP
.nf
292                               {
293 
294 }
.fi
.SS "void amd_am79c973::DoSend (uint8_t * buffer, uint32_t size)\fC [virtual]\fP"

.PP
This function sends a package\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to send 
.br
\fIsize\fP The size of the buffer 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line 203 of file amd_am79c973\&.cpp\&.
.PP
.nf
203                                                         {
204 
205     while(!active);
206 
207     int sendDescriptor = currentSendBuffer;              // Get where data has been written to
208     currentSendBuffer = (currentSendBuffer + 1) % 8;    // Move send buffer to next send buffer (div by 8 so that it is cycled) (this allows for data to be sent from different m_tasks in parallel)
209 
210     if(size > 1518){                                    // If attempt to send more than 1518 bytes at once it will be too large
211         size = 1518;                                    // Discard all data after that  (Generally if data is bigger than that at driver level then a higher up network layer must have made a mistake)
212 
213     }
214 
215     // What this loop does is copy the information passed as the parameter buffer (src) to the send buffer in the ram (dst) which the card will then use to send the data
216     for (uint8_t *src = buffer + size -1,                                                   // Set src pointer to the end of the data that is being sent
217          *dst = (uint8_t*)(sendBufferDescr[sendDescriptor]\&.address + size -1);       // Take the buffer that has been slected
218          src >= buffer;                                                             // While there is still information in the buffer that hasnt been written to src
219          src--,dst--                                                                // Move 2 pointers to the end of the buffers
220             )
221     {
222         *dst = *src;                                                                        // Copy data from source buffer to destiantion buffer
223     }
224 
225 
226     sendBufferDescr[sendDescriptor]\&.avail = 0;                               // Set that this buffer is in use
227     sendBufferDescr[sendDescriptor]\&.flags2 = 0;                              // Clear any previous error messages
228     sendBufferDescr[sendDescriptor]\&.flags = 0x8300F000                       // Encode the size of what is being sent
229                                             | ((uint16_t)((-size) & 0xFFF));;
230 
231     registerAddressPort\&.write(0);                           // Tell device to write to register 0
232     registerDataPort\&.write(
233         0x48);                           // Tell device to send the data currently in the buffer
234 }
.fi
.PP
References size, and MaxOS::hardwarecommunication::Port16Bit::write()\&.
.SS "\fBstring\fP amd_am79c973::get_device_name ()\fC [virtual]\fP"

.PP
Get the device name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The device name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 300 of file amd_am79c973\&.cpp\&.
.PP
.nf
300                                      {
301     return "PCnet-Fast III (Am79C973)";
302 }
.fi
.SS "\fBstring\fP amd_am79c973::get_vendor_name ()\fC [virtual]\fP"

.PP
Get the vendor name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The vendor name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 296 of file amd_am79c973\&.cpp\&.
.PP
.nf
296                                      {
297     return "AMD";
298 }
.fi
.SS "uint64_t amd_am79c973::GetMediaAccessControlAddress ()\fC [virtual]\fP"

.PP
This function gets the MAC address\&. 
.PP
\fBReturns\fP
.RS 4
The MAC address 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line 287 of file amd_am79c973\&.cpp\&.
.PP
.nf
287                                                     {
288     while(ownMAC == 0);
289     return ownMAC;
290 }
.fi
.SS "void amd_am79c973::handle_interrupt ()\fC [virtual]\fP"

.PP
This function handles the interrupt for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIesp\fP The stack pointer (where to return to) 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line 158 of file amd_am79c973\&.cpp\&.
.PP
.nf
158                                     {
159 
160 
161 
162 
163     // Similar to PIC, data needs to be read when a interrupt is sent, or it hangs
164     registerAddressPort\&.write(0);                           // Tell device to read from register 0
165     uint32_t temp = registerDataPort\&.read();                     // Get current data
166 
167     // Note: Cant be switch case as multiple errors can occur at the same time
168 
169     // Errors
170     if((temp & 0x8000) == 0x8000)
171       error_message("AMD am79c973 ERROR: ");
172     if((temp & 0x2000) == 0x2000)
173       error_message("COLLISION ERROR\n");
174     if((temp & 0x1000) == 0x1000)
175       error_message("MISSED FRAME\n");
176     if((temp & 0x0800) == 0x0800)
177       error_message("MEMORY ERROR\n");
178 
179 
180     // Responses
181     if((temp & 0x0400) == 0x0400) FetchDataReceived();
182     if((temp & 0x0200) == 0x0200) FetchDataSent();
183     if((temp & 0x0100) == 0x0100) initDone = true;//
184 
185     // Reply that it was received
186     registerAddressPort\&.write(0);                           // Tell device to write to register 0
187     registerDataPort\&.write(temp);                           // Tell device that the interrupt was received
188 }
.fi
.PP
References MaxOS::drivers::Driver::error_message(), MaxOS::hardwarecommunication::Port16Bit::read(), and MaxOS::hardwarecommunication::Port16Bit::write()\&.
.SS "uint32_t amd_am79c973::reset ()\fC [virtual]\fP"

.PP
This function resets the device\&. 
.PP
\fBReturns\fP
.RS 4
The amount of ms to wait 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 143 of file amd_am79c973\&.cpp\&.
.PP
.nf
143                              {
144 
145   resetPort\&.read();
146   resetPort\&.write(0);
147   return 10;                      // 10 means wait for 10ms
148 
149 }
.fi
.PP
References MaxOS::hardwarecommunication::Port16Bit::read(), and MaxOS::hardwarecommunication::Port16Bit::write()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::net::UserDatagramProtocolHandler" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::UserDatagramProtocolHandler \- Handles the UDP protocol\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <udp\&.h>\fP
.PP
Inherits \fBMaxOS::net::IPV4PayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBUserDatagramProtocolHandler\fP (\fBInternetProtocolHandler\fP *\fBinternet_protocol_handler\fP, \fBcommon::OutputStream\fP *error_messages)"
.br
.RI "Construct a new User Datagram Protocol Handler object\&. "
.ti -1c
.RI "\fBbool\fP \fBhandle_internet_protocol_payload\fP (\fBnet::InternetProtocolAddress\fP source_ip, \fBnet::InternetProtocolAddress\fP destination_ip, \fBuint8_t\fP *\fBpayload_data\fP, \fBuint32_t\fP size) \fBoverride\fP"
.br
.RI "Handle the recivement of an UDP packet\&. "
.ti -1c
.RI "\fBUDPSocket\fP * \fBconnect\fP (\fBuint32_t\fP \fBip\fP, \fBuint16_t\fP \fBport\fP)"
.br
.ti -1c
.RI "\fBUDPSocket\fP * \fBlisten\fP (\fBuint16_t\fP \fBport\fP)"
.br
.RI "Listens for incoming packets on the port\&. "
.ti -1c
.RI "\fBvoid\fP \fBdisconnect\fP (\fBUDPSocket\fP *socket)"
.br
.RI "Disconnects the socket from the remote IP and port\&. "
.ti -1c
.RI "\fBvoid\fP \fBsend\fP (\fBUDPSocket\fP *socket, \fBconst\fP \fBuint8_t\fP *data, \fBuint16_t\fP size)"
.br
.RI "Sends a packet to the remote IP and port\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBUDPSocket\fP * \fBconnect\fP (\fBconst\fP \fBstring\fP &address)"
.br
.RI "Connects to a remote host through the UDP protocol\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBbind\fP (\fBUDPSocket\fP *socket, \fBUDPPayloadHandler\fP *\fBudp_payload_handler\fP)"
.br
.RI "Binds a handler to the socket\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Vector\fP< \fBUDPSocket\fP * > \fBsockets\fP"
.br
.RI "The list of UDP sockets\&. "
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.RI "Where to write error messages\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBUserDatagramProtocolPort\fP \fBfree_ports\fP = 0x8000"
.br
.RI "The next free port number\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the UDP protocol\&. 
.PP
Definition at line \fB113\fP of file \fBudp\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "UserDatagramProtocolHandler::UserDatagramProtocolHandler (\fBInternetProtocolHandler\fP * internet_protocol_handler, \fBcommon::OutputStream\fP * error_messages)"

.PP
Construct a new User Datagram Protocol Handler object\&. 
.PP
\fBParameters\fP
.RS 4
\fIinternet_protocol_handler\fP The Internet protocol handler 
.br
\fIerror_messages\fP Where to write error messages 
.RE
.PP

.PP
Definition at line \fB112\fP of file \fBudp\&.cpp\fP\&..PP
.nf
113 : IPV4PayloadHandler(internet_protocol_handler, 0x11)    //0x11 is the UDP protocol number
114 {
115     this \-> errorMessages = error_messages;
116 }
.fi

.PP
References \fBerrorMessages\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP UserDatagramProtocolHandler::bind (\fBUDPSocket\fP * socket, \fBUDPPayloadHandler\fP * udp_payload_handler)\fC [static]\fP"

.PP
Binds a handler to the socket\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to bind the handler to 
.br
\fIudp_payload_handler\fP The handler to bind 
.RE
.PP

.PP
Definition at line \fB308\fP of file \fBudp\&.cpp\fP\&..PP
.nf
308                                                                                                 {
309 
310   socket\->m_handlers\&.push_back(udp_payload_handler);                                                                //Set the handler of the socket to the handler that was passed in
311 
312 
313 }
.fi

.PP
References \fBMaxOS::common::EventManager< EventType >::m_handlers\fP\&.
.SS "\fBUDPSocket\fP * UserDatagramProtocolHandler::connect (\fBconst\fP \fBstring\fP & address)\fC [static]\fP"

.PP
Connects to a remote host through the UDP protocol\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to connect to in the form 'IP:PORT' 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that is connected to the remote host, nullptr if it failed
.RE
.PP
\fBTodo\fP
.RS 4
Implement string parsing to extract IP and port 
.RE
.PP

.PP
Definition at line \fB211\fP of file \fBudp\&.cpp\fP\&..PP
.nf
211                                                                      {
212 
213   return nullptr;
214 }
.fi

.SS "\fBUDPSocket\fP * UserDatagramProtocolHandler::connect (\fBuint32_t\fP ip, \fBuint16_t\fP port)"
Connects the socket to the remote IP and port 
.PP
\fBParameters\fP
.RS 4
\fIip\fP The remote IP address in big endian 
.br
\fIport\fP The remote port 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that was connected 
.RE
.PP

.PP
Definition at line \fB181\fP of file \fBudp\&.cpp\fP\&..PP
.nf
181                                                                           {
182 
183 
184     auto* socket = (UDPSocket*)MemoryManager::kmalloc(sizeof(UDPSocket));   //Allocate memory for the socket
185 
186     if(socket != nullptr) //If the socket was created
187     {
188         new (socket) UDPSocket();    //Create the socket
189 
190         //Configure the socket
191         socket \-> remote_port = port;                                    //Port to that application wants to connect to
192         socket \-> remote_ip = ip;                                        //IP to that application wants to connect to
193         socket \-> local_port = free_ports++;                               //Port that we will use to connect to the remote application  (note, local port doesnt have to be the same as remote)
194         socket \-> local_ip = internet_protocol_handler\->get_internet_protocol_address();    //IP that we will use to connect to the remote application
195         socket \-> user_datagram_protocol_handler = this;                    //Set the UDP handler
196 
197         sockets\&.push_back(socket);                                       //Add the socket to the list of sockets
198     }
199 
200     return socket;                                        //Return the socket
201 }
.fi

.PP
References \fBfree_ports\fP, \fBMaxOS::net::InternetProtocolHandler::get_internet_protocol_address()\fP, \fBMaxOS::net::IPV4PayloadHandler::internet_protocol_handler\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, and \fBsockets\fP\&.
.SS "\fBvoid\fP UserDatagramProtocolHandler::disconnect (\fBUDPSocket\fP * socket)"

.PP
Disconnects the socket from the remote IP and port\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to disconnect 
.RE
.PP

.PP
Definition at line \fB248\fP of file \fBudp\&.cpp\fP\&..PP
.nf
248                                                               {
249 
250 
251     for(Vector<UDPSocket*>::iterator current_socket = sockets\&.begin(); current_socket != sockets\&.end(); current_socket++) {
252         if((*current_socket) == socket)                               //If the socket is the same as the socket that is being checked
253         {
254             sockets\&.erase(current_socket);                            //Remove the socket from the list of sockets
255             MemoryManager::kfree(socket);      //Free the socket
256             break;                                                   //Break out of the loop
257         }
258     }
259 
260 }
.fi

.PP
References \fBMaxOS::memory::MemoryManager::kfree()\fP, and \fBsockets\fP\&.
.PP
Referenced by \fBMaxOS::net::UDPSocket::disconnect()\fP\&.
.SS "\fBbool\fP UserDatagramProtocolHandler::handle_internet_protocol_payload (\fBnet::InternetProtocolAddress\fP source_ip, \fBnet::InternetProtocolAddress\fP destination_ip, \fBuint8_t\fP * payload_data, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle the recivement of an UDP packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource_ip\fP The source IP address in big endian 
.br
\fIdestination_ip\fP The destination IP address in big endian 
.br
\fIpayload_data\fP The UDP payload 
.br
\fIsize\fP The size of the UDP payload 
.RE
.PP
\fBReturns\fP
.RS 4
True if the packet is to be sent back to the sender 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::IPV4PayloadHandler\fP\&.
.PP
Definition at line \fB129\fP of file \fBudp\&.cpp\fP\&..PP
.nf
129                                                                                                                                                                                         {
130 
131     //Check the size
132     if(size < sizeof(UDPHeader)) {
133         return false;
134     }
135 
136     //Get the header
137     auto* header = (UDPHeader*)payload_data;
138 
139     //Set the local and remote ports
140     uint16_t local_port = header \-> destination_port;
141     uint16_t remote_port = header \-> source_port;
142 
143     UDPSocket* socket = nullptr;                     //The socket that will be used
144     for(auto & current_socket : sockets) {
145         if(current_socket\->local_port == local_port                  //If the local port (header dst, our port) is the same as the local port of the socket
146         && current_socket\->local_ip == destination_ip                     //If the local IP (packet dst, our IP) is the same as the local IP of the socket
147         && current_socket\->listening)                              //If the socket is listening
148         {
149 
150             socket = current_socket;                               //Set the socket to the socket that is being checked
151             socket\->listening = false;                         //Set the socket to not listening, as it is now in use
152             socket\->remote_port = remote_port;                   //Set the remote port of the socket to the remote port of the packet
153             socket\->remote_ip = source_ip;                       //Set the remote IP of the socket to the remote IP of the packet
154 
155         }else if(current_socket\->local_port == local_port            //If the local port (header dst, our port) is the same as the local port of the socket
156               && current_socket\->local_ip == destination_ip              //If the local IP (packet dst, our IP) is the same as the local IP of the socket
157               && current_socket\->remote_port == remote_port         //If the remote port (header src, their port) is the same as the remote port of the socket
158               && current_socket\->remote_ip == source_ip)            //If the remote IP (packet src, their IP) is the same as the remote IP of the socket
159         {
160             socket = current_socket;                               //Set the socket to the current socket
161         }
162 
163     }
164 
165     if(socket != nullptr) {                                          //If the socket is not null then pass the data to the socket
166         socket\->handle_user_datagram_protocol_payload(payload_data + sizeof(UDPHeader),
167                                                       size \- sizeof(UDPHeader));
168     }
169 
170     //UDP doesn't send back packets, so always return false
171     return false;
172 
173 }
.fi

.PP
References \fBMaxOS::net::UDPSocket::handle_user_datagram_protocol_payload()\fP, \fBMaxOS::net::UDPSocket::listening\fP, \fBMaxOS::net::UDPSocket::remote_ip\fP, \fBMaxOS::net::UDPSocket::remote_port\fP, and \fBsockets\fP\&.
.SS "\fBUDPSocket\fP * UserDatagramProtocolHandler::listen (\fBuint16_t\fP port)"

.PP
Listens for incoming packets on the port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP The port to listen on 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that is listening 
.RE
.PP

.PP
Definition at line \fB222\fP of file \fBudp\&.cpp\fP\&..PP
.nf
222                                                             {
223 
224     auto* socket = (UDPSocket*)MemoryManager::kmalloc(sizeof(UDPSocket));   //Allocate memory for the socket
225 
226     if(socket != nullptr) //If the socket was created
227     {
228         new (socket) UDPSocket();    //Create the socket
229 
230         //Configure the socket
231         socket \-> listening = true;                                     //Set the socket to listening
232         socket \-> local_port = port;                                     //Port that we will use to connect to the remote application  (note, local port doesnt have to be the same as remote)
233         socket \-> local_ip = internet_protocol_handler\->get_internet_protocol_address();    //IP that we will use to connect to the remote application
234         socket \-> user_datagram_protocol_handler = this;                    //Set the UDP handler
235 
236         sockets\&.push_back(socket);                                       //Add the socket to the list of sockets
237     }
238 
239     return socket;                                        //Return the socket
240 
241 }
.fi

.PP
References \fBMaxOS::net::InternetProtocolHandler::get_internet_protocol_address()\fP, \fBMaxOS::net::IPV4PayloadHandler::internet_protocol_handler\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, and \fBsockets\fP\&.
.SS "\fBvoid\fP UserDatagramProtocolHandler::send (\fBUDPSocket\fP * socket, \fBconst\fP \fBuint8_t\fP * data, \fBuint16_t\fP size)"

.PP
Sends a packet to the remote IP and port\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to send the packet from 
.br
\fIdata\fP The data to send 
.br
\fIsize\fP The size of the data 
.RE
.PP

.PP
Definition at line \fB269\fP of file \fBudp\&.cpp\fP\&..PP
.nf
269                                                                                             {
270 
271     uint16_t total_size = sizeof(UDPHeader) + size;                                 //Get the total size of the packet
272     auto* buffer = (uint8_t*)MemoryManager::kmalloc(total_size);          //Allocate memory for the packet
273     uint8_t* buffer2 = buffer + sizeof(UDPHeader);                                 //Get the buffer that will be used to store the data
274 
275     auto* header = (UDPHeader*)buffer;                       //Create the header of the packet
276 
277     //Set the header
278     header \-> source_port = socket \-> local_port;                                                    //Set the source port to the local port of the socket    (this is the port that the packet will be sent from)
279     header \-> destination_port = socket \-> remote_port;                                              //Set the destination port to the remote port of the socket (this is the port that the packet will be sent to)
280     header \-> length = ((total_size & 0x00FF) << 8) | ((total_size & 0xFF00) >> 8);                  //Set the length of the packet
281 
282     // Convert the ports into big endian
283     header \-> source_port = ((header \-> source_port & 0x00FF) << 8) | ((header \-> source_port & 0xFF00) >> 8);
284     header \-> destination_port = ((header \-> destination_port & 0x00FF) << 8) | ((header \-> destination_port & 0xFF00) >> 8);
285 
286     //Copy the data to the buffer
287     for (int i = 0; i < size; ++i) {                                                               //Loop through the data
288         buffer2[i] = data[i];                                                                      //Copy the data to the buffer
289     }
290 
291     //Set the checksum
292     header \-> checksum = 0;                                                                        //Set the checksum to 0, this is becuase UDP doesnt have to have a checksum
293 
294     //Send the packet
295     IPV4PayloadHandler::send(socket\->remote_ip, buffer, total_size);
296 
297     //Free the buffer
298     MemoryManager::kfree(buffer);
299 
300 }
.fi

.PP
References \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::net::UDPSocket::remote_ip\fP, and \fBMaxOS::net::IPV4PayloadHandler::send()\fP\&.
.PP
Referenced by \fBMaxOS::net::UDPSocket::send()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* MaxOS::net::UserDatagramProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Where to write error messages\&. 
.PP
Definition at line \fB117\fP of file \fBudp\&.h\fP\&.
.PP
Referenced by \fBUserDatagramProtocolHandler()\fP\&.
.SS "\fBUserDatagramProtocolPort\fP UserDatagramProtocolHandler::free_ports = 0x8000\fC [static]\fP, \fC [protected]\fP"

.PP
The next free port number\&. \fBProvider\fP 
.PP
Definition at line \fB116\fP of file \fBudp\&.h\fP\&.
.PP
Referenced by \fBconnect()\fP\&.
.SS "\fBcommon::Vector\fP<\fBUDPSocket\fP*> MaxOS::net::UserDatagramProtocolHandler::sockets\fC [protected]\fP"

.PP
The list of UDP sockets\&. 
.PP
Definition at line \fB115\fP of file \fBudp\&.h\fP\&.
.PP
Referenced by \fBconnect()\fP, \fBdisconnect()\fP, \fBhandle_internet_protocol_payload()\fP, and \fBlisten()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "maxOS::drivers::clock::Clock" 3 "Fri Jan 5 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::drivers::clock::Clock \- \fBDriver\fP for the CMOS Real Time \fBClock\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <clock\&.h>\fP
.PP
Inherits \fBmaxOS::drivers::Driver\fP, \fBmaxOS::hardwarecommunication::InterruptHandler\fP, and \fBmaxOS::common::EventManager< ClockEvents >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBClock\fP (\fBhardwarecommunication::InterruptManager\fP *interrupt_manager, uint16_t time_between_events=10)"
.br
.RI "\fB\fBClock\fP\fP "
.ti -1c
.RI "\fB~Clock\fP ()"
.br
.ti -1c
.RI "void \fBactivate\fP () override"
.br
.RI "Activates the clock, setting the binary coded decimal representation flag\&. "
.ti -1c
.RI "void \fBdelay\fP (uint32_t milliseconds)"
.br
.RI "Delays the program for a specified number of milliseconds (rounded to the nearest 100) "
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP () final"
.br
.RI "Gets the name of the vendor\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP () final"
.br
.RI "Gets the name of the device\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBhandle_interrupt\fP () final"
.br
.RI "Handle the RTC interrupt, raising the clock event if enough time has passed\&. "
.ti -1c
.RI "uint8_t \fBread_hardware_clock\fP (uint8_t \fBaddress\fP)"
.br
.RI "read the current time from the hardware clock and return it "
.ti -1c
.RI "uint8_t \fBbinary_representation\fP (uint8_t number)"
.br
.RI "The binary representation of a number\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBm_binary_coded_decimal_representation\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_data_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_command_port\fP"
.br
.ti -1c
.RI "uint16_t \fBm_ticks_between_events\fP { 0 }"
.br
.ti -1c
.RI "uint16_t \fBm_ticks_until_next_event\fP { 1 }"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
\fBDriver\fP for the CMOS Real Time \fBClock\fP\&. 
.PP
Definition at line 56 of file clock\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Clock::Clock (\fBhardwarecommunication::InterruptManager\fP * interrupt_manager, uint16_t time_between_events = \fC10\fP)"

.PP
\fB\fBClock\fP\fP Constructor for the \fBClock\fP class
.PP
\fBParameters\fP
.RS 4
\fIinterrupt_manager\fP The interrupt manager 
.br
\fItime_between_events\fP The time between events in 10ths of a second 
.RE
.PP

.PP
Definition at line 54 of file clock\&.cpp\&.
.PP
.nf
55 : Driver(),
56   InterruptHandler(interrupt_manager->hardware_interrupt_offset(), interrupt_manager),
57   m_data_port(0x71), m_command_port(0x70),
58   m_ticks_between_events(time_between_events)
59 {
60 
61 }
.fi
.SS "Clock::~Clock ()"

.PP
Definition at line 63 of file clock\&.cpp\&.
.PP
.nf
63               {
64 
65 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Clock::activate ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Activates the clock, setting the binary coded decimal representation flag\&. 
.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 148 of file clock\&.cpp\&.
.PP
.nf
148                      {
149 
150     // read the status register
151     uint8_t status = read_hardware_clock(0xb);
152 
153     // If the fourth bit is 0 the binary coded decimal representation is used
154     m_binary_coded_decimal_representation = (status & 4) == 0;
155 
156     // Convert status to binary
157     // 00001011 = 0x0B (status as an example)
158     // 00000100 = 0x04 (binary mask used to extract fourth bit)
159     // 00000000 = 0x00 (result of bitwise AND operation with binary mask)
160     // 00000000 == 0 (check if fourth bit is 0 to determine if BCD is used)
161 }
.fi
.PP
References m_binary_coded_decimal_representation, read_hardware_clock(), and status\&.
.SS "uint8_t Clock::binary_representation (uint8_t number)\fC [protected]\fP"

.PP
The binary representation of a number\&. 
.PP
\fBParameters\fP
.RS 4
\fInumber\fP The number to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The binary representation of the number if the binary coded decimal representation is used, otherwise the number 
.RE
.PP

.PP
Definition at line 134 of file clock\&.cpp\&.
.PP
.nf
134                                                    {
135 
136     // If the binary coded decimal representation is not used, return the number
137     if(!m_binary_coded_decimal_representation)
138         return number;
139 
140     // Otherwise, return the binary representation
141     return (number & 0xf) + ((number >> 4) & 0xf) * 10;
142 
143 }
.fi
.PP
References m_binary_coded_decimal_representation\&.
.PP
Referenced by handle_interrupt()\&.
.SS "void Clock::delay (uint32_t milliseconds)"

.PP
Delays the program for a specified number of milliseconds (rounded to the nearest 100) 
.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP How many milliseconds to delay the program for 
.RE
.PP

.PP
Definition at line 169 of file clock\&.cpp\&.
.PP
.nf
169                                        {
170 
171         // Round the number of milliseconds to the nearest 100
172         uint64_t rounded_milliseconds =  ((milliseconds+99)/100);
173 
174         // Calculate the number of ticks until the delay is over
175         uint64_t ticks_until_delay_is_over = m_ticks + rounded_milliseconds;
176 
177         // Wait until the number of ticks is equal to the number of ticks until the delay is over
178         while(m_ticks < ticks_until_delay_is_over)
179             asm volatile("nop"); // execute the "nop" assembly instruction, which does nothing, but prevents the compiler from optimizing away the loop
180 }
.fi
.SS "\fBstring\fP Clock::get_device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the name of the device\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 194 of file clock\&.cpp\&.
.PP
.nf
194                               {
195     return "Clock";
196 }
.fi
.SS "\fBstring\fP Clock::get_vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the name of the vendor\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 186 of file clock\&.cpp\&.
.PP
.nf
186                               {
187     return "Generic";
188 }
.fi
.SS "void Clock::handle_interrupt ()\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Handle the RTC interrupt, raising the clock event if enough time has passed\&. 
.PP
Reimplemented from \fBmaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line 71 of file clock\&.cpp\&.
.PP
.nf
71                              {
72 
73     // Increment the number of ticks and decrement the number of ticks until the next event
74     m_ticks++;
75     m_ticks_until_next_event--;
76 
77     // If the number of ticks until the next event is not 0 then return
78     if(m_ticks_until_next_event != 0)
79         return;
80 
81     // Otherwise, reset the number of ticks until the next event
82     m_ticks_until_next_event = m_ticks_between_events;
83 
84     // Create a time object
85     Time time;
86 
87     // read the time from the hardware clock
88     time\&.year = binary_representation(read_hardware_clock(0x9)) + 2000;              // Register 9 is the year
89     time\&.month = binary_representation(read_hardware_clock(0x8));                    // Register 8 is the month
90     time\&.day = binary_representation(read_hardware_clock(0x7));                      // Register 7 is the day
91     time\&.hour = binary_representation(read_hardware_clock(0x4));                     // Register 4 is the hour
92     time\&.minute = binary_representation(read_hardware_clock(0x2));                   // Register 2 is the minute
93     time\&.second = binary_representation(
94 read_hardware_clock(0x0));                   // Register 0 is the second
95 
96     //Raise the clock event
97     TimeEvent* event = new TimeEvent(&time);
98     raise_event(event);
99     //TODO: delete event;
100 }
.fi
.PP
References binary_representation(), maxOS::common::Time::day, maxOS::common::Time::hour, m_ticks_between_events, m_ticks_until_next_event, maxOS::common::Time::minute, maxOS::common::Time::month, maxOS::common::EventManager< ClockEvents >::raise_event(), read_hardware_clock(), maxOS::common::Time::second, and maxOS::common::Time::year\&.
.SS "uint8_t Clock::read_hardware_clock (uint8_t address)\fC [protected]\fP"

.PP
read the current time from the hardware clock and return it 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the register to read from 
.RE
.PP
\fBReturns\fP
.RS 4
The value of the register 
.RE
.PP

.PP
Definition at line 109 of file clock\&.cpp\&.
.PP
.nf
110 {
111     // If the address is a time or date register, disable updates
112     if(address < 10)
113     {
114       m_command_port\&.write(0xa);
115 
116         // Wait until any updates are finished
117         while((m_data_port\&.read() & (1 << 7)) != 0)
118             asm volatile("nop"); // execute the "nop" assembly instruction, which does nothing, but prevents the compiler from optimizing away the loop
119     }
120 
121     // Send the address to the hardware clock
122     m_command_port\&.write(address);
123 
124     // read the value from the hardware clock
125     return m_data_port\&.read();
126 }
.fi
.PP
References address, m_command_port, m_data_port, maxOS::hardwarecommunication::Port8Bit::read(), and maxOS::hardwarecommunication::Port8Bit::write()\&.
.PP
Referenced by activate(), and handle_interrupt()\&.
.SH "Member Data Documentation"
.PP 
.SS "bool maxOS::drivers::clock::Clock::m_binary_coded_decimal_representation\fC [protected]\fP"

.PP
Definition at line 64 of file clock\&.h\&.
.PP
Referenced by activate(), and binary_representation()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::clock::Clock::m_command_port\fC [protected]\fP"

.PP
Definition at line 68 of file clock\&.h\&.
.PP
Referenced by read_hardware_clock()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::clock::Clock::m_data_port\fC [protected]\fP"

.PP
Definition at line 67 of file clock\&.h\&.
.PP
Referenced by read_hardware_clock()\&.
.SS "uint16_t maxOS::drivers::clock::Clock::m_ticks_between_events { 0 }\fC [protected]\fP"

.PP
Definition at line 71 of file clock\&.h\&.
.PP
Referenced by handle_interrupt()\&.
.SS "uint16_t maxOS::drivers::clock::Clock::m_ticks_until_next_event { 1 }\fC [protected]\fP"

.PP
Definition at line 72 of file clock\&.h\&.
.PP
Referenced by handle_interrupt()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

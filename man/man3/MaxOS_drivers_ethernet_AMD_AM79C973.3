.TH "MaxOS::drivers::ethernet::AMD_AM79C973" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::ethernet::AMD_AM79C973 \- \fBDriver\fP for the AMD AM79C973 Ethernet Controller\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <amd_am79c973\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriver\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAMD_AM79C973\fP (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP *\fBdevice_descriptor\fP)"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBreset\fP () \fBfinal\fP"
.br
.RI "This function resets the device\&. "
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP () \fBfinal\fP"
.br
.RI "This function activates the device and starts it (Runs when the driver-manger calls activateAll()) "
.ti -1c
.RI "\fBvoid\fP \fBdeactivate\fP () \fBfinal\fP"
.br
.RI "deactivate the driver "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBfinal\fP"
.br
.RI "Get who created the device\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBfinal\fP"
.br
.RI "Get the device name of the driver\&. "
.ti -1c
.RI "\fBvoid\fP \fBhandle_interrupt\fP () \fBfinal\fP"
.br
.RI "This function handles the interrupt for the device\&. "
.ti -1c
.RI "\fBvoid\fP \fBDoSend\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP) \fBfinal\fP"
.br
.RI "This function sends a package\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBGetMediaAccessControlAddress\fP () \fBfinal\fP"
.br
.RI "This function gets the MAC address\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBSend\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send data to the network via the driver backend\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventManager< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBconnect_event_handler\fP (\fBEventHandler\fP< EthernetDriverEvents > *\fBhandler\fP)"
.br
.RI "Connect an event handler to the event manager if it is not already connected\&. "
.ti -1c
.RI "\fBvoid\fP \fBdisconnect_event_handler\fP (\fBEventHandler\fP< EthernetDriverEvents > *\fBhandler\fP)"
.br
.RI "Disconnect an event handler from the event manager if it is connected\&. "
.ti -1c
.RI "\fBVector\fP< \fBEvent\fP< EthernetDriverEvents > * > \fBraise_event\fP (\fBEvent\fP< EthernetDriverEvents > *\fBevent\fP)"
.br
.RI "Calls the on_event function of all the event m_handlers connected to the event manager and returns a list of the results\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP system::cpu_status_t * \fBhandle_interrupt\fP (system::cpu_status_t *status)"
.br
.RI "Handles an interrupt and returns the status\&. "
.in -1c
.SS "Additional Inherited Members"


Static Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBstatic\fP \fBMediaAccessControlAddress\fP \fBCreateMediaAccessControlAddress\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP, \fBuint8_t\fP \fBdigit5\fP, \fBuint8_t\fP \fBdigit6\fP)"
.br
.RI "Create a Media Access Control Address\&. "
.in -1c

Protected Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBFireDataReceived\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Handle the recieved data\&. "
.ti -1c
.RI "\fBvoid\fP \fBFireDataSent\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send data\&. "
.in -1c

Protected Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP (\fBuint8_t\fP interrupt_number, \fBint64_t\fP \fBredirect\fP=\-1, \fBuint64_t\fP \fBredirect_index\fP=0)"
.br
.RI "Creates a new interrupt handler and registers it with the interrupt manager\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::common::EventManager< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBVector\fP< \fBEventHandler\fP< EthernetDriverEvents > * > \fBm_handlers\fP"
.br
.in -1c

Protected Attributes inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "uint8_t \fBm_interrupt_number\fP"
.br
.RI "The interrupt number this handler handles\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the AMD AM79C973 Ethernet Controller\&. 
.PP
Definition at line \fB30\fP of file \fBamd_am79c973\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AMD_AM79C973::AMD_AM79C973 (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP * device_descriptor)"
MAX OS NET CODE: All the old (this) networking code poorly written and not used, this will be moved to userspace in the future but is kept here as a reference for now\&. 
.PP
Definition at line \fB22\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
23 : InterruptHandler(0x20 + dev \-> interrupt),
24   MACAddress0Port(dev \->port_base),
25   MACAddress2Port(dev \->port_base + 0x02),
26   MACAddress4Port(dev \->port_base + 0x04),
27   registerDataPort(dev \->port_base + 0x10),
28   registerAddressPort(dev \->port_base + 0x12),
29   busControlRegisterDataPort(dev \->port_base + 0x16),
30   resetPort(dev \->port_base + 0x14),
31   initBlock(),
32   sendBuffers(),
33   recvBuffers()
34 {
35     // No active buffer at the start
36     currentSendBuffer = 0;
37     currentRecvBuffer = 0;
38 
39     //Not active or initialized
40     active = false;
41     initDone = false;
42 
43     // Get the MAC addresses (split up in little endian order)
44     uint64_t MAC0 = MACAddress0Port\&.read() % 256;
45     uint64_t MAC1 = MACAddress0Port\&.read() / 256;
46     uint64_t MAC2 = MACAddress2Port\&.read() % 256;
47     uint64_t MAC3 = MACAddress2Port\&.read() / 256;
48     uint64_t MAC4 = MACAddress4Port\&.read() % 256;
49     uint64_t MAC5 = MACAddress4Port\&.read() / 256;
50 
51     // Combine MAC addresses into one 48 bit number
52     ownMAC = MAC5 << 40
53              | MAC4 << 32
54              | MAC3 << 24
55              | MAC2 << 16
56              | MAC1 << 8
57              | MAC0;
58 
59     // Set the device to 32 bit mode
60     registerAddressPort\&.write(20);              // Tell device to write to register 20
61     busControlRegisterDataPort\&.write(0x102);    // write desired data
62 
63     // Reset the stop bit (tell device it's not supposed to be reset now)
64     registerAddressPort\&.write(0);               // Tell device to write to register 0
65     registerDataPort\&.write(0x04);               // write desired data
66 
67     // Set the initialization block
68     initBlock\&.mode = 0x0000;                         // Promiscuous mode = false   ( promiscuous mode tells it to receive all packets, not just broadcasts and those for its own MAC address)
69     initBlock\&.reserved1 = 0;                         // Reserved
70     initBlock\&.numSendBuffers = 3;                    // Means 8 because 2^8 (number of bits used)
71     initBlock\&.reserved2 = 0;                         // Reserved
72     initBlock\&.numRecvBuffers = 3;                    // Means 8 because 2^8 (number of bits used)
73     initBlock\&.physicalAddress = ownMAC;              // Set the physical address to the MAC address
74     initBlock\&.reserved3 = 0;                         // Reserved
75     initBlock\&.logicalAddress = 0;                    // None for now
76 
77     // Set Buffer descriptors memory
78     sendBufferDescr = (BufferDescriptor*)(MemoryManager::kmalloc((sizeof(BufferDescriptor) * 8) + 15));  // Allocate memory for 8 buffer descriptors
79     initBlock\&.sendBufferDescrAddress = (uint64_t)sendBufferDescr;
80 
81     recvBufferDescr = (BufferDescriptor*)(MemoryManager::kmalloc((sizeof(BufferDescriptor) * 8) + 15));  // Allocate memory for 8 buffer descriptors
82     initBlock\&.recvBufferDescrAddress = (uint64_t)recvBufferDescr;
83 
84     for(uint8_t i = 0; i < 8; i++)
85     {
86 
87         // Send buffer descriptors
88         sendBufferDescr[i]\&.address = (((uint64_t)&sendBuffers[i]) + 15 ) & ~(uint32_t)0xF;       // Same as above
89         sendBufferDescr[i]\&.flags = 0x7FF                                                         // Length of descriptor
90                                    | 0xF000;                                                     // Set it to send buffer
91         sendBufferDescr[i]\&.flags2 = 0;                                                           // "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive
92         sendBufferDescr[i]\&.avail = 0;                                                            // IF it is in use
93 
94         // Receive
95         recvBufferDescr[i]\&.address = (((uint64_t)&recvBuffers[i]) + 15 ) & ~(uint32_t)0xF;   // Same as above
96         recvBufferDescr[i]\&.flags = 0xF7FF                                                        // Length of descriptor        (This 0xF7FF is what was causing the problem, it used to be 0x7FF)
97                                    | 0x80000000;                                                 // Set it to receive buffer
98         recvBufferDescr[i]\&.flags2 = 0;                                                           // "Flags2" shows whether an error occurred while sending and should therefore be set to 0 by the drive
99         recvBufferDescr[i]\&.avail = 0;                                                            // IF it is in use
100     }
101 
102     // Move initialization block into device
103     registerAddressPort\&.write(1);                                     // Tell device to write to register 1
104     registerDataPort\&.write((uint64_t)(&initBlock) &
105                            0xFFFF);             // write address data
106     registerAddressPort\&.write(2);                                     // Tell device to write to register 2
107     registerDataPort\&.write(((uint64_t)(&initBlock) >> 16) &
108                            0xFFFF);     // write shifted address data
109 
110 
111 }
.fi

.PP
References \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, and \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP AMD_AM79C973::activate ()\fC [final]\fP, \fC [virtual]\fP"

.PP
This function activates the device and starts it (Runs when the driver-manger calls activateAll()) 
.PP
\fBTodo\fP
.RS 4
Re-implement this class 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB122\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
123 {
124 
125     return;
126 
127     initDone = false;                                            // Set initDone to false
128     registerAddressPort\&.write(0);                           // Tell device to write to register 0
129     registerDataPort\&.write(0x41);                           // Enable Interrupts and start the device
130     while(!initDone);                                            // Wait for initDone to be set to true
131 
132     registerAddressPort\&.write(4);                           // Tell device to read from register 4
133     uint32_t temp = registerDataPort\&.read();                     // Get current data
134 
135     registerAddressPort\&.write(4);                           // Tell device to write to register 4
136     registerDataPort\&.write(temp | 0xC00);                   // Bitwise OR function on data (This automatically enlarges packets smaller than 64 bytes to that size and removes some relatively superfluous information from received packets\&.)
137 
138     registerAddressPort\&.write(0);                           // Tell device to write to register 0
139     registerDataPort\&.write(0x42);                           // Tell device that it is initialised and can begin operating
140 
141     active = true;                                               // Set active to true
142 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, and \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP\&.
.SS "\fBvoid\fP AMD_AM79C973::deactivate ()\fC [final]\fP, \fC [virtual]\fP"

.PP
deactivate the driver 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB294\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
294                               {
295 
296 }
.fi

.SS "\fBstring\fP AMD_AM79C973::device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the device name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The device name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB302\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
302                                  {
303     return "PCnet\-Fast III (Am79C973)";
304 }
.fi

.SS "\fBvoid\fP AMD_AM79C973::DoSend (\fBuint8_t\fP * buffer, \fBuint32_t\fP size)\fC [final]\fP, \fC [virtual]\fP"

.PP
This function sends a package\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to send 
.br
\fIsize\fP The size of the buffer 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line \fB205\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
205                                                         {
206 
207     while(!active);
208 
209     int sendDescriptor = currentSendBuffer;              // Get where data has been written to
210     currentSendBuffer = (currentSendBuffer + 1) % 8;    // Move send buffer to next send buffer (div by 8 so that it is cycled) (this allows for data to be sent from different m_tasks in parallel)
211 
212     if(size > 1518){                                    // If attempt to send more than 1518 bytes at once it will be too large
213         size = 1518;                                    // Discard all data after that  (Generally if data is bigger than that at driver level then a higher up network layer must have made a mistake)
214 
215     }
216 
217     // What this loop does is copy the information passed as the parameter buffer (src) to the send buffer in the ram (dst) which the card will then use to send the data
218     for (uint8_t *src = buffer + size \-1,                                                   // Set src pointer to the end of the data that is being sent
219          *dst = (uint8_t*)(sendBufferDescr[sendDescriptor]\&.address + size \-1);       // Take the buffer that has been selected
220          src >= buffer;                                                             // While there is still information in the buffer that hasn't been written to src
221          src\-\-,dst\-\-                                                                // Move 2 pointers to the end of the buffers
222             )
223     {
224         *dst = *src;                                                                        // Copy data from source buffer to destination buffer
225     }
226 
227 
228     sendBufferDescr[sendDescriptor]\&.avail = 0;                               // Set that this buffer is in use
229     sendBufferDescr[sendDescriptor]\&.flags2 = 0;                              // Clear any previous error messages
230     sendBufferDescr[sendDescriptor]\&.flags = 0x8300F000                       // Encode the size of what is being sent
231                                             | ((uint16_t)((\-size) & 0xFFF));
232 
233     registerAddressPort\&.write(0);                           // Tell device to write to register 0
234     registerDataPort\&.write(
235         0x48);                           // Tell device to send the data currently in the buffer
236 }
.fi

.PP
References \fBsize\fP, and \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP\&.
.SS "\fBuint64_t\fP AMD_AM79C973::GetMediaAccessControlAddress ()\fC [final]\fP, \fC [virtual]\fP"

.PP
This function gets the MAC address\&. 
.PP
\fBReturns\fP
.RS 4
The MAC address 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line \fB289\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
289                                                     {
290     while(ownMAC == 0);
291     return ownMAC;
292 }
.fi

.SS "\fBvoid\fP AMD_AM79C973::handle_interrupt ()\fC [final]\fP, \fC [virtual]\fP"

.PP
This function handles the interrupt for the device\&. 
.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line \fB163\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
163                                     {
164 
165     // Similar to PIC, data needs to be read when an interrupt is sent, or it hangs
166     registerAddressPort\&.write(0);                           // Tell device to read from register 0
167     uint32_t temp = registerDataPort\&.read();                     // Get current data
168 
169     // Note: Cant be switch case as multiple errors can occur at the same time
170 
171     // Errors
172     if((temp & 0x8000) == 0x8000)
173       Logger::WARNING() << "AMD am79c973 ERROR: ";
174     if((temp & 0x2000) == 0x2000)
175       Logger::WARNING() << "COLLISION ERROR\\n";
176     if((temp & 0x1000) == 0x1000)
177       Logger::WARNING() << "MISSED FRAME\\n";
178     if((temp & 0x0800) == 0x0800)
179       Logger::WARNING() << "MEMORY ERROR\\n";
180 
181 
182     // Responses
183     if((temp & 0x0400) == 0x0400) FetchDataReceived();
184     if((temp & 0x0200) == 0x0200) FetchDataSent();
185     if((temp & 0x0100) == 0x0100) initDone = true;//
186 
187     // Reply that it was received
188     registerAddressPort\&.write(0);                           // Tell device to write to register 0
189     registerDataPort\&.write(temp);                           // Tell device that the interrupt was received
190 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, \fBLogger::WARNING()\fP, and \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP\&.
.SS "\fBuint32_t\fP AMD_AM79C973::reset ()\fC [final]\fP, \fC [virtual]\fP"

.PP
This function resets the device\&. 
.PP
\fBReturns\fP
.RS 4
The amount of ms to wait 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB149\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
149                              {
150 
151   resetPort\&.read();
152   resetPort\&.write(0);
153   return 10;                      // 10 means wait for 10ms
154 
155 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, and \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP\&.
.SS "\fBstring\fP AMD_AM79C973::vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get who created the device\&. 
.PP
\fBReturns\fP
.RS 4
The vendor name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB298\fP of file \fBamd_am79c973\&.cpp\fP\&..PP
.nf
298                                  {
299     return "AMD";
300 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

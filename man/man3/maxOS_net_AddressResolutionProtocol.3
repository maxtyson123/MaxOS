.TH "maxOS::net::AddressResolutionProtocol" 3 "Sat Jan 6 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::net::AddressResolutionProtocol
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <arp\&.h>\fP
.PP
Inherits \fBmaxOS::net::EthernetFramePayloadHandler\fP, and \fBmaxOS::net::InternetProtocolAddressResolver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAddressResolutionProtocol\fP (\fBEthernetFrameHandler\fP *ethernetFrameHandler, \fBInternetProtocolHandler\fP *internetProtocolHandler, \fBcommon::OutputStream\fP *errorMessages)"
.br
.ti -1c
.RI "\fB~AddressResolutionProtocol\fP ()"
.br
.ti -1c
.RI "bool \fBhandleEthernetFramePayload\fP (uint8_t *\fBdata\fP, uint32_t \fBsize\fP)"
.br
.RI "Called when an ARP packet is received\&. "
.ti -1c
.RI "void \fBRequestMACAddress\fP (\fBInternetProtocolAddress\fP \fBaddress\fP)"
.br
.RI "Request the MAC address of a given IP address\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBResolve\fP (\fBInternetProtocolAddress\fP \fBaddress\fP)"
.br
.RI "Get the MAC address from an IP via ARP\&. "
.ti -1c
.RI "void \fBStore\fP (\fBInternetProtocolAddress\fP internetProtocolAddress, \fBdrivers::ethernet::MediaAccessControlAddress\fP mediaAccessControlAddress)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 34 of file arp\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "net::AddressResolutionProtocol::AddressResolutionProtocol (\fBEthernetFrameHandler\fP * ethernetFrameHandler, \fBInternetProtocolHandler\fP * internetProtocolHandler, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line 15 of file arp\&.cpp\&.
.PP
.nf
16 : EthernetFramePayloadHandler(ethernetFrameHandler, 0x0806),
17   InternetProtocolAddressResolver(internetProtocolHandler)
18 {
19     this->internetProtocolHandler = internetProtocolHandler;
20     this->errorMessages = errorMessages;
21 }
.fi
.SS "net::AddressResolutionProtocol::~AddressResolutionProtocol ()"

.PP
Definition at line 23 of file arp\&.cpp\&.
.PP
.nf
23                                                          {
24 
25 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool AddressResolutionProtocol::handleEthernetFramePayload (uint8_t * etherframePayload, uint32_t size)"

.PP
Called when an ARP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIetherframePayload\fP The payload of the ARP packet\&. 
.br
\fIsize\fP The size of the ARP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the device should send a response, false otherwise\&. 
.RE
.PP

.PP
Definition at line 34 of file arp\&.cpp\&.
.PP
.nf
34                                                                                                     {
35 
36     //Check if the size is correct
37     if(size < sizeof(AddressResolutionProtocolMessage))
38         return false;
39 
40     //Convert the payload to an ARP message
41     AddressResolutionProtocolMessage* arpMessage = (AddressResolutionProtocolMessage*)etherframePayload;
42 
43     //Check if the message hardware type is Ethernet (BigEndian)
44     if(arpMessage -> hardwareType == 0x100){
45 
46         if(arpMessage -> protocol == 0x0008             //Check if the protocol is IPv4 (BigEndian)
47         && arpMessage -> hardwareAddressSize == 6
48         && arpMessage -> protocolAddressSize == 4
49         && arpMessage -> dstIP == internetProtocolHandler -> GetInternetProtocolAddress())
50         {
51 
52             switch (arpMessage -> command) {
53                 //Request
54                 case 0x0100:
55                     arpMessage -> command = 0x0200;                                                                         //Set the command to reply
56                     arpMessage -> dstMAC = arpMessage -> srcMAC;                                                            //Set the destination MAC to the source MAC
57                     arpMessage -> dstIP = arpMessage -> srcIP;                                                              //Set the destination IP to the source IP
58                     arpMessage -> srcMAC = internetProtocolHandler -> GetMediaAccessControlAddress();                      //Set the source MAC to this MAC
59                     arpMessage -> srcIP = internetProtocolHandler -> GetInternetProtocolAddress();                         //Set the source IP to this IP
60                     return true;
61                     break;
62 
63                 //Response
64                 case 0x0200:
65                     addressCache\&.insert((InternetProtocolAddress)arpMessage -> srcIP, (MediaAccessControlAddress)arpMessage -> srcMAC);     //Insert the MAC address into the cache
66                     break;
67 
68                 default:
69                     break;
70 
71             }
72 
73         }
74 
75     }
76 
77     //By default, don't send anything back
78     return false;
79 
80 
81 }
.fi
.PP
References command, dstIP, dstMAC, hardwareAddressSize, hardwareType, maxOS::common::Map< Key, Value >::insert(), protocol, protocolAddressSize, size, srcIP, and srcMAC\&.
.SS "void AddressResolutionProtocol::RequestMACAddress (\fBInternetProtocolAddress\fP address)"

.PP
Request the MAC address of a given IP address\&. 
.PP
\fBParameters\fP
.RS 4
\fIIP_BE\fP The IP address in BigEndian\&. 
.RE
.PP

.PP
Definition at line 89 of file arp\&.cpp\&.
.PP
.nf
89                                                                                  {
90 
91     //When a MAC adress is requested, instantiate a new ARP message block on the stack
92     AddressResolutionProtocolMessage arpMessage;
93 
94     //Set the message's values
95     arpMessage\&.hardwareType = 0x0100;                                                   //Ethernet, encoded in BigEndian
96     arpMessage\&.protocol = 0x0008;                                                       //IPv4, encoded in BigEndian
97     arpMessage\&.hardwareAddressSize = 6;                                                 //MAC address size
98     arpMessage\&.protocolAddressSize = 4;                                                 //IPv4 address size
99     arpMessage\&.command = 0x0100;                                                        //Request, encoded in BigEndian
100 
101     //Set the message's source and destination
102     arpMessage\&.srcMAC = frameHandler -> getMAC();                                       //Set the source MAC address to the backend's MAC address
103     arpMessage\&.srcIP = internetProtocolHandler -> GetInternetProtocolAddress();        //Set the source IP address to the backend's IP address
104     arpMessage\&.dstMAC = 0xFFFFFFFFFFFF;                                                 //Set the destination MAC address to broadcast
105     arpMessage\&.dstIP = address;                                                           //Set the destination IP address to the requested IP address
106 
107     //Send the message
108     this -> Send(arpMessage\&.dstMAC, (uint8_t*)&arpMessage, sizeof(AddressResolutionProtocolMessage));
109 
110 
111 }
.fi
.PP
References address, maxOS::net::AddressResolutionProtocolMessage::command, maxOS::net::AddressResolutionProtocolMessage::dstIP, maxOS::net::AddressResolutionProtocolMessage::dstMAC, maxOS::net::EthernetFramePayloadHandler::frameHandler, maxOS::net::AddressResolutionProtocolMessage::hardwareAddressSize, maxOS::net::AddressResolutionProtocolMessage::hardwareType, maxOS::net::AddressResolutionProtocolMessage::protocol, maxOS::net::AddressResolutionProtocolMessage::protocolAddressSize, maxOS::net::EthernetFramePayloadHandler::Send(), maxOS::net::AddressResolutionProtocolMessage::srcIP, and maxOS::net::AddressResolutionProtocolMessage::srcMAC\&.
.PP
Referenced by Resolve()\&.
.SS "\fBMediaAccessControlAddress\fP AddressResolutionProtocol::Resolve (\fBInternetProtocolAddress\fP address)\fC [virtual]\fP"

.PP
Get the MAC address from an IP via ARP\&. 
.PP
\fBParameters\fP
.RS 4
\fIIP_BE\fP The IP address to get the MAC address from\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The MAC address of the IP address\&. 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::net::InternetProtocolAddressResolver\fP\&.
.PP
Definition at line 120 of file arp\&.cpp\&.
.PP
.nf
120                                                                                             {
121 
122     volatile Map<InternetProtocolAddress, MediaAccessControlAddress>::iterator cacheIterator = addressCache\&.find(address); //Check if the MAC address is in the cache
123 
124     //If not, request it
125     if(addressCache\&.end() == cacheIterator){
126         RequestMACAddress(address);
127     }
128 
129     //TODO: Add clock to wait
130 
131     //This isnt safe because the MAC address might not be in the cache yet or the machine may not be connected to the network (possible infinite loop) //TODO: TIMEOUT
132     while (cacheIterator == addressCache\&.end()) {                         //Wait until the MAC address is found
133         cacheIterator = addressCache\&.find(address);
134     }
135 
136     //Return the MAC address
137 
138     return cacheIterator -> second;
139 
140 }
.fi
.PP
References address, maxOS::common::Map< Key, Value >::end(), maxOS::common::Map< Key, Value >::find(), and RequestMACAddress()\&.
.SS "void AddressResolutionProtocol::Store (\fBInternetProtocolAddress\fP internetProtocolAddress, \fBdrivers::ethernet::MediaAccessControlAddress\fP mediaAccessControlAddress)\fC [virtual]\fP"

.PP
Reimplemented from \fBmaxOS::net::InternetProtocolAddressResolver\fP\&.
.PP
Definition at line 142 of file arp\&.cpp\&.
.PP
.nf
142                                                                                                                                           {
143     addressCache\&.insert(internetProtocolAddress, mediaAccessControlAddress);
144 }
.fi
.PP
References maxOS::common::Map< Key, Value >::insert()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

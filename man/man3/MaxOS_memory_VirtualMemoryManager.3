.TH "MaxOS::memory::VirtualMemoryManager" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::VirtualMemoryManager \- Manages the virtual memory of the system and provides functions to allocate and free memory in the virtual address space\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <virtual\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVirtualMemoryManager\fP ()"
.br
.RI "Construct a new Virtual Memory Manager object and set up the initial page tables (kernel mapped into the hh) "
.ti -1c
.RI "\fB~VirtualMemoryManager\fP ()"
.br
.RI "Destroy the Virtual Memory Manager object and free all used pages\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate\fP (\fBsize_t\fP size, \fBsize_t\fP flags)"
.br
.RI "Allocate a new chunk of virtual memory\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate\fP (\fBuint64_t\fP address, \fBsize_t\fP size, \fBsize_t\fP flags)"
.br
.RI "Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) "
.ti -1c
.RI "\fBvoid\fP \fBfree\fP (\fBvoid\fP *address)"
.br
.RI "Free a chunk of virtual memory\&. "
.ti -1c
.RI "\fBvoid\fP * \fBload_physical_into_address_space\fP (\fBuintptr_t\fP physical_address, \fBsize_t\fP size, \fBsize_t\fP flags)"
.br
.RI "Load physical memory into the VMM's address space\&. "
.ti -1c
.RI "\fBvoid\fP * \fBload_shared_memory\fP (\fBconst\fP \fBstring\fP &name)"
.br
.RI "Load shared memory into the VMM's address space\&. "
.ti -1c
.RI "\fBvoid\fP * \fBload_shared_memory\fP (\fBuintptr_t\fP physical_address, \fBsize_t\fP size)"
.br
.RI "Load shared memory into the VMM's address space\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBpml4_root_address\fP ()"
.br
.RI "Get the virtual address of the PML4 root\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBpml4_root_address_physical\fP ()"
.br
.RI "Get the physical address of the PML4 root\&. "
.ti -1c
.RI "\fBsize_t\fP \fBmemory_used\fP ()"
.br
.RI "Returns the amount of memory used\&. "
.in -1c
.SH "Detailed Description"
.PP 
Manages the virtual memory of the system and provides functions to allocate and free memory in the virtual address space\&. 


.PP
\fBNote\fP
.RS 4
Have to use a linked list as vector class depends on dynamic memory allocation (which depends on this) 
.RE
.PP

.PP
Definition at line \fB96\fP of file \fBvirtual\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VirtualMemoryManager::VirtualMemoryManager ()"

.PP
Construct a new Virtual Memory Manager object and set up the initial page tables (kernel mapped into the hh) 
.PP
\fBNote\fP
.RS 4
Should only be called once per memory manager (kernel and each process) 
.RE
.PP

.PP
Definition at line \fB22\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
22                                            {
23 
24     // Set the kernel flag
25     bool is_kernel = MemoryManager::s_kernel_memory_manager == nullptr;
26     if (!is_kernel) {
27 
28         // Get a new pml4 table
29         m_pml4_root_physical_address = (uint64_t*) PhysicalMemoryManager::s_current_manager\->allocate_frame();
30         m_pml4_root_address = (uint64_t*) PhysicalMemoryManager::to_dm_region((uint64_t) m_pml4_root_physical_address);
31 
32         // Clear the table
33         PhysicalMemoryManager::clean_page_table(m_pml4_root_address);
34 
35         // Map the higher half of the kernel (p4 256 \- 511)
36         for (size_t i = 256; i < 512; i++) {
37 
38             // Recursive Map the pml4 table (so that we can access the new pml4 table later on)
39             if (i == 510) {
40                 m_pml4_root_address[i] = (uint64_t) m_pml4_root_physical_address | PRESENT | WRITE;
41                 continue;
42             }
43 
44             // Set the new pml4 table to the old (kernel) pml4 table
45             m_pml4_root_address[i] = PhysicalMemoryManager::s_current_manager\->pml4_root_address()[i];
46 
47         }
48         Logger::DEBUG() << "Mapped higher half of kernel\\n";
49 
50 
51     } else {
52         m_pml4_root_address = PhysicalMemoryManager::s_current_manager\->pml4_root_address();
53         m_pml4_root_physical_address = (uint64_t*) PhysicalMemoryManager::to_lower_region((uint64_t) m_pml4_root_address);
54     }
55 
56     // Allocate space for the vmm
57     uint64_t vmm_space = PhysicalMemoryManager::align_to_page(HIGHER_HALF_DIRECT_MAP + PhysicalMemoryManager::s_current_manager\->memory_size() + PAGE_SIZE);
58     void* vmm_space_physical = PhysicalMemoryManager::s_current_manager\->allocate_frame();
59     PhysicalMemoryManager::s_current_manager\->map(vmm_space_physical, (virtual_address_t*) vmm_space, PRESENT | WRITE, m_pml4_root_address);
60     Logger::DEBUG() << "VMM space: physical \- 0x" << (uint64_t) vmm_space_physical << ", virtual \- 0x" << (uint64_t) vmm_space << "\\n";
61 
62     // Make sure everything is mapped correctly
63     if (!is_kernel)
64         ASSERT(vmm_space_physical != PhysicalMemoryManager::s_current_manager\->get_physical_address((virtual_address_t*) vmm_space, m_pml4_root_address), "Physical address does not match mapped address: 0x%x != 0x%x\\n", vmm_space_physical,
65                PhysicalMemoryManager::s_current_manager\->get_physical_address((virtual_address_t*) vmm_space, m_pml4_root_address));
66 
67     // Set the first region
68     m_first_region = (virtual_memory_region_t*) vmm_space;
69     m_current_region = m_first_region;
70     m_first_region\->next = nullptr;
71 
72     // Calculate the next available address (kernel needs to reserve space for the higher half)
73     m_next_available_address = is_kernel ? vmm_space + VMM_RESERVED : PAGE_SIZE;
74     Logger::DEBUG() << "Next available address: 0x" << m_next_available_address << "\\n";
75 
76 }
.fi

.PP
References \fBMaxOS::memory::PhysicalMemoryManager::align_to_page()\fP, \fBASSERT\fP, \fBMaxOS::memory::PhysicalMemoryManager::clean_page_table()\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBMaxOS::memory::HIGHER_HALF_DIRECT_MAP\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_dm_region()\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_lower_region()\fP, and \fBMaxOS::memory::WRITE\fP\&.
.SS "VirtualMemoryManager::~VirtualMemoryManager ()"

.PP
Destroy the Virtual Memory Manager object and free all used pages\&. 
.PP
Definition at line \fB81\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
81                                             {
82 
83     // Free all the frames used by the VMM
84     virtual_memory_region_t* region = m_first_region;
85 
86     // Loop through the regions
87     while (region != nullptr) {
88 
89         // Loop through the chunks
90         for (size_t i = 0; i < CHUNKS_PER_PAGE; i++) {
91 
92             // Have reached the end?
93             if (i == m_current_chunk && region == m_current_region)
94                 break;
95 
96             // Free each page in the chunk
97             size_t pages = PhysicalMemoryManager::size_to_frames(region\->chunks[i]\&.size);
98             for (size_t j = 0; j < pages; j++) {
99 
100                 // Convert the virtual address to a physical address and free it
101                 physical_address_t* frame = PhysicalMemoryManager::s_current_manager\->get_physical_address((virtual_address_t*) region\->chunks[i]\&.start_address + (j * PAGE_SIZE), m_pml4_root_address);
102                 PhysicalMemoryManager::s_current_manager\->free_frame(frame);
103 
104             }
105         }
106 
107         region = region\->next;
108     }
109 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, and \fBMaxOS::memory::PhysicalMemoryManager::size_to_frames()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP * VirtualMemoryManager::allocate (\fBsize_t\fP size, \fBsize_t\fP flags)"

.PP
Allocate a new chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory 
.RE
.PP

.PP
Definition at line \fB119\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
119                                                               {
120 
121     return allocate(0, size, flags);
122 }
.fi

.PP
References \fBallocate()\fP\&.
.PP
Referenced by \fBallocate()\fP, \fBload_physical_into_address_space()\fP, and \fBMaxOS::memory::MemoryManager::MemoryManager()\fP\&.
.SS "\fBvoid\fP * VirtualMemoryManager::allocate (\fBuint64_t\fP address, \fBsize_t\fP size, \fBsize_t\fP flags)"

.PP
Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to allocate at 
.br
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory or nullptr if failed 
.RE
.PP

.PP
Definition at line \fB133\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
133                                                                                 {
134 
135     // Make sure allocating something
136     if (size == 0)
137         return nullptr;
138 
139     // If specific address is given
140     if (address != 0) {
141 
142         // Make sure isn't already allocated
143         if (address < m_next_available_address)
144             return nullptr;
145 
146         // Make sure its aligned
147         if (!PhysicalMemoryManager::check_aligned(address))
148             return nullptr;
149 
150     }
151 
152     // Make sure the size is aligned
153     size = PhysicalMemoryManager::align_up_to_page(size, PAGE_SIZE);
154 
155     // Check the free list for a chunk (if not asking for a specific address)
156     free_chunk_t* reusable_chunk = address == 0 ? find_and_remove_free_chunk(size) : nullptr;
157     if (reusable_chunk != nullptr) {
158 
159         // If the chunk is not being reserved then the old memory needs to be unmapped
160         if (flags & VirtualFlags::RESERVE) {
161 
162             // Unmap the memory
163             size_t pages = PhysicalMemoryManager::size_to_frames(size);
164             for (size_t i = 0; i < pages; i++) {
165 
166                 // Get the frame
167                 physical_address_t* frame = PhysicalMemoryManager::s_current_manager\->get_physical_address((virtual_address_t*) reusable_chunk\->start_address + (i * PAGE_SIZE), m_pml4_root_address);
168 
169                 // Free the frame
170                 PhysicalMemoryManager::s_current_manager\->free_frame(frame);
171 
172             }
173         }
174 
175         // Return the address
176         return (void*) reusable_chunk\->start_address;
177     }
178 
179 
180     // Is there space in the current region
181     if (m_current_chunk >= CHUNKS_PER_PAGE)
182         new_region();
183 
184     // If needed to allocate at a specific address, fill with free memory up to that address to prevent fragmentation
185     if (address != 0)
186         fill_up_to_address(address, flags, false);
187 
188     // Allocate the memory
189     virtual_memory_chunk_t* chunk = &m_current_region\->chunks[m_current_chunk];
190     chunk\->size = size;
191     chunk\->flags = flags;
192     chunk\->start_address = m_next_available_address;
193 
194     // Update the next available address
195     m_next_available_address += size;
196     m_current_chunk++;
197 
198     // If just reserving the space don't map it
199     if (flags & RESERVE)
200         return (void*) chunk\->start_address;
201 
202     // Map the memory
203     size_t pages = PhysicalMemoryManager::size_to_frames(size);
204     for (size_t i = 0; i < pages; i++) {
205 
206         // Allocate a new frame
207         physical_address_t* frame = PhysicalMemoryManager::s_current_manager\->allocate_frame();
208         ASSERT(frame != nullptr, "Failed to allocate frame (from current region)\\n");
209 
210         // Map the frame
211         PhysicalMemoryManager::s_current_manager\->map(frame, (virtual_address_t*) chunk\->start_address + (i * PAGE_SIZE), PRESENT | WRITE, m_pml4_root_address);
212 
213     }
214 
215     // Return the address
216     return (void*) chunk\->start_address;
217 }
.fi

.PP
References \fBMaxOS::memory::PhysicalMemoryManager::align_up_to_page()\fP, \fBASSERT\fP, \fBMaxOS::memory::PhysicalMemoryManager::check_aligned()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::memory::RESERVE\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::memory::PhysicalMemoryManager::size_to_frames()\fP, and \fBMaxOS::memory::WRITE\fP\&.
.SS "\fBvoid\fP VirtualMemoryManager::free (\fBvoid\fP * address)"

.PP
Free a chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the memory to free 
.RE
.PP

.PP
Definition at line \fB253\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
253                                              {
254 
255     // Make sure freeing something
256     if (address == nullptr)
257         return;
258 
259     // Find the chunk
260     virtual_memory_region_t* region = m_first_region;
261     virtual_memory_chunk_t* chunk = nullptr;
262     while (region != nullptr) {
263 
264         // Loop through the chunks
265         for (size_t i = 0; i < CHUNKS_PER_PAGE; i++) {
266 
267             // Check if the address is in the chunk
268             if (region\->chunks[i]\&.start_address == (uintptr_t) address) {
269                 chunk = &region\->chunks[i];
270                 break;
271             }
272         }
273 
274         // If the chunk was found
275         if (chunk != nullptr)
276             break;
277 
278         // Move to the next region
279         region = region\->next;
280     }
281 
282     // Make sure the chunk was found
283     if (chunk == nullptr)
284         return;
285 
286     // If the chunk is shared, don't unmap it incase other processes are using it
287     if (chunk\->flags & VirtualFlags::SHARED) {
288 
289         // Find the resource
290         for(const auto& resource : GlobalScheduler::current_process()\->resource_manager\&.resources()){
291 
292             // Skip non\-shared memory resources
293             if(resource\&.second\->type() != resource_type_t::SHARED_MEMORY)
294                 continue;
295 
296             // Skip shared memory that points elsewhere
297             auto shared = (SharedMemory*)resource\&.second;
298             if((void*)shared\->physical_address() != address)
299                 continue;
300 
301             // Close the resource
302             GlobalScheduler::current_process()\->resource_manager\&.close_resource(resource\&.first, 0);
303         }
304     }
305 
306     // Add the chunk to the free list
307     add_free_chunk(chunk\->start_address, chunk\->size);
308 
309     // Clear the chunk
310     chunk\->size = 0;
311     chunk\->flags = 0;
312     chunk\->start_address = 0;
313 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP\&.
.SS "\fBvoid\fP * VirtualMemoryManager::load_physical_into_address_space (\fBuintptr_t\fP physical_address, \fBsize_t\fP size, \fBsize_t\fP flags)"

.PP
Load physical memory into the VMM's address space\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address of the memory 
.br
\fIsize\fP The size of the memory 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the memory in the VMM's address space 
.RE
.PP

.PP
Definition at line \fB455\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
455                                                                                                                   {
456 
457     // Reserve some space
458     void* address = allocate(size, flags | RESERVE);
459 
460     // Map the shared memory
461     size_t pages = PhysicalMemoryManager::size_to_frames(size);
462     for (size_t i = 0; i < pages; i++)
463         PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) (physical_address + (i * PAGE_SIZE)), (virtual_address_t*) ((uintptr_t) address + (i * PAGE_SIZE)), PRESENT | WRITE, m_pml4_root_address);
464 
465 
466     // All done
467     return address;
468 }
.fi

.PP
References \fBallocate()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::memory::RESERVE\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::memory::PhysicalMemoryManager::size_to_frames()\fP, and \fBMaxOS::memory::WRITE\fP\&.
.PP
Referenced by \fBload_shared_memory()\fP\&.
.SS "\fBvoid\fP * VirtualMemoryManager::load_shared_memory (\fBconst\fP \fBstring\fP & name)"

.PP
Load shared memory into the VMM's address space\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the shared memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the shared memory in the VMM's address space 
.RE
.PP

.PP
Definition at line \fB418\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
418                                                                  {
419 
420     // Get the shared memory block
421     auto block = (SharedMemory*)GlobalScheduler::current_process()\->resource_manager\&.get_resource(name);
422 
423     // Load the shared memory
424     if (block != nullptr)
425         return load_shared_memory(block\->physical_address(), block\->size());
426 
427     return nullptr;
428 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP, and \fBload_shared_memory()\fP\&.
.PP
Referenced by \fBload_shared_memory()\fP\&.
.SS "\fBvoid\fP * VirtualMemoryManager::load_shared_memory (\fBuintptr_t\fP physical_address, \fBsize_t\fP size)"

.PP
Load shared memory into the VMM's address space\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address of the shared memory 
.br
\fIsize\fP The size of the shared memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the shared memory in the VMM's address space 
.RE
.PP

.PP
Definition at line \fB437\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
437                                                                                       {
438 
439     // Make sure there is somthing to map
440     if (size == 0 || physical_address == 0)
441         return nullptr;
442 
443     // Load it into physical memory
444     return load_physical_into_address_space(physical_address, size, SHARED);
445 }
.fi

.PP
References \fBload_physical_into_address_space()\fP, and \fBMaxOS::memory::SHARED\fP\&.
.SS "\fBsize_t\fP VirtualMemoryManager::memory_used ()"

.PP
Returns the amount of memory used\&. 
.PP
\fBReturns\fP
.RS 4
The amount of memory used 
.RE
.PP

.PP
Definition at line \fB320\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
320                                          {
321 
322     // Loop through all the regions and add up the size of the allocated chunks
323     size_t result = 0;
324 
325     // Iterate through the regions
326     virtual_memory_region_t* region = m_first_region;
327     while (region != nullptr) {
328 
329         // Loop through the chunks
330         for (size_t i = 0; i < CHUNKS_PER_PAGE; i++) {
331 
332             // Check if the address is in the chunk
333             if (region\->chunks[i]\&.size != 0)
334                 result += region\->chunks[i]\&.size;
335         }
336 
337         // Move to the next region
338         region = region\->next;
339     }
340 
341     return result;
342 }
.fi

.SS "\fBuint64_t\fP * VirtualMemoryManager::pml4_root_address ()"

.PP
Get the virtual address of the PML4 root\&. 
.PP
\fBReturns\fP
.RS 4
The virtual address or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB521\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
521                                                   {
522 
523     // Make sure the address is valid
524     if (m_pml4_root_address == nullptr)
525         return nullptr;
526 
527     // Return the address
528     return m_pml4_root_address;
529 }
.fi

.SS "\fBuint64_t\fP * VirtualMemoryManager::pml4_root_address_physical ()"

.PP
Get the physical address of the PML4 root\&. 
.PP
\fBReturns\fP
.RS 4
The physical address of the PML4 root 
.RE
.PP

.PP
Definition at line \fB407\fP of file \fBvirtual\&.cpp\fP\&..PP
.nf
407                                                            {
408 
409     return m_pml4_root_physical_address;
410 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

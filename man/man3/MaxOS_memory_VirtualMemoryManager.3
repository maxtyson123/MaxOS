.TH "MaxOS::memory::VirtualMemoryManager" 3 "Sun Oct 13 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::VirtualMemoryManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <virtual\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVirtualMemoryManager\fP (bool is_kernel)"
.br
.ti -1c
.RI "\fB~VirtualMemoryManager\fP ()"
.br
.ti -1c
.RI "void * \fBallocate\fP (size_t \fBsize\fP, size_t \fBflags\fP)"
.br
.RI "Allocate a new chunk of virtual memory\&. "
.ti -1c
.RI "void * \fBallocate\fP (uint64_t \fBaddress\fP, size_t \fBsize\fP, size_t \fBflags\fP)"
.br
.RI "Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) "
.ti -1c
.RI "void \fBfree\fP (void *\fBaddress\fP)"
.br
.RI "Free a chunk of virtual memory\&. "
.ti -1c
.RI "size_t \fBmemory_used\fP ()"
.br
.RI "Returns the amount of memory used\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 35 of file virtual\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VirtualMemoryManager::VirtualMemoryManager (bool is_kernel)"

.PP
Definition at line 11 of file virtual\&.cpp\&.
.PP
.nf
12 : m_physical_memory_manager(PhysicalMemoryManager::s_current_manager),
13   m_is_kernel(is_kernel)
14 {
15 
16     // If not the kernel, we need to allocate a new PML4 table
17     if(!m_is_kernel){
18 
19       // Get a new pml4 table
20       m_pml4_root_physical_address = (uint64_t*)m_physical_memory_manager->allocate_frame();
21       m_pml4_root_address = (uint64_t*)MemoryManager::to_dm_region((uint64_t)m_pml4_root_physical_address);
22       _kprintf("Allocated new PML4 table at: 0x%x\n", m_pml4_root_address);
23 
24       // Clear the table
25       m_physical_memory_manager -> clean_page_table(m_pml4_root_address);
26 
27       // Map the higher half of the kernel (p4 256 - 511)
28       for (size_t i = 256; i < 512; i++){
29 
30         // Recursive Map the pml4 table (so that we can access the new pml4 table later on)
31         if(i == 510) {
32           m_pml4_root_address[i] = (uint64_t)m_pml4_root_physical_address | Present | Write;
33           continue;
34         }
35 
36         // Set the new pml4 table to the old (kernel) pml4 table
37         m_pml4_root_address[i] = m_physical_memory_manager->get_pml4_root_address()[i];
38 
39       }
40       _kprintf("Mapped higher half of kernel\n");
41 
42 
43     }else{
44       m_pml4_root_address = m_physical_memory_manager->get_pml4_root_address();
45     };
46 
47     // Space to store VMM chunks
48     uint64_t vmm_space = PhysicalMemoryManager::align_to_page(MemoryManager::s_hh_direct_map_offset + m_physical_memory_manager->get_memory_size() + PhysicalMemoryManager::s_page_size);
49     m_first_region = (virtual_memory_region_t*)vmm_space;
50     m_current_region = m_first_region;
51 
52     // Allocate space for the vmm
53     void* vmm_space_physical = m_physical_memory_manager->allocate_frame();
54     ASSERT(vmm_space_physical != nullptr, "Failed to allocate VMM space");
55     m_physical_memory_manager->map(vmm_space_physical, (virtual_address_t*)vmm_space, Present | Write, m_pml4_root_address);
56     m_first_region->next = nullptr;
57     _kprintf("Allocated VMM: physical: 0x%x, virtual: 0x%x\n", vmm_space_physical, vmm_space);
58 
59     // Calculate the next available address
60     m_next_available_address = PhysicalMemoryManager::s_page_size;
61     if(m_is_kernel){
62 
63       // Kernel needs to start at the higher half
64       m_next_available_address += vmm_space + s_reserved_space;
65 
66     }
67     _kprintf("Next available address: 0x%x\n", m_next_available_address);
68 
69 
70 }
.fi
.PP
References _kprintf, MaxOS::memory::PhysicalMemoryManager::align_to_page(), MaxOS::memory::PhysicalMemoryManager::allocate_frame(), ASSERT, MaxOS::memory::PhysicalMemoryManager::get_memory_size(), MaxOS::memory::PhysicalMemoryManager::get_pml4_root_address(), MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::map(), MaxOS::memory::Present, MaxOS::memory::MemoryManager::s_hh_direct_map_offset, MaxOS::memory::PhysicalMemoryManager::s_page_size, MaxOS::memory::MemoryManager::to_dm_region(), and MaxOS::memory::Write\&.
.SS "VirtualMemoryManager::~VirtualMemoryManager ()"

.PP
Definition at line 72 of file virtual\&.cpp\&.
.PP
.nf
72                                             {
73 
74 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void * VirtualMemoryManager::allocate (size_t size, size_t flags)"

.PP
Allocate a new chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory 
.RE
.PP

.PP
Definition at line 83 of file virtual\&.cpp\&.
.PP
.nf
83                                                               {
84   return allocate(0, size, flags);
85 }
.fi
.PP
References flags, and size\&.
.PP
Referenced by MaxOS::memory::MemoryManager::MemoryManager()\&.
.SS "void * VirtualMemoryManager::allocate (uint64_t address, size_t size, size_t flags)"

.PP
Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to allocate at 
.br
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory or nullptr if failed 
.RE
.PP

.PP
Definition at line 95 of file virtual\&.cpp\&.
.PP
.nf
95                                                                                 {
96 
97   // Make sure allocating something
98   if(size == 0)
99     return nullptr;
100 
101   // If specific address is given
102   if(address != 0){
103 
104       // Make sure isnt already allocated
105       if(address < m_next_available_address)
106         return nullptr;
107 
108       // Make sure its aligned
109       if(!PhysicalMemoryManager::check_aligned(address))
110         return nullptr;
111 
112   }
113 
114   // Make sure the size is aligned
115   size = PhysicalMemoryManager::align_up_to_page(size, PhysicalMemoryManager::s_page_size);
116 
117   // Is there space in the current region
118   if(m_current_chunk >= s_chunks_per_page)
119     new_region();
120 
121   // If we need to allocate at a specific address
122   if(address != 0){
123     m_next_available_address = address;    //TODO: Creates mem fragmentation - fix
124   }
125 
126   // Allocate the memory
127   virtual_memory_chunk_t* chunk = &m_current_region->chunks[m_current_chunk];
128   chunk->size = size;
129   chunk->flags = flags;
130   chunk->start_address = m_next_available_address;
131 
132   // Update the next available address
133   m_next_available_address += size;
134   m_current_chunk++;
135 
136   // If just reserving the space don't map it
137   if(flags & Reserve)
138     return (void*)chunk->start_address;
139 
140   // Map the memory
141   size_t pages = PhysicalMemoryManager::size_to_frames(size);
142   for (size_t i = 0; i < pages; i++){
143 
144     // Allocate a new frame
145     physical_address_t* frame = m_physical_memory_manager->allocate_frame();
146     ASSERT(frame != nullptr, "Failed to allocate frame");
147 
148     // Map the frame
149     m_physical_memory_manager->map(frame, (virtual_address_t*)chunk->start_address + (i * PhysicalMemoryManager::s_page_size), Present | Write, m_pml4_root_address);
150 
151   }
152 
153   // Return the address
154   return (void*)chunk->start_address;
155 }
.fi
.PP
References address, MaxOS::memory::PhysicalMemoryManager::align_up_to_page(), MaxOS::memory::PhysicalMemoryManager::allocate_frame(), ASSERT, MaxOS::memory::PhysicalMemoryManager::check_aligned(), flags, MaxOS::memory::VirtualMemoryChunk::flags, MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::map(), MaxOS::memory::Present, MaxOS::memory::Reserve, MaxOS::memory::PhysicalMemoryManager::s_page_size, size, MaxOS::memory::VirtualMemoryChunk::size, MaxOS::memory::PhysicalMemoryManager::size_to_frames(), MaxOS::memory::VirtualMemoryChunk::start_address, and MaxOS::memory::Write\&.
.SS "void VirtualMemoryManager::free (void * address)"

.PP
Free a chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the memory to free 
.RE
.PP

.PP
Definition at line 184 of file virtual\&.cpp\&.
.PP
.nf
184                                              {
185 
186   // Make sure freeing something
187   if(address == nullptr)
188     return;
189 
190   // Find the chunk
191   virtual_memory_region_t* region = m_first_region;
192   virtual_memory_chunk_t* chunk = nullptr;
193   while(region != nullptr){
194 
195       // Loop through the chunks
196       for (size_t i = 0; i < s_chunks_per_page; i++){
197 
198         // Check if the address is in the chunk
199         if(region->chunks[i]\&.start_address == (uintptr_t)address){
200               chunk = &region->chunks[i];
201               break;
202         }
203       }
204 
205       // If the chunk was found
206       if(chunk != nullptr)
207         break;
208 
209       // Move to the next region
210       region = region->next;
211   }
212 
213   // Make sure the chunk was found
214   if(chunk == nullptr)
215     return;
216 
217   // Unmap the memory
218   size_t pages = PhysicalMemoryManager::size_to_frames(chunk->size);
219   for (size_t i = 0; i < pages; i++){
220 
221         // Unmap the frame
222         m_physical_memory_manager->unmap((virtual_address_t*)chunk->start_address + (i * PhysicalMemoryManager::s_page_size), m_pml4_root_address);
223 
224   }
225 
226   // Clear the chunk
227   chunk->size = 0;
228   chunk->flags = 0;
229   chunk->start_address = 0;
230 
231   // TODO: Some logic to use this space again
232 }
.fi
.PP
References address, MaxOS::memory::VirtualMemoryChunk::flags, MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::s_page_size, MaxOS::memory::VirtualMemoryChunk::size, MaxOS::memory::PhysicalMemoryManager::size_to_frames(), MaxOS::memory::VirtualMemoryChunk::start_address, and MaxOS::memory::PhysicalMemoryManager::unmap()\&.
.SS "size_t VirtualMemoryManager::memory_used ()"

.PP
Returns the amount of memory used\&. 
.PP
\fBReturns\fP
.RS 4
The amount of memory used 
.RE
.PP

.PP
Definition at line 238 of file virtual\&.cpp\&.
.PP
.nf
238                                          {
239 
240   // Loop through all the regions and add up the size of the allocated chunks
241   size_t result = 0;
242 
243   // Iterate through the regions
244   virtual_memory_region_t *region = m_first_region;
245   while (region != nullptr) {
246 
247     // Loop through the chunks
248     for (size_t i = 0; i < s_chunks_per_page; i++) {
249 
250       // Check if the address is in the chunk
251       if (region->chunks[i]\&.size != 0)
252         result += region->chunks[i]\&.size;
253     }
254 
255     // Move to the next region
256     region = region->next;
257   }
258 
259   return result;
260 }
.fi
.PP
References MaxOS::drivers::peripherals::i\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

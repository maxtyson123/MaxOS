.TH "MaxOS::memory::VirtualMemoryManager" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::VirtualMemoryManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <virtual\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVirtualMemoryManager\fP (bool is_kernel)"
.br
.ti -1c
.RI "\fB~VirtualMemoryManager\fP ()"
.br
.ti -1c
.RI "void * \fBallocate\fP (size_t \fBsize\fP, size_t \fBflags\fP)"
.br
.RI "Allocate a new chunk of virtual memory\&. "
.ti -1c
.RI "void * \fBallocate\fP (uint64_t \fBaddress\fP, size_t \fBsize\fP, size_t \fBflags\fP)"
.br
.RI "Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) "
.ti -1c
.RI "void \fBfree\fP (void *\fBaddress\fP)"
.br
.RI "Free a chunk of virtual memory\&. "
.ti -1c
.RI "size_t \fBmemory_used\fP ()"
.br
.RI "Returns the amount of memory used\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 41 of file virtual\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VirtualMemoryManager::VirtualMemoryManager (bool is_kernel)"

.PP
Definition at line 11 of file virtual\&.cpp\&.
.PP
.nf
12 : m_physical_memory_manager(PhysicalMemoryManager::s_current_manager),
13   m_is_kernel(is_kernel)
14 {
15 
16     // If not the kernel, we need to allocate a new PML4 table
17     if(!m_is_kernel){
18 
19       // Get a new pml4 table
20       m_pml4_root_physical_address = (uint64_t*)m_physical_memory_manager->allocate_frame();
21       m_pml4_root_address = (uint64_t*)MemoryManager::to_dm_region((uint64_t)m_pml4_root_physical_address);
22       _kprintf("Allocated new PML4 table at: 0x%x\n", m_pml4_root_address);
23 
24       // Clear the table
25       m_physical_memory_manager -> clean_page_table(m_pml4_root_address);
26 
27       // Map the higher half of the kernel (p4 256 - 511)
28       for (size_t i = 256; i < 512; i++){
29 
30         // Recursive Map the pml4 table (so that we can access the new pml4 table later on)
31         if(i == 510) {
32           m_pml4_root_address[i] = (uint64_t)m_pml4_root_physical_address | Present | Write;
33           continue;
34         }
35 
36         // Set the new pml4 table to the old (kernel) pml4 table
37         m_pml4_root_address[i] = m_physical_memory_manager->get_pml4_root_address()[i];
38 
39       }
40       _kprintf("Mapped higher half of kernel\n");
41 
42 
43     }else{
44       m_pml4_root_address = m_physical_memory_manager->get_pml4_root_address();
45     };
46 
47     // Space to store VMM chunks
48     uint64_t vmm_space = PhysicalMemoryManager::align_to_page(MemoryManager::s_hh_direct_map_offset + m_physical_memory_manager->get_memory_size() + PhysicalMemoryManager::s_page_size);
49     m_first_region = (virtual_memory_region_t*)vmm_space;
50     m_current_region = m_first_region;
51 
52     // Allocate space for the vmm
53     void* vmm_space_physical = m_physical_memory_manager->allocate_frame();
54     ASSERT(vmm_space_physical != nullptr, "Failed to allocate VMM space\n");
55     m_physical_memory_manager->map(vmm_space_physical, (virtual_address_t*)vmm_space, Present | Write, m_pml4_root_address);
56     m_first_region->next = nullptr;
57     _kprintf("Allocated VMM: physical: 0x%x, virtual: 0x%x\n", vmm_space_physical, vmm_space);
58 
59     // Calculate the next available address
60     m_next_available_address = PhysicalMemoryManager::s_page_size;
61     if(m_is_kernel){
62 
63       // Kernel needs to start at the higher half
64       m_next_available_address += vmm_space + s_reserved_space;
65 
66     }
67     _kprintf("Next available address: 0x%x\n", m_next_available_address);
68 
69 
70 }
.fi
.PP
References _kprintf, MaxOS::memory::PhysicalMemoryManager::align_to_page(), MaxOS::memory::PhysicalMemoryManager::allocate_frame(), ASSERT, MaxOS::memory::PhysicalMemoryManager::get_memory_size(), MaxOS::memory::PhysicalMemoryManager::get_pml4_root_address(), MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::map(), MaxOS::memory::Present, MaxOS::memory::MemoryManager::s_hh_direct_map_offset, MaxOS::memory::PhysicalMemoryManager::s_page_size, MaxOS::memory::MemoryManager::to_dm_region(), and MaxOS::memory::Write\&.
.SS "VirtualMemoryManager::~VirtualMemoryManager ()"

.PP
Definition at line 72 of file virtual\&.cpp\&.
.PP
.nf
72                                             {
73 
74 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void * VirtualMemoryManager::allocate (size_t size, size_t flags)"

.PP
Allocate a new chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory 
.RE
.PP

.PP
Definition at line 83 of file virtual\&.cpp\&.
.PP
.nf
83                                                               {
84 
85   return allocate(0, size, flags);
86 }
.fi
.PP
References flags, and size\&.
.PP
Referenced by MaxOS::memory::MemoryManager::MemoryManager()\&.
.SS "void * VirtualMemoryManager::allocate (uint64_t address, size_t size, size_t flags)"

.PP
Allocate a new chunk of virtual memory at a specific address (ie for mmap io devices) 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to allocate at 
.br
\fIsize\fP The size of the memory to allocate 
.br
\fIflags\fP The flags to set on the memory 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the allocated memory or nullptr if failed 
.RE
.PP

.PP
Definition at line 96 of file virtual\&.cpp\&.
.PP
.nf
96                                                                                 {
97 
98   // Make sure allocating something
99   if(size == 0)
100     return nullptr;
101 
102   // If specific address is given
103   if(address != 0){
104 
105       // Make sure isnt already allocated
106       if(address < m_next_available_address)
107         return nullptr;
108 
109       // Make sure its aligned
110       if(!PhysicalMemoryManager::check_aligned(address))
111         return nullptr;
112 
113   }
114 
115   // Make sure the size is aligned
116   size = PhysicalMemoryManager::align_up_to_page(size, PhysicalMemoryManager::s_page_size);
117 
118   // Check the free list for a chunk
119   free_chunk_t* reusable_chunk = find_and_remove_free_chunk(size);
120   if(reusable_chunk != nullptr){
121 
122     // If the chunk is not being reserved
123     if(!(flags & Reserve)){
124 
125       // Map the memory
126       size_t pages = PhysicalMemoryManager::size_to_frames(size);
127       for (size_t i = 0; i < pages; i++){
128 
129         // Allocate a new frame
130         physical_address_t* frame = m_physical_memory_manager->allocate_frame();
131         ASSERT(frame != nullptr, "Failed to allocate frame (from free chunk list)\n");
132 
133         // Map the frame
134         m_physical_memory_manager->map(frame, (virtual_address_t*)reusable_chunk->start_address + (i * PhysicalMemoryManager::s_page_size), Present | Write, m_pml4_root_address);
135 
136       }
137 
138     }
139 
140     // Return the address
141     return (void*)reusable_chunk->start_address;
142 
143   }
144 
145 
146   // Is there space in the current region
147   if(m_current_chunk >= s_chunks_per_page)
148     new_region();
149 
150   // If we need to allocate at a specific address
151   if(address != 0){
152     m_next_available_address = address;    //TODO: Creates mem fragmentation - fix
153   }
154 
155   // Allocate the memory
156   virtual_memory_chunk_t* chunk = &m_current_region->chunks[m_current_chunk];
157   chunk->size = size;
158   chunk->flags = flags;
159   chunk->start_address = m_next_available_address;
160 
161   // Update the next available address
162   m_next_available_address += size;
163   m_current_chunk++;
164 
165   // If just reserving the space don't map it
166   if(flags & Reserve)
167     return (void*)chunk->start_address;
168 
169   // Map the memory
170   size_t pages = PhysicalMemoryManager::size_to_frames(size);
171   for (size_t i = 0; i < pages; i++){
172 
173     // Allocate a new frame
174     physical_address_t* frame = m_physical_memory_manager->allocate_frame();
175     ASSERT(frame != nullptr, "Failed to allocate frame (from current region)\n");
176 
177     // Map the frame
178     m_physical_memory_manager->map(frame, (virtual_address_t*)chunk->start_address + (i * PhysicalMemoryManager::s_page_size), Present | Write, m_pml4_root_address);
179 
180   }
181 
182   // Return the address
183   return (void*)chunk->start_address;
184 }
.fi
.PP
References address, MaxOS::memory::PhysicalMemoryManager::align_up_to_page(), MaxOS::memory::PhysicalMemoryManager::allocate_frame(), ASSERT, MaxOS::memory::PhysicalMemoryManager::check_aligned(), flags, MaxOS::memory::VirtualMemoryChunk::flags, MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::map(), MaxOS::memory::Present, MaxOS::memory::Reserve, MaxOS::memory::PhysicalMemoryManager::s_page_size, size, MaxOS::memory::VirtualMemoryChunk::size, MaxOS::memory::PhysicalMemoryManager::size_to_frames(), MaxOS::memory::VirtualMemoryChunk::start_address, MaxOS::memory::FreeChunk::start_address, and MaxOS::memory::Write\&.
.SS "void VirtualMemoryManager::free (void * address)"

.PP
Free a chunk of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the memory to free 
.RE
.PP

.PP
Definition at line 213 of file virtual\&.cpp\&.
.PP
.nf
213                                              {
214 
215   // Make sure freeing something
216   if(address == nullptr)
217     return;
218 
219   // Find the chunk
220   virtual_memory_region_t* region = m_first_region;
221   virtual_memory_chunk_t* chunk = nullptr;
222   while(region != nullptr){
223 
224       // Loop through the chunks
225       for (size_t i = 0; i < s_chunks_per_page; i++){
226 
227         // Check if the address is in the chunk
228         if(region->chunks[i]\&.start_address == (uintptr_t)address){
229               chunk = &region->chunks[i];
230               break;
231         }
232       }
233 
234       // If the chunk was found
235       if(chunk != nullptr)
236         break;
237 
238       // Move to the next region
239       region = region->next;
240   }
241 
242   // Make sure the chunk was found
243   if(chunk == nullptr)
244     return;
245 
246   // Unmap the memory
247   size_t pages = PhysicalMemoryManager::size_to_frames(chunk->size);
248   for (size_t i = 0; i < pages; i++){
249 
250         // Unmap the frame
251         m_physical_memory_manager->unmap((virtual_address_t*)chunk->start_address + (i * PhysicalMemoryManager::s_page_size), m_pml4_root_address);
252 
253   }
254 
255   // Add the chunk to the free list
256   add_free_chunk(chunk->start_address, chunk->size);
257 
258   // Clear the chunk
259   chunk->size = 0;
260   chunk->flags = 0;
261   chunk->start_address = 0;
262 }
.fi
.PP
References address, MaxOS::memory::VirtualMemoryChunk::flags, MaxOS::drivers::peripherals::i, MaxOS::memory::PhysicalMemoryManager::s_page_size, MaxOS::memory::VirtualMemoryChunk::size, MaxOS::memory::PhysicalMemoryManager::size_to_frames(), MaxOS::memory::VirtualMemoryChunk::start_address, and MaxOS::memory::PhysicalMemoryManager::unmap()\&.
.SS "size_t VirtualMemoryManager::memory_used ()"

.PP
Returns the amount of memory used\&. 
.PP
\fBReturns\fP
.RS 4
The amount of memory used 
.RE
.PP

.PP
Definition at line 268 of file virtual\&.cpp\&.
.PP
.nf
268                                          {
269 
270   // Loop through all the regions and add up the size of the allocated chunks
271   size_t result = 0;
272 
273   // Iterate through the regions
274   virtual_memory_region_t *region = m_first_region;
275   while (region != nullptr) {
276 
277     // Loop through the chunks
278     for (size_t i = 0; i < s_chunks_per_page; i++) {
279 
280       // Check if the address is in the chunk
281       if (region->chunks[i]\&.size != 0)
282         result += region->chunks[i]\&.size;
283     }
284 
285     // Move to the next region
286     region = region->next;
287   }
288 
289   return result;
290 }
.fi
.PP
References MaxOS::drivers::peripherals::i\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

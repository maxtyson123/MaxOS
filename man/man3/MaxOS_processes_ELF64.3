.TH "MaxOS::processes::ELF64" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::ELF64 \- Handles the loading and parsing of 64-bit ELF files\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <elf\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBELF64\fP (uintptr_t elf_header_address)"
.br
.RI "Constructor for the \fBELF64\fP class\&. "
.ti -1c
.RI "\fB~ELF64\fP ()"
.br
.RI "Destructor for the \fBELF64\fP class\&. "
.ti -1c
.RI "void \fBload\fP ()"
.br
.RI "Loads the elf program into memory if a valid elf file\&. "
.ti -1c
.RI "bool \fBis_valid\fP () const"
.br
.RI "Checks if the elf file is valid for MaxOS runtime\&. "
.ti -1c
.RI "\fBelf_64_header_t\fP * \fBheader\fP () const"
.br
.RI "Gets the header of the elf file\&. "
.ti -1c
.RI "\fBelf_64_program_header_t\fP * \fBget_program_header\fP (size_t index) const"
.br
.RI "Gets a program header from the elf file\&. "
.ti -1c
.RI "\fBelf_64_section_header_t\fP * \fBget_section_header\fP (size_t index) const"
.br
.RI "Gets a section header from the elf file\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static uint64_t \fBto_vmm_flags\fP (uint32_t type)"
.br
.RI "Converts elf flags to vmm flags\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the loading and parsing of 64-bit ELF files\&. 
.PP
Definition at line \fB217\fP of file \fBelf\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ELF64::ELF64 (uintptr_t elf_header_address)\fC [explicit]\fP"

.PP
Constructor for the \fBELF64\fP class\&. 
.PP
\fBParameters\fP
.RS 4
\fIelf_header_address\fP The address of the elf header, this must be mapped to memory before uses 
.RE
.PP

.PP
Definition at line \fB23\fP of file \fBelf\&.cpp\fP\&..PP
.nf
24 : m_elf_header_address(elf_header_address)
25 {
26 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBelf_64_program_header_t\fP * ELF64::get_program_header (size_t index) const"

.PP
Gets a program header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The program header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line \fB63\fP of file \fBelf\&.cpp\fP\&..PP
.nf
63                                                                      {
64 
65     // Check bounds
66     if (index >= header()\->program_header_count)
67         return nullptr;
68 
69     // Find the program headers and return the item
70     auto* program_headers = (elf_64_program_header_t*) (m_elf_header_address + header()\->program_header_offset);
71     return &program_headers[index];
72 
73 }
.fi

.PP
References \fBheader()\fP, and \fBMaxOS::processes::ELFHeader64::program_header_offset\fP\&.
.SS "\fBelf_64_section_header_t\fP * ELF64::get_section_header (size_t index) const"

.PP
Gets a section header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the section header 
.RE
.PP
\fBReturns\fP
.RS 4
The section header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line \fB81\fP of file \fBelf\&.cpp\fP\&..PP
.nf
81                                                                      {
82 
83     // Check bound
84     if (index >= header()\->section_header_count)
85         return nullptr;
86 
87     // Find the section headers and return the item
88     auto* section_headers = (elf_64_section_header_t*) (m_elf_header_address + header()\->section_header_offset);
89     return &section_headers[index];
90 
91 }
.fi

.PP
References \fBheader()\fP, and \fBMaxOS::processes::ELFHeader64::section_header_offset\fP\&.
.SS "\fBelf_64_header_t\fP * ELF64::header () const"

.PP
Gets the header of the elf file\&. 
.PP
\fBReturns\fP
.RS 4
The header of the elf file 
.RE
.PP

.PP
Definition at line \fB52\fP of file \fBelf\&.cpp\fP\&..PP
.nf
52                                      {
53 
54     return (elf_64_header_t*) m_elf_header_address;
55 }
.fi

.PP
Referenced by \fBget_program_header()\fP, \fBget_section_header()\fP, and \fBis_valid()\fP\&.
.SS "bool ELF64::is_valid () const"

.PP
Checks if the elf file is valid for MaxOS runtime\&. 
.PP
\fBReturns\fP
.RS 4
True if the elf file is valid, false otherwise
.RE
.PP
\fBTodo\fP
.RS 4
Add support for maxOS ABI 
.RE
.PP

.PP
Definition at line \fB100\fP of file \fBelf\&.cpp\fP\&..PP
.nf
100                            {
101 
102     // Validate the magic number
103     for (size_t i = 0; i < 4; i++)
104         if (header()\->identification[i] != ELF_MAGIC[i])
105             return false;
106 
107     // Check if the elf is 64 bit
108     if (header()\->identification[(int) ELFIdentification::Class] != (int) ELFClass::Bits64)
109         return false;
110 
111     // Check if the elf is little endian
112     if (header()\->identification[(int) ELFIdentification::Data] != (int) ELFData::LittleEndian)
113         return false;
114 
115     // Check if the elf is version 1
116     if (header()\->identification[(int) ELFIdentification::Version] != (int) ELFVersion::Current)
117         return false;
118 
119     // Check if the elf is for the MaxOS platform
120     //  if(header() \-> identification[OSABI] != MaxOSABI)
121     //      return false;
122 
123     // Check if the elf is executable
124     if (header()\->type != (int) ELFType::Executable)
125         return false;
126 
127     // Check if the elf is for the x86_64 platform
128     if (header()\->machine != (int) ELFMachine::x86_64)
129         return false;
130 
131     // LGTM
132     return true;
133 
134 }
.fi

.PP
References \fBMaxOS::processes::ELF_MAGIC\fP, and \fBheader()\fP\&.
.PP
Referenced by \fBload()\fP, and \fBMaxOS::processes::GlobalScheduler::load_multiboot_elfs()\fP\&.
.SS "void ELF64::load ()"

.PP
Loads the elf program into memory if a valid elf file\&. 
.PP
\fBTodo\fP
.RS 4
Error handling 
.RE
.PP

.PP
Definition at line \fB38\fP of file \fBelf\&.cpp\fP\&..PP
.nf
38                  {
39 
40     if (!is_valid())
41         return;
42 
43     load_program_headers();
44 
45 }
.fi

.PP
References \fBis_valid()\fP\&.
.SS "uint64_t ELF64::to_vmm_flags (uint32_t type)\fC [static]\fP"

.PP
Converts elf flags to vmm flags\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The elf flags of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The vmm flags 
.RE
.PP

.PP
Definition at line \fB173\fP of file \fBelf\&.cpp\fP\&..PP
.nf
173                                           {
174 
175     // Conversion
176     // ELF   |   VMM
177     // 0x0   |   Executable
178     // 0x1   |   Write
179     // 0x2   |   Read
180 
181     uint64_t flags = PRESENT | USER | NO_EXECUTE;
182 
183     // Enable write
184     if (type & ELFWrite)
185         flags |= WRITE;
186 
187     // Disable no execute
188     if (type & ELFExecute)
189         flags &= ~NO_EXECUTE;
190 
191     return flags;
192 }
.fi

.PP
References \fBMaxOS::memory::NO_EXECUTE\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::memory::USER\fP, and \fBMaxOS::memory::WRITE\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::hardwarecommunication::InterruptHandler" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptHandler \- Handles a certain interrupt number\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::clock::Clock\fP, \fBMaxOS::drivers::clock::PIT\fP, \fBMaxOS::drivers::ethernet::AMD_AM79C973\fP, \fBMaxOS::drivers::ethernet::IntelI217\fP, \fBMaxOS::drivers::peripherals::KeyboardDriver\fP, \fBMaxOS::drivers::peripherals::MouseDriver\fP, \fBMaxOS::processes::GlobalScheduler\fP, and \fBMaxOS::system::SyscallManager\fP\fC [private]\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBhandle_interrupt\fP ()"
.br
.RI "Handles an interrupt\&. "
.ti -1c
.RI "\fBvirtual\fP \fBsystem::cpu_status_t\fP * \fBhandle_interrupt\fP (\fBsystem::cpu_status_t\fP *status)"
.br
.RI "Handles an interrupt and returns the status\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP (\fBuint8_t\fP interrupt_number, \fBint64_t\fP \fBredirect\fP=\-1, \fBuint64_t\fP \fBredirect_index\fP=0)"
.br
.RI "Creates a new interrupt handler and registers it with the interrupt manager\&. "
.ti -1c
.RI "\fB~InterruptHandler\fP ()"
.br
.RI "Destroys the interrupt handler and unregisters it from the interrupt manager\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint8_t \fBm_interrupt_number\fP"
.br
.RI "The interrupt number this handler handles\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles a certain interrupt number\&. 
.PP
Definition at line \fB30\fP of file \fBinterrupts\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptHandler::InterruptHandler (\fBuint8_t\fP interrupt_number, \fBint64_t\fP redirect = \fC\-1\fP, \fBuint64_t\fP redirect_index = \fC0\fP)\fC [explicit]\fP, \fC [protected]\fP"

.PP
Creates a new interrupt handler and registers it with the interrupt manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt_number\fP The interrupt number to handle 
.br
\fIredirect\fP What legacy interrupt to redirect from (-1 for no redirection) 
.br
\fIredirect_index\fP Which index of the legacy interrupt to redirect from 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
25 : m_interrupt_number(interrupt_number)
26 {
27 
28     // Get the interrupt manager
29     InterruptManager* interrupt_manager = InterruptManager::s_active_interrupt_manager;
30     ASSERT(interrupt_manager != nullptr, "No active interrupt manager");
31 
32     // Register the handler
33     interrupt_manager\->set_interrupt_handler(m_interrupt_number, this);
34 
35     // Not all interrupts need redirecting
36     if (redirect == \-1)
37         return;
38 
39     // Redirect a legacy interrupt to an interrupt the kernel expects
40     IOAPIC* io_apic = interrupt_manager\->active_apic()\->io_apic();
41     interrupt_redirect_t temp = {
42             \&.type = (uint8_t) redirect,
43             \&.index = (uint8_t) redirect_index,
44             \&.interrupt = m_interrupt_number,
45             \&.destination = 0x00,
46             \&.flags = 0x00,
47             \&.mask = false,
48     };
49     io_apic\->set_redirect(&temp);
50 }
.fi

.PP
References \fBASSERT\fP, \fBm_interrupt_number\fP, \fBMaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager\fP, and \fBMaxOS::hardwarecommunication::IOAPIC::set_redirect()\fP\&.
.SS "InterruptHandler::~InterruptHandler ()\fC [protected]\fP"

.PP
Destroys the interrupt handler and unregisters it from the interrupt manager\&. 
.PP
Definition at line \fB55\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
55                                     {
56 
57     // Get the interrupt manager
58     InterruptManager* interrupt_manager = InterruptManager::s_active_interrupt_manager;
59     if (interrupt_manager == nullptr) return;
60 
61     // Remove the handler
62     interrupt_manager\->set_interrupt_handler(m_interrupt_number, nullptr);
63 }
.fi

.PP
References \fBm_interrupt_number\fP, and \fBMaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InterruptHandler::handle_interrupt ()\fC [virtual]\fP"

.PP
Handles an interrupt\&. 
.PP
Reimplemented in \fBMaxOS::drivers::ethernet::AMD_AM79C973\fP, \fBMaxOS::drivers::ethernet::IntelI217\fP, and \fBMaxOS::drivers::peripherals::KeyboardDriver\fP\&.
.PP
Definition at line \fB68\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
68                                         {
69 
70 }
.fi

.PP
Referenced by \fBhandle_interrupt()\fP, and \fBMaxOS::hardwarecommunication::InterruptManager::handle_interrupt_request()\fP\&.
.SS "\fBsystem::cpu_status_t\fP * InterruptHandler::handle_interrupt (\fBsystem::cpu_status_t\fP * status)\fC [virtual]\fP"

.PP
Handles an interrupt and returns the status\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The status of the CPU 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the CPU 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::system::SyscallManager\fP, and \fBMaxOS::processes::GlobalScheduler\fP\&.
.PP
Definition at line \fB78\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
78                                                                                  {
79 
80     // For handlers that don't care about the status
81     handle_interrupt();
82 
83     // Return the default status
84     return status;
85 }
.fi

.PP
References \fBhandle_interrupt()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t MaxOS::hardwarecommunication::InterruptHandler::m_interrupt_number\fC [protected]\fP"

.PP
The interrupt number this handler handles\&. 
.PP
Definition at line \fB32\fP of file \fBinterrupts\&.h\fP\&.
.PP
Referenced by \fBInterruptHandler()\fP, and \fB~InterruptHandler()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

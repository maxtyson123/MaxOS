.TH "MaxOS::hardwarecommunication::InterruptHandler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptHandler \- Handles a certain interrupt number\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::clock::Clock\fP, \fBMaxOS::drivers::clock::PIT\fP, \fBMaxOS::drivers::ethernet::AMD_AM79C973\fP, \fBMaxOS::drivers::ethernet::intel_i217\fP, \fBMaxOS::drivers::peripherals::KeyboardDriver\fP, \fBMaxOS::drivers::peripherals::MouseDriver\fP, \fBMaxOS::processes::Scheduler\fP, and \fBMaxOS::system::SyscallManager\fP\fC [private]\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBhandle_interrupt\fP ()"
.br
.RI "Handles an interrupt\&. "
.ti -1c
.RI "\fBvirtual\fP system::cpu_status_t * \fBhandle_interrupt\fP (system::cpu_status_t *\fBstatus\fP)"
.br
.RI "Handles an interrupt and returns the status\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP (\fBuint8_t\fP interrupt_number, \fBint64_t\fP \fBredirect\fP=\-1, \fBuint64_t\fP \fBredirect_index\fP=0)"
.br
.ti -1c
.RI "\fB~InterruptHandler\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint8_t \fBm_interrupt_number\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles a certain interrupt number\&. 
.PP
Definition at line \fB28\fP of file \fBinterrupts\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptHandler::InterruptHandler (\fBuint8_t\fP interrupt_number, \fBint64_t\fP redirect = \fC\-1\fP, \fBuint64_t\fP redirect_index = \fC0\fP)\fC [protected]\fP"

.PP
Definition at line \fB13\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
14 : m_interrupt_number(interrupt_number)
15 {
16 
17     // Get the interrupt manager
18     InterruptManager* interrupt_manager = InterruptManager::s_active_interrupt_manager;
19     ASSERT(interrupt_manager != nullptr, "No active interrupt manager");
20 
21     // Register the handler
22     interrupt_manager\->set_interrupt_handler(m_interrupt_number, this);
23 
24     // Not all interrupts need redirecting
25     if (redirect == \-1)
26         return;
27 
28     // Redirect a legacy interrupt to an interrupt the kernel expects
29     IOAPIC* io_apic = interrupt_manager\->active_apic()\->io_apic();
30     interrupt_redirect_t temp = {
31             \&.type = (uint8_t) redirect,
32             \&.index = (uint8_t) redirect_index,
33             \&.interrupt = m_interrupt_number,
34             \&.destination = 0x00,
35             \&.flags = 0x00,
36             \&.mask = false,
37     };
38     io_apic\->set_redirect(&temp);
39 }
.fi

.PP
References \fBASSERT\fP, \fBm_interrupt_number\fP, \fBMaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager\fP, and \fBMaxOS::hardwarecommunication::IOAPIC::set_redirect()\fP\&.
.SS "InterruptHandler::~InterruptHandler ()\fC [protected]\fP"

.PP
Definition at line \fB42\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
42                                     {
43 
44     // Get the interrupt manager
45     InterruptManager* interrupt_manager = InterruptManager::s_active_interrupt_manager;
46     if (interrupt_manager == nullptr) return;
47 
48     // Remove the handler
49     interrupt_manager\->set_interrupt_handler(m_interrupt_number, nullptr);
50 }
.fi

.PP
References \fBm_interrupt_number\fP, and \fBMaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InterruptHandler::handle_interrupt ()\fC [virtual]\fP"

.PP
Handles an interrupt\&. 
.PP
Reimplemented in \fBMaxOS::drivers::clock::PIT\fP, \fBMaxOS::drivers::clock::Clock\fP, \fBMaxOS::drivers::ethernet::AMD_AM79C973\fP, \fBMaxOS::drivers::ethernet::intel_i217\fP, and \fBMaxOS::drivers::peripherals::KeyboardDriver\fP\&.
.PP
Definition at line \fB55\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
55                                         {
56 
57 }
.fi

.PP
Referenced by \fBhandle_interrupt()\fP, and \fBMaxOS::hardwarecommunication::InterruptManager::handle_interrupt_request()\fP\&.
.SS "system::cpu_status_t * InterruptHandler::handle_interrupt (system::cpu_status_t * status)\fC [virtual]\fP"

.PP
Handles an interrupt and returns the status\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The status of the CPU 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the CPU 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::processes::Scheduler\fP\&.
.PP
Definition at line \fB65\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
65                                                                                  {
66 
67     // For handlers that don't care about the status
68     handle_interrupt();
69 
70     // Return the default status
71     return status;
72 }
.fi

.PP
References \fBhandle_interrupt()\fP, and \fBstatus\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t MaxOS::hardwarecommunication::InterruptHandler::m_interrupt_number\fC [protected]\fP"

.PP
Definition at line \fB30\fP of file \fBinterrupts\&.h\fP\&.
.PP
Referenced by \fBInterruptHandler()\fP, and \fB~InterruptHandler()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

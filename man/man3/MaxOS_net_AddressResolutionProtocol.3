.TH "MaxOS::net::AddressResolutionProtocol" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::AddressResolutionProtocol
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <arp\&.h>\fP
.PP
Inherits \fBMaxOS::net::EthernetFramePayloadHandler\fP, and \fBMaxOS::net::InternetProtocolAddressResolver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAddressResolutionProtocol\fP (\fBEthernetFrameHandler\fP *ethernetFrameHandler, \fBInternetProtocolHandler\fP *internetProtocolHandler, \fBcommon::OutputStream\fP *errorMessages)"
.br
.ti -1c
.RI "\fB~AddressResolutionProtocol\fP ()"
.br
.ti -1c
.RI "bool \fBhandleEthernetFramePayload\fP (uint8_t *\fBdata\fP, uint32_t \fBsize\fP)"
.br
.RI "Called when an ARP packet is received\&. "
.ti -1c
.RI "void \fBRequestMACAddress\fP (\fBInternetProtocolAddress\fP \fBaddress\fP)"
.br
.RI "Request the MAC address of a given IP address\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBResolve\fP (\fBInternetProtocolAddress\fP \fBaddress\fP)"
.br
.RI "Get the MAC address from an IP via ARP\&. "
.ti -1c
.RI "void \fBStore\fP (\fBInternetProtocolAddress\fP internetProtocolAddress, \fBdrivers::ethernet::MediaAccessControlAddress\fP mediaAccessControlAddress)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 34 of file arp\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "net::AddressResolutionProtocol::AddressResolutionProtocol (\fBEthernetFrameHandler\fP * ethernetFrameHandler, \fBInternetProtocolHandler\fP * internetProtocolHandler, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line 15 of file arp\&.cpp\&.
.PP
.nf
16 : EthernetFramePayloadHandler(ethernetFrameHandler, 0x0806),
17   InternetProtocolAddressResolver(internetProtocolHandler)
18 {
19     this->internetProtocolHandler = internetProtocolHandler;
20     this->errorMessages = errorMessages;
21 }
.fi
.SS "net::AddressResolutionProtocol::~AddressResolutionProtocol ()"

.PP
Definition at line 23 of file arp\&.cpp\&.
.PP
.nf
23                                                          {
24 
25 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool AddressResolutionProtocol::handleEthernetFramePayload (uint8_t * etherframePayload, uint32_t size)"

.PP
Called when an ARP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIetherframePayload\fP The payload of the ARP packet\&. 
.br
\fIsize\fP The size of the ARP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the device should send a response, false otherwise\&. 
.RE
.PP

.PP
Definition at line 34 of file arp\&.cpp\&.
.PP
.nf
34                                                                                                     {
35 
36     //Check if the size is correct
37     if(size < sizeof(AddressResolutionProtocolMessage))
38         return false;
39 
40     //Convert the payload to an ARP message
41     AddressResolutionProtocolMessage* arpMessage = (AddressResolutionProtocolMessage*)etherframePayload;
42 
43     //Check if the message hardware type is Ethernet (BigEndian)
44     if(arpMessage -> hardwareType == 0x100){
45 
46         if(arpMessage -> protocol == 0x0008             //Check if the protocol is IPv4 (BigEndian)
47         && arpMessage -> hardwareAddressSize == 6
48         && arpMessage -> protocolAddressSize == 4
49         && arpMessage -> dstIP == internetProtocolHandler -> GetInternetProtocolAddress())
50         {
51 
52             switch (arpMessage -> command) {
53                 //Request
54                 case 0x0100:
55                     arpMessage -> command = 0x0200;                                                                         //Set the command to reply
56                     arpMessage -> dstMAC = arpMessage -> srcMAC;                                                            //Set the destination MAC to the source MAC
57                     arpMessage -> dstIP = arpMessage -> srcIP;                                                              //Set the destination IP to the source IP
58                     arpMessage -> srcMAC = internetProtocolHandler -> GetMediaAccessControlAddress();                      //Set the source MAC to this MAC
59                     arpMessage -> srcIP = internetProtocolHandler -> GetInternetProtocolAddress();                         //Set the source IP to this IP
60                     return true;
61 
62                 //Response
63                 case 0x0200:
64                     addressCache\&.insert((InternetProtocolAddress)arpMessage -> srcIP, (MediaAccessControlAddress)arpMessage -> srcMAC);     //Insert the MAC address into the cache
65                     break;
66 
67                 default:
68                     break;
69 
70             }
71 
72         }
73 
74     }
75 
76     //By default, don't send anything back
77     return false;
78 
79 
80 }
.fi
.PP
References command, dstIP, dstMAC, hardwareAddressSize, hardwareType, MaxOS::common::Map< Key, Value >::insert(), protocol, protocolAddressSize, size, srcIP, and srcMAC\&.
.SS "void AddressResolutionProtocol::RequestMACAddress (\fBInternetProtocolAddress\fP address)"

.PP
Request the MAC address of a given IP address\&. 
.PP
\fBParameters\fP
.RS 4
\fIIP_BE\fP The IP address in BigEndian\&. 
.RE
.PP

.PP
Definition at line 88 of file arp\&.cpp\&.
.PP
.nf
88                                                                                  {
89 
90     //When a MAC adress is requested, instantiate a new ARP message block on the stack
91     AddressResolutionProtocolMessage arpMessage;
92 
93     //Set the message's values
94     arpMessage\&.hardwareType = 0x0100;                                                   //Ethernet, encoded in BigEndian
95     arpMessage\&.protocol = 0x0008;                                                       //IPv4, encoded in BigEndian
96     arpMessage\&.hardwareAddressSize = 6;                                                 //MAC address size
97     arpMessage\&.protocolAddressSize = 4;                                                 //IPv4 address size
98     arpMessage\&.command = 0x0100;                                                        //Request, encoded in BigEndian
99 
100     //Set the message's source and destination
101     arpMessage\&.srcMAC = frameHandler -> getMAC();                                       //Set the source MAC address to the backend's MAC address
102     arpMessage\&.srcIP = internetProtocolHandler -> GetInternetProtocolAddress();        //Set the source IP address to the backend's IP address
103     arpMessage\&.dstMAC = 0xFFFFFFFFFFFF;                                                 //Set the destination MAC address to broadcast
104     arpMessage\&.dstIP = address;                                                           //Set the destination IP address to the requested IP address
105 
106     //Send the message
107     this -> Send(arpMessage\&.dstMAC, (uint8_t*)&arpMessage, sizeof(AddressResolutionProtocolMessage));
108 
109 
110 }
.fi
.PP
References address, MaxOS::net::AddressResolutionProtocolMessage::command, MaxOS::net::AddressResolutionProtocolMessage::dstIP, MaxOS::net::AddressResolutionProtocolMessage::dstMAC, MaxOS::net::EthernetFramePayloadHandler::frameHandler, MaxOS::net::AddressResolutionProtocolMessage::hardwareAddressSize, MaxOS::net::AddressResolutionProtocolMessage::hardwareType, MaxOS::net::AddressResolutionProtocolMessage::protocol, MaxOS::net::AddressResolutionProtocolMessage::protocolAddressSize, MaxOS::net::EthernetFramePayloadHandler::Send(), MaxOS::net::AddressResolutionProtocolMessage::srcIP, and MaxOS::net::AddressResolutionProtocolMessage::srcMAC\&.
.PP
Referenced by Resolve()\&.
.SS "\fBMediaAccessControlAddress\fP AddressResolutionProtocol::Resolve (\fBInternetProtocolAddress\fP address)\fC [virtual]\fP"

.PP
Get the MAC address from an IP via ARP\&. 
.PP
\fBParameters\fP
.RS 4
\fIIP_BE\fP The IP address to get the MAC address from\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The MAC address of the IP address\&. 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::InternetProtocolAddressResolver\fP\&.
.PP
Definition at line 119 of file arp\&.cpp\&.
.PP
.nf
119                                                                                             {
120 
121     volatile Map<InternetProtocolAddress, MediaAccessControlAddress>::iterator cacheIterator = addressCache\&.find(address); //Check if the MAC address is in the cache
122 
123     //If not, request it
124     if(addressCache\&.end() == cacheIterator){
125         RequestMACAddress(address);
126     }
127 
128     //TODO: Add clock to wait
129 
130     //This isnt safe because the MAC address might not be in the cache yet or the machine may not be connected to the network (possible infinite loop) //TODO: TIMEOUT
131     while (cacheIterator == addressCache\&.end()) {                         //Wait until the MAC address is found
132         cacheIterator = addressCache\&.find(address);
133     }
134 
135     //Return the MAC address
136 
137     return cacheIterator -> second;
138 
139 }
.fi
.PP
References address, MaxOS::common::Map< Key, Value >::end(), MaxOS::common::Map< Key, Value >::find(), and RequestMACAddress()\&.
.SS "void AddressResolutionProtocol::Store (\fBInternetProtocolAddress\fP internetProtocolAddress, \fBdrivers::ethernet::MediaAccessControlAddress\fP mediaAccessControlAddress)\fC [virtual]\fP"

.PP
Reimplemented from \fBMaxOS::net::InternetProtocolAddressResolver\fP\&.
.PP
Definition at line 141 of file arp\&.cpp\&.
.PP
.nf
141                                                                                                                                           {
142     addressCache\&.insert(internetProtocolAddress, mediaAccessControlAddress);
143 }
.fi
.PP
References MaxOS::common::Map< Key, Value >::insert()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

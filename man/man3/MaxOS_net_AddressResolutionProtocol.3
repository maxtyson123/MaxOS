.TH "MaxOS::net::AddressResolutionProtocol" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::AddressResolutionProtocol \- Handles ARP requests and replies\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <arp\&.h>\fP
.PP
Inherits \fBMaxOS::net::EthernetFramePayloadHandler\fP, and \fBMaxOS::net::IPV4AddressResolver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAddressResolutionProtocol\fP (\fBEthernetFrameHandler\fP *\fBethernetFrameHandler\fP, \fBInternetProtocolHandler\fP *internetProtocolHandler, \fBcommon::OutputStream\fP *errorMessages)"
.br
.RI "Constructs an \fBAddressResolutionProtocol\fP handler\&. "
.ti -1c
.RI "\fBbool\fP \fBhandleEthernetframePayload\fP (\fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Called when an ARP packet is received\&. "
.ti -1c
.RI "\fBvoid\fP \fBRequestMACAddress\fP (InternetProtocolAddress address)"
.br
.RI "Request the MAC address of a given IP address\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBResolve\fP (InternetProtocolAddress address) \fBfinal\fP"
.br
.RI "Get the MAC address from an IP via ARP\&. "
.ti -1c
.RI "\fBvoid\fP \fBStore\fP (InternetProtocolAddress \fBinternetProtocolAddress\fP, \fBdrivers::ethernet::MediaAccessControlAddress\fP \fBmediaAccessControlAddress\fP) \fBfinal\fP"
.br
.RI "Store a mapping of an IP address to a MAC address\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFramePayloadHandler\fP (\fBEthernetFrameHandler\fP *\fBframeHandler\fP, \fBuint16_t\fP \fBhandledType\fP)"
.br
.RI "Construct a new Ether Frame Payload Handler object\&. "
.ti -1c
.RI "\fB~EthernetFramePayloadHandler\fP ()"
.br
.RI "Destroy the EtherFrameHandler:: EtherFrameHandler object, Removes it from the handler list\&. "
.ti -1c
.RI "\fBvoid\fP \fBSend\fP (\fBuint64_t\fP \fBdestinationMAC\fP, \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send an packet via the backend driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::net::IPV4AddressResolver\fP
.in +1c
.ti -1c
.RI "\fBIPV4AddressResolver\fP (\fBInternetProtocolHandler\fP *internetProtocolHandler)"
.br
.RI "\fBRESOLVER\fP/// "
.in -1c
.SS "Additional Inherited Members"


Protected Attributes inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP * \fBframeHandler\fP"
.br
.RI "The Ethernet frame handler this payload handler is connected to\&. "
.ti -1c
.RI "uint16_t \fBhandledType\fP"
.br
.RI "The Ethernet frame type this handler handles\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles ARP requests and replies\&. 
.PP
Definition at line \fB45\fP of file \fBarp\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "net::AddressResolutionProtocol::AddressResolutionProtocol (\fBEthernetFrameHandler\fP * ethernetFrameHandler, \fBInternetProtocolHandler\fP * internetProtocolHandler, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Constructs an \fBAddressResolutionProtocol\fP handler\&. 
.PP
\fBParameters\fP
.RS 4
\fIethernetFrameHandler\fP The Ethernet frame handler to use\&. 
.br
\fIinternetProtocolHandler\fP The Internet protocol handler to use\&. 
.br
\fIerrorMessages\fP The output stream to use for error messages\&. 
.RE
.PP

.PP
Definition at line \fB25\fP of file \fBarp\&.cpp\fP\&..PP
.nf
26 : EthernetFramePayloadHandler(ethernetFrameHandler, 0x0806),
27   IPV4AddressResolver(internetProtocolHandler)
28 {
29     this\->internetProtocolHandler = internetProtocolHandler;
30     this\->errorMessages = errorMessages;
31 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBbool\fP AddressResolutionProtocol::handleEthernetframePayload (\fBuint8_t\fP * etherframePayload, \fBuint32_t\fP size)\fC [virtual]\fP"

.PP
Called when an ARP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIetherframePayload\fP The payload of the ARP packet\&. 
.br
\fIsize\fP The size of the ARP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the device should send a response, false otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.PP
Definition at line \fB42\fP of file \fBarp\&.cpp\fP\&..PP
.nf
42                                                                                                     {
43 
44     //Check if the size is correct
45     if(size < sizeof(ARPMessage))
46         return false;
47 
48     //Convert the payload to an ARP message
49     ARPMessage* arpMessage = (ARPMessage*)etherframePayload;
50 
51     //Check if the message hardware type is Ethernet (BigEndian)
52     if(arpMessage \-> hardwareType == 0x100){
53 
54         if(arpMessage \-> protocol == 0x0008             //Check if the protocol is IPv4 (BigEndian)
55         && arpMessage \-> hardwareAddressSize == 6
56         && arpMessage \-> protocolAddressSize == 4
57         && arpMessage \-> dstIP == internetProtocolHandler \-> GetInternetProtocolAddress())
58         {
59 
60             switch (arpMessage \-> command) {
61                 //Request
62                 case 0x0100:
63                     arpMessage \-> command = 0x0200;                                                                         //Set the command to reply
64                     arpMessage \-> dstMAC = arpMessage \-> srcMAC;                                                            //Set the destination MAC to the source MAC
65                     arpMessage \-> dstIP = arpMessage \-> srcIP;                                                              //Set the destination IP to the source IP
66                     arpMessage \-> srcMAC = internetProtocolHandler \-> GetMediaAccessControlAddress();                      //Set the source MAC to this MAC
67                     arpMessage \-> srcIP = internetProtocolHandler \-> GetInternetProtocolAddress();                         //Set the source IP to this IP
68                     return true;
69 
70                 //Response
71                 case 0x0200:
72                     addressCache\&.insert((InternetProtocolAddress)arpMessage \-> srcIP, (MediaAccessControlAddress)arpMessage \-> srcMAC);     //Insert the MAC address into the cache
73                     break;
74 
75                 default:
76                     break;
77 
78             }
79 
80         }
81 
82     }
83 
84     //By default, don't send anything back
85     return false;
86 
87 
88 }
.fi

.PP
References \fBcommand\fP, \fBdstIP\fP, \fBdstMAC\fP, \fBhardwareAddressSize\fP, \fBhardwareType\fP, \fBMaxOS::common::Map< Key, Value >::insert()\fP, \fBprotocol\fP, \fBprotocolAddressSize\fP, \fBsize\fP, \fBsrcIP\fP, and \fBsrcMAC\fP\&.
.SS "\fBvoid\fP AddressResolutionProtocol::RequestMACAddress (InternetProtocolAddress address)"

.PP
Request the MAC address of a given IP address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The IP address in BigEndian\&. 
.RE
.PP

.PP
Definition at line \fB96\fP of file \fBarp\&.cpp\fP\&..PP
.nf
96                                                                                  {
97 
98     //When a MAC address is requested, instantiate a new ARP message block on the stack
99     ARPMessage arpMessage = {};
100 
101     //Set the message's values
102     arpMessage\&.hardwareType = 0x0100;                                                   //Ethernet, encoded in BigEndian
103     arpMessage\&.protocol = 0x0008;                                                       //IPv4, encoded in BigEndian
104     arpMessage\&.hardwareAddressSize = 6;                                                 //MAC address size
105     arpMessage\&.protocolAddressSize = 4;                                                 //IPv4 address size
106     arpMessage\&.command = 0x0100;                                                        //Request, encoded in BigEndian
107 
108     //Set the message's source and destination
109     arpMessage\&.srcMAC = frameHandler \-> getMAC();                                       //Set the source MAC address to the backend's MAC address
110     arpMessage\&.srcIP = internetProtocolHandler \-> GetInternetProtocolAddress();        //Set the source IP address to the backend's IP address
111     arpMessage\&.dstMAC = 0xFFFFFFFFFFFF;                                                 //Set the destination MAC address to broadcast
112     arpMessage\&.dstIP = address;                                                           //Set the destination IP address to the requested IP address
113 
114     //Send the message
115     this \-> Send(arpMessage\&.dstMAC, (uint8_t*)&arpMessage, sizeof(ARPMessage));
116 
117 
118 }
.fi

.PP
References \fBMaxOS::net::EthernetFramePayloadHandler::frameHandler\fP, and \fBMaxOS::net::EthernetFramePayloadHandler::Send()\fP\&.
.PP
Referenced by \fBResolve()\fP\&.
.SS "MediaAccessControlAddress AddressResolutionProtocol::Resolve (InternetProtocolAddress address)\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the MAC address from an IP via ARP\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The IP address to get the MAC address from\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The MAC address of the IP address\&.
.RE
.PP
\fBTodo\fP
.RS 4
Should have a timeout in case the address cannot be resolved and avoid infinite loops 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::IPV4AddressResolver\fP\&.
.PP
Definition at line \fB129\fP of file \fBarp\&.cpp\fP\&..PP
.nf
129                                                                                             {
130 
131     volatile Map<InternetProtocolAddress, MediaAccessControlAddress>::iterator cacheIterator = addressCache\&.find(address); //Check if the MAC address is in the cache
132 
133     //If not, request it
134     if(addressCache\&.end() == cacheIterator){
135         RequestMACAddress(address);
136     }
137 
138     //This isn't safe because the MAC address might not be in the cache yet or the machine may not be connected to the network (possible infinite loop) //TODO: TIMEOUT
139     while (cacheIterator == addressCache\&.end()) {                         //Wait until the MAC address is found
140         cacheIterator = addressCache\&.find(address);
141     }
142 
143     //Return the MAC address
144 
145     return cacheIterator \-> second;
146 
147 }
.fi

.PP
References \fBMaxOS::common::Map< Key, Value >::end()\fP, \fBMaxOS::common::Map< Key, Value >::find()\fP, and \fBRequestMACAddress()\fP\&.
.SS "\fBvoid\fP AddressResolutionProtocol::Store (InternetProtocolAddress internetProtocolAddress, \fBdrivers::ethernet::MediaAccessControlAddress\fP mediaAccessControlAddress)\fC [final]\fP, \fC [virtual]\fP"

.PP
Store a mapping of an IP address to a MAC address\&. 
.PP
\fBParameters\fP
.RS 4
\fIinternetProtocolAddress\fP The IP address\&. 
.br
\fImediaAccessControlAddress\fP The MAC address\&. 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::IPV4AddressResolver\fP\&.
.PP
Definition at line \fB155\fP of file \fBarp\&.cpp\fP\&..PP
.nf
155                                                                                                                                           {
156     addressCache\&.insert(internetProtocolAddress, mediaAccessControlAddress);
157 }
.fi

.PP
References \fBMaxOS::common::Map< Key, Value >::insert()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "maxOS::hardwarecommunication::PeripheralComponentInterconnectController" 3 "Fri Jan 5 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::hardwarecommunication::PeripheralComponentInterconnectController \- Handles the selecting and loading of drivers for PCI devices\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <pci\&.h>\fP
.PP
Inherits \fBmaxOS::drivers::DriverSelector\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPeripheralComponentInterconnectController\fP (\fBcommon::OutputStream\fP *)"
.br
.RI "__CONTROLLER___ "
.ti -1c
.RI "\fB~PeripheralComponentInterconnectController\fP ()"
.br
.ti -1c
.RI "void \fBselect_drivers\fP (\fBdrivers::DriverSelectorEventHandler\fP *handler, \fBhardwarecommunication::InterruptManager\fP *interrupt_manager, \fBcommon::OutputStream\fP *error_message_stream)"
.br
.RI "Select the driver for the device\&. "
.ti -1c
.RI "\fBdrivers::Driver\fP * \fBget_driver\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev, \fBInterruptManager\fP *interrupt_manager)"
.br
.RI "Get the driver for the device\&. "
.ti -1c
.RI "void \fBlist_known_deivce\fP (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles the selecting and loading of drivers for PCI devices\&. 
.PP
Definition at line 77 of file pci\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PeripheralComponentInterconnectController::PeripheralComponentInterconnectController (\fBcommon::OutputStream\fP * stream)"

.PP
__CONTROLLER___ 
.PP
Definition at line 80 of file pci\&.cpp\&.
.PP
.nf
81 : m_data_port(0xCFC),
82   m_command_port(0xCF8),
83   m_debug_messages_stream(stream)
84 {
85 
86 }
.fi
.SS "PeripheralComponentInterconnectController::~PeripheralComponentInterconnectController ()"

.PP
Definition at line 88 of file pci\&.cpp\&.
.PP
.nf
88                                                                                       {
89 
90 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBDriver\fP * PeripheralComponentInterconnectController::get_driver (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev, \fBInterruptManager\fP * interrupt_manager)"

.PP
Get the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdev\fP Device descriptor 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device, 0 if there is no driver 
.RE
.PP

.PP
Definition at line 238 of file pci\&.cpp\&.
.PP
.nf
238                                                                                                                                                      {
239 
240     // Dont use new here, manually allocate memory instead
241 
242     Driver* driver = 0;
243     switch (dev\&.vendor_id)
244     {
245         case 0x1022:    //AMD
246         {
247             switch (dev\&.device_id)
248             {
249                 case 0x2000:    //am79c971
250                 {
251                     amd_am79c973* result = (amd_am79c973*)MemoryManager::s_active_memory_manager
252                           ->malloc(sizeof(amd_am79c973));
253                     new (result) amd_am79c973(&dev, interrupt_manager);
254                     return result;
255 
256                 }
257                 default:
258                     break;
259             }
260             break;
261         }
262         case 0x8086:  //Intel
263         {
264             switch (dev\&.device_id)
265             {
266                 case 0x100E: //i217 (Ethernet Controller)
267                 {
268                     intel_i217* result = (intel_i217*)MemoryManager::s_active_memory_manager
269                           ->malloc(sizeof(intel_i217));
270                     new (result) intel_i217(&dev, interrupt_manager);
271                     return result;
272                 }
273                 default:
274                     break;
275             }
276             break;
277         }//End Intel
278     }
279 
280     //If there is no driver for the particular device, go into generic devices
281     switch (dev\&.class_id)
282     {
283         case 0x03: //Graphics
284         {
285 
286             switch (dev\&.subclass_id)
287             {
288                 case 0x00:  //VGA
289                 {
290                     VideoGraphicsArray* result = (VideoGraphicsArray*)MemoryManager::s_active_memory_manager->malloc(sizeof(VideoGraphicsArray));
291                     new (result) VideoGraphicsArray();
292                     return result;
293                 }
294             }
295             break;
296         }
297     }
298 
299     return driver;
300 }
.fi
.PP
References maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::class_id, maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::device_id, maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::subclass_id, and maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id\&.
.PP
Referenced by select_drivers()\&.
.SS "void PeripheralComponentInterconnectController::list_known_deivce (\fBPeripheralComponentInterconnectDeviceDescriptor\fP dev)"

.PP
Definition at line 303 of file pci\&.cpp\&.
.PP
.nf
303                                                                                                                      {
304     switch (dev\&.vendor_id)
305     {
306         case 0x1022:
307         {
308             // The vendor is AMD
309             m_debug_messages_stream->write("AMD ");
310 
311             // List the device
312             switch (dev\&.device_id)
313             {
314                 default:
315                   m_debug_messages_stream->write_hex(dev\&.device_id);
316                   break;
317             }
318             break;
319         }
320 
321         case 0x106B:
322         {
323             // The vendor is Apple
324             m_debug_messages_stream->write("Apple ");
325 
326             // List the device
327             switch (dev\&.device_id)
328             {
329                 case 0x003F:
330                 {
331                   m_debug_messages_stream->write("KeyLargo/Intrepid USB");
332                   break;
333                 }
334 
335                 default:
336                   m_debug_messages_stream->write_hex(dev\&.device_id);
337                     break;
338             }
339             break;
340         }
341 
342         case 1234:
343         {
344             // The vendor is QEMU
345             m_debug_messages_stream->write("QEMU ");
346 
347             // List the device
348             switch (dev\&.device_id)
349             {
350 
351                 case 0x1111:
352                 {
353                   m_debug_messages_stream->write("Virtual Video Controller");
354                     break;
355                 }
356             }
357             break;
358         }
359 
360         case 0x8086:
361         {
362             // The vendor is Intel
363             m_debug_messages_stream->write("Intel ");
364 
365             // List the device
366             switch (dev\&.device_id)
367             {
368 
369                 case 0x1237:
370                 {
371                   m_debug_messages_stream->write("440FX");
372                     break;
373                 }
374 
375                 case 0x2415:
376                 {
377                   m_debug_messages_stream->write("AC'97");
378                     break;
379                 }
380 
381                 case 0x7000:
382                 {
383                   m_debug_messages_stream->write("PIIX3");
384                     break;
385 
386                 }
387 
388                 case 0x7010:
389                 {
390                   m_debug_messages_stream->write("PIIX4");
391                     break;
392 
393                 }
394 
395                 case 0x7111:
396                 {
397                   m_debug_messages_stream->write("PIIX3");
398                     break;
399                 }
400 
401                 case 0x7113:
402                 {
403                   m_debug_messages_stream->write("PIIX4 ACPI");
404                     break;
405                 }
406 
407                 default:
408                     break;
409 
410             }
411             break;
412         }
413 
414         case 0x80EE: {
415 
416             // The vendor is VirtualBox
417             m_debug_messages_stream->write("VirtualBox ");
418 
419             // List the device
420             switch (dev\&.device_id) {
421 
422                 case 0xBEEF: {
423                   m_debug_messages_stream->write("Graphics Adapter");
424                     break;
425                 }
426 
427                 case 0xCAFE: {
428                   m_debug_messages_stream->write("Guest Service");
429                     break;
430                 }
431             }
432             break;
433         }
434 
435         default:    // Unknown
436           m_debug_messages_stream->write_hex(dev\&.vendor_id);
437           m_debug_messages_stream->write(" ");
438           m_debug_messages_stream->write_hex(dev\&.device_id);
439           break;
440 
441     }
442 }
.fi
.PP
References maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::device_id, maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id, maxOS::common::OutputStream::write(), and maxOS::common::OutputStream::write_hex()\&.
.PP
Referenced by select_drivers()\&.
.SS "void PeripheralComponentInterconnectController::select_drivers (\fBdrivers::DriverSelectorEventHandler\fP * handler, \fBhardwarecommunication::InterruptManager\fP * interrupt_manager, \fBcommon::OutputStream\fP * error_message_stream)\fC [virtual]\fP"

.PP
Select the driver for the device\&. 
.PP
\fBParameters\fP
.RS 4
\fIdriverManager\fP device driver manager 
.br
\fIinterrupt_manager\fP Interrupt manager 
.RE
.PP
\fBReturns\fP
.RS 4
Driver for the device 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::drivers::DriverSelector\fP\&.
.PP
Definition at line 159 of file pci\&.cpp\&.
.PP
.nf
160 {
161     for (int bus = 0; bus < 8; ++bus) {
162         for (int device = 0; device < 32; ++device) {
163 
164             int numFunctions = (device_has_functions(bus, device)) ? 8 : 1;
165 
166             for (int function = 0; function < numFunctions; ++function) {
167 
168                 // Get the device descriptor, if the vendor id is 0x0000 or 0xFFFF, the device is not present/ready
169                 PeripheralComponentInterconnectDeviceDescriptor deviceDescriptor = get_device_descriptor(bus, device, function);
170                 if(deviceDescriptor\&.vendor_id == 0x0000 || deviceDescriptor\&.vendor_id == 0x0001 || deviceDescriptor\&.vendor_id == 0xFFFF)
171                     continue;
172 
173 
174                 // Get port number
175                 for(int barNum = 5; barNum >= 0; barNum--){
176                     BaseAddressRegister bar = get_base_address_register(bus, device, function, barNum);
177                     if(bar\&.address && (bar\&.type == InputOutput))
178                         deviceDescriptor\&.port_base = (uint32_t)bar\&.address;
179                 }
180 
181                 // write to the debug stream
182                 m_debug_messages_stream->write(deviceDescriptor\&.get_type());
183                 m_debug_messages_stream->write(": ");
184 
185                 // Select the driver and print information about the device
186                 Driver* driver = get_driver(deviceDescriptor, interrupt_manager);
187                 if(driver != 0){
188                   handler->on_driver_selected(driver);
189                   m_debug_messages_stream->write(driver->get_vendor_name());
190                   m_debug_messages_stream->write(" ");
191                   m_debug_messages_stream->write(driver->get_device_name());
192                 }else{
193                   list_known_deivce(deviceDescriptor);
194                 }
195 
196                 // New line
197                 m_debug_messages_stream->write("\n");
198             }
199         }
200     }
201 }
.fi
.PP
References maxOS::hardwarecommunication::BaseAddressRegister::address, maxOS::drivers::Driver::get_device_name(), get_driver(), maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::get_type(), maxOS::drivers::Driver::get_vendor_name(), maxOS::hardwarecommunication::InputOutput, list_known_deivce(), maxOS::drivers::DriverSelectorEventHandler::on_driver_selected(), maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::port_base, maxOS::hardwarecommunication::BaseAddressRegister::type, maxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::vendor_id, and maxOS::common::OutputStream::write()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

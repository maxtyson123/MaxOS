.TH "MaxOS::processes::IPC" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::IPC \- Handles Inter \fBProcess\fP Communication\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipc\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIPC\fP ()"
.br
.RI "Creates a new \fBIPC\fP handler\&. "
.ti -1c
.RI "\fB~IPC\fP ()"
.br
.ti -1c
.RI "\fBipc_shared_memory_t\fP * \fBalloc_shared_memory\fP (size_t \fBsize\fP, \fBstring\fP \fBname\fP)"
.br
.RI "Creates a new shared memory block\&. "
.ti -1c
.RI "\fBipc_shared_memory_t\fP * \fBget_shared_memory\fP (\fBstring\fP \fBname\fP)"
.br
.RI "Gets a shared memory block by name\&. "
.ti -1c
.RI "void \fBfree_shared_memory\fP (\fBstring\fP \fBname\fP)"
.br
.RI "Deletes a shared memory block by name\&. "
.ti -1c
.RI "void \fBfree_shared_memory\fP (uintptr_t \fBphysical_address\fP)"
.br
.RI "Deletes a shared memory block by physical address\&. "
.ti -1c
.RI "void \fBfree_shared_memory\fP (\fBipc_shared_memory_t\fP *block)"
.br
.RI "Deletes a shared memory block\&. "
.ti -1c
.RI "\fBipc_message_endpoint_t\fP * \fBcreate_message_endpoint\fP (\fBstring\fP \fBname\fP)"
.br
.RI "Creates a endpoint for message passing\&. "
.ti -1c
.RI "\fBipc_message_endpoint_t\fP * \fBget_message_endpoint\fP (\fBstring\fP \fBname\fP)"
.br
.RI "Gets a message endpoint by name\&. "
.ti -1c
.RI "void \fBfree_message_endpoint\fP (\fBstring\fP \fBname\fP)"
.br
.RI "Deletes a message endpoint by name, all messages will be lost\&. "
.ti -1c
.RI "void \fBfree_message_endpoint\fP (\fBipc_message_endpoint_t\fP *endpoint)"
.br
.RI "Deletes a message endpoint, all messages will be lost\&. "
.ti -1c
.RI "void \fBsend_message\fP (\fBstring\fP \fBname\fP, void *message, size_t \fBsize\fP)"
.br
.RI "Finds the endpoint by name and adds a message to it's queue\&. "
.ti -1c
.RI "void \fBsend_message\fP (\fBipc_message_endpoint_t\fP *endpoint, void *message, size_t \fBsize\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles Inter \fBProcess\fP Communication\&. 
.PP
Definition at line 53 of file ipc\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IPC::IPC ()"

.PP
Creates a new \fBIPC\fP handler\&. 
.PP
Definition at line 16 of file ipc\&.cpp\&.
.PP
.nf
16          {
17 
18   // Clear the spinlock
19   m_lock = Spinlock();
20 
21 }
.fi
.SS "IPC::~IPC ()"

.PP
Definition at line 24 of file ipc\&.cpp\&.
.PP
.nf
24           {
25 
26   // Free all the shared memory
27   for(auto block : m_shared_memory_blocks){
28         delete block -> name;
29         delete block;
30   }
31 
32 
33 }
.fi
.PP
References name\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBipc_shared_memory_t\fP * IPC::alloc_shared_memory (size_t size, \fBstring\fP name)"

.PP
Creates a new shared memory block\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size of the block 
.br
\fIname\fP The name of the block 
.RE
.PP
\fBReturns\fP
.RS 4
The shared memory block 
.RE
.PP

.PP
Definition at line 41 of file ipc\&.cpp\&.
.PP
.nf
41                                                                       {
42 
43   // Wait for the lock
44   m_lock\&.lock();
45 
46   // Make sure the name is unique
47   for(auto endpoint : m_message_endpoints){
48     if(endpoint -> name -> equals(name)){
49       m_lock\&.unlock();
50       return nullptr;
51     }
52   }
53 
54   // Create the shared memory block
55   ipc_shared_memory_t* block = new ipc_shared_memory_t;
56   block -> physical_address  = (uintptr_t)PhysicalMemoryManager::s_current_manager -> allocate_area(0, size);
57   block -> size              = size;
58   block -> use_count         = 1;
59   block -> owner_pid         = Scheduler::get_current_process()->get_pid();
60   block -> name              = new String(name);
61 
62   // Add the block to the list
63   m_shared_memory_blocks\&.push_back(block);
64 
65   // Clear the lock
66   m_lock\&.unlock();
67 
68   _kprintf("Created shared memory block %s at 0x%x\n", name\&.c_str(), block -> physical_address);
69 
70   // Return the block
71   return block;
72 }
.fi
.PP
References _kprintf, MaxOS::drivers::peripherals::equals, MaxOS::processes::Scheduler::get_current_process(), MaxOS::processes::Process::get_pid(), name, physical_address, and size\&.
.SS "\fBipc_message_endpoint_t\fP * IPC::create_message_endpoint (\fBstring\fP name)"

.PP
Creates a endpoint for message passing\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the endpoint 
.RE
.PP
\fBReturns\fP
.RS 4
The endpoint 
.RE
.PP

.PP
Definition at line 175 of file ipc\&.cpp\&.
.PP
.nf
175                                                                 {
176 
177   // Wait for the lock
178   m_lock\&.lock();
179 
180   // Make sure the name is unique
181   ipc_message_endpoint_t* existing = get_message_endpoint(name);
182   if(existing != nullptr){
183       m_lock\&.unlock();
184       return nullptr;
185   }
186 
187   // Create the endpoint (With the queue on in the user's memory space)
188   ipc_message_endpoint_t* endpoint = new ipc_message_endpoint_t;
189   endpoint -> queue = (ipc_message_queue_t*)MemoryManager::malloc(sizeof(ipc_message_queue_t));
190   endpoint -> queue -> messages = nullptr;
191   endpoint -> owner_pid = Scheduler::get_current_process() -> get_pid();
192   endpoint -> name = new String(name);
193 
194   // Add the endpoint to the list
195   m_message_endpoints\&.push_back(endpoint);
196 
197   // Free the lock
198   m_lock\&.unlock();
199 
200   // Return the endpoint
201   return endpoint;
202 }
.fi
.PP
References MaxOS::processes::Scheduler::get_current_process(), and name\&.
.SS "void IPC::free_message_endpoint (\fBipc_message_endpoint_t\fP * endpoint)"

.PP
Deletes a message endpoint, all messages will be lost\&. 
.PP
\fBParameters\fP
.RS 4
\fIendpoint\fP 
.RE
.PP

.PP
Definition at line 241 of file ipc\&.cpp\&.
.PP
.nf
241                                                                 {
242 
243   // Make sure the endpoint exists
244   if(endpoint == nullptr)
245      return;
246 
247   // Make sure the endpoint is owned by the current process
248   if(endpoint -> owner_pid != Scheduler::get_current_process() -> get_pid())
249       return;
250 
251   // Wait for the lock
252   endpoint -> message_lock\&.lock();
253 
254   // Delete the messages
255   ipc_message_t* message = endpoint -> queue -> messages;
256   while(message != nullptr){
257       ipc_message_t* next = (ipc_message_t*)message -> next_message;
258       delete message;
259       message = next;
260   }
261   delete endpoint -> name;
262 
263   // Free the lock (nothing can be done to it now that the name isn't there)
264   endpoint -> message_lock\&.unlock();
265 
266   // Delete the endpoint
267   delete endpoint;
268 
269 }
.fi
.PP
References MaxOS::processes::Scheduler::get_current_process(), name, and next\&.
.SS "void IPC::free_message_endpoint (\fBstring\fP name)"

.PP
Deletes a message endpoint by name, all messages will be lost\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the endpoint 
.RE
.PP

.PP
Definition at line 227 of file ipc\&.cpp\&.
.PP
.nf
227                                            {
228 
229   // Find the endpoint
230   ipc_message_endpoint_t* endpoint = get_message_endpoint(name);
231 
232   // Free the endpoint
233   free_message_endpoint(endpoint);
234 
235 }
.fi
.PP
References name\&.
.SS "void IPC::free_shared_memory (\fBipc_shared_memory_t\fP * block)"

.PP
Deletes a shared memory block\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block to delete (will only free memory if no one is using it) 
.RE
.PP

.PP
Definition at line 143 of file ipc\&.cpp\&.
.PP
.nf
143                                                        {
144 
145   // Wait for the lock
146   m_lock\&.lock();
147 
148   // Decrement the use count
149   block->use_count--;
150 
151   // If the block is still in use
152   if (block->use_count > 0) {
153     m_lock\&.unlock();
154     return;
155   }
156 
157   _kprintf("Deleting shared memory block %s at 0x%x\n", block->name->c_str(), block->physical_address);
158 
159   // Free the block
160   PhysicalMemoryManager::s_current_manager->free_area(block->physical_address, block->size);
161   delete block->name;
162   delete block;
163 
164   // Clear the lock
165   m_lock\&.unlock();
166 
167 }
.fi
.PP
References _kprintf, MaxOS::String::c_str(), MaxOS::processes::IPCSharedMemory::name, MaxOS::processes::IPCSharedMemory::physical_address, MaxOS::processes::IPCSharedMemory::size, and MaxOS::processes::IPCSharedMemory::use_count\&.
.SS "void IPC::free_shared_memory (\fBstring\fP name)"

.PP
Deletes a shared memory block by name\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the block 
.RE
.PP

.PP
Definition at line 122 of file ipc\&.cpp\&.
.PP
.nf
122                                         {
123 
124 
125   // Find the block
126   for (auto block : m_shared_memory_blocks) {
127 
128     // Check if the block is the one we are looking for
129     if (!block->name->equals(name))
130       continue;
131 
132     free_shared_memory(block);
133 
134   }
135 
136 
137 }
.fi
.PP
References name\&.
.SS "void IPC::free_shared_memory (uintptr_t physical_address)"

.PP
Deletes a shared memory block by physical address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address of the block 
.RE
.PP

.PP
Definition at line 105 of file ipc\&.cpp\&.
.PP
.nf
105                                                        {
106 
107     // Find the block
108     for(auto block : m_shared_memory_blocks){
109 
110         if(block -> physical_address == physical_address){
111             free_shared_memory(block);
112             return;
113         }
114 
115     }
116 }
.fi
.PP
References physical_address\&.
.SS "\fBipc_message_endpoint_t\fP * IPC::get_message_endpoint (\fBstring\fP name)"

.PP
Gets a message endpoint by name\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the endpoint 
.RE
.PP
\fBReturns\fP
.RS 4
The endpoint or nullptr if not found 
.RE
.PP

.PP
Definition at line 210 of file ipc\&.cpp\&.
.PP
.nf
210                                                              {
211 
212   // Try to find the endpoint
213   for(auto endpoint : m_message_endpoints){
214       if(endpoint -> name -> equals(name))
215         return endpoint;
216   }
217 
218   // Not found
219   return nullptr;
220 
221 }
.fi
.PP
References MaxOS::drivers::peripherals::equals, and name\&.
.SS "\fBipc_shared_memory_t\fP * IPC::get_shared_memory (\fBstring\fP name)"

.PP
Gets a shared memory block by name\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the block 
.RE
.PP
\fBReturns\fP
.RS 4
The shared memory block or nullptr if not found 
.RE
.PP

.PP
Definition at line 79 of file ipc\&.cpp\&.
.PP
.nf
79                                                        {
80 
81   // Wait for the lock
82   m_lock\&.lock();
83 
84   // Find the block
85   for(auto block : m_shared_memory_blocks){
86       if(block -> name -> equals(name)){
87         block -> use_count++;
88         m_lock\&.unlock();
89         return block;
90       }
91   }
92 
93   // Clear the lock
94   m_lock\&.unlock();
95 
96   // Not found
97   return nullptr;
98 
99 }
.fi
.PP
References MaxOS::drivers::peripherals::equals, and name\&.
.SS "void IPC::send_message (\fBipc_message_endpoint_t\fP * endpoint, void * message, size_t size)"

.PP
Definition at line 291 of file ipc\&.cpp\&.
.PP
.nf
291                                                                                    {
292 
293   // Wait for the endpoint lock
294   endpoint -> message_lock\&.lock();
295 
296   // Copy the buffer into the kernel so that the endpoint can access it
297   void* kernel_copy = new char[size];
298   memcpy(kernel_copy, message, size);
299 
300   //Switch to endpoint's memory space
301   MemoryManager::switch_active_memory_manager(Scheduler::get_process(endpoint -> owner_pid) -> memory_manager);
302 
303   // Create the message & copy it into the endpoint's memory space
304   ipc_message_t* new_message = (ipc_message_t*)MemoryManager::malloc(sizeof(ipc_message_t));
305   void* new_buffer = MemoryManager::malloc(size);
306   new_message -> message_buffer = memcpy(new_buffer, kernel_copy, size);
307   new_message -> message_size = size;
308   new_message -> next_message = 0;
309 
310   // Add the message to the end of the queue
311   ipc_message_t* current = endpoint -> queue -> messages;
312   while(current != nullptr){
313     if(current -> next_message == 0){
314       current -> next_message = (uintptr_t)new_message;
315       break;
316     }
317     current = (ipc_message_t*)current -> next_message;
318   }
319 
320   // If it was the first message
321   if (current == nullptr)
322     endpoint->queue->messages = new_message;
323 
324   //Switch back from endpoint's memory space
325   MemoryManager::switch_active_memory_manager(Scheduler::get_current_process() -> memory_manager);
326 
327   // Free the lock & kernel copy
328   delete kernel_copy;
329   endpoint -> message_lock\&.unlock();
330 
331 }
.fi
.PP
References MaxOS::processes::Scheduler::get_current_process(), MaxOS::processes::Scheduler::get_process(), memcpy(), MaxOS::processes::IPCMessageQueue::messages, MaxOS::processes::IPCMessageEndpoint::queue, and size\&.
.SS "void IPC::send_message (\fBstring\fP name, void * message, size_t size)"

.PP
Finds the endpoint by name and adds a message to it's queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the endpoint 
.br
\fImessage\fP The message to send 
.br
\fIsize\fP The size of the message 
.RE
.PP

.PP
Definition at line 277 of file ipc\&.cpp\&.
.PP
.nf
277                                                               {
278 
279 
280   // Find the endpoint
281   ipc_message_endpoint_t* endpoint = get_message_endpoint(name);
282   if(endpoint == nullptr)
283       return;
284 
285 
286   // Send the message
287   send_message(endpoint, message, size);
288 
289 
290 }
.fi
.PP
References name, and size\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

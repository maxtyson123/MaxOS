.TH "MaxOS::String" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::String \- Dynamically sized string with various operations\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <string\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBString\fP ()"
.br
.RI "Construct a \fBString\fP, 0 length and only contains the null terminator\&. "
.ti -1c
.RI "\fBString\fP (char c)"
.br
.RI "Constructs a \fBString\fP from a single character\&. "
.ti -1c
.RI "\fBString\fP (char const *\fBstring\fP)"
.br
.RI "Constructs a \fBString\fP from a pointer to an array of chars\&. "
.ti -1c
.RI "\fBString\fP (uint8_t const *\fBstring\fP, int \fBlength\fP)"
.br
.RI "Constructs a string from a an array of bytes (doesnt have to be null terminated) "
.ti -1c
.RI "\fBString\fP (\fBString\fP const &other)"
.br
.RI "Copy constructor for the string\&. "
.ti -1c
.RI "\fBString\fP (int value)"
.br
.RI "Constructs a string from an integer (must be base 10) "
.ti -1c
.RI "\fBString\fP (uint64_t value)"
.br
.RI "Constructs a string from a hex value (Excludes 0x) "
.ti -1c
.RI "\fBString\fP (float value)"
.br
.RI "Constructs a \fBString\fP from a float\&. "
.ti -1c
.RI "\fBString\fP (bool value)"
.br
.RI "Constructs a \fBString\fP from a boolean as 'true' or 'false'\&. "
.ti -1c
.RI "void \fBcopy\fP (\fBString\fP const &other)"
.br
.RI "Copies the other string\&. "
.ti -1c
.RI "int \fBlength\fP (bool count_ansi=true) const"
.br
.RI "Returns the length of the string\&. "
.ti -1c
.RI "char * \fBc_str\fP ()"
.br
.RI "The char pointer representation of the current string\&. "
.ti -1c
.RI "const char * \fBc_str\fP () const"
.br
.RI "Returns the string as a c string\&. "
.ti -1c
.RI "bool \fBstarts_with\fP (\fBString\fP const &other)"
.br
.RI "Checks if the string starts with the other string (must contain the same characters in the same order) "
.ti -1c
.RI "\fBString\fP \fBsubstring\fP (int start, int \fBlength\fP) const"
.br
.RI "Get a section of the string\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBString\fP > \fBsplit\fP (\fBString\fP const &delimiter) const"
.br
.RI "Splits the string by the delimiter\&. "
.ti -1c
.RI "\fBString\fP \fBstrip\fP (char strip_char=' ') const"
.br
.RI "Strips the string of whitespace\&. "
.ti -1c
.RI "\fBString\fP \fBcenter\fP (int width, char fill=' ') const"
.br
.RI "Centers the string in a specified width\&. "
.ti -1c
.RI "bool \fBequals\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is equal to another\&. "
.ti -1c
.RI "\fBString\fP & \fBoperator=\fP (\fBString\fP const &other)"
.br
.RI "Sets the string to the other string\&. "
.ti -1c
.RI "\fBString\fP \fBoperator+\fP (\fBString\fP const &other) const"
.br
.RI "Adds the other string to the string\&. "
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (\fBString\fP const &other)"
.br
.RI "Adds the other string to the string\&. "
.ti -1c
.RI "\fBString\fP \fBoperator*\fP (int times) const"
.br
.RI "Returns the string repeated a number of times\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is equal to another\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is not equal to another\&. "
.ti -1c
.RI "bool \fBoperator<\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is less than the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator>\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is greater than the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is less than or equal to the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is greater than or equal to the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "char & \fBoperator[]\fP (int index)"
.br
.RI "Returns the character at the specified index\&. "
.ti -1c
.RI "char & \fBoperator[]\fP (int index) const"
.br
.RI "Returns the character at the specified index\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBString\fP \fBformatted\fP (char const *format,\&.\&.\&.)"
.br
.RI "Creates a formated string\&. s = string, x = hex, d = decimal\&. "
.ti -1c
.RI "static \fBString\fP \fBformatted\fP (char const *format, va_list parameters)"
.br
.RI "Creates a formated string\&. s = string, x = hex, d = decimal\&. "
.in -1c
.SH "Detailed Description"
.PP 
Dynamically sized string with various operations\&. 
.PP
Definition at line \fB26\fP of file \fBstring\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "String::String ()"

.PP
Construct a \fBString\fP, 0 length and only contains the null terminator\&. 
.PP
Definition at line \fB16\fP of file \fBstring\&.cpp\fP\&..PP
.nf
16                {
17 
18     // String that only contains the null terminator
19     allocate_self();
20     m_string[0] = '\\0';
21     m_length = 0;
22 
23 }
.fi

.SS "String::String (char c)\fC [explicit]\fP"

.PP
Constructs a \fBString\fP from a single character\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP The character 
.RE
.PP

.PP
Definition at line \fB29\fP of file \fBstring\&.cpp\fP\&..PP
.nf
29                      {
30 
31     // Create the memory
32     m_length = 1;
33     allocate_self();
34 
35     // Store the char
36     m_string[0] = c;
37     m_string[m_length] = '\\0';
38 
39 
40 }
.fi

.SS "String::String (char const * string)"

.PP
Constructs a \fBString\fP from a pointer to an array of chars\&. 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP An array of chars, must be null terminated and of length less than 10,000 
.RE
.PP

.PP
Definition at line \fB46\fP of file \fBstring\&.cpp\fP\&..PP
.nf
46                                  {
47 
48     // Get the length of the string, prevent longer than 10000 because this should mean something's gone wrong
49     m_length = 0;
50     while (string[m_length] != '\\0' && m_length <= 10000)
51         m_length++;
52     allocate_self();
53 
54     // Copy the string
55     for (int i = 0; i < m_length; i++)
56         m_string[i] = string[i];
57 
58     // If the length is more than 10,000 Replace the end with a warning incase future use actually requires that
59     const char *warning = "MAXOS: String length exceeded 10000 \- might be a bug";
60     if (m_length > 10000)
61         for (int i = 0; i < 52; i++)
62             m_string[m_length \- 52 + i] = warning[i];
63 
64     m_string[m_length] = '\\0';
65 }
.fi

.SS "String::String (uint8_t const * string, int length)"

.PP
Constructs a string from a an array of bytes (doesnt have to be null terminated) 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP The string bytes 
.br
\fIlength\fP How large the string byte buffer is 
.RE
.PP

.PP
Definition at line \fB73\fP of file \fBstring\&.cpp\fP\&..PP
.nf
73                                                 {
74     // Allocate memory for the string (and null terminator)
75     m_length = length;
76     allocate_self();
77 
78     // Copy the string
79     for (int i = 0; i < length; i++)
80         m_string[i] = string[i];
81 
82     // Write the null terminator
83     m_string[length] = '\\0';
84 }
.fi

.PP
References \fBlength\fP\&.
.SS "String::String (\fBString\fP const & other)"

.PP
Copy constructor for the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP \fBString\fP to copy from 
.RE
.PP

.PP
Definition at line \fB165\fP of file \fBstring\&.cpp\fP\&..PP
.nf
165                                   {
166     copy(other);
167 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "String::String (int value)\fC [explicit]\fP"

.PP
Constructs a string from an integer (must be base 10) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The integer value 
.RE
.PP

.PP
Definition at line \fB91\fP of file \fBstring\&.cpp\fP\&..PP
.nf
91                         {
92 
93     // Convert to a string
94     const char *str = itoa(10, value);
95     m_length = strlen(str);
96 
97     // Create space to store
98     allocate_self();
99 
100     // Store the string
101     for (int i = 0; i < m_length; i++)
102         m_string[i] = str[i];
103     m_string[m_length] = '\\0';
104 
105 }
.fi

.PP
References \fBitoa()\fP, and \fBstrlen()\fP\&.
.SS "String::String (uint64_t value)\fC [explicit]\fP"

.PP
Constructs a string from a hex value (Excludes 0x) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The hex value 
.RE
.PP

.PP
Definition at line \fB112\fP of file \fBstring\&.cpp\fP\&..PP
.nf
112                              {
113 
114     // Convert to a string
115     const char *str = htoa(value);
116     m_length = strlen(str);
117 
118     // Create space to store
119     allocate_self();
120 
121     // Store the string
122     for (int i = 0; i < m_length; i++)
123         m_string[i] = str[i];
124     m_string[m_length] = '\\0';
125 }
.fi

.PP
References \fBhtoa()\fP, and \fBstrlen()\fP\&.
.SS "String::String (float value)\fC [explicit]\fP"

.PP
Constructs a \fBString\fP from a float\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The float value 
.RE
.PP

.PP
Definition at line \fB131\fP of file \fBstring\&.cpp\fP\&..PP
.nf
131                           {
132 
133     // Convert to a string
134     const char *str = ftoa(value);
135     m_length = strlen(str);
136 
137     // Create space to store
138     allocate_self();
139 
140     // Store the string
141     for (int i = 0; i < m_length; i++)
142         m_string[i] = str[i];
143     m_string[m_length] = '\\0';
144 
145 }
.fi

.PP
References \fBftoa()\fP, and \fBstrlen()\fP\&.
.SS "String::String (bool value)\fC [explicit]\fP"

.PP
Constructs a \fBString\fP from a boolean as 'true' or 'false'\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The bool value 
.RE
.PP

.PP
Definition at line \fB151\fP of file \fBstring\&.cpp\fP\&..PP
.nf
151                          {
152 
153     if(value)
154         *this = string("true");
155     else
156         *this = string("false");
157 
158 }
.fi

.SS "String::~String ()"

.PP
Definition at line \fB170\fP of file \fBstring\&.cpp\fP\&..PP
.nf
170                 {
171 
172     // Free the memory
173     if (!m_using_small)
174         delete[] m_string;
175 
176 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "char * String::c_str ()"

.PP
The char pointer representation of the current string\&. 
.PP
\fBReturns\fP
.RS 4
The char* string 
.RE
.PP

.PP
Definition at line \fB251\fP of file \fBstring\&.cpp\fP\&..PP
.nf
251                     {
252 
253     return m_string;
254 }
.fi

.PP
Referenced by \fBstrcmp()\fP, \fBstrcmp()\fP, \fBstrcmp()\fP, \fBstrncmp()\fP, \fBstrncmp()\fP, and \fBstrncmp()\fP\&.
.SS "const char * String::c_str () const"

.PP
Returns the string as a c string\&. 
.PP
\fBReturns\fP
.RS 4
The string as an array of characters 
.RE
.PP

.PP
Definition at line \fB261\fP of file \fBstring\&.cpp\fP\&..PP
.nf
261                                 {
262 
263     return m_string;
264 }
.fi

.SS "\fBString\fP String::center (int width, char fill = \fC' '\fP) const"

.PP
Centers the string in a specified width\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP The width of the string 
.br
\fIfill\fP The character to fill the string with 
.RE
.PP
\fBReturns\fP
.RS 4
The centered string 
.RE
.PP

.PP
Definition at line \fB580\fP of file \fBstring\&.cpp\fP\&..PP
.nf
580                                                 {
581 
582     // The number of characters to add
583     int add = (width \- m_length) / 2;
584 
585     // The centered string
586     String centered;
587     centered\&.m_length = width;
588     centered\&.allocate_self();
589 
590     // Fill the right side (before)
591     for (int i = 0; i < add; i++)
592         centered\&.m_string[i] = fill;
593 
594     // Copy the string (middle)
595     for (int i = 0; i < m_length; i++)
596         centered\&.m_string[add + i] = m_string[i];
597 
598     // Fill the left side (after)
599     for (int i = add + m_length; i < width; i++)
600         centered\&.m_string[i] = fill;
601 
602     // Write the null terminator
603     centered\&.m_string[width] = '\\0';
604 
605     return centered;
606 }
.fi

.SS "void String::copy (\fBString\fP const & other)"

.PP
Copies the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP

.PP
Definition at line \fB183\fP of file \fBstring\&.cpp\fP\&..PP
.nf
183                                      {
184 
185     // Allocate memory for the string (and null terminator)
186     m_length = other\&.length();
187     allocate_self();
188 
189     // Copy the string
190     for (int i = 0; i < m_length; i++)
191         m_string[i] = other[i];
192 
193     // Write the null terminator
194     m_string[m_length] = '\\0';
195 
196 }
.fi

.PP
References \fBlength()\fP\&.
.PP
Referenced by \fBoperator+=()\fP, \fBoperator=()\fP, \fBString()\fP, and \fBstrip()\fP\&.
.SS "bool String::equals (\fBString\fP const & other) const"

.PP
Checks if one string is equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB392\fP of file \fBstring\&.cpp\fP\&..PP
.nf
392                                              {
393 
394     // Check if the lengths are equal
395     if (m_length != other\&.length())
396         return false;
397 
398     // Check if the characters are equal
399     for (int i = 0; i < m_length; i++)
400         if (m_string[i] != other[i])
401             return false;
402 
403     // The strings are equal
404     return true;
405 
406 }
.fi

.PP
References \fBlength()\fP\&.
.PP
Referenced by \fBoperator!=()\fP, and \fBoperator==()\fP\&.
.SS "\fBString\fP String::formatted (char const * format, va_list parameters)\fC [static]\fP"

.PP
Creates a formated string\&. s = string, x = hex, d = decimal\&. 
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The string containing the format 
.br
\fIparameters\fP The arguments to format into the string
.RE
.PP
\fBReturns\fP
.RS 4
The string with the arguments formated inside 
.RE
.PP

.PP
Definition at line \fB659\fP of file \fBstring\&.cpp\fP\&..PP
.nf
659                                                                {
660 
661     String out;
662 
663     // Loop through the format string
664     for (; *format != '\\0'; format++) {
665 
666         // If it is not a %, print the character
667         if (*format != '%') {
668             out += (string)(char)(*format);
669             continue;
670         }
671 
672         // Move to the next character
673         format++;
674         switch (*format) {
675             case 'd': {
676                 // Print a decimal
677                 int number = va_arg (parameters, int);
678                 out += (string)(number);
679                 break;
680             }
681             case 'x': {
682                 // Print a hex
683                 uint64_t number = va_arg (parameters, uint64_t);
684                 out += (string)(number);
685                 break;
686             }
687             case 's': {
688                 // Print a string
689                 char *str = va_arg (parameters, char*);
690                 out += (string)(str);
691                 break;
692             }
693         }
694     }
695 
696     return out;
697 
698 }
.fi

.SS "\fBString\fP String::formatted (char const * format,  \&.\&.\&.)\fC [static]\fP"

.PP
Creates a formated string\&. s = string, x = hex, d = decimal\&. 
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The string containing the format 
.br
\fI\&.\&.\&.\fP The arguments to format into the string
.RE
.PP
\fBReturns\fP
.RS 4
The string with the arguments formated inside 
.RE
.PP

.PP
Definition at line \fB641\fP of file \fBstring\&.cpp\fP\&..PP
.nf
641                                                 {
642 
643     // Create a pointer to the data
644     va_list parameters;
645     va_start(parameters, format);
646 
647     return formatted(format, parameters);
648 
649 }
.fi

.PP
References \fBformatted()\fP\&.
.PP
Referenced by \fBLogger::ASSERT()\fP, \fBformatted()\fP, and \fBLogger::printf()\fP\&.
.SS "int String::length (bool count_ansi = \fCtrue\fP) const"

.PP
Returns the length of the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIcount_ansi\fP Whether to count the ansi characters (default true) 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line \fB361\fP of file \fBstring\&.cpp\fP\&..PP
.nf
361                                         {
362 
363     // If ansi characters are not to be counted
364     if (count_ansi)
365         return m_length;
366 
367     // Calculate the length of the string without ansi characters
368     int total_length = 0;
369     int clean_length = 0;
370     while (m_string[total_length] != '\\0') {
371 
372         // If the character is an ansi character, skip it
373         if (m_string[total_length] == '\\033')
374             while (m_string[total_length] != 'm')
375                 total_length++;
376 
377         // Increment the length
378         clean_length++;
379         total_length++;
380     }
381 
382     // Return the length
383     return clean_length;
384 }
.fi

.PP
Referenced by \fBcopy()\fP, \fBequals()\fP, \fBoperator+()\fP, \fBsplit()\fP, and \fBstarts_with()\fP\&.
.SS "bool String::operator!= (\fBString\fP const & other) const"

.PP
Checks if one string is not equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are not equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB426\fP of file \fBstring\&.cpp\fP\&..PP
.nf
426                                                    {
427 
428     // Self assignment check
429     if (*this == other)
430         return false;
431 
432     return !equals(other);
433 }
.fi

.PP
References \fBequals()\fP\&.
.SS "\fBString\fP String::operator* (int times) const"

.PP
Returns the string repeated a number of times\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP The number of times to repeat the string 
.RE
.PP
\fBReturns\fP
.RS 4
The string repeated a number of times 
.RE
.PP

.PP
Definition at line \fB553\fP of file \fBstring\&.cpp\fP\&..PP
.nf
553                                         {
554 
555     // The repeated string
556     String repeated;
557     repeated\&.m_length = m_length * times;
558     repeated\&.allocate_self();
559 
560     // Copy the string
561     for (int i = 0; i < times; i++)
562         for (int j = 0; j < m_length; j++)
563             repeated\&.m_string[i * m_length + j] = m_string[j];
564 
565     // Write the null terminator
566     repeated\&.m_string[repeated\&.m_length] = '\\0';
567 
568     // Return the repeated string
569     return repeated;
570 
571 }
.fi

.SS "\fBString\fP String::operator+ (\fBString\fP const & other) const"

.PP
Adds the other string to the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
The concatenated string 
.RE
.PP

.PP
Definition at line \fB489\fP of file \fBstring\&.cpp\fP\&..PP
.nf
489                                                     {
490 
491     // The concatenated string
492     String concatenated;
493     concatenated\&.m_length = m_length + other\&.length();
494     concatenated\&.allocate_self();
495 
496     // Copy the first string
497     for (int i = 0; i < m_length; i++)
498         concatenated\&.m_string[i] = m_string[i];
499 
500     // Copy the second string
501     for (int i = 0; i < other\&.length(); i++)
502         concatenated\&.m_string[m_length + i] = other[i];
503 
504     // Write the null terminator
505     concatenated\&.m_string[concatenated\&.m_length] = '\\0';
506 
507     // Return the concatenated string
508     return concatenated;
509 }
.fi

.PP
References \fBlength()\fP\&.
.SS "\fBString\fP & String::operator+= (\fBString\fP const & other)"

.PP
Adds the other string to the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
The concatenated string 
.RE
.PP

.PP
Definition at line \fB517\fP of file \fBstring\&.cpp\fP\&..PP
.nf
517                                               {
518 
519     // Add the other string to this string
520     String concatenated = *this + other;
521     copy(concatenated);
522     return *this;
523 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "bool String::operator< (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is less than the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is less than the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB441\fP of file \fBstring\&.cpp\fP\&..PP
.nf
441                                                   {
442 
443     return lex_value(*this) < lex_value(other);
444 
445 }
.fi

.SS "bool String::operator<= (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is less than or equal to the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is less than or equal to the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB465\fP of file \fBstring\&.cpp\fP\&..PP
.nf
465                                                    {
466 
467     return lex_value(*this) <= lex_value(other);
468 
469 }
.fi

.SS "\fBString\fP & String::operator= (\fBString\fP const & other)"

.PP
Sets the string to the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The string for this one to be updated to 
.RE
.PP
\fBReturns\fP
.RS 4
\fBString\fP The string 
.RE
.PP

.PP
Definition at line \fB235\fP of file \fBstring\&.cpp\fP\&..PP
.nf
235                                              {
236 
237     // Self assignment check
238     if (this == &other)
239         return *this;
240 
241     // Copy the other string
242     copy(other);
243     return *this;
244 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "bool String::operator== (\fBString\fP const & other) const"

.PP
Checks if one string is equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB414\fP of file \fBstring\&.cpp\fP\&..PP
.nf
414                                                    {
415 
416     // Check if the strings are equal
417     return equals(other);
418 }
.fi

.PP
References \fBequals()\fP\&.
.SS "bool String::operator> (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is greater than the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is greater than the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB453\fP of file \fBstring\&.cpp\fP\&..PP
.nf
453                                                   {
454 
455     return lex_value(*this) > lex_value(other);
456 
457 }
.fi

.SS "bool String::operator>= (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is greater than or equal to the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is greater than or equal to the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB477\fP of file \fBstring\&.cpp\fP\&..PP
.nf
477                                                    {
478 
479     return lex_value(*this) >= lex_value(other);
480 
481 }
.fi

.SS "char & String::operator[] (int index)"

.PP
Returns the character at the specified index\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the character 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified index 
.RE
.PP

.PP
Definition at line \fB532\fP of file \fBstring\&.cpp\fP\&..PP
.nf
532                                   {
533     return m_string[index];
534 }
.fi

.SS "char & String::operator[] (int index) const"

.PP
Returns the character at the specified index\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the character 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified index 
.RE
.PP

.PP
Definition at line \fB543\fP of file \fBstring\&.cpp\fP\&..PP
.nf
543                                         {
544     return m_string[index];
545 }
.fi

.SS "\fBcommon::Vector\fP< \fBString\fP > String::split (\fBString\fP const & delimiter) const"

.PP
Splits the string by the delimiter\&. 
.PP
\fBParameters\fP
.RS 4
\fIdelimiter\fP What to split the string by 
.RE
.PP
\fBReturns\fP
.RS 4
A vector of strings that were split by the delimiter 
.RE
.PP

.PP
Definition at line \fB325\fP of file \fBstring\&.cpp\fP\&..PP
.nf
325                                                                 {
326     common::Vector<String> strings;
327 
328     // Go through the string and split it by the delimiter
329     int start = 0;
330     for (int i = 0; i <= m_length \- delimiter\&.length(); i++) {
331 
332         // Check if matches at this position
333         bool matches = true;
334         for (int j = 0; j < delimiter\&.length(); j++)
335             if (m_string[i + j] != delimiter[j]) {
336                 matches = false;
337                 break;
338             }
339 
340         if(!matches)
341             continue;
342 
343         // Add the splice of the string
344         strings\&.push_back(substring(start, i \- start));
345         start = i + delimiter\&.length();
346         i += delimiter\&.length() \- 1;
347     }
348 
349     // Add the last string to the vector
350     strings\&.push_back(substring(start, m_length \- start));
351 
352     return strings;
353 }
.fi

.PP
References \fBlength()\fP, and \fBsubstring()\fP\&.
.SS "bool String::starts_with (\fBString\fP const & other)"

.PP
Checks if the string starts with the other string (must contain the same characters in the same order) 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string starts with the other string, false otherwise 
.RE
.PP

.PP
Definition at line \fB272\fP of file \fBstring\&.cpp\fP\&..PP
.nf
272                                             {
273 
274     // Must at least be able to fit the other string
275     if (m_length < other\&.length())
276         return false;
277 
278     // Check if the string starts with the other string
279     for (int i = 0; i < other\&.length(); i++)
280         if (m_string[i] != other[i])
281             return false;
282 
283     // No string left over to check so it must contain other
284     return true;
285 }
.fi

.PP
References \fBlength()\fP\&.
.SS "\fBString\fP String::strip (char strip_char = \fC' '\fP) const"

.PP
Strips the string of whitespace\&. 
.PP
\fBParameters\fP
.RS 4
\fIstrip_char\fP The character to strip (default = ' ') 
.RE
.PP
\fBReturns\fP
.RS 4
The stripped string (new string) 
.RE
.PP

.PP
Definition at line \fB614\fP of file \fBstring\&.cpp\fP\&..PP
.nf
614                                           {
615 
616     // The stripped string
617     String stripped;
618     stripped\&.copy(*this);
619 
620     // Search from the back for the earliest non\-whitespace character
621     int end = m_length \- 1;
622     while (end >= 0 && (m_string[end] == strip_char || m_string[end] == '\\n' || m_string[end] == '\\t'))
623         end\-\-;
624 
625     // Make sure there is something to strip
626     if (end < 0)
627         return stripped;
628 
629     // Split the string to remove the end
630     return stripped\&.substring(0, end + 1);
631 }
.fi

.PP
References \fBcopy()\fP, and \fBsubstring()\fP\&.
.SS "\fBString\fP String::substring (int start, int length) const"

.PP
Get a section of the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP The start of the substring 
.br
\fIlength\fP The length of the substring 
.RE
.PP
\fBReturns\fP
.RS 4
The substring or empty string if out of bounds 
.RE
.PP

.PP
Definition at line \fB294\fP of file \fBstring\&.cpp\fP\&..PP
.nf
294                                                     {
295 
296     // Ensure the start is within bounds
297     if (start < 0 || start >= m_length)
298         return {};
299 
300     // Ensure the length is within bounds
301     if (length < 0 || start + length > m_length)
302         return {};
303 
304     // Allocate memory for the substring (and null terminator)
305     String substring;
306     substring\&.m_length = length;
307     substring\&.allocate_self();
308 
309     // Copy the substring
310     for (int i = 0; i < length; i++)
311         substring\&.m_string[i] = m_string[start + i];
312 
313     // Write the null terminator
314     substring\&.m_string[length] = '\\0';
315 
316     return substring;
317 }
.fi

.PP
References \fBlength\fP, and \fBsubstring()\fP\&.
.PP
Referenced by \fBsplit()\fP, \fBstrip()\fP, and \fBsubstring()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

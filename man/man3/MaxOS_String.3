.TH "MaxOS::String" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::String \- Dynamically sized string with various operations\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <string\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBString\fP ()"
.br
.RI "Construct a \fBString\fP, 0 length and only contains the null terminator\&. "
.ti -1c
.RI "\fBString\fP (char c)"
.br
.RI "Constructs a \fBString\fP from a single character\&. "
.ti -1c
.RI "\fBString\fP (char const *\fBstring\fP)"
.br
.RI "Constructs a \fBString\fP from a pointer to an array of chars\&. "
.ti -1c
.RI "\fBString\fP (uint8_t const *\fBstring\fP, int \fBlength\fP)"
.br
.RI "Constructs a string from a an array of bytes (doesnt have to be null terminated) "
.ti -1c
.RI "\fBString\fP (\fBString\fP const &other)"
.br
.RI "Copy constructor for the string\&. "
.ti -1c
.RI "\fBString\fP (int value)"
.br
.RI "Constructs a string from an integer (must be base 10) "
.ti -1c
.RI "\fBString\fP (uint64_t value)"
.br
.RI "Constructs a string from a hex value (Excludes 0x) "
.ti -1c
.RI "\fBString\fP (bool value)"
.br
.RI "Constructs a \fBString\fP from a boolean as 'true' or 'false'\&. "
.ti -1c
.RI "\fB~String\fP ()"
.br
.RI "Destructor for the string, cleans up memory if needed\&. "
.ti -1c
.RI "void \fBcopy\fP (\fBString\fP const &other)"
.br
.RI "Copies the other string\&. "
.ti -1c
.RI "size_t \fBlength\fP (bool count_ansi=true) const"
.br
.RI "Returns the length of the string\&. "
.ti -1c
.RI "char * \fBc_str\fP ()"
.br
.RI "The char pointer representation of the current string\&. "
.ti -1c
.RI "const char * \fBc_str\fP () const"
.br
.RI "Returns the string as a c string\&. "
.ti -1c
.RI "bool \fBstarts_with\fP (\fBString\fP const &other)"
.br
.RI "Checks if the string starts with the other string (must contain the same characters in the same order) "
.ti -1c
.RI "\fBString\fP \fBsubstring\fP (size_t start, size_t \fBlength\fP) const"
.br
.RI "Get a section of the string\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBString\fP > \fBsplit\fP (\fBString\fP const &delimiter) const"
.br
.RI "Splits the string by the delimiter\&. "
.ti -1c
.RI "\fBString\fP \fBstrip\fP (char strip_char=' ') const"
.br
.RI "Strips the string of whitespace\&. "
.ti -1c
.RI "\fBString\fP \fBcenter\fP (size_t width, char fill=' ') const"
.br
.RI "Centers the string in a specified width\&. "
.ti -1c
.RI "bool \fBequals\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is equal to another\&. "
.ti -1c
.RI "\fBString\fP & \fBoperator=\fP (\fBString\fP const &other)"
.br
.RI "Sets the string to the other string\&. "
.ti -1c
.RI "\fBString\fP \fBoperator+\fP (\fBString\fP const &other) const"
.br
.RI "Adds the other string to the string\&. "
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (\fBString\fP const &other)"
.br
.RI "Adds the other string to the string\&. "
.ti -1c
.RI "\fBString\fP \fBoperator*\fP (int times) const"
.br
.RI "Returns the string repeated a number of times\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is equal to another\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if one string is not equal to another\&. "
.ti -1c
.RI "bool \fBoperator<\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is less than the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator>\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is greater than the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is less than or equal to the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (\fBString\fP const &other) const"
.br
.RI "Checks if the sum of the ascii values of the characters in the string is greater than or equal to the sum of the ascii values of the characters in the other string\&. "
.ti -1c
.RI "char & \fBoperator[]\fP (size_t index)"
.br
.RI "Returns the character at the specified index\&. "
.ti -1c
.RI "char & \fBoperator[]\fP (size_t index) const"
.br
.RI "Returns the character at the specified index\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBString\fP \fBformatted\fP (char const *format,\&.\&.\&.)"
.br
.RI "Creates a formated string\&. s = string, x = hex, d = decimal\&. "
.ti -1c
.RI "static \fBString\fP \fBformatted\fP (char const *format, va_list parameters)"
.br
.RI "Creates a formated string\&. s = string, x = hex, d = decimal\&. "
.in -1c
.SH "Detailed Description"
.PP 
Dynamically sized string with various operations\&. 
.PP
Definition at line \fB26\fP of file \fBstring\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "String::String ()"

.PP
Construct a \fBString\fP, 0 length and only contains the null terminator\&. 
.PP
Definition at line \fB16\fP of file \fBstring\&.cpp\fP\&..PP
.nf
16                {
17 
18     // String that only contains the null terminator
19     m_length = 0;
20     allocate_self();
21     m_string[0] = '\\0';
22 
23 
24 }
.fi

.SS "String::String (char c)"

.PP
Constructs a \fBString\fP from a single character\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP The character 
.RE
.PP

.PP
Definition at line \fB30\fP of file \fBstring\&.cpp\fP\&..PP
.nf
30                      {
31 
32     // Create the memory
33     m_length = 1;
34     allocate_self();
35 
36     // Store the char
37     m_string[0] = c;
38     m_string[m_length] = '\\0';
39 
40 
41 }
.fi

.SS "String::String (char const * string)"

.PP
Constructs a \fBString\fP from a pointer to an array of chars\&. 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP An array of chars, must be null terminated and of length less than 10,000 
.RE
.PP

.PP
Definition at line \fB47\fP of file \fBstring\&.cpp\fP\&..PP
.nf
47                                  {
48 
49     // Get the length of the string, prevent longer than 10000 because this should mean something's gone wrong
50     m_length = 0;
51     while (string[m_length] != '\\0' && m_length <= 10000)
52         m_length++;
53     allocate_self();
54 
55     // Copy the string
56     for (size_t i = 0; i < m_length; i++)
57         m_string[i] = string[i];
58 
59     // If the length is more than 10,000 Replace the end with a warning incase future use actually requires that
60     const char* warning = "MAXOS: String length exceeded 10000 \- might be a bug";
61     if (m_length > 10000)
62         for (int i = 0; i < 52; i++)
63             m_string[m_length \- 52 + i] = warning[i];
64 
65     m_string[m_length] = '\\0';
66 }
.fi

.SS "String::String (uint8_t const * string, int length)"

.PP
Constructs a string from a an array of bytes (doesnt have to be null terminated) 
.PP
\fBParameters\fP
.RS 4
\fIstring\fP The string bytes 
.br
\fIlength\fP How large the string byte buffer is 
.RE
.PP

.PP
Definition at line \fB74\fP of file \fBstring\&.cpp\fP\&..PP
.nf
74                                                 {
75     // Allocate memory for the string (and null terminator)
76     m_length = length;
77     allocate_self();
78 
79     // Copy the string
80     for (int i = 0; i < length; i++)
81         m_string[i] = string[i];
82 
83     // Write the null terminator
84     m_string[length] = '\\0';
85 }
.fi

.PP
References \fBlength()\fP\&.
.SS "String::String (\fBString\fP const & other)"

.PP
Copy constructor for the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP \fBString\fP to copy from 
.RE
.PP

.PP
Definition at line \fB146\fP of file \fBstring\&.cpp\fP\&..PP
.nf
146                                   {
147     copy(other);
148 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "String::String (int value)"

.PP
Constructs a string from an integer (must be base 10) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The integer value 
.RE
.PP

.PP
Definition at line \fB92\fP of file \fBstring\&.cpp\fP\&..PP
.nf
92                         {
93 
94     // Convert to a string
95     const char* str = itoa(10, value);
96     m_length = strlen(str);
97 
98     // Create space to store
99     allocate_self();
100 
101     // Store the string
102     for (size_t i = 0; i < m_length; i++)
103         m_string[i] = str[i];
104     m_string[m_length] = '\\0';
105 
106 }
.fi

.PP
References \fBitoa()\fP, and \fBstrlen()\fP\&.
.SS "String::String (uint64_t value)"

.PP
Constructs a string from a hex value (Excludes 0x) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The hex value 
.RE
.PP

.PP
Definition at line \fB113\fP of file \fBstring\&.cpp\fP\&..PP
.nf
113                              {
114 
115     // Convert to a string
116     const char* str = htoa(value);
117     m_length = strlen(str);
118 
119     // Create space to store
120     allocate_self();
121 
122     // Store the string
123     for (size_t i = 0; i < m_length; i++)
124         m_string[i] = str[i];
125     m_string[m_length] = '\\0';
126 }
.fi

.PP
References \fBhtoa()\fP, and \fBstrlen()\fP\&.
.SS "String::String (bool value)"

.PP
Constructs a \fBString\fP from a boolean as 'true' or 'false'\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The bool value 
.RE
.PP

.PP
Definition at line \fB132\fP of file \fBstring\&.cpp\fP\&..PP
.nf
132                          {
133 
134     if (value)
135         *this = string("true");
136     else
137         *this = string("false");
138 
139 }
.fi

.SS "String::~String ()"

.PP
Destructor for the string, cleans up memory if needed\&. 
.PP
Definition at line \fB153\fP of file \fBstring\&.cpp\fP\&..PP
.nf
153                 {
154 
155     // Free the memory
156     if (!m_using_small)
157         delete[] m_string;
158 
159 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "char * String::c_str ()"

.PP
The char pointer representation of the current string\&. 
.PP
\fBReturns\fP
.RS 4
The char* string 
.RE
.PP

.PP
Definition at line \fB234\fP of file \fBstring\&.cpp\fP\&..PP
.nf
234                     {
235 
236     return m_string;
237 }
.fi

.PP
Referenced by \fBstrcmp()\fP, \fBstrcmp()\fP, \fBstrcmp()\fP, \fBstrncmp()\fP, \fBstrncmp()\fP, and \fBstrncmp()\fP\&.
.SS "const char * String::c_str () const"

.PP
Returns the string as a c string\&. 
.PP
\fBReturns\fP
.RS 4
The string as an array of characters 
.RE
.PP

.PP
Definition at line \fB244\fP of file \fBstring\&.cpp\fP\&..PP
.nf
244                                 {
245 
246     return m_string;
247 }
.fi

.SS "\fBString\fP String::center (size_t width, char fill = \fC' '\fP) const"

.PP
Centers the string in a specified width\&. 
.PP
\fBParameters\fP
.RS 4
\fIwidth\fP The width of the string 
.br
\fIfill\fP The character to fill the string with 
.RE
.PP
\fBReturns\fP
.RS 4
The centered string 
.RE
.PP

.PP
Definition at line \fB563\fP of file \fBstring\&.cpp\fP\&..PP
.nf
563                                                    {
564 
565     // The number of characters to add
566     size_t add = (width \- m_length) / 2;
567 
568     // The centered string
569     String centered;
570     centered\&.m_length = width;
571     centered\&.allocate_self();
572 
573     // Fill the right side (before)
574     for (size_t i = 0; i < add; i++)
575         centered\&.m_string[i] = fill;
576 
577     // Copy the string (middle)
578     for (size_t i = 0; i < m_length; i++)
579         centered\&.m_string[add + i] = m_string[i];
580 
581     // Fill the left side (after)
582     for (size_t i = add + m_length; i < width; i++)
583         centered\&.m_string[i] = fill;
584 
585     // Write the null terminator
586     centered\&.m_string[width] = '\\0';
587 
588     return centered;
589 }
.fi

.SS "void String::copy (\fBString\fP const & other)"

.PP
Copies the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP

.PP
Definition at line \fB166\fP of file \fBstring\&.cpp\fP\&..PP
.nf
166                                      {
167 
168     // Allocate memory for the string (and null terminator)
169     m_length = other\&.length();
170     allocate_self();
171 
172     // Copy the string
173     for (size_t i = 0; i < m_length; i++)
174         m_string[i] = other[i];
175 
176     // Write the null terminator
177     m_string[m_length] = '\\0';
178 
179 }
.fi

.PP
References \fBlength()\fP\&.
.PP
Referenced by \fBoperator+=()\fP, \fBoperator=()\fP, \fBString()\fP, and \fBstrip()\fP\&.
.SS "bool String::equals (\fBString\fP const & other) const"

.PP
Checks if one string is equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB375\fP of file \fBstring\&.cpp\fP\&..PP
.nf
375                                              {
376 
377     // Check if the lengths are equal
378     if (m_length != other\&.length())
379         return false;
380 
381     // Check if the characters are equal
382     for (size_t i = 0; i < m_length; i++)
383         if (m_string[i] != other[i])
384             return false;
385 
386     // The strings are equal
387     return true;
388 
389 }
.fi

.PP
References \fBlength()\fP\&.
.PP
Referenced by \fBoperator!=()\fP, and \fBoperator==()\fP\&.
.SS "\fBString\fP String::formatted (char const * format, va_list parameters)\fC [static]\fP"

.PP
Creates a formated string\&. s = string, x = hex, d = decimal\&. 
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The string containing the format 
.br
\fIparameters\fP The arguments to format into the string
.RE
.PP
\fBReturns\fP
.RS 4
The string with the arguments formated inside 
.RE
.PP

.PP
Definition at line \fB642\fP of file \fBstring\&.cpp\fP\&..PP
.nf
642                                                                {
643 
644     String out;
645 
646     // Loop through the format string
647     for (; *format != '\\0'; format++) {
648 
649         // If it is not a %, print the character
650         if (*format != '%') {
651             out += (string) (char) (*format);
652             continue;
653         }
654 
655         // Move to the next character
656         format++;
657         switch (*format) {
658             case 'd': {
659                 // Print a decimal
660                 int number = va_arg (parameters, int);
661                 out += (string) (number);
662                 break;
663             }
664             case 'x': {
665                 // Print a hex
666                 uint64_t number = va_arg (parameters, uint64_t);
667                 out += (string) (number);
668                 break;
669             }
670             case 's': {
671                 // Print a string
672                 char* str = va_arg (parameters, char*);
673                 out += (string) (str);
674                 break;
675             }
676         }
677     }
678 
679     return out;
680 
681 }
.fi

.SS "\fBString\fP String::formatted (char const * format,  \&.\&.\&.)\fC [static]\fP"

.PP
Creates a formated string\&. s = string, x = hex, d = decimal\&. 
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The string containing the format 
.br
\fI\&.\&.\&.\fP The arguments to format into the string
.RE
.PP
\fBReturns\fP
.RS 4
The string with the arguments formated inside 
.RE
.PP

.PP
Definition at line \fB624\fP of file \fBstring\&.cpp\fP\&..PP
.nf
624                                                 {
625 
626     // Create a pointer to the data
627     va_list parameters;
628     va_start(parameters, format);
629 
630     return formatted(format, parameters);
631 
632 }
.fi

.PP
References \fBformatted()\fP\&.
.PP
Referenced by \fBMaxOS::Logger::ASSERT()\fP, \fBformatted()\fP, and \fBMaxOS::Logger::printf()\fP\&.
.SS "size_t String::length (bool count_ansi = \fCtrue\fP) const"

.PP
Returns the length of the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIcount_ansi\fP Whether to count the ansi characters (default true) 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line \fB344\fP of file \fBstring\&.cpp\fP\&..PP
.nf
344                                            {
345 
346     // If ansi characters are not to be counted
347     if (count_ansi)
348         return m_length;
349 
350     // Calculate the length of the string without ansi characters
351     int total_length = 0;
352     int clean_length = 0;
353     while (m_string[total_length] != '\\0') {
354 
355         // If the character is an ansi character, skip it
356         if (m_string[total_length] == '\\033')
357             while (m_string[total_length] != 'm')
358                 total_length++;
359 
360         // Increment the length
361         clean_length++;
362         total_length++;
363     }
364 
365     // Return the length
366     return clean_length;
367 }
.fi

.PP
Referenced by \fBcopy()\fP, \fBequals()\fP, \fBoperator+()\fP, \fBsplit()\fP, \fBstarts_with()\fP, \fBString()\fP, and \fBsubstring()\fP\&.
.SS "bool String::operator!= (\fBString\fP const & other) const"

.PP
Checks if one string is not equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are not equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB409\fP of file \fBstring\&.cpp\fP\&..PP
.nf
409                                                   {
410 
411     // Self assignment check
412     if (*this == other)
413         return false;
414 
415     return !equals(other);
416 }
.fi

.PP
References \fBequals()\fP\&.
.SS "\fBString\fP String::operator* (int times) const"

.PP
Returns the string repeated a number of times\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP The number of times to repeat the string 
.RE
.PP
\fBReturns\fP
.RS 4
The string repeated a number of times 
.RE
.PP

.PP
Definition at line \fB536\fP of file \fBstring\&.cpp\fP\&..PP
.nf
536                                          {
537 
538     // The repeated string
539     String repeated;
540     repeated\&.m_length = m_length * times;
541     repeated\&.allocate_self();
542 
543     // Copy the string
544     for (int i = 0; i < times; i++)
545         for (size_t j = 0; j < m_length; j++)
546             repeated\&.m_string[i * m_length + j] = m_string[j];
547 
548     // Write the null terminator
549     repeated\&.m_string[repeated\&.m_length] = '\\0';
550 
551     // Return the repeated string
552     return repeated;
553 
554 }
.fi

.SS "\fBString\fP String::operator+ (\fBString\fP const & other) const"

.PP
Adds the other string to the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
The concatenated string 
.RE
.PP

.PP
Definition at line \fB472\fP of file \fBstring\&.cpp\fP\&..PP
.nf
472                                                    {
473 
474     // The concatenated string
475     String concatenated;
476     concatenated\&.m_length = m_length + other\&.length();
477     concatenated\&.allocate_self();
478 
479     // Copy the first string
480     for (size_t i = 0; i < m_length; i++)
481         concatenated\&.m_string[i] = m_string[i];
482 
483     // Copy the second string
484     for (size_t i = 0; i < other\&.length(); i++)
485         concatenated\&.m_string[m_length + i] = other[i];
486 
487     // Write the null terminator
488     concatenated\&.m_string[concatenated\&.m_length] = '\\0';
489 
490     // Return the concatenated string
491     return concatenated;
492 }
.fi

.PP
References \fBlength()\fP\&.
.SS "\fBString\fP & String::operator+= (\fBString\fP const & other)"

.PP
Adds the other string to the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
The concatenated string 
.RE
.PP

.PP
Definition at line \fB500\fP of file \fBstring\&.cpp\fP\&..PP
.nf
500                                                {
501 
502     // Add the other string to this string
503     String concatenated = *this + other;
504     copy(concatenated);
505     return *this;
506 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "bool String::operator< (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is less than the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is less than the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB424\fP of file \fBstring\&.cpp\fP\&..PP
.nf
424                                                  {
425 
426     return lex_value(*this) < lex_value(other);
427 
428 }
.fi

.SS "bool String::operator<= (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is less than or equal to the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is less than or equal to the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB448\fP of file \fBstring\&.cpp\fP\&..PP
.nf
448                                                   {
449 
450     return lex_value(*this) <= lex_value(other);
451 
452 }
.fi

.SS "\fBString\fP & String::operator= (\fBString\fP const & other)"

.PP
Sets the string to the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The string for this one to be updated to 
.RE
.PP
\fBReturns\fP
.RS 4
\fBString\fP The string 
.RE
.PP

.PP
Definition at line \fB218\fP of file \fBstring\&.cpp\fP\&..PP
.nf
218                                               {
219 
220     // Self assignment check
221     if (this == &other)
222         return *this;
223 
224     // Copy the other string
225     copy(other);
226     return *this;
227 }
.fi

.PP
References \fBcopy()\fP\&.
.SS "bool String::operator== (\fBString\fP const & other) const"

.PP
Checks if one string is equal to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB397\fP of file \fBstring\&.cpp\fP\&..PP
.nf
397                                                   {
398 
399     // Check if the strings are equal
400     return equals(other);
401 }
.fi

.PP
References \fBequals()\fP\&.
.SS "bool String::operator> (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is greater than the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is greater than the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB436\fP of file \fBstring\&.cpp\fP\&..PP
.nf
436                                                  {
437 
438     return lex_value(*this) > lex_value(other);
439 
440 }
.fi

.SS "bool String::operator>= (\fBString\fP const & other) const"

.PP
Checks if the sum of the ascii values of the characters in the string is greater than or equal to the sum of the ascii values of the characters in the other string\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string is greater than or equal to the other, false otherwise 
.RE
.PP

.PP
Definition at line \fB460\fP of file \fBstring\&.cpp\fP\&..PP
.nf
460                                                   {
461 
462     return lex_value(*this) >= lex_value(other);
463 
464 }
.fi

.SS "char & String::operator[] (size_t index)"

.PP
Returns the character at the specified index\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the character 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified index 
.RE
.PP

.PP
Definition at line \fB515\fP of file \fBstring\&.cpp\fP\&..PP
.nf
515                                       {
516     return m_string[index];
517 }
.fi

.SS "char & String::operator[] (size_t index) const"

.PP
Returns the character at the specified index\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the character 
.RE
.PP
\fBReturns\fP
.RS 4
The character at the specified index 
.RE
.PP

.PP
Definition at line \fB526\fP of file \fBstring\&.cpp\fP\&..PP
.nf
526                                             {
527     return m_string[index];
528 }
.fi

.SS "\fBcommon::Vector\fP< \fBString\fP > String::split (\fBString\fP const & delimiter) const"

.PP
Splits the string by the delimiter\&. 
.PP
\fBParameters\fP
.RS 4
\fIdelimiter\fP What to split the string by 
.RE
.PP
\fBReturns\fP
.RS 4
A vector of strings that were split by the delimiter 
.RE
.PP

.PP
Definition at line \fB308\fP of file \fBstring\&.cpp\fP\&..PP
.nf
308                                                                 {
309     common::Vector<String> strings;
310 
311     // Go through the string and split it by the delimiter
312     size_t start = 0;
313     for (size_t i = 0; i <= m_length \- delimiter\&.length(); i++) {
314 
315         // Check if matches at this position
316         bool matches = true;
317         for (size_t j = 0; j < delimiter\&.length(); j++)
318             if (m_string[i + j] != delimiter[j]) {
319                 matches = false;
320                 break;
321             }
322 
323         if (!matches)
324             continue;
325 
326         // Add the splice of the string
327         strings\&.push_back(substring(start, i \- start));
328         start = i + delimiter\&.length();
329         i += delimiter\&.length() \- 1;
330     }
331 
332     // Add the last string to the vector
333     strings\&.push_back(substring(start, m_length \- start));
334 
335     return strings;
336 }
.fi

.PP
References \fBlength()\fP, and \fBsubstring()\fP\&.
.SS "bool String::starts_with (\fBString\fP const & other)"

.PP
Checks if the string starts with the other string (must contain the same characters in the same order) 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The other string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the string starts with the other string, false otherwise 
.RE
.PP

.PP
Definition at line \fB255\fP of file \fBstring\&.cpp\fP\&..PP
.nf
255                                             {
256 
257     // Must at least be able to fit the other string
258     if (m_length < other\&.length())
259         return false;
260 
261     // Check if the string starts with the other string
262     for (size_t i = 0; i < other\&.length(); i++)
263         if (m_string[i] != other[i])
264             return false;
265 
266     // No string left over to check so it must contain other
267     return true;
268 }
.fi

.PP
References \fBlength()\fP\&.
.SS "\fBString\fP String::strip (char strip_char = \fC' '\fP) const"

.PP
Strips the string of whitespace\&. 
.PP
\fBParameters\fP
.RS 4
\fIstrip_char\fP The character to strip (default = ' ') 
.RE
.PP
\fBReturns\fP
.RS 4
The stripped string (new string) 
.RE
.PP

.PP
Definition at line \fB597\fP of file \fBstring\&.cpp\fP\&..PP
.nf
597                                           {
598 
599     // The stripped string
600     String stripped;
601     stripped\&.copy(*this);
602 
603     // Search from the back for the earliest non\-whitespace character
604     size_t end = m_length \- 1;
605     while (end >= 0 && (m_string[end] == strip_char || m_string[end] == '\\n' || m_string[end] == '\\t'))
606         end\-\-;
607 
608     // Make sure there is something to strip
609     if (end < 0)
610         return stripped;
611 
612     // Split the string to remove the end
613     return stripped\&.substring(0, end + 1);
614 }
.fi

.PP
References \fBcopy()\fP, and \fBsubstring()\fP\&.
.SS "\fBString\fP String::substring (size_t start, size_t length) const"

.PP
Get a section of the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP The start of the substring 
.br
\fIlength\fP The length of the substring 
.RE
.PP
\fBReturns\fP
.RS 4
The substring or empty string if out of bounds 
.RE
.PP

.PP
Definition at line \fB277\fP of file \fBstring\&.cpp\fP\&..PP
.nf
277                                                           {
278 
279     // Ensure the start is within bounds
280     if (start >= m_length)
281         return { };
282 
283     // Ensure the length is within bounds
284     if (start + length > m_length)
285         return { };
286 
287     // Allocate memory for the substring (and null terminator)
288     String substring;
289     substring\&.m_length = length;
290     substring\&.allocate_self();
291 
292     // Copy the substring
293     for (size_t i = 0; i < length; i++)
294         substring\&.m_string[i] = m_string[start + i];
295 
296     // Write the null terminator
297     substring\&.m_string[length] = '\\0';
298 
299     return substring;
300 }
.fi

.PP
References \fBlength()\fP, and \fBsubstring()\fP\&.
.PP
Referenced by \fBsplit()\fP, \fBstrip()\fP, and \fBsubstring()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

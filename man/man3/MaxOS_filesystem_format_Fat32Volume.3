.TH "MaxOS::filesystem::format::Fat32Volume" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::format::Fat32Volume \- Handles the FAT table that stores the information about the files on the disk and operations on the disk\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fat32\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFat32Volume\fP (\fBdrivers::disk::Disk\fP *\fBdisk\fP, \fBlba_t\fP partition_offset)"
.br
.RI "Construct a new Fat32 Volume object\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBnext_cluster\fP (\fBuint32_t\fP \fBcluster\fP) \fBconst\fP"
.br
.RI "Take the cluster and gets the next cluster in the chain\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBset_next_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBuint32_t\fP \fBnext_cluster\fP) \fBconst\fP"
.br
.RI "Sets the next cluster in the chain (where the base cluster should point) "
.ti -1c
.RI "\fBuint32_t\fP \fBfind_free_cluster\fP () \fBconst\fP"
.br
.RI "Searches the fat table for a free cluster starting from the first free cluster in the fsinfo, will then wrap around\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBallocate_cluster\fP (\fBuint32_t\fP \fBcluster\fP)"
.br
.RI "Allocate a cluster in the FAT table\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBallocate_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBsize_t\fP \fBamount\fP)"
.br
.RI "Allocate a number of clusters in the FAT table, updates the fsinfo and the chain\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_cluster\fP (\fBuint32_t\fP \fBcluster\fP)"
.br
.RI "Free a cluster in the FAT table\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBsize_t\fP \fBamount\fP)"
.br
.RI "Free a number of clusters in the FAT table\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBbpb32_t\fP \fBbpb\fP = { }"
.br
.RI "The BIOS Parameter Block for the FAT32 volume\&. "
.ti -1c
.RI "\fBfs_info_t\fP \fBfsinfo\fP = { }"
.br
.RI "The \fBFSInfo\fP structure for the FAT32 volume\&. "
.ti -1c
.RI "size_t \fBfat_total_clusters\fP"
.br
.RI "How many clusters are in the FAT table\&. "
.ti -1c
.RI "\fBlba_t\fP \fBfat_lba\fP"
.br
.RI "The starting LBA of the FAT table\&. "
.ti -1c
.RI "\fBlba_t\fP \fBfat_info_lba\fP"
.br
.RI "The LBA of the \fBFSInfo\fP structure\&. "
.ti -1c
.RI "\fBlba_t\fP \fBfat_copies\fP"
.br
.RI "How many FAT tables are present\&. "
.ti -1c
.RI "\fBlba_t\fP \fBdata_lba\fP"
.br
.RI "The starting LBA of the data region\&. "
.ti -1c
.RI "\fBlba_t\fP \fBroot_lba\fP"
.br
.RI "The starting LBA of the root directory\&. "
.ti -1c
.RI "\fBdrivers::disk::Disk\fP * \fBdisk\fP"
.br
.RI "The disk that this volume is on\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the FAT table that stores the information about the files on the disk and operations on the disk\&. 
.PP
Definition at line \fB171\fP of file \fBfat32\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Fat32Volume::Fat32Volume (\fBdrivers::disk::Disk\fP * disk, \fBlba_t\fP partition_offset)"

.PP
Construct a new Fat32 Volume object\&. 
.PP
\fBParameters\fP
.RS 4
\fIdisk\fP The disk to read from 
.br
\fIpartition_offset\fP The offset of the partition on the disk 
.RE
.PP

.PP
Definition at line \fB26\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
27         : disk(disk) {
28 
29     // Read the BIOS parameter block
30     buffer_t bpb_buffer(&bpb, sizeof(bpb32_t));
31     disk\->read(partition_offset, &bpb_buffer);
32 
33     // Parse the FAT info
34     uint32_t total_data_sectors =
35             bpb\&.total_sectors_32 \- (bpb\&.reserved_sectors + (bpb\&.table_copies * bpb\&.table_size_32));
36     fat_total_clusters = total_data_sectors / bpb\&.sectors_per_cluster;
37     fat_lba = partition_offset + bpb\&.reserved_sectors;
38     fat_copies = bpb\&.table_copies;
39     fat_info_lba = partition_offset + bpb\&.fat_info;
40     data_lba = fat_lba + (bpb\&.table_copies * bpb\&.table_size_32);
41     root_lba = data_lba + bpb\&.sectors_per_cluster * (bpb\&.root_cluster \- 2);
42 
43     // Read the fs info
44     buffer_t fs_buffer(&fsinfo, sizeof(fs_info_t));
45     disk\->read(fat_info_lba, &fs_buffer);
46 
47     // Validate the fat information
48     if(fsinfo\&.lead_signature != 0x41615252 || fsinfo\&.structure_signature != 0x61417272 ||
49        fsinfo\&.trail_signature != 0xAA550000) {
50         Logger::ERROR() << "Invalid FAT32 filesystem information TODO: Handle this\\n";
51         return;
52     }
53 }
.fi

.PP
References \fBbpb\fP, \fBdata_lba\fP, \fBdisk\fP, \fBMaxOS::Logger::ERROR()\fP, \fBfat_copies\fP, \fBfat_info_lba\fP, \fBfat_lba\fP, \fBfat_total_clusters\fP, \fBfsinfo\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBroot_lba\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP Fat32Volume::allocate_cluster (\fBuint32_t\fP cluster)"

.PP
Allocate a cluster in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from or 0 if this is a new chain 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB141\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
141                                                        {
142 
143     // Allocate 1 cluster
144     return allocate_cluster(cluster, 1);
145 }
.fi

.PP
References \fBallocate_cluster()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::allocate_cluster (\fBuint32_t\fP cluster, \fBsize_t\fP amount)"

.PP
Allocate a number of clusters in the FAT table, updates the fsinfo and the chain\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from or 0 if this is a new chain 
.br
\fIamount\fP The number of clusters to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB154\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
154                                                                       {
155 
156     // Make sure within bounds
157     if(cluster > fat_total_clusters || cluster + amount > fat_total_clusters)
158         return 0;
159 
160     // Go through allocating the clusters
161     for(size_t i = 0; i < amount; i++) {
162         uint32_t next_cluster = find_free_cluster();
163 
164         // Update the fsinfo
165         fsinfo\&.next_free_cluster = next_cluster + 1;
166         fsinfo\&.free_cluster_count \-= 1;
167 
168         // If there is an existing chain it needs to be updated
169         if(cluster != 0)
170             set_next_cluster(cluster, next_cluster);
171 
172         cluster = next_cluster;
173     }
174 
175     // Once all the updates are done flush the changes to the disk
176     buffer_t fs_info_buffer(&fsinfo, sizeof(fs_info_t));
177     disk\->write(fat_info_lba, &fs_info_buffer);
178 
179     // Finish the chain
180     set_next_cluster(cluster, (uint32_t) ClusterState::END_OF_CHAIN);
181     return cluster;
182 }
.fi

.PP
References \fBdisk\fP, \fBfat_info_lba\fP, \fBfat_total_clusters\fP, \fBfind_free_cluster()\fP, \fBfsinfo\fP, \fBnext_cluster()\fP, \fBset_next_cluster()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::find_free_cluster () const"

.PP
Searches the fat table for a free cluster starting from the first free cluster in the fsinfo, will then wrap around\&. 
.PP
\fBReturns\fP
.RS 4
The first free cluster in the FAT table 
.RE
.PP

.PP
Definition at line \fB119\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
119                                               {
120 
121     // Get the first free cluster
122     for(uint32_t start = fsinfo\&.next_free_cluster; start < fat_total_clusters + 1; start++)
123         if(next_cluster(start) == 0)
124             return start;
125 
126     // Check any clusters before the first free cluster
127     for(uint32_t start = 2; start < fsinfo\&.next_free_cluster; start++)
128         if(next_cluster(start) == 0)
129             return start;
130 
131     ASSERT(false, "No free clusters found in the FAT table");
132     return 0;
133 }
.fi

.PP
References \fBASSERT\fP, \fBfat_total_clusters\fP, \fBfsinfo\fP, and \fBnext_cluster()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP\&.
.SS "\fBvoid\fP Fat32Volume::free_cluster (\fBuint32_t\fP cluster)"

.PP
Free a cluster in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.RE
.PP

.PP
Definition at line \fB189\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
189                                             {
190 
191     // Free 1 cluster
192     free_cluster(cluster, 1);
193 
194 }
.fi

.PP
References \fBfree_cluster()\fP\&.
.PP
Referenced by \fBfree_cluster()\fP\&.
.SS "\fBvoid\fP Fat32Volume::free_cluster (\fBuint32_t\fP cluster, \fBsize_t\fP amount)"

.PP
Free a number of clusters in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.br
\fIamount\fP The number of clusters to free 
.RE
.PP

.PP
Definition at line \fB202\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
202                                                               {
203 
204     // Make sure within bounds
205     if(cluster < 2 || cluster > fat_total_clusters || cluster + amount > fat_total_clusters)
206         return;
207 
208     // Go through freeing the clusters
209     for(size_t i = 0; i < amount; i++) {
210 
211         // Find the next cluster before it is removed from the chain
212         uint32_t next_in_chain = next_cluster(cluster);
213 
214         // Update the fsinfo
215         fsinfo\&.next_free_cluster = cluster;
216         fsinfo\&.free_cluster_count += 1;
217 
218         // Update the chain
219         set_next_cluster(cluster, (lba_t) ClusterState::FREE);
220         cluster = next_in_chain;
221     }
222 
223     // Save the fsinfo
224     buffer_t fs_info_buffer(&fsinfo, sizeof(fs_info_t));
225     disk\->write(fat_info_lba, &fs_info_buffer);
226 
227     // Mark the end of the chain
228     set_next_cluster(cluster, (uint32_t) ClusterState::END_OF_CHAIN);
229 }
.fi

.PP
References \fBdisk\fP, \fBfat_info_lba\fP, \fBfat_total_clusters\fP, \fBfsinfo\fP, \fBnext_cluster()\fP, \fBset_next_cluster()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.SS "\fBlba_t\fP Fat32Volume::next_cluster (\fBuint32_t\fP cluster) const"

.PP
Take the cluster and gets the next cluster in the chain\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain
.RE
.PP
\fBTodo\fP
.RS 4
The auto entry = uint32_t* '&' is weird, fix it 
.RE
.PP

.PP
Definition at line \fB65\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
65                                                    {
66 
67     // Get the location in the FAT table
68     lba_t offset = cluster * sizeof(uint32_t);
69     lba_t sector = fat_lba + (offset / bpb\&.bytes_per_sector);
70     uint32_t entry_index = offset % bpb\&.bytes_per_sector;
71 
72     // Read the FAT entry
73     buffer_t fat(bpb\&.bytes_per_sector);
74     disk\->read(sector, &fat);
75 
76     // Get the next cluster info (mask the upper 4 bits)
77     auto entry = (uint32_t*) (&(fat\&.raw()[entry_index]));
78     return *entry & 0x0FFFFFFF;
79 }
.fi

.PP
References \fBbpb\fP, \fBdisk\fP, \fBfat_lba\fP, and \fBMaxOS::drivers::disk::Disk::read()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBfind_free_cluster()\fP, \fBfree_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::set_next_cluster (\fBuint32_t\fP cluster, \fBuint32_t\fP next_cluster) const"

.PP
Sets the next cluster in the chain (where the base cluster should point) 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.br
\fInext_cluster\fP The next cluster in the chain 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain
.RE
.PP
\fBTodo\fP
.RS 4
when in userspace: For performance cache fat entirely, cache file data, cache cluster chains 
.RE
.PP

.PP
Definition at line \fB90\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
90                                                                                     {
91 
92     // Get the location in the FAT table
93     lba_t offset = cluster * sizeof(uint32_t);
94 
95     for(uint32_t i = 0; i < fat_copies; ++i) {
96 
97         lba_t sector = (fat_lba + i * bpb\&.table_size_32) + (offset / bpb\&.bytes_per_sector);
98         uint32_t entry_index = offset % bpb\&.bytes_per_sector;
99 
100         // Read the FAT entry
101         buffer_t fat(bpb\&.bytes_per_sector);
102         disk\->read(sector, &fat);
103 
104         // Set the next cluster info (mask the upper 4 bits)
105         auto entry = (uint32_t*) (&(fat\&.raw()[entry_index]));
106         *entry = next_cluster & 0x0FFFFFFF;
107         disk\->write(sector, &fat);
108 
109     }
110 
111     return next_cluster;
112 }
.fi

.PP
References \fBbpb\fP, \fBdisk\fP, \fBfat_copies\fP, \fBfat_lba\fP, \fBnext_cluster()\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, and \fBfree_cluster()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBbpb32_t\fP MaxOS::filesystem::format::Fat32Volume::bpb = { }"

.PP
The BIOS Parameter Block for the FAT32 volume\&. 
.PP
Definition at line \fB176\fP of file \fBfat32\&.h\fP\&..PP
.nf
176 { };                   
.fi

.PP
Referenced by \fBMaxOS::filesystem::format::Fat32FileSystem::Fat32FileSystem()\fP, \fBFat32Volume()\fP, \fBnext_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::data_lba"

.PP
The starting LBA of the data region\&. 
.PP
Definition at line \fB184\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBdrivers::disk::Disk\fP* MaxOS::filesystem::format::Fat32Volume::disk"

.PP
The disk that this volume is on\&. 
.PP
Definition at line \fB187\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfree_cluster()\fP, \fBnext_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_copies"

.PP
How many FAT tables are present\&. 
.PP
Definition at line \fB182\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, and \fBset_next_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_info_lba"

.PP
The LBA of the \fBFSInfo\fP structure\&. 
.PP
Definition at line \fB181\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, and \fBfree_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_lba"

.PP
The starting LBA of the FAT table\&. 
.PP
Definition at line \fB180\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, \fBnext_cluster()\fP, and \fBset_next_cluster()\fP\&.
.SS "size_t MaxOS::filesystem::format::Fat32Volume::fat_total_clusters"

.PP
How many clusters are in the FAT table\&. 
.PP
Definition at line \fB179\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfind_free_cluster()\fP, and \fBfree_cluster()\fP\&.
.SS "\fBfs_info_t\fP MaxOS::filesystem::format::Fat32Volume::fsinfo = { }"

.PP
The \fBFSInfo\fP structure for the FAT32 volume\&. 
.PP
Definition at line \fB177\fP of file \fBfat32\&.h\fP\&..PP
.nf
177 { };              
.fi

.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfind_free_cluster()\fP, and \fBfree_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::root_lba"

.PP
The starting LBA of the root directory\&. 
.PP
Definition at line \fB185\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

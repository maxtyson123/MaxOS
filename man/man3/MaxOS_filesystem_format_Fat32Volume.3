.TH "MaxOS::filesystem::format::Fat32Volume" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::format::Fat32Volume \- Handles the FAT table that stores the information about the files on the disk and operations on the disk\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fat32\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFat32Volume\fP (\fBdrivers::disk::Disk\fP *\fBdisk\fP, \fBlba_t\fP partition_offset)"
.br
.ti -1c
.RI "\fB~Fat32Volume\fP ()"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBnext_cluster\fP (\fBuint32_t\fP \fBcluster\fP)"
.br
.RI "Take the cluster and gets the next cluster in the chain\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBset_next_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBuint32_t\fP \fBnext_cluster\fP)"
.br
.RI "Sets the next cluster in the chain (where the base cluster should point) "
.ti -1c
.RI "\fBuint32_t\fP \fBfind_free_cluster\fP ()"
.br
.RI "Searches the fat table for a free cluster starting from the first free cluster in the fsinfo, will then wrap around\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBallocate_cluster\fP (\fBuint32_t\fP \fBcluster\fP)"
.br
.RI "Allocate a cluster in the FAT table\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBallocate_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBsize_t\fP \fBamount\fP)"
.br
.RI "Allocate a number of clusters in the FAT table, updates the fsinfo and the chain\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_cluster\fP (\fBuint32_t\fP \fBcluster\fP)"
.br
.RI "Free a cluster in the FAT table\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_cluster\fP (\fBuint32_t\fP \fBcluster\fP, \fBsize_t\fP \fBamount\fP)"
.br
.RI "Free a number of clusters in the FAT table\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bpb32_t \fBbpb\fP"
.br
.ti -1c
.RI "fs_info_t \fBfsinfo\fP"
.br
.ti -1c
.RI "size_t \fBfat_total_clusters\fP"
.br
.ti -1c
.RI "\fBlba_t\fP \fBfat_lba\fP"
.br
.ti -1c
.RI "\fBlba_t\fP \fBfat_info_lba\fP"
.br
.ti -1c
.RI "\fBlba_t\fP \fBfat_copies\fP"
.br
.ti -1c
.RI "\fBlba_t\fP \fBdata_lba\fP"
.br
.ti -1c
.RI "\fBlba_t\fP \fBroot_lba\fP"
.br
.ti -1c
.RI "\fBdrivers::disk::Disk\fP * \fBdisk\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles the FAT table that stores the information about the files on the disk and operations on the disk\&. 
.PP
Definition at line \fB166\fP of file \fBfat32\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Fat32Volume::Fat32Volume (\fBdrivers::disk::Disk\fP * disk, \fBlba_t\fP partition_offset)"

.PP
Definition at line \fB16\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
17 : disk(hd)
18 {
19 
20     // Read the BIOS parameter block
21     buffer_t bpb_buffer(&bpb, sizeof(bpb32_t));
22     disk\->read(partition_offset, &bpb_buffer);
23 
24     // Parse the FAT info
25     uint32_t total_data_sectors = bpb\&.total_sectors_32 \- (bpb\&.reserved_sectors + (bpb\&.table_copies * bpb\&.table_size_32));
26     fat_total_clusters          = total_data_sectors / bpb\&.sectors_per_cluster;
27     fat_lba                     = partition_offset + bpb\&.reserved_sectors;
28     fat_copies                  = bpb\&.table_copies;
29     fat_info_lba                = partition_offset + bpb\&.fat_info;
30     data_lba                    = fat_lba + (bpb\&.table_copies * bpb\&.table_size_32);
31     root_lba                    = data_lba + bpb\&.sectors_per_cluster * (bpb\&.root_cluster \- 2);
32 
33     // Read the fs info
34     buffer_t fs_buffer(&fsinfo, sizeof(fs_info_t));
35     disk\->read(fat_info_lba, &fs_buffer);
36 
37     // Validate the fat information
38     if (fsinfo\&.lead_signature != 0x41615252 || fsinfo\&.structure_signature != 0x61417272 ||
39         fsinfo\&.trail_signature != 0xAA550000) {
40         Logger::ERROR() << "Invalid FAT32 filesystem information TODO: Handle this\\n";
41         return;
42     }
43 }
.fi

.PP
References \fBbpb\fP, \fBdata_lba\fP, \fBdisk\fP, \fBLogger::ERROR()\fP, \fBfat_copies\fP, \fBfat_info_lba\fP, \fBfat_lba\fP, \fBfat_total_clusters\fP, \fBfsinfo\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBroot_lba\fP\&.
.SS "Fat32Volume::~Fat32Volume ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP Fat32Volume::allocate_cluster (\fBuint32_t\fP cluster)"

.PP
Allocate a cluster in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from or 0 if this is a new chain 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB129\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
129                                                        {
130 
131     // Allocate 1 cluster
132     return allocate_cluster(cluster, 1);
133 }
.fi

.PP
References \fBallocate_cluster()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::allocate_cluster (\fBuint32_t\fP cluster, \fBsize_t\fP amount)"

.PP
Allocate a number of clusters in the FAT table, updates the fsinfo and the chain\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from or 0 if this is a new chain 
.br
\fIamount\fP The number of clusters to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB142\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
142                                                                       {
143 
144     // Make sure within bounds
145     if (cluster > fat_total_clusters || cluster + amount > fat_total_clusters)
146         return 0;
147 
148     // Go through allocating the clusters
149     for (size_t i = 0; i < amount; i++) {
150         uint32_t next_cluster = find_free_cluster();
151 
152         // Update the fsinfo
153         fsinfo\&.next_free_cluster = next_cluster + 1;
154         fsinfo\&.free_cluster_count \-= 1;
155 
156         // If there is an existing chain it needs to be updated
157         if (cluster != 0)
158             set_next_cluster(cluster, next_cluster);
159 
160         cluster = next_cluster;
161     }
162 
163     // Once all the updates are done flush the changes to the disk
164     buffer_t fs_info_buffer(&fsinfo, sizeof(fs_info_t));
165     disk\->write(fat_info_lba, &fs_info_buffer);
166 
167     // Finish the chin
168     set_next_cluster(cluster, (uint32_t) ClusterState::END_OF_CHAIN);
169     uint32_t next = next_cluster(cluster);
170     return cluster;
171 }
.fi

.PP
References \fBdisk\fP, \fBMaxOS::filesystem::format::END_OF_CHAIN\fP, \fBfat_info_lba\fP, \fBfat_total_clusters\fP, \fBfind_free_cluster()\fP, \fBfsinfo\fP, \fBnext\fP, \fBnext_cluster()\fP, \fBset_next_cluster()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::find_free_cluster ()"

.PP
Searches the fat table for a free cluster starting from the first free cluster in the fsinfo, will then wrap around\&. 
.PP
\fBReturns\fP
.RS 4
The first free cluster in the FAT table 
.RE
.PP

.PP
Definition at line \fB107\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
107                                         {
108 
109     // Get the first free cluster
110     for (uint32_t start = fsinfo\&.next_free_cluster; start < fat_total_clusters + 1; start++)
111         if (next_cluster(start) == 0)
112             return start;
113 
114     // Check any clusters before the first free cluster
115     for (uint32_t start = 2; start < fsinfo\&.next_free_cluster; start++)
116         if (next_cluster(start) == 0)
117             return start;
118 
119     ASSERT(false, "No free clusters found in the FAT table");
120     return 0;
121 }
.fi

.PP
References \fBASSERT\fP, \fBfat_total_clusters\fP, \fBfsinfo\fP, and \fBnext_cluster()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP\&.
.SS "\fBvoid\fP Fat32Volume::free_cluster (\fBuint32_t\fP cluster)"

.PP
Free a cluster in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.br
\fIfull\fP Weather the chain's length is 1 or not 
.RE
.PP

.PP
Definition at line \fB179\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
179                                             {
180 
181     // Free 1 cluster
182     free_cluster(cluster, 1);
183 
184 }
.fi

.PP
References \fBfree_cluster()\fP\&.
.PP
Referenced by \fBfree_cluster()\fP\&.
.SS "\fBvoid\fP Fat32Volume::free_cluster (\fBuint32_t\fP cluster, \fBsize_t\fP amount)"

.PP
Free a number of clusters in the FAT table\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.br
\fIamount\fP The number of clusters to free 
.RE
.PP

.PP
Definition at line \fB192\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
192                                                               {
193 
194     // Make sure within bounds
195     if (cluster < 2 || cluster > fat_total_clusters || cluster + amount > fat_total_clusters)
196         return;
197 
198     // Go through freeing the clusters
199     for (size_t i = 0; i < amount; i++) {
200 
201         // Find the next cluster before it is removed from the chain
202         uint32_t next_in_chain = next_cluster(cluster);
203 
204         // Update the fsinfo
205         fsinfo\&.next_free_cluster = cluster;
206         fsinfo\&.free_cluster_count += 1;
207 
208         // Update the chain
209         set_next_cluster(cluster, (lba_t) ClusterState::FREE);
210         cluster = next_in_chain;
211     }
212 
213     // Save the fsinfo
214     buffer_t fs_info_buffer(&fsinfo, sizeof(fs_info_t));
215     disk\->write(fat_info_lba, &fs_info_buffer);
216 
217     // Mark the end of the chain
218     set_next_cluster(cluster, (uint32_t) ClusterState::END_OF_CHAIN);
219 }
.fi

.PP
References \fBdisk\fP, \fBMaxOS::filesystem::format::END_OF_CHAIN\fP, \fBfat_info_lba\fP, \fBfat_total_clusters\fP, \fBMaxOS::filesystem::format::FREE\fP, \fBfsinfo\fP, \fBnext_cluster()\fP, \fBset_next_cluster()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.SS "\fBlba_t\fP Fat32Volume::next_cluster (\fBuint32_t\fP cluster)"

.PP
Take the cluster and gets the next cluster in the chain\&. 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB53\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
53                                              {
54 
55     // Get the location in the FAT table
56     lba_t offset = cluster * sizeof(uint32_t);
57     lba_t sector = fat_lba + (offset / bpb\&.bytes_per_sector);
58     uint32_t entry_index = offset % bpb\&.bytes_per_sector;
59 
60     // Read the FAT entry
61     buffer_t fat(bpb\&.bytes_per_sector);
62     disk\->read(sector, &fat);
63 
64     // Get the next cluster info (mask the upper 4 bits)
65     auto entry = (uint32_t *) (&(fat\&.raw()[entry_index])); //  TODO & here is weird
66     return *entry & 0x0FFFFFFF;
67 }
.fi

.PP
References \fBbpb\fP, \fBdisk\fP, \fBfat_lba\fP, and \fBMaxOS::drivers::disk::Disk::read()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBfind_free_cluster()\fP, \fBfree_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBuint32_t\fP Fat32Volume::set_next_cluster (\fBuint32_t\fP cluster, \fBuint32_t\fP next_cluster)"

.PP
Sets the next cluster in the chain (where the base cluster should point) 
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP The base cluster to start from 
.br
\fInext_cluster\fP The next cluster in the chain 
.RE
.PP
\fBReturns\fP
.RS 4
The next cluster in the chain 
.RE
.PP

.PP
Definition at line \fB76\fP of file \fBfat32\&.cpp\fP\&..PP
.nf
76                                                                               {
77 
78     // TODO \- when in userspace: For performance cache fat entirely, cache file data, cache cluster chains
79 
80     // Get the location in the FAT table
81     lba_t offset = cluster * sizeof(uint32_t);
82 
83     for (int i = 0; i < fat_copies; ++i) {
84 
85         lba_t sector = (fat_lba + i * bpb\&.table_size_32) + (offset / bpb\&.bytes_per_sector);
86         uint32_t entry_index = offset % bpb\&.bytes_per_sector;
87 
88         // Read the FAT entry
89         buffer_t fat(bpb\&.bytes_per_sector);
90         disk\->read(sector, &fat);
91 
92         // Set the next cluster info (mask the upper 4 bits)
93         auto entry = (uint32_t *) (&(fat\&.raw()[entry_index]));
94         *entry = next_cluster & 0x0FFFFFFF;
95         disk\->write(sector, &fat);
96 
97     }
98 
99     return next_cluster;
100 }
.fi

.PP
References \fBbpb\fP, \fBdisk\fP, \fBfat_copies\fP, \fBfat_lba\fP, \fBnext_cluster()\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, and \fBfree_cluster()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bpb32_t MaxOS::filesystem::format::Fat32Volume::bpb"

.PP
Definition at line \fB172\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::Fat32FileSystem::Fat32FileSystem()\fP, \fBFat32Volume()\fP, \fBnext_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::data_lba"

.PP
Definition at line \fB180\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBdrivers::disk::Disk\fP* MaxOS::filesystem::format::Fat32Volume::disk"

.PP
Definition at line \fB183\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfree_cluster()\fP, \fBnext_cluster()\fP, \fBMaxOS::filesystem::format::Fat32File::read()\fP, \fBset_next_cluster()\fP, \fBMaxOS::filesystem::format::Fat32Directory::update_entry_on_disk()\fP, and \fBMaxOS::filesystem::format::Fat32File::write()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_copies"

.PP
Definition at line \fB178\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, and \fBset_next_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_info_lba"

.PP
Definition at line \fB177\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, and \fBfree_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::fat_lba"

.PP
Definition at line \fB176\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP, \fBnext_cluster()\fP, and \fBset_next_cluster()\fP\&.
.SS "size_t MaxOS::filesystem::format::Fat32Volume::fat_total_clusters"

.PP
Definition at line \fB175\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfind_free_cluster()\fP, and \fBfree_cluster()\fP\&.
.SS "fs_info_t MaxOS::filesystem::format::Fat32Volume::fsinfo"

.PP
Definition at line \fB173\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBallocate_cluster()\fP, \fBFat32Volume()\fP, \fBfind_free_cluster()\fP, and \fBfree_cluster()\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::Fat32Volume::root_lba"

.PP
Definition at line \fB181\fP of file \fBfat32\&.h\fP\&.
.PP
Referenced by \fBFat32Volume()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

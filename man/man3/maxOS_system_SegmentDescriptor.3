.TH "maxOS::system::SegmentDescriptor" 3 "Fri Jan 5 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::system::SegmentDescriptor \- Stores data for the segment descriptors in the GDT\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <gdt\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSegmentDescriptor\fP (uint32_t \fBbase\fP, uint32_t \fBlimit\fP, uint8_t \fBtype\fP)"
.br
.RI "Constructor for Segment Selector\&. "
.ti -1c
.RI "uint32_t \fBbase\fP ()"
.br
.RI "Look up the pointer\&. "
.ti -1c
.RI "uint32_t \fBlimit\fP ()"
.br
.RI "Look up the limit\&. "
.in -1c
.SH "Detailed Description"
.PP 
Stores data for the segment descriptors in the GDT\&. 
.PP
Definition at line 18 of file gdt\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SegmentDescriptor::SegmentDescriptor (uint32_t base, uint32_t limit, uint8_t type)"

.PP
Constructor for Segment Selector\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP base address 
.br
\fIlimit\fP limit 
.br
\fIflags\fP Flags 
.RE
.PP

.PP
Definition at line 18 of file gdt\&.cpp\&.
.PP
.nf
19 {
20   uint8_t* target = (uint8_t*)this;       //segment entry in GDT\&.
21 
22   if (limit <= 65536)
23   {
24     // 16-bit address space
25     target[6] = 0x40;
26   }
27   else
28   {
29     // 32-bit address space
30     if((limit & 0xFFF) != 0xFFF)
31       limit = (limit >> 12)-1;
32     else
33       limit = limit >> 12;
34 
35     target[6] = 0xC0;
36   }
37 
38   // Encode the limit
39   target[0] = limit & 0xFF;
40   target[1] = (limit >> 8) & 0xFF;
41   target[6] |= (limit >> 16) & 0xF;
42 
43   // Encode the base
44   target[2] = base & 0xFF;
45   target[3] = (base >> 8) & 0xFF;
46   target[4] = (base >> 16) & 0xFF;
47   target[7] = (base >> 24) & 0xFF;
48 
49   // Type / Access Rights
50   target[5] = type;
51 }
.fi
.PP
References base(), limit(), and type\&.
.SH "Member Function Documentation"
.PP 
.SS "uint32_t SegmentDescriptor::base ()"

.PP
Look up the pointer\&. 
.PP
\fBReturns\fP
.RS 4
The pointer 
.RE
.PP

.PP
Definition at line 57 of file gdt\&.cpp\&.
.PP
.nf
58 {
59   uint8_t* target = (uint8_t*)this;
60 
61   uint32_t result = target[7];
62   result = (result << 8) + target[4];
63   result = (result << 8) + target[3];
64   result = (result << 8) + target[2];
65 
66   return result;
67 }
.fi
.PP
Referenced by SegmentDescriptor()\&.
.SS "uint32_t SegmentDescriptor::limit ()"

.PP
Look up the limit\&. 
.PP
\fBReturns\fP
.RS 4
The limit 
.RE
.PP

.PP
Definition at line 74 of file gdt\&.cpp\&.
.PP
.nf
75 {
76   uint8_t* target = (uint8_t*)this;
77 
78   uint32_t result = target[6] & 0xF;
79   result = (result << 8) + target[1];
80   result = (result << 8) + target[0];
81 
82   if((target[6] & 0xC0) == 0xC0)
83     result = (result << 12) | 0xFFF;
84 
85   return result;
86 }
.fi
.PP
Referenced by SegmentDescriptor()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

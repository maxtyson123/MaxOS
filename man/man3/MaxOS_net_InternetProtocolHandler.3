.TH "MaxOS::net::InternetProtocolHandler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::InternetProtocolHandler
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipv4\&.h>\fP
.PP
Inherits \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInternetProtocolHandler\fP (\fBEthernetFrameHandler\fP *\fBbackend\fP, \fBInternetProtocolAddress\fP \fBownInternetProtocolAddress\fP, \fBInternetProtocolAddress\fP \fBdefaultGatewayInternetProtocolAddress\fP, \fBSubnetMask\fP \fBsubnetMask\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.ti -1c
.RI "\fB~InternetProtocolHandler\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBhandleEthernetframePayload\fP (\fBuint8_t\fP *\fBethernetframePayload\fP, \fBuint32_t\fP \fBsize\fP) \fBoverride\fP"
.br
.RI "Called when an IP packet is received\&. "
.ti -1c
.RI "\fBvoid\fP \fBsendInternetProtocolPacket\fP (\fBuint32_t\fP \fBdstIP_BE\fP, \fBuint8_t\fP \fBprotocol\fP, \fBconst\fP \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Sends an IP packet\&. "
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBGetInternetProtocolAddress\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBGetMediaAccessControlAddress\fP ()"
.br
.ti -1c
.RI "\fBvoid\fP \fBconnectInternetProtocolPayloadHandler\fP (\fBInternetProtocolPayloadHandler\fP *\fBinternetProtocolPayloadHandler\fP)"
.br
.in -1c

Public Member Functions inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFramePayloadHandler\fP (\fBEthernetFrameHandler\fP *\fBframeHandler\fP, \fBuint16_t\fP \fBhandledType\fP)"
.br
.ti -1c
.RI "\fB~EthernetFramePayloadHandler\fP ()"
.br
.RI "Destroy the EtherFrameHandler:: EtherFrameHandler object, Removes it from the handler list\&. "
.ti -1c
.RI "\fBvoid\fP \fBSend\fP (\fBuint64_t\fP \fBdestinationMAC\fP, \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send an packet via the backend driver\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBuint16_t\fP \fBChecksum\fP (\fBconst\fP \fBuint16_t\fP *\fBdata\fP, \fBuint32_t\fP \fBlengthInBytes\fP)"
.br
.RI "Creates a checksum for the given data\&. "
.ti -1c
.RI "\fBstatic\fP \fBInternetProtocolAddress\fP \fBCreateInternetProtocolAddress\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.ti -1c
.RI "\fBstatic\fP \fBInternetProtocolAddress\fP \fBParse\fP (\fBstring\fP \fBaddress\fP)"
.br
.ti -1c
.RI "\fBstatic\fP \fBSubnetMask\fP \fBCreateSubnetMask\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBRegisterInternetProtocolAddressResolver\fP (\fBInternetProtocolAddressResolver\fP *\fBresolver\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint8_t, \fBInternetProtocolPayloadHandler\fP * > \fBinternetProtocolPayloadHandlers\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddressResolver\fP * \fBresolver\fP = nullptr"
.br
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBownInternetProtocolAddress\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBdefaultGatewayInternetProtocolAddress\fP"
.br
.ti -1c
.RI "\fBSubnetMask\fP \fBsubnetMask\fP"
.br
.in -1c

Protected Attributes inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP * \fBframeHandler\fP"
.br
.ti -1c
.RI "uint16_t \fBhandledType\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInternetProtocolAddressResolver\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB62\fP of file \fBipv4\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InternetProtocolHandler::InternetProtocolHandler (\fBEthernetFrameHandler\fP * backend, \fBInternetProtocolAddress\fP ownInternetProtocolAddress, \fBInternetProtocolAddress\fP defaultGatewayInternetProtocolAddress, \fBSubnetMask\fP subnetMask, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line \fB88\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
89         : EthernetFramePayloadHandler(backend, 0x0800)
90 {
91     //Store vars
92     this \-> ownInternetProtocolAddress = ownInternetProtocolAddress;
93     this \-> defaultGatewayInternetProtocolAddress = defaultGatewayInternetProtocolAddress;
94     this \-> subnetMask = subnetMask;
95     this \-> errorMessages = errorMessages;
96 }
.fi

.PP
References \fBdefaultGatewayInternetProtocolAddress\fP, \fBerrorMessages\fP, \fBownInternetProtocolAddress\fP, and \fBsubnetMask\fP\&.
.SS "InternetProtocolHandler::~InternetProtocolHandler ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBuint16_t\fP InternetProtocolHandler::Checksum (\fBconst\fP \fBuint16_t\fP * data, \fBuint32_t\fP lengthInBytes)\fC [static]\fP"

.PP
Creates a checksum for the given data\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to create a checksum for\&. 
.br
\fIlengthInBytes\fP The length of the data in bytes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The checksum\&. 
.RE
.PP

.PP
Definition at line \fB215\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
215                                                                                        {
216 
217     uint32_t temp = 0;                                                                             //Init sum
218 
219     for(uint32_t i = 0; i < lengthInBytes/2; i++)                                                       //Loop through data (/2 bc bytes)
220         temp += ((data[i] & 0xFF00) >> 8) | ((data[i] & 0x00FF) << 8);                             //Add data to sum in big endian
221 
222     if(lengthInBytes % 2)                                                                          //If there is an odd number of bytes
223         temp += ((uint16_t)((char*)data)[lengthInBytes\-1]) << 8;                                   //Add the last byte to the sum
224 
225     while(temp & 0xFFFF0000)                                                                       //While there is a carry
226         temp = (temp & 0xFFFF) + (temp >> 16);                                                     //Add the carry to the sum
227 
228     return ((~temp & 0xFF00) >> 8) | ((~temp & 0x00FF) << 8);
229 }
.fi

.PP
References \fBdata\fP\&.
.PP
Referenced by \fBhandleEthernetframePayload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::handleInternetProtocolPayload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::RequestEchoReply()\fP, \fBsendInternetProtocolPacket()\fP, and \fBMaxOS::net::TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::connectInternetProtocolPayloadHandler (\fBInternetProtocolPayloadHandler\fP * internetProtocolPayloadHandler)"

.PP
Definition at line \fB277\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
277                                                                                                                                    {
278     internetProtocolPayloadHandlers\&.insert(internetProtocolPayloadHandler \-> ipProtocol, internetProtocolPayloadHandler);
279 }
.fi

.PP
References \fBinternetProtocolPayloadHandlers\fP\&.
.PP
Referenced by \fBMaxOS::net::InternetProtocolPayloadHandler::InternetProtocolPayloadHandler()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::CreateInternetProtocolAddress (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Definition at line \fB237\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
237                                                                                                                                              {
238     InternetProtocolAddress result = digit4;
239     result = (result << 8) | digit3;
240     result = (result << 8) | digit2;
241     result = (result << 8) | digit1;
242     return result;
243 }
.fi

.PP
Referenced by \fBCreateSubnetMask()\fP, and \fBParse()\fP\&.
.SS "\fBSubnetMask\fP InternetProtocolHandler::CreateSubnetMask (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Definition at line \fB265\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
265                                                                                                                    {
266     return (SubnetMask)CreateInternetProtocolAddress(digit1, digit2, digit3, digit4);
267 }
.fi

.PP
References \fBCreateInternetProtocolAddress()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::GetInternetProtocolAddress () const"

.PP
Definition at line \fB269\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
269                                                                                   {
270     return ownInternetProtocolAddress;
271 }
.fi

.PP
References \fBownInternetProtocolAddress\fP\&.
.PP
Referenced by \fBhandleEthernetframePayload()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBMediaAccessControlAddress\fP InternetProtocolHandler::GetMediaAccessControlAddress ()"

.PP
Definition at line \fB273\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
273                                                                                 {
274     return frameHandler \-> getMAC();
275 }
.fi

.PP
References \fBMaxOS::net::EthernetFramePayloadHandler::frameHandler\fP\&.
.SS "\fBbool\fP InternetProtocolHandler::handleEthernetframePayload (\fBuint8_t\fP * ethernetframePayload, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when an IP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIetherframePayload\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the packet is to be sent back, false otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.PP
Definition at line \fB107\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
107                                                                                                     {
108 
109     errorMessages \->write("IP: Handling packet\\n");
110 
111     //Check if the size is big enough to contain an ethernet frame
112     if(size < sizeof(InternetProtocolV4Header))
113         return false;
114 
115     //Convert to struct for easier use
116     auto* ipMessage = (InternetProtocolV4Header*)ethernetframePayload;
117     bool sendBack = false;
118 
119     //Only handle if it is for this device
120     if(ipMessage \-> destinationIP == GetInternetProtocolAddress())
121     {
122         uint32_t length = ipMessage \-> totalLength;                          //Get length of the message
123         if(length > size)                                               //Check if the length is bigger than the size of the message
124             length = size;                                              //If so, set length to size (this stops heartbleed attacks as it will not read past the end of the message, which the attacker could have filled with data)
125 
126         // Get the handler for the protocol
127         Map<uint8_t, InternetProtocolPayloadHandler*>::iterator handlerIterator = internetProtocolPayloadHandlers\&.find(ipMessage \-> protocol);
128         if(handlerIterator != internetProtocolPayloadHandlers\&.end()) {
129             InternetProtocolPayloadHandler* handler = handlerIterator \-> second;
130             if(handler != nullptr) {
131                 sendBack = handler \-> handleInternetProtocolPayload(ipMessage \-> sourceIP, ipMessage \-> destinationIP, ethernetframePayload + sizeof(InternetProtocolV4Header), length \- sizeof(InternetProtocolV4Header));
132             }
133         }
134 
135 
136     }
137 
138     //If the data is to be sent back again
139     if(sendBack){
140 
141         //Swap source and destination
142         uint32_t temp = ipMessage \-> destinationIP;                                                                                     //Store destination IP
143         ipMessage \-> destinationIP = ipMessage \-> sourceIP;                                                                                //Set destination IP to source IP
144         ipMessage \-> sourceIP = temp;                                                                                              //Set source IP to destination IP
145 
146         ipMessage \-> timeToLive = 0x40;                                                                                         //Reset TTL
147         ipMessage \-> checksum = Checksum((uint16_t*)ipMessage, 4 * ipMessage \-> headerLength);                  //Reset checksum as the source and destination IP have changed so has the time to live and therefore there is a different header
148 
149 
150         // TODO: Set the identifier
151     }
152 
153     errorMessages \->write("IP: Handled packet\\n");
154     return sendBack;
155 }
.fi

.PP
References \fBchecksum\fP, \fBChecksum()\fP, \fBdestinationIP\fP, \fBerrorMessages\fP, \fBGetInternetProtocolAddress()\fP, \fBheaderLength\fP, \fBinternetProtocolPayloadHandlers\fP, \fBlength\fP, \fBprotocol\fP, \fBsize\fP, \fBsourceIP\fP, \fBtimeToLive\fP, \fBtotalLength\fP, and \fBMaxOS::common::OutputStream::write()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::Parse (\fBstring\fP address)\fC [static]\fP"

.PP
Definition at line \fB245\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
245                                                                      {
246     uint8_t digits[4];
247 
248     uint8_t currentDigit = 0;
249     for(unsigned char & digit : digits)
250         digit = 0;
251 
252     for(int i = 0; i < address\&.length(); i++) {
253         if(address[i] == '\&.') {
254             currentDigit++;
255             continue;
256         }
257 
258         digits[currentDigit] *= 10;
259         digits[currentDigit] += address[i] \- '0';
260     }
261 
262     return CreateInternetProtocolAddress(digits[0], digits[1], digits[2], digits[3]);
263 }
.fi

.PP
References \fBaddress\fP, and \fBCreateInternetProtocolAddress()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::RegisterInternetProtocolAddressResolver (\fBInternetProtocolAddressResolver\fP * resolver)\fC [protected]\fP"

.PP
Definition at line \fB231\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
231                                                                                                                {
232 
233     this \-> resolver = resolver;
234 
235 }
.fi

.PP
References \fBresolver\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::sendInternetProtocolPacket (\fBuint32_t\fP dstIP_BE, \fBuint8_t\fP protocol, \fBconst\fP \fBuint8_t\fP * data, \fBuint32_t\fP size)"

.PP
Sends an IP packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIdstIP_BE\fP The destination IP address\&. 
.br
\fIprotocol\fP The protocol of the IP packet\&. 
.br
\fIdata\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP

.PP
Definition at line \fB166\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
166                                                                                                                                 {
167 
168     auto* buffer = (uint8_t*)MemoryManager::kmalloc(sizeof(InternetProtocolV4Header) + size);                           //Allocate memory for the message
169     auto *message = (InternetProtocolV4Header*)buffer;                                                                            //Convert to struct for easier use
170 
171     message \-> version = 4;                                                                                                                           //Set version
172     message \-> headerLength = sizeof(InternetProtocolV4Header)/4;                                                                                     //Set header length
173     message \-> typeOfService = 0;                                                                                                                     //Set type of service (not private)
174 
175     message \-> totalLength = size + sizeof(InternetProtocolV4Header);                                                                                 //Set total length
176     message \-> totalLength = ((message \-> totalLength & 0xFF00) >> 8)                                                                                 // Convert to big endian (Swap bytes)
177                              | ((message \-> totalLength & 0x00FF) << 8);                                                                              // Convert to big endian (Swap bytes)
178 
179     message \-> identifier = 0x100;                                                                                                                    //Set identification TODO: do properly
180     message \-> flagsAndOffset = 0x0040;                                                                                                               //Set flags/offset, 0x40 because we are not fragmenting (TODO: doesnt work for packets bigger than 1500 bytes)
181 
182     message \-> timeToLive = 0x40;                                                                                                                     //Set time to live
183     message \-> protocol = protocol;                                                                                                                   //Set protocol
184 
185     message \-> destinationIP = dstIP_BE;                                                                                                                      //Set destination IP
186     message \-> sourceIP = GetInternetProtocolAddress();                                                                                                  //Set source IP
187 
188     message \-> checksum = 0;                                                                                                                          //Set checksum to 0, init with 0 as checksum funct will also add this value
189     message \-> checksum = Checksum((uint16_t*)message, sizeof(InternetProtocolV4Header));                                             //Calculate checksum
190 
191     //Copy data
192     uint8_t* data_buffer = buffer + sizeof(InternetProtocolV4Header);                                                                                  //Get pointer to the data
193     for(uint32_t i = 0; i < size; i++)                                                                                                                            //Loop through data
194       data_buffer[i] = data[i];                                                                                                                             //Copy data
195 
196     //Check if the destination is on the same subnet, The if condition determines if the destination device is on the same Local network as the source device \&. and if they are not on the same local network then we resolve the ip address of the gateway \&.
197     InternetProtocolAddress route = dstIP_BE;                                                                                                                               //Set route to destination IP by default
198     if((dstIP_BE & subnetMask) != (ownInternetProtocolAddress & subnetMask))                                                                                             //Check if the destination is on the same subnet
199         route = defaultGatewayInternetProtocolAddress;                                                                                                                                   //If not, set route to gateway IP
200                                                                                                                     //Print debug info
201     uint32_t MAC = resolver \->Resolve(route);
202 
203     //Send message
204     frameHandler \-> sendEthernetFrame(MAC, this \-> handledType, buffer, size + sizeof(InternetProtocolV4Header));      //Send message
205     MemoryManager::kfree(buffer);                                                                                                 //Free memory
206 }
.fi

.PP
References \fBchecksum\fP, \fBChecksum()\fP, \fBdata\fP, \fBdefaultGatewayInternetProtocolAddress\fP, \fBdestinationIP\fP, \fBflagsAndOffset\fP, \fBMaxOS::net::EthernetFramePayloadHandler::frameHandler\fP, \fBGetInternetProtocolAddress()\fP, \fBMaxOS::net::EthernetFramePayloadHandler::handledType\fP, \fBheaderLength\fP, \fBidentifier\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBownInternetProtocolAddress\fP, \fBprotocol\fP, \fBMaxOS::net::InternetProtocolAddressResolver::Resolve()\fP, \fBresolver\fP, \fBsize\fP, \fBsourceIP\fP, \fBsubnetMask\fP, \fBtimeToLive\fP, \fBtotalLength\fP, \fBtypeOfService\fP, and \fBversion\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBInternetProtocolAddressResolver\fP\fC [friend]\fP"

.PP
Definition at line \fB64\fP of file \fBipv4\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInternetProtocolAddress\fP MaxOS::net::InternetProtocolHandler::defaultGatewayInternetProtocolAddress\fC [protected]\fP"

.PP
Definition at line \fB74\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBcommon::OutputStream\fP* MaxOS::net::InternetProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Definition at line \fB71\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBhandleEthernetframePayload()\fP, and \fBInternetProtocolHandler()\fP\&.
.SS "\fBcommon::Map\fP<uint8_t, \fBInternetProtocolPayloadHandler\fP*> MaxOS::net::InternetProtocolHandler::internetProtocolPayloadHandlers\fC [protected]\fP"

.PP
Definition at line \fB68\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBconnectInternetProtocolPayloadHandler()\fP, and \fBhandleEthernetframePayload()\fP\&.
.SS "\fBInternetProtocolAddress\fP MaxOS::net::InternetProtocolHandler::ownInternetProtocolAddress\fC [protected]\fP"

.PP
Definition at line \fB73\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBGetInternetProtocolAddress()\fP, \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBInternetProtocolAddressResolver\fP* MaxOS::net::InternetProtocolHandler::resolver = nullptr\fC [protected]\fP"

.PP
Definition at line \fB70\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBRegisterInternetProtocolAddressResolver()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBSubnetMask\fP MaxOS::net::InternetProtocolHandler::subnetMask\fC [protected]\fP"

.PP
Definition at line \fB75\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

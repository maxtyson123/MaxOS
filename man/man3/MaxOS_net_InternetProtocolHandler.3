.TH "MaxOS::net::InternetProtocolHandler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::InternetProtocolHandler \- Handles IPv4 packets over Ethernet frames\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipv4\&.h>\fP
.PP
Inherits \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInternetProtocolHandler\fP (\fBEthernetFrameHandler\fP *\fBbackend\fP, InternetProtocolAddress \fBownInternetProtocolAddress\fP, InternetProtocolAddress \fBdefaultGatewayInternetProtocolAddress\fP, SubnetMask \fBsubnetMask\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.RI "Construct a new Internet Protocol Handler object\&. "
.ti -1c
.RI "\fBbool\fP \fBhandleEthernetframePayload\fP (\fBuint8_t\fP *\fBethernetframePayload\fP, \fBuint32_t\fP \fBsize\fP) \fBoverride\fP"
.br
.RI "Called when an IP packet is received\&. "
.ti -1c
.RI "\fBvoid\fP \fBsendInternetProtocolPacket\fP (\fBuint32_t\fP \fBdstIP_BE\fP, \fBuint8_t\fP \fBprotocol\fP, \fBconst\fP \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Sends an IP packet\&. "
.ti -1c
.RI "InternetProtocolAddress \fBGetInternetProtocolAddress\fP () \fBconst\fP"
.br
.RI "Gets the IP address of this device\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBGetMediaAccessControlAddress\fP ()"
.br
.RI "Gets the MAC address of this device\&. "
.ti -1c
.RI "\fBvoid\fP \fBconnectIPV4PayloadHandler\fP (\fBIPV4PayloadHandler\fP *\fBIPV4PayloadHandler\fP)"
.br
.RI "Connects an IP protocol payload handler\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFramePayloadHandler\fP (\fBEthernetFrameHandler\fP *\fBframeHandler\fP, \fBuint16_t\fP \fBhandledType\fP)"
.br
.RI "Construct a new Ether Frame Payload Handler object\&. "
.ti -1c
.RI "\fB~EthernetFramePayloadHandler\fP ()"
.br
.RI "Destroy the EtherFrameHandler:: EtherFrameHandler object, Removes it from the handler list\&. "
.ti -1c
.RI "\fBvoid\fP \fBSend\fP (\fBuint64_t\fP \fBdestinationMAC\fP, \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send an packet via the backend driver\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBuint16_t\fP \fBChecksum\fP (\fBconst\fP \fBuint16_t\fP *\fBdata\fP, \fBuint32_t\fP \fBlengthInBytes\fP)"
.br
.RI "Creates a checksum for the given data\&. "
.ti -1c
.RI "\fBstatic\fP InternetProtocolAddress \fBCreateInternetProtocolAddress\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.RI "Creates an IP address from four digits\&. "
.ti -1c
.RI "\fBstatic\fP InternetProtocolAddress \fBParse\fP (\fBstring\fP address)"
.br
.RI "Parses a string representation of an IP address\&. "
.ti -1c
.RI "\fBstatic\fP SubnetMask \fBCreateSubnetMask\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.RI "Creates a subnet mask from four digits\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBRegisterIPV4AddressResolver\fP (\fBIPV4AddressResolver\fP *\fBresolver\fP)"
.br
.RI "Registers an IP address resolver\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint8_t, \fBIPV4PayloadHandler\fP * > \fBIPV4PayloadHandlers\fP"
.br
.RI "Map of IP protocol numbers to their payload handlers\&. "
.ti -1c
.RI "\fBIPV4AddressResolver\fP * \fBresolver\fP = nullptr"
.br
.RI "The IP address resolver\&. "
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.RI "Stream to output error messages to\&. "
.ti -1c
.RI "InternetProtocolAddress \fBownInternetProtocolAddress\fP"
.br
.RI "The IP address of this device\&. "
.ti -1c
.RI "InternetProtocolAddress \fBdefaultGatewayInternetProtocolAddress\fP"
.br
.RI "The IP address of the default gateway\&. "
.ti -1c
.RI "SubnetMask \fBsubnetMask\fP"
.br
.RI "The subnet mask\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP * \fBframeHandler\fP"
.br
.RI "The Ethernet frame handler this payload handler is connected to\&. "
.ti -1c
.RI "uint16_t \fBhandledType\fP"
.br
.RI "The Ethernet frame type this handler handles\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBIPV4AddressResolver\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles IPv4 packets over Ethernet frames\&. 
.PP
Definition at line \fB81\fP of file \fBipv4\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InternetProtocolHandler::InternetProtocolHandler (\fBEthernetFrameHandler\fP * backend, InternetProtocolAddress ownInternetProtocolAddress, InternetProtocolAddress defaultGatewayInternetProtocolAddress, SubnetMask subnetMask, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Construct a new Internet Protocol Handler object\&. 
.PP
\fBParameters\fP
.RS 4
\fIbackend\fP The backend Ethernet frame handler\&. 
.br
\fIownInternetProtocolAddress\fP The IP address of this device\&. 
.br
\fIdefaultGatewayInternetProtocolAddress\fP The IP address of the default gateway\&. 
.br
\fIsubnetMask\fP The subnet mask\&. 
.br
\fIerrorMessages\fP Where to write error messages\&. 
.RE
.PP

.PP
Definition at line \fB107\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
108         : EthernetFramePayloadHandler(backend, 0x0800)
109 {
110     //Store vars
111     this \-> ownInternetProtocolAddress = ownInternetProtocolAddress;
112     this \-> defaultGatewayInternetProtocolAddress = defaultGatewayInternetProtocolAddress;
113     this \-> subnetMask = subnetMask;
114     this \-> errorMessages = errorMessages;
115 }
.fi

.PP
References \fBdefaultGatewayInternetProtocolAddress\fP, \fBerrorMessages\fP, \fBownInternetProtocolAddress\fP, and \fBsubnetMask\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBuint16_t\fP InternetProtocolHandler::Checksum (\fBconst\fP \fBuint16_t\fP * data, \fBuint32_t\fP lengthInBytes)\fC [static]\fP"

.PP
Creates a checksum for the given data\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to create a checksum for\&. 
.br
\fIlengthInBytes\fP The length of the data in bytes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The checksum\&. 
.RE
.PP

.PP
Definition at line \fB234\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
234                                                                                        {
235 
236     uint32_t temp = 0;                                                                             //Init sum
237 
238     for(uint32_t i = 0; i < lengthInBytes/2; i++)                                                       //Loop through data (/2 bc bytes)
239         temp += ((data[i] & 0xFF00) >> 8) | ((data[i] & 0x00FF) << 8);                             //Add data to sum in big endian
240 
241     if(lengthInBytes % 2)                                                                          //If there is an odd number of bytes
242         temp += ((uint16_t)((char*)data)[lengthInBytes\-1]) << 8;                                   //Add the last byte to the sum
243 
244     while(temp & 0xFFFF0000)                                                                       //While there is a carry
245         temp = (temp & 0xFFFF) + (temp >> 16);                                                     //Add the carry to the sum
246 
247     return ((~temp & 0xFF00) >> 8) | ((~temp & 0x00FF) << 8);
248 }
.fi

.PP
References \fBdata\fP\&.
.PP
Referenced by \fBhandleEthernetframePayload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::handleInternetProtocolPayload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::RequestEchoReply()\fP, \fBsendInternetProtocolPacket()\fP, and \fBMaxOS::net::TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::connectIPV4PayloadHandler (\fBIPV4PayloadHandler\fP * IPV4PayloadHandler)"

.PP
Connects an IP protocol payload handler\&. 
.PP
\fBParameters\fP
.RS 4
\fI\fBIPV4PayloadHandler\fP\fP The payload handler to connect\&. 
.RE
.PP

.PP
Definition at line \fB342\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
342                                                                                                {
343     IPV4PayloadHandlers\&.insert(IPV4PayloadHandler \-> ipProtocol, IPV4PayloadHandler);
344 }
.fi

.PP
References \fBIPV4PayloadHandlers\fP\&.
.PP
Referenced by \fBMaxOS::net::IPV4PayloadHandler::IPV4PayloadHandler()\fP\&.
.SS "InternetProtocolAddress InternetProtocolHandler::CreateInternetProtocolAddress (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Creates an IP address from four digits\&. 
.PP
\fBParameters\fP
.RS 4
\fIdigit1\fP The first digit\&. 
.br
\fIdigit2\fP The second digit\&. 
.br
\fIdigit3\fP The third digit\&. 
.br
\fIdigit4\fP The fourth digit\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created IP address\&. 
.RE
.PP

.PP
Definition at line \fB271\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
271                                                                                                                                              {
272     InternetProtocolAddress result = digit4;
273     result = (result << 8) | digit3;
274     result = (result << 8) | digit2;
275     result = (result << 8) | digit1;
276     return result;
277 }
.fi

.PP
Referenced by \fBCreateSubnetMask()\fP, and \fBParse()\fP\&.
.SS "SubnetMask InternetProtocolHandler::CreateSubnetMask (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Creates a subnet mask from four digits\&. 
.PP
\fBParameters\fP
.RS 4
\fIdigit1\fP The first digit\&. 
.br
\fIdigit2\fP The second digit\&. 
.br
\fIdigit3\fP The third digit\&. 
.br
\fIdigit4\fP The fourth digit\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created subnet mask\&. 
.RE
.PP

.PP
Definition at line \fB315\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
315                                                                                                                    {
316     return (SubnetMask)CreateInternetProtocolAddress(digit1, digit2, digit3, digit4);
317 }
.fi

.PP
References \fBCreateInternetProtocolAddress()\fP\&.
.SS "InternetProtocolAddress InternetProtocolHandler::GetInternetProtocolAddress () const"

.PP
Gets the IP address of this device\&. 
.PP
\fBReturns\fP
.RS 4
The IP address\&. 
.RE
.PP

.PP
Definition at line \fB324\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
324                                                                                   {
325     return ownInternetProtocolAddress;
326 }
.fi

.PP
References \fBownInternetProtocolAddress\fP\&.
.PP
Referenced by \fBMaxOS::net::TransmissionControlProtocolHandler::Connect()\fP, \fBhandleEthernetframePayload()\fP, \fBMaxOS::net::TransmissionControlProtocolHandler::Listen()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBMediaAccessControlAddress\fP InternetProtocolHandler::GetMediaAccessControlAddress ()"

.PP
Gets the MAC address of this device\&. 
.PP
\fBReturns\fP
.RS 4
The MAC address\&. 
.RE
.PP

.PP
Definition at line \fB333\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
333                                                                                 {
334     return frameHandler \-> getMAC();
335 }
.fi

.PP
References \fBMaxOS::net::EthernetFramePayloadHandler::frameHandler\fP\&.
.SS "\fBbool\fP InternetProtocolHandler::handleEthernetframePayload (\fBuint8_t\fP * ethernetframePayload, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when an IP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIethernetframePayload\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the packet is to be sent back, false otherwise\&.
.RE
.PP
\fBTodo\fP
.RS 4
Set the identifier when sending packets back 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.PP
Definition at line \fB128\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
128                                                                                                     {
129 
130     errorMessages \->write("IP: Handling packet\\n");
131 
132     //Check if the size is big enough to contain an ethernet frame
133     if(size < sizeof(IPV4Header))
134         return false;
135 
136     //Convert to struct for easier use
137     auto* ipMessage = (IPV4Header*)ethernetframePayload;
138     bool sendBack = false;
139 
140     //Only handle if it is for this device
141     if(ipMessage \-> destinationIP == GetInternetProtocolAddress())
142     {
143         uint32_t length = ipMessage \-> totalLength;                          //Get length of the message
144         if(length > size)                                               //Check if the length is bigger than the size of the message
145             length = size;                                              //If so, set length to size (this stops heartbleed attacks as it will not read past the end of the message, which the attacker could have filled with data)
146 
147         // Get the handler for the protocol
148         Map<uint8_t, IPV4PayloadHandler*>::iterator handlerIterator = IPV4PayloadHandlers\&.find(ipMessage \-> protocol);
149         if(handlerIterator != IPV4PayloadHandlers\&.end()) {
150             IPV4PayloadHandler* handler = handlerIterator \-> second;
151             if(handler != nullptr) {
152                 sendBack = handler \-> handleInternetProtocolPayload(ipMessage \-> sourceIP, ipMessage \-> destinationIP, ethernetframePayload + sizeof(IPV4Header), length \- sizeof(IPV4Header));
153             }
154         }
155 
156 
157     }
158 
159     //If the data is to be sent back again
160     if(sendBack){
161 
162         //Swap source and destination
163         uint32_t temp = ipMessage \-> destinationIP;                                                                                     //Store destination IP
164         ipMessage \-> destinationIP = ipMessage \-> sourceIP;                                                                                //Set destination IP to source IP
165         ipMessage \-> sourceIP = temp;                                                                                              //Set source IP to destination IP
166 
167         ipMessage \-> timeToLive = 0x40;                                                                                         //Reset TTL
168         ipMessage \-> checksum = Checksum((uint16_t*)ipMessage, 4 * ipMessage \-> headerLength);                  //Reset checksum as the source and destination IP have changed so has the time to live and therefore there is a different header
169 
170     }
171 
172     errorMessages \->write("IP: Handled packet\\n");
173     return sendBack;
174 }
.fi

.PP
References \fBchecksum\fP, \fBChecksum()\fP, \fBdestinationIP\fP, \fBerrorMessages\fP, \fBGetInternetProtocolAddress()\fP, \fBheaderLength\fP, \fBIPV4PayloadHandlers\fP, \fBlength\fP, \fBprotocol\fP, \fBsize\fP, \fBsourceIP\fP, \fBtimeToLive\fP, \fBtotalLength\fP, and \fBMaxOS::common::OutputStream::write()\fP\&.
.SS "InternetProtocolAddress InternetProtocolHandler::Parse (\fBstring\fP address)\fC [static]\fP"

.PP
Parses a string representation of an IP address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The string representation of the IP address\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The parsed IP address\&. 
.RE
.PP

.PP
Definition at line \fB285\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
285                                                                      {
286     uint8_t digits[4];
287 
288     uint8_t currentDigit = 0;
289     for(unsigned char & digit : digits)
290         digit = 0;
291 
292     for(int i = 0; i < address\&.length(); i++) {
293         if(address[i] == '\&.') {
294             currentDigit++;
295             continue;
296         }
297 
298         digits[currentDigit] *= 10;
299         digits[currentDigit] += address[i] \- '0';
300     }
301 
302     return CreateInternetProtocolAddress(digits[0], digits[1], digits[2], digits[3]);
303 }
.fi

.PP
References \fBCreateInternetProtocolAddress()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::RegisterIPV4AddressResolver (\fBIPV4AddressResolver\fP * resolver)\fC [protected]\fP"

.PP
Registers an IP address resolver\&. 
.PP
\fBParameters\fP
.RS 4
\fIresolver\fP The resolver to register\&. 
.RE
.PP

.PP
Definition at line \fB255\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
255                                                                                        {
256 
257     this \-> resolver = resolver;
258 
259 }
.fi

.PP
References \fBresolver\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::sendInternetProtocolPacket (\fBuint32_t\fP dstIP_BE, \fBuint8_t\fP protocol, \fBconst\fP \fBuint8_t\fP * data, \fBuint32_t\fP size)"

.PP
Sends an IP packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIdstIP_BE\fP The destination IP address\&. 
.br
\fIprotocol\fP The protocol of the IP packet\&. 
.br
\fIdata\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP

.PP
Definition at line \fB185\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
185                                                                                                                                 {
186 
187     auto* buffer = (uint8_t*)MemoryManager::kmalloc(sizeof(IPV4Header) + size);                           //Allocate memory for the message
188     auto *message = (IPV4Header*)buffer;                                                                            //Convert to struct for easier use
189 
190     message \-> version = 4;                                                                                                                           //Set version
191     message \-> headerLength = sizeof(IPV4Header)/4;                                                                                     //Set header length
192     message \-> typeOfService = 0;                                                                                                                     //Set type of service (not private)
193 
194     message \-> totalLength = size + sizeof(IPV4Header);                                                                                 //Set total length
195     message \-> totalLength = ((message \-> totalLength & 0xFF00) >> 8)                                                                                 // Convert to big endian (Swap bytes)
196                              | ((message \-> totalLength & 0x00FF) << 8);                                                                              // Convert to big endian (Swap bytes)
197 
198     message \-> identifier = 0x100;                                                                                                                    //Set identification TODO: do properly
199     message \-> flagsAndOffset = 0x0040;                                                                                                               //Set flags/offset, 0x40 because we are not fragmenting (TODO: doesnt work for packets bigger than 1500 bytes)
200 
201     message \-> timeToLive = 0x40;                                                                                                                     //Set time to live
202     message \-> protocol = protocol;                                                                                                                   //Set protocol
203 
204     message \-> destinationIP = dstIP_BE;                                                                                                                      //Set destination IP
205     message \-> sourceIP = GetInternetProtocolAddress();                                                                                                  //Set source IP
206 
207     message \-> checksum = 0;                                                                                                                          //Set checksum to 0, init with 0 as checksum funct will also add this value
208     message \-> checksum = Checksum((uint16_t*)message, sizeof(IPV4Header));                                             //Calculate checksum
209 
210     //Copy data
211     uint8_t* data_buffer = buffer + sizeof(IPV4Header);                                                                                  //Get pointer to the data
212     for(uint32_t i = 0; i < size; i++)                                                                                                                            //Loop through data
213       data_buffer[i] = data[i];                                                                                                                             //Copy data
214 
215     //Check if the destination is on the same subnet, The if condition determines if the destination device is on the same Local network as the source device \&. and if they are not on the same local network then we resolve the ip address of the gateway \&.
216     InternetProtocolAddress route = dstIP_BE;                                                                                                                               //Set route to destination IP by default
217     if((dstIP_BE & subnetMask) != (ownInternetProtocolAddress & subnetMask))                                                                                             //Check if the destination is on the same subnet
218         route = defaultGatewayInternetProtocolAddress;                                                                                                                                   //If not, set route to gateway IP
219                                                                                                                     //Print debug info
220     uint32_t MAC = resolver \->Resolve(route);
221 
222     //Send message
223     frameHandler \-> sendEthernetFrame(MAC, this \-> handledType, buffer, size + sizeof(IPV4Header));      //Send message
224     MemoryManager::kfree(buffer);                                                                                                 //Free memory
225 }
.fi

.PP
References \fBchecksum\fP, \fBChecksum()\fP, \fBdata\fP, \fBdefaultGatewayInternetProtocolAddress\fP, \fBdestinationIP\fP, \fBflagsAndOffset\fP, \fBMaxOS::net::EthernetFramePayloadHandler::frameHandler\fP, \fBGetInternetProtocolAddress()\fP, \fBMaxOS::net::EthernetFramePayloadHandler::handledType\fP, \fBheaderLength\fP, \fBidentifier\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBownInternetProtocolAddress\fP, \fBprotocol\fP, \fBMaxOS::net::IPV4AddressResolver::Resolve()\fP, \fBresolver\fP, \fBsize\fP, \fBsourceIP\fP, \fBsubnetMask\fP, \fBtimeToLive\fP, \fBtotalLength\fP, \fBtypeOfService\fP, and \fBversion\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBIPV4AddressResolver\fP\fC [friend]\fP"

.PP
Definition at line \fB83\fP of file \fBipv4\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "InternetProtocolAddress MaxOS::net::InternetProtocolHandler::defaultGatewayInternetProtocolAddress\fC [protected]\fP"

.PP
The IP address of the default gateway\&. 
.PP
Definition at line \fB93\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBcommon::OutputStream\fP* MaxOS::net::InternetProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Stream to output error messages to\&. 
.PP
Definition at line \fB90\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBhandleEthernetframePayload()\fP, and \fBInternetProtocolHandler()\fP\&.
.SS "\fBcommon::Map\fP<uint8_t, \fBIPV4PayloadHandler\fP*> MaxOS::net::InternetProtocolHandler::IPV4PayloadHandlers\fC [protected]\fP"

.PP
Map of IP protocol numbers to their payload handlers\&. 
.PP
Definition at line \fB87\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBconnectIPV4PayloadHandler()\fP, and \fBhandleEthernetframePayload()\fP\&.
.SS "InternetProtocolAddress MaxOS::net::InternetProtocolHandler::ownInternetProtocolAddress\fC [protected]\fP"

.PP
The IP address of this device\&. 
.PP
Definition at line \fB92\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBGetInternetProtocolAddress()\fP, \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "\fBIPV4AddressResolver\fP* MaxOS::net::InternetProtocolHandler::resolver = nullptr\fC [protected]\fP"

.PP
The IP address resolver\&. 
.PP
Definition at line \fB89\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBRegisterIPV4AddressResolver()\fP, and \fBsendInternetProtocolPacket()\fP\&.
.SS "SubnetMask MaxOS::net::InternetProtocolHandler::subnetMask\fC [protected]\fP"

.PP
The subnet mask\&. 
.PP
Definition at line \fB94\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsendInternetProtocolPacket()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

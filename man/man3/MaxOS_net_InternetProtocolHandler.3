.TH "MaxOS::net::InternetProtocolHandler" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::InternetProtocolHandler \- Handles IPv4 packets over Ethernet frames\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipv4\&.h>\fP
.PP
Inherits \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInternetProtocolHandler\fP (\fBEthernetFrameHandler\fP *\fBbackend\fP, \fBInternetProtocolAddress\fP \fBown_internet_protocol_address\fP, \fBInternetProtocolAddress\fP \fBdefault_gateway_internet_protocol_address\fP, \fBSubnetMask\fP \fBsubnet_mask\fP, \fBcommon::OutputStream\fP *\fBerror_messages\fP)"
.br
.RI "Construct a new Internet Protocol Handler object\&. "
.ti -1c
.RI "\fBbool\fP \fBhandle_ethernetframe_payload\fP (\fBuint8_t\fP *\fBethernetframe_payload\fP, \fBuint32_t\fP size) \fBoverride\fP"
.br
.RI "Called when an IP packet is received\&. "
.ti -1c
.RI "\fBvoid\fP \fBsend_internet_protocol_packet\fP (\fBuint32_t\fP \fBdst_ip_be\fP, \fBuint8_t\fP protocol, \fBconst\fP \fBuint8_t\fP *data, \fBuint32_t\fP size)"
.br
.RI "Sends an IP packet\&. "
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBget_internet_protocol_address\fP () \fBconst\fP"
.br
.RI "Gets the IP address of this device\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBget_media_access_control_address\fP ()"
.br
.RI "Gets the MAC address of this device\&. "
.ti -1c
.RI "\fBvoid\fP \fBconnect_ipv_4_payload_handler\fP (\fBIPV4PayloadHandler\fP *\fBipv_4_payload_handler\fP)"
.br
.RI "Connects an IP protocol payload handler\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFramePayloadHandler\fP (\fBEthernetFrameHandler\fP *\fBframe_handler\fP, \fBuint16_t\fP \fBhandled_type\fP)"
.br
.RI "Construct a new Ether Frame Payload Handler object\&. "
.ti -1c
.RI "\fB~EthernetFramePayloadHandler\fP ()"
.br
.RI "Destroy the EtherFrameHandler:: EtherFrameHandler object, Removes it from the handler list\&. "
.ti -1c
.RI "\fBvoid\fP \fBsend\fP (\fBuint64_t\fP destination, \fBuint8_t\fP *data, \fBuint32_t\fP size)"
.br
.RI "send an packet via the backend driver "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBuint16_t\fP \fBchecksum\fP (\fBconst\fP \fBuint16_t\fP *data, \fBuint32_t\fP \fBlength_in_bytes\fP)"
.br
.RI "Creates a checksum for the given data\&. "
.ti -1c
.RI "\fBstatic\fP \fBInternetProtocolAddress\fP \fBcreate_internet_protocol_address\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.RI "Creates an IP address from four digits\&. "
.ti -1c
.RI "\fBstatic\fP \fBInternetProtocolAddress\fP \fBparse\fP (\fBstring\fP address)"
.br
.RI "Parses a string representation of an IP address\&. "
.ti -1c
.RI "\fBstatic\fP \fBSubnetMask\fP \fBcreate_subnet_mask\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP)"
.br
.RI "Creates a subnet mask from four digits\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBregister_ipv_4_address_resolver\fP (\fBIPV4AddressResolver\fP *\fBipv4_resolver\fP)"
.br
.RI "Registers an IP address resolver\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint8_t, \fBIPV4PayloadHandler\fP * > \fBipv_4_payload_handlers\fP"
.br
.RI "Map of IP protocol numbers to their payload handlers\&. "
.ti -1c
.RI "\fBIPV4AddressResolver\fP * \fBresolver\fP = nullptr"
.br
.RI "The IP address resolver\&. "
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerror_messages\fP"
.br
.RI "Stream to output error messages to\&. "
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBown_internet_protocol_address\fP"
.br
.RI "The IP address of this device\&. "
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBdefault_gateway_internet_protocol_address\fP"
.br
.RI "The IP address of the default gateway\&. "
.ti -1c
.RI "\fBSubnetMask\fP \fBsubnet_mask\fP"
.br
.RI "The subnet mask\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::net::EthernetFramePayloadHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP * \fBframe_handler\fP"
.br
.RI "The Ethernet frame handler this payload handler is connected to\&. "
.ti -1c
.RI "uint16_t \fBhandled_type\fP"
.br
.RI "The Ethernet frame type this handler handles\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBIPV4AddressResolver\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles IPv4 packets over Ethernet frames\&. 
.PP
Definition at line \fB85\fP of file \fBipv4\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InternetProtocolHandler::InternetProtocolHandler (\fBEthernetFrameHandler\fP * backend, \fBInternetProtocolAddress\fP own_internet_protocol_address, \fBInternetProtocolAddress\fP default_gateway_internet_protocol_address, \fBSubnetMask\fP subnet_mask, \fBcommon::OutputStream\fP * error_messages)"

.PP
Construct a new Internet Protocol Handler object\&. 
.PP
\fBParameters\fP
.RS 4
\fIbackend\fP The backend Ethernet frame handler\&. 
.br
\fIown_internet_protocol_address\fP The IP address of this device\&. 
.br
\fIdefault_gateway_internet_protocol_address\fP The IP address of the default gateway\&. 
.br
\fIsubnet_mask\fP The subnet mask\&. 
.br
\fIerror_messages\fP Where to write error messages\&. 
.RE
.PP

.PP
Definition at line \fB110\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
111 : EthernetFramePayloadHandler(backend, 0x0800) {
112     //Store vars
113     this\->own_internet_protocol_address = own_internet_protocol_address;
114     this\->default_gateway_internet_protocol_address = default_gateway_internet_protocol_address;
115     this\->subnet_mask = subnet_mask;
116     this\->error_messages = error_messages;
117 }
.fi

.PP
References \fBdefault_gateway_internet_protocol_address\fP, \fBerror_messages\fP, \fBown_internet_protocol_address\fP, and \fBsubnet_mask\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBuint16_t\fP InternetProtocolHandler::checksum (\fBconst\fP \fBuint16_t\fP * data, \fBuint32_t\fP length_in_bytes)\fC [static]\fP"

.PP
Creates a checksum for the given data\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to create a checksum for\&. 
.br
\fIlength_in_bytes\fP The length of the data in bytes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The checksum\&. 
.RE
.PP

.PP
Definition at line \fB249\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
249                                                                                          {
250 
251     uint32_t temp = 0;                                                                             //Init sum
252 
253     for(uint32_t i = 0; i < length_in_bytes /
254                             2; i++)                                                       //Loop through data (/2 bc bytes)
255         temp += ((data[i] & 0xFF00) >> 8) |
256                 ((data[i] & 0x00FF) << 8);                             //Add data to sum in big endian
257 
258     if(length_in_bytes %
259        2)                                                                          //If there is an odd number of bytes
260         temp += ((uint16_t) ((char*) data)[length_in_bytes \- 1])
261         << 8;                                   //Add the last byte to the sum
262 
263     while(temp &
264           0xFFFF0000)                                                                       //While there is a carry
265         temp = (temp & 0xFFFF) +
266                (temp >> 16);                                                     //Add the carry to the sum
267 
268     return ((~temp & 0xFF00) >> 8) | ((~temp & 0x00FF) << 8);
269 }
.fi

.PP
Referenced by \fBhandle_ethernetframe_payload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::handle_internet_protocol_payload()\fP, \fBMaxOS::net::InternetControlMessageProtocol::request_echo_reply()\fP, \fBsend_internet_protocol_packet()\fP, and \fBMaxOS::net::TransmissionControlProtocolHandler::send_transmission_control_protocol_packet()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::connect_ipv_4_payload_handler (\fBIPV4PayloadHandler\fP * ipv_4_payload_handler)"

.PP
Connects an IP protocol payload handler\&. 
.PP
\fBParameters\fP
.RS 4
\fIipv_4_payload_handler\fP The payload handler to connect\&. 
.RE
.PP

.PP
Definition at line \fB363\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
363                                                                                                      {
364     ipv_4_payload_handlers\&.insert(ipv_4_payload_handler\->ip_protocol, ipv_4_payload_handler);
365 }
.fi

.PP
References \fBipv_4_payload_handlers\fP\&.
.PP
Referenced by \fBMaxOS::net::IPV4PayloadHandler::IPV4PayloadHandler()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::create_internet_protocol_address (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Creates an IP address from four digits\&. 
.PP
\fBParameters\fP
.RS 4
\fIdigit1\fP The first digit\&. 
.br
\fIdigit2\fP The second digit\&. 
.br
\fIdigit3\fP The third digit\&. 
.br
\fIdigit4\fP The fourth digit\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created IP address\&. 
.RE
.PP

.PP
Definition at line \fB292\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
292                                                                                                                                                 {
293     InternetProtocolAddress result = digit4;
294     result = (result << 8) | digit3;
295     result = (result << 8) | digit2;
296     result = (result << 8) | digit1;
297     return result;
298 }
.fi

.PP
Referenced by \fBcreate_subnet_mask()\fP, and \fBparse()\fP\&.
.SS "\fBSubnetMask\fP InternetProtocolHandler::create_subnet_mask (\fBuint8_t\fP digit1, \fBuint8_t\fP digit2, \fBuint8_t\fP digit3, \fBuint8_t\fP digit4)\fC [static]\fP"

.PP
Creates a subnet mask from four digits\&. 
.PP
\fBParameters\fP
.RS 4
\fIdigit1\fP The first digit\&. 
.br
\fIdigit2\fP The second digit\&. 
.br
\fIdigit3\fP The third digit\&. 
.br
\fIdigit4\fP The fourth digit\&.
.RE
.PP
\fBReturns\fP
.RS 4
The created subnet mask\&. 
.RE
.PP

.PP
Definition at line \fB336\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
336                                                                                                                      {
337     return (SubnetMask) create_internet_protocol_address(digit1, digit2, digit3, digit4);
338 }
.fi

.PP
References \fBcreate_internet_protocol_address()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::get_internet_protocol_address () const"

.PP
Gets the IP address of this device\&. 
.PP
\fBReturns\fP
.RS 4
The IP address\&. 
.RE
.PP

.PP
Definition at line \fB345\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
345                                                                                      {
346     return own_internet_protocol_address;
347 }
.fi

.PP
References \fBown_internet_protocol_address\fP\&.
.PP
Referenced by \fBMaxOS::net::TransmissionControlProtocolHandler::connect()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::connect()\fP, \fBMaxOS::net::AddressResolutionProtocol::handle_ethernetframe_payload()\fP, \fBhandle_ethernetframe_payload()\fP, \fBMaxOS::net::TransmissionControlProtocolHandler::listen()\fP, \fBMaxOS::net::UserDatagramProtocolHandler::listen()\fP, \fBMaxOS::net::AddressResolutionProtocol::request_mac_address()\fP, and \fBsend_internet_protocol_packet()\fP\&.
.SS "\fBMediaAccessControlAddress\fP InternetProtocolHandler::get_media_access_control_address ()"

.PP
Gets the MAC address of this device\&. 
.PP
\fBReturns\fP
.RS 4
The MAC address\&. 
.RE
.PP

.PP
Definition at line \fB354\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
354                                                                                     {
355     return frame_handler\->get_mac();
356 }
.fi

.PP
References \fBMaxOS::net::EthernetFramePayloadHandler::frame_handler\fP, and \fBMaxOS::net::EthernetFrameHandler::get_mac()\fP\&.
.PP
Referenced by \fBMaxOS::net::AddressResolutionProtocol::handle_ethernetframe_payload()\fP\&.
.SS "\fBbool\fP InternetProtocolHandler::handle_ethernetframe_payload (\fBuint8_t\fP * ethernetframe_payload, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when an IP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIethernetframe_payload\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the packet is to be sent back, false otherwise\&.
.RE
.PP
\fBTodo\fP
.RS 4
Set the identifier when sending packets back 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::EthernetFramePayloadHandler\fP\&.
.PP
Definition at line \fB130\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
130                                                                                                         {
131 
132     error_messages\->write("IP: Handling packet\\n");
133 
134     //Check if the size is big enough to contain an ethernet frame
135     if(size < sizeof(IPV4Header))
136         return false;
137 
138     //Convert to struct for easier use
139     auto* ip_message = (IPV4Header*) ethernetframe_payload;
140     bool send_back = false;
141 
142     //Only handle if it is for this device
143     if(ip_message\->destination_ip == get_internet_protocol_address()) {
144         uint32_t length = ip_message\->total_length;                          //Get length of the message
145         if(length >
146            size)                                               //Check if the length is bigger than the size of the message
147             length = size;                                              //If so, set length to size (this stops heartbleed attacks as it will not read past the end of the message, which the attacker could have filled with data)
148 
149         // Get the handler for the protocol
150         Map<uint8_t, IPV4PayloadHandler*>::iterator handler_iterator = ipv_4_payload_handlers\&.find(ip_message\->protocol);
151         if(handler_iterator != ipv_4_payload_handlers\&.end()) {
152             IPV4PayloadHandler* handler = handler_iterator\->second;
153             if(handler != nullptr) {
154                 send_back = handler\->handle_internet_protocol_payload(ip_message\->source_ip, ip_message\->destination_ip,
155                                                                       ethernetframe_payload + sizeof(IPV4Header),
156                                                                       length \- sizeof(IPV4Header));
157             }
158         }
159 
160 
161     }
162 
163     //If the data is to be sent back again
164     if(send_back) {
165 
166         //Swap source and destination
167         uint32_t temp = ip_message\->destination_ip;                                                                                     //Store destination IP
168         ip_message\->destination_ip = ip_message\->source_ip;                                                                                //Set destination IP to source IP
169         ip_message\->source_ip = temp;                                                                                              //Set source IP to destination IP
170 
171         ip_message\->time_to_live = 0x40;                                                                                         //Reset TTL
172         ip_message\->checksum = checksum((uint16_t*) ip_message, 4 *
173                                                                 ip_message\->header_length);                  //Reset checksum as the source and destination IP have changed so has the time to live and therefore there is a different header
174 
175     }
176 
177     error_messages\->write("IP: Handled packet\\n");
178     return send_back;
179 }
.fi

.PP
References \fBchecksum()\fP, \fBerror_messages\fP, \fBget_internet_protocol_address()\fP, \fBipv_4_payload_handlers\fP, and \fBMaxOS::common::OutputStream::write()\fP\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::parse (\fBstring\fP address)\fC [static]\fP"

.PP
Parses a string representation of an IP address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The string representation of the IP address\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The parsed IP address\&. 
.RE
.PP

.PP
Definition at line \fB306\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
306                                                                      {
307     uint8_t digits[4];
308 
309     uint8_t current_digit = 0;
310     for(unsigned char& digit : digits)
311         digit = 0;
312 
313     for(size_t i = 0; i < address\&.length(); i++) {
314         if(address[i] == '\&.') {
315             current_digit++;
316             continue;
317         }
318 
319         digits[current_digit] *= 10;
320         digits[current_digit] += address[i] \- '0';
321     }
322 
323     return create_internet_protocol_address(digits[0], digits[1], digits[2], digits[3]);
324 }
.fi

.PP
References \fBcreate_internet_protocol_address()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::register_ipv_4_address_resolver (\fBIPV4AddressResolver\fP * ipv4_resolver)\fC [protected]\fP"

.PP
Registers an IP address resolver\&. 
.PP
\fBParameters\fP
.RS 4
\fIipv4_resolver\fP The resolver to register\&. 
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
276                                                                                                 {
277 
278     this\->resolver = ipv4_resolver;
279 
280 }
.fi

.PP
References \fBresolver\fP\&.
.PP
Referenced by \fBMaxOS::net::IPV4AddressResolver::IPV4AddressResolver()\fP\&.
.SS "\fBvoid\fP InternetProtocolHandler::send_internet_protocol_packet (\fBuint32_t\fP dst_ip_be, \fBuint8_t\fP protocol, \fBconst\fP \fBuint8_t\fP * data, \fBuint32_t\fP size)"

.PP
Sends an IP packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIdst_ip_be\fP The destination IP address\&. 
.br
\fIprotocol\fP The protocol of the IP packet\&. 
.br
\fIdata\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP

.PP
Definition at line \fB190\fP of file \fBipv4\&.cpp\fP\&..PP
.nf
190                                                                                                                                     {
191 
192     auto* buffer = (uint8_t*) MemoryManager::kmalloc(
193     sizeof(IPV4Header) + size);                           //Allocate memory for the message
194     auto* message = (IPV4Header*) buffer;                                                                            //Convert to struct for easier use
195 
196     message\->version = 4;                                                                                                                           //Set version
197     message\->header_length = sizeof(IPV4Header) /
198                              4;                                                                                     //Set header length
199     message\->type_of_service = 0;                                                                                                                     //Set type of service (not private)
200 
201     message\->total_length = size +
202                             sizeof(IPV4Header);                                                                                 //Set total length
203     message\->total_length = ((message\->total_length & 0xFF00)
204     >> 8)                                                                                 // Convert to big endian (Swap bytes)
205                             | ((message\->total_length & 0x00FF)
206     << 8);                                                                              // Convert to big endian (Swap bytes)
207 
208     message\->identifier = 0x100;                                                                                                                    //Set identification TODO: do properly
209     message\->flags_and_offset = 0x0040;                                                                                                               //Set flags/offset, 0x40 because we are not fragmenting (TODO: doesnt work for packets bigger than 1500 bytes)
210 
211     message\->time_to_live = 0x40;                                                                                                                     //Set time to live
212     message\->protocol = protocol;                                                                                                                   //Set protocol
213 
214     message\->destination_ip = dst_ip_be;                                                                                                                      //Set destination IP
215     message\->source_ip = get_internet_protocol_address();                                                                                                  //Set source IP
216 
217     message\->checksum = 0;                                                                                                                          //Set checksum to 0, init with 0 as checksum funct will also add this value
218     message\->checksum = checksum((uint16_t*) message,
219                                  sizeof(IPV4Header));                                             //Calculate checksum
220 
221     //Copy data
222     uint8_t* data_buffer = buffer +
223                            sizeof(IPV4Header);                                                                                  //Get pointer to the data
224     for(uint32_t i = 0; i <
225                         size; i++)                                                                                                                            //Loop through data
226         data_buffer[i] = data[i];                                                                                                                             //Copy data
227 
228     //Check if the destination is on the same subnet, The if condition determines if the destination device is on the same Local network as the source device \&. and if they are not on the same local network then we resolve the ip address of the gateway \&.
229     InternetProtocolAddress route = dst_ip_be;                                                                                                                               //Set route to destination IP by default
230     if((dst_ip_be & subnet_mask) != (own_internet_protocol_address &
231                                      subnet_mask))                                                                                             //Check if the destination is on the same subnet
232         route = default_gateway_internet_protocol_address;                                                                                                                                   //If not, set route to gateway IP
233     //Print debug info
234     uint32_t mac = resolver\->resolve(route);
235 
236     //Send message
237     frame_handler\->send_ethernet_frame(mac, this\->handled_type, buffer, size + sizeof(IPV4Header));      //Send message
238     MemoryManager::kfree(
239     buffer);                                                                                                 //Free memory
240 }
.fi

.PP
References \fBchecksum()\fP, \fBdefault_gateway_internet_protocol_address\fP, \fBMaxOS::net::EthernetFramePayloadHandler::frame_handler\fP, \fBget_internet_protocol_address()\fP, \fBMaxOS::net::EthernetFramePayloadHandler::handled_type\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBown_internet_protocol_address\fP, \fBMaxOS::net::IPV4AddressResolver::resolve()\fP, \fBresolver\fP, \fBMaxOS::net::EthernetFrameHandler::send_ethernet_frame()\fP, and \fBsubnet_mask\fP\&.
.PP
Referenced by \fBMaxOS::net::IPV4PayloadHandler::send()\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBIPV4AddressResolver\fP\fC [friend]\fP"

.PP
Definition at line \fB87\fP of file \fBipv4\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInternetProtocolAddress\fP MaxOS::net::InternetProtocolHandler::default_gateway_internet_protocol_address\fC [protected]\fP"

.PP
The IP address of the default gateway\&. 
.PP
Definition at line \fB97\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsend_internet_protocol_packet()\fP\&.
.SS "\fBcommon::OutputStream\fP* MaxOS::net::InternetProtocolHandler::error_messages\fC [protected]\fP"

.PP
Stream to output error messages to\&. 
.PP
Definition at line \fB94\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBhandle_ethernetframe_payload()\fP, and \fBInternetProtocolHandler()\fP\&.
.SS "\fBcommon::Map\fP<uint8_t, \fBIPV4PayloadHandler\fP*> MaxOS::net::InternetProtocolHandler::ipv_4_payload_handlers\fC [protected]\fP"

.PP
Map of IP protocol numbers to their payload handlers\&. 
.PP
Definition at line \fB91\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBconnect_ipv_4_payload_handler()\fP, and \fBhandle_ethernetframe_payload()\fP\&.
.SS "\fBInternetProtocolAddress\fP MaxOS::net::InternetProtocolHandler::own_internet_protocol_address\fC [protected]\fP"

.PP
The IP address of this device\&. 
.PP
Definition at line \fB96\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBget_internet_protocol_address()\fP, \fBInternetProtocolHandler()\fP, and \fBsend_internet_protocol_packet()\fP\&.
.SS "\fBIPV4AddressResolver\fP* MaxOS::net::InternetProtocolHandler::resolver = nullptr\fC [protected]\fP"

.PP
The IP address resolver\&. 
.PP
Definition at line \fB93\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBregister_ipv_4_address_resolver()\fP, and \fBsend_internet_protocol_packet()\fP\&.
.SS "\fBSubnetMask\fP MaxOS::net::InternetProtocolHandler::subnet_mask\fC [protected]\fP"

.PP
The subnet mask\&. 
.PP
Definition at line \fB98\fP of file \fBipv4\&.h\fP\&.
.PP
Referenced by \fBInternetProtocolHandler()\fP, and \fBsend_internet_protocol_packet()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

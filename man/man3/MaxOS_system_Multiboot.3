.TH "MaxOS::system::Multiboot" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::system::Multiboot \- Parses and provides access to \fBMultiboot\fP 2 information\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <multiboot\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMultiboot\fP (\fBunsigned\fP \fBlong\fP address, \fBunsigned\fP \fBlong\fP magic)"
.br
.RI "Constructor for the \fBMultiboot\fP class\&. Parses the multiboot info struct and loads the tags\&. "
.ti -1c
.RI "\fBmultiboot_tag_framebuffer\fP * \fBframebuffer\fP ()"
.br
.RI "Get the framebuffer tag\&. "
.ti -1c
.RI "\fBmultiboot_tag_basic_meminfo\fP * \fBbasic_meminfo\fP ()"
.br
.RI "Get the basic memory info tag\&. "
.ti -1c
.RI "\fBmultiboot_tag_string\fP * \fBbootloader_name\fP ()"
.br
.RI "Get the bootloader name tag\&. "
.ti -1c
.RI "\fBmultiboot_tag_mmap\fP * \fBmmap\fP ()"
.br
.RI "Get the module tag\&. "
.ti -1c
.RI "\fBmultiboot_tag_old_acpi\fP * \fBold_acpi\fP ()"
.br
.RI "Get the old ACPI tag\&. "
.ti -1c
.RI "\fBmultiboot_tag_new_acpi\fP * \fBnew_acpi\fP ()"
.br
.RI "Get the new ACPI tag\&. "
.ti -1c
.RI "\fBmultiboot_tag\fP * \fBstart_tag\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_reserved\fP (multiboot_uint64_t address) \fBconst\fP"
.br
.RI "Check if an address is reserved by a multiboot module\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "unsigned long \fBstart_address\fP"
.br
.RI "The start address of the multiboot info struct\&. "
.ti -1c
.RI "unsigned long \fBend_address\fP"
.br
.RI "The end address of the multiboot info struct\&. "
.in -1c
.SH "Detailed Description"
.PP 
Parses and provides access to \fBMultiboot\fP 2 information\&. 
.PP
Definition at line \fB518\fP of file \fBmultiboot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Multiboot::Multiboot (\fBunsigned\fP \fBlong\fP address, \fBunsigned\fP \fBlong\fP magic)"

.PP
Constructor for the \fBMultiboot\fP class\&. Parses the multiboot info struct and loads the tags\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the multiboot info struct 
.br
\fImagic\fP The magic number to confirm the bootloader 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
25 : start_address(address)
26 {
27 
28     // Confirm the bootloader
29     ASSERT(magic == MULTIBOOT2_BOOTLOADER_MAGIC, "Multiboot2 Bootloader Not Detected");
30     Logger::DEBUG() << "Multiboot2 Bootloader Detected at 0x" << (uint64_t) address << "\\n";
31 
32     multiboot_tag* tag = start_tag();
33 
34     // Loop through the tags and load them
35     while (true) {
36 
37         // Handle the tag
38         switch (tag\->type) {
39 
40             case MULTIBOOT_TAG_TYPE_END:
41                 end_address = (unsigned long) PhysicalMemoryManager::to_lower_region((uint64_t) tag);
42                 return;
43 
44             case MULTIBOOT_TAG_TYPE_FRAMEBUFFER:
45                 m_framebuffer = (multiboot_tag_framebuffer*) tag;
46                 break;
47 
48             case MULTIBOOT_TAG_TYPE_BASIC_MEMINFO:
49                 m_basic_meminfo = (multiboot_tag_basic_meminfo*) tag;
50                 break;
51 
52             case MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME:
53                 m_bootloader_name = (multiboot_tag_string*) tag;
54                 Logger::DEBUG() << "Bootloader: " << m_bootloader_name\->string << "\\n";
55                 break;
56 
57             case MULTIBOOT_TAG_TYPE_BOOTDEV:
58                 multiboot_tag_bootdev* bootdev;
59                 bootdev = (multiboot_tag_bootdev*) tag;
60                 Logger::DEBUG() << "Boot device: drive=0x" << (uint64_t) bootdev\->biosdev << ", partition=0x" << (uint64_t) bootdev\->part << "\\n";
61                 break;
62 
63             case MULTIBOOT_TAG_TYPE_MMAP:
64 
65                 // If there is not already a mmap tag, set it
66                 if (m_mmap == nullptr)
67                     m_mmap = (multiboot_tag_mmap*) tag;
68 
69                 break;
70 
71             case MULTIBOOT_TAG_TYPE_ACPI_OLD:
72                 m_old_acpi = (multiboot_tag_old_acpi*) tag;
73                 break;
74 
75 
76             case MULTIBOOT_TAG_TYPE_ACPI_NEW:
77                 m_new_acpi = (multiboot_tag_new_acpi*) tag;
78                 break;
79 
80             case MULTIBOOT_TAG_TYPE_MODULE:
81                 multiboot_tag_module* module;
82                 module = (multiboot_tag_module*) tag;
83                 Logger::DEBUG() << "Module: start=0x" << (uint64_t) module\->mod_start << ", end=0x" << (uint64_t) module\->mod_end << ", cmdline=" << module\->cmdline << "\\n";
84                 m_module = module;
85                 break;
86         }
87 
88         // Move to the next tag
89         tag = (struct multiboot_tag*) ((multiboot_uint8_t*) tag + ((tag\->size + 7) & ~7));
90     }
91 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBend_address\fP, \fBstart_tag()\fP, \fBmultiboot_tag_string::string\fP, and \fBMaxOS::memory::PhysicalMemoryManager::to_lower_region()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBmultiboot_tag_basic_meminfo\fP * Multiboot::basic_meminfo ()"

.PP
Get the basic memory info tag\&. 
.PP
\fBReturns\fP
.RS 4
The basic memory info tag 
.RE
.PP

.PP
Definition at line \fB108\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
108                                                       {
109 
110     return m_basic_meminfo;
111 }
.fi

.SS "\fBmultiboot_tag_string\fP * Multiboot::bootloader_name ()"

.PP
Get the bootloader name tag\&. 
.PP
\fBReturns\fP
.RS 4
The bootloader name tag 
.RE
.PP

.PP
Definition at line \fB117\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
117                                                  {
118 
119     return m_bootloader_name;
120 }
.fi

.SS "\fBmultiboot_tag_framebuffer\fP * Multiboot::framebuffer ()"

.PP
Get the framebuffer tag\&. 
.PP
\fBReturns\fP
.RS 4
The framebuffer tag 
.RE
.PP

.PP
Definition at line \fB99\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
99                                                   {
100 
101     return m_framebuffer;
102 }
.fi

.SS "\fBbool\fP Multiboot::is_reserved (multiboot_uint64_t address) const"

.PP
Check if an address is reserved by a multiboot module\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is reserved 
.RE
.PP

.PP
Definition at line \fB154\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
154                                                             {
155 
156     // Loop through the tags checking if the address is reserved
157     for (multiboot_tag* tag = start_tag(); tag\->type != MULTIBOOT_TAG_TYPE_END; tag = (struct multiboot_tag*) ((multiboot_uint8_t*) tag + ((tag\->size + 7) & ~7))) {
158 
159         // Check if the tag is a module or mmap
160         if (tag\->type != MULTIBOOT_TAG_TYPE_MODULE && tag\->type != MULTIBOOT_TAG_TYPE_MMAP)
161             continue;
162 
163         // Get the module tag
164         auto* module = (struct multiboot_tag_module*) tag;
165 
166         // Check if the address is within the module
167         if (address >= module\->mod_start && address < module\->mod_end)
168             return true;
169     }
170 
171 
172     // Not part of multiboot
173     return false;
174 
175 }
.fi

.PP
References \fBstart_tag()\fP\&.
.SS "\fBmultiboot_tag_mmap\fP * Multiboot::mmap ()"

.PP
Get the module tag\&. 
.PP
\fBReturns\fP
.RS 4
The module tag 
.RE
.PP

.PP
Definition at line \fB126\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
126                                     {
127 
128     return m_mmap;
129 }
.fi

.PP
Referenced by \fBMaxOS::memory::PhysicalMemoryManager::PhysicalMemoryManager()\fP\&.
.SS "\fBmultiboot_tag_new_acpi\fP * Multiboot::new_acpi ()"

.PP
Get the new ACPI tag\&. 
.PP
\fBReturns\fP
.RS 4
The new ACPI tag 
.RE
.PP

.PP
Definition at line \fB144\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
144                                             {
145 
146     return m_new_acpi;
147 }
.fi

.SS "\fBmultiboot_tag_old_acpi\fP * Multiboot::old_acpi ()"

.PP
Get the old ACPI tag\&. 
.PP
\fBReturns\fP
.RS 4
The old ACPI tag 
.RE
.PP

.PP
Definition at line \fB135\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
135                                             {
136 
137     return m_old_acpi;
138 }
.fi

.SS "\fBmultiboot_tag\fP * Multiboot::start_tag () const"
Get the start tag of the multiboot information (useful for iterating through the tags)
.PP
\fBReturns\fP
.RS 4
The start tag 
.RE
.PP

.PP
Definition at line \fB182\fP of file \fBmultiboot\&.cpp\fP\&..PP
.nf
182                                           {
183 
184     return (multiboot_tag*) (start_address + HIGHER_HALF_KERNEL_OFFSET + 8);
185 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_KERNEL_OFFSET\fP, and \fBstart_address\fP\&.
.PP
Referenced by \fBis_reserved()\fP, \fBMaxOS::processes::GlobalScheduler::load_multiboot_elfs()\fP, and \fBMultiboot()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "unsigned long MaxOS::system::Multiboot::end_address"

.PP
The end address of the multiboot info struct\&. 
.PP
Definition at line \fB540\fP of file \fBmultiboot\&.h\fP\&.
.PP
Referenced by \fBMultiboot()\fP\&.
.SS "unsigned long MaxOS::system::Multiboot::start_address"

.PP
The start address of the multiboot info struct\&. 
.PP
Definition at line \fB539\fP of file \fBmultiboot\&.h\fP\&.
.PP
Referenced by \fBstart_tag()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::SharedMessageEndpoint" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::SharedMessageEndpoint
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipc\&.h>\fP
.PP
Inherits \fBMaxOS::processes::Resource\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSharedMessageEndpoint\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBsize_t\fP \fBsize\fP, \fBresource_type_t\fP \fBtype\fP)"
.br
.ti -1c
.RI "\fB~SharedMessageEndpoint\fP () \fBfinal\fP"
.br
.ti -1c
.RI "\fBint\fP \fBread\fP (\fBvoid\fP *buffer, \fBsize_t\fP \fBsize\fP, \fBsize_t\fP \fBflags\fP) \fBfinal\fP"
.br
.RI "Reads the first message from the endpoint or will yield until a message has been written\&. "
.ti -1c
.RI "\fBint\fP \fBwrite\fP (\fBconst\fP \fBvoid\fP *buffer, \fBsize_t\fP \fBsize\fP, \fBsize_t\fP \fBflags\fP) \fBfinal\fP"
.br
.RI "Handles writing to the message endpoint resource by writing the buffer as a message\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::processes::Resource\fP
.in +1c
.ti -1c
.RI "\fBResource\fP (const \fBstring\fP &\fBname\fP, size_t \fBflags\fP, \fBresource_type_t\fP \fBtype\fP)"
.br
.ti -1c
.RI "virtual \fB~Resource\fP ()"
.br
.ti -1c
.RI "\fBstring\fP \fBname\fP ()"
.br
.RI "Gets the name of this resource\&. "
.ti -1c
.RI "\fBresource_type_t\fP \fBtype\fP ()"
.br
.RI "Gets the type of this resource\&. "
.ti -1c
.RI "virtual void \fBopen\fP (size_t \fBflags\fP)"
.br
.RI "Opens the resource\&. "
.ti -1c
.RI "virtual void \fBclose\fP (size_t \fBflags\fP)"
.br
.RI "Closes the resource\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB45\fP of file \fBipc\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SharedMessageEndpoint::SharedMessageEndpoint (\fBconst\fP \fBstring\fP & name, \fBsize_t\fP size, \fBresource_type_t\fP type)"

.PP
Definition at line \fB96\fP of file \fBipc\&.cpp\fP\&..PP
.nf
97 : Resource(name, size, type)
98 {
99 
100 }
.fi

.SS "SharedMessageEndpoint::~SharedMessageEndpoint ()\fC [final]\fP"

.PP
Definition at line \fB102\fP of file \fBipc\&.cpp\fP\&..PP
.nf
102                                               {
103 
104     // Free the messages
105     for(auto& message : m_queue)
106         delete message;
107 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBint\fP SharedMessageEndpoint::read (\fBvoid\fP * buffer, \fBsize_t\fP size, \fBsize_t\fP flags)\fC [final]\fP, \fC [virtual]\fP"

.PP
Reads the first message from the endpoint or will yield until a message has been written\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Where to write the message to 
.br
\fIsize\fP Max size of the message to be read 
.RE
.PP
\fBReturns\fP
.RS 4
The amount of bytes read 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::processes::Resource\fP\&.
.PP
Definition at line \fB118\fP of file \fBipc\&.cpp\fP\&..PP
.nf
118                                                                        {
119 
120     // Wait for a message
121     if(m_queue\&.empty())
122         return \-1 * (int)resource_error_base_t::SHOULD_BLOCK;
123 
124     // Read the message into the buffer
125     buffer_t* message = m_queue\&.pop_front();
126     size_t readable = size > message\->capacity() ? message\->capacity() : size;
127     memcpy(buffer, message \-> raw(), readable);
128 
129     return readable;
130 }
.fi

.PP
References \fBmemcpy()\fP, and \fBsize\fP\&.
.SS "\fBint\fP SharedMessageEndpoint::write (\fBconst\fP \fBvoid\fP * buffer, \fBsize_t\fP size, \fBsize_t\fP flags)\fC [final]\fP, \fC [virtual]\fP"

.PP
Handles writing to the message endpoint resource by writing the buffer as a message\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The message to write to the endpoint 
.br
\fIsize\fP The size of the message 
.RE
.PP
\fBReturns\fP
.RS 4
The amount of bytes written 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::processes::Resource\fP\&.
.PP
Definition at line \fB139\fP of file \fBipc\&.cpp\fP\&..PP
.nf
139                                                                               {
140 
141     m_message_lock\&.lock();
142 
143     // Create the message
144     auto* new_message = new buffer_t(size);
145     new_message\->copy_from(buffer, size);
146     m_queue\&.push_back(new_message);
147 
148     m_message_lock\&.unlock();
149     return size;
150 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, \fBsize\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

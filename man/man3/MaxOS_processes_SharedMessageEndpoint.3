.TH "MaxOS::processes::SharedMessageEndpoint" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::SharedMessageEndpoint \- A endpoint that allows processes to queue messages on\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipc\&.h>\fP
.PP
Inherits \fBMaxOS::processes::Resource\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSharedMessageEndpoint\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBsize_t\fP size, \fBresource_type_t\fP \fBtype\fP)"
.br
.RI "Creates a new shared message endpoint\&. "
.ti -1c
.RI "\fB~SharedMessageEndpoint\fP () \fBfinal\fP"
.br
.RI "Destroys the shared message endpoint and frees all messages\&. "
.ti -1c
.RI "\fBint\fP \fBread\fP (\fBvoid\fP *buffer, \fBsize_t\fP size, \fBsize_t\fP flags) \fBfinal\fP"
.br
.RI "Reads the first message from the endpoint or will yield until a message has been written\&. "
.ti -1c
.RI "\fBint\fP \fBwrite\fP (\fBconst\fP \fBvoid\fP *buffer, \fBsize_t\fP size, \fBsize_t\fP flags) \fBfinal\fP"
.br
.RI "Handles writing to the message endpoint resource by writing the buffer as a message\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::processes::Resource\fP
.in +1c
.ti -1c
.RI "\fBResource\fP (const \fBstring\fP &\fBname\fP, size_t flags, \fBresource_type_t\fP \fBtype\fP)"
.br
.RI "Constructs a new \fBResource\fP object\&. "
.ti -1c
.RI "\fBstring\fP \fBname\fP ()"
.br
.RI "Gets the name of this resource\&. "
.ti -1c
.RI "\fBresource_type_t\fP \fBtype\fP ()"
.br
.RI "Gets the type of this resource\&. "
.ti -1c
.RI "virtual void \fBopen\fP (size_t flags)"
.br
.RI "Opens the resource\&. "
.ti -1c
.RI "virtual void \fBclose\fP (size_t flags)"
.br
.RI "Closes the resource\&. "
.in -1c
.SH "Detailed Description"
.PP 
A endpoint that allows processes to queue messages on\&. 
.PP
Definition at line \fB54\fP of file \fBipc\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SharedMessageEndpoint::SharedMessageEndpoint (\fBconst\fP \fBstring\fP & name, \fBsize_t\fP size, \fBresource_type_t\fP type)"

.PP
Creates a new shared message endpoint\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the endpoint 
.br
\fIsize\fP The size of messages that can be sent 
.br
\fItype\fP The type of resource 
.RE
.PP

.PP
Definition at line \fB112\fP of file \fBipc\&.cpp\fP\&..PP
.nf
113 : Resource(name, size, type)
114 {
115 
116 }
.fi

.SS "SharedMessageEndpoint::~SharedMessageEndpoint ()\fC [final]\fP"

.PP
Destroys the shared message endpoint and frees all messages\&. 
.PP
Definition at line \fB121\fP of file \fBipc\&.cpp\fP\&..PP
.nf
121                                               {
122 
123     // Free the messages
124     for(auto& message : m_queue)
125         delete message;
126 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBint\fP SharedMessageEndpoint::read (\fBvoid\fP * buffer, \fBsize_t\fP size, \fBsize_t\fP flags)\fC [final]\fP, \fC [virtual]\fP"

.PP
Reads the first message from the endpoint or will yield until a message has been written\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Where to write the message to 
.br
\fIsize\fP Max size of the message to be read 
.br
\fIflags\fP Unused 
.RE
.PP
\fBReturns\fP
.RS 4
The amount of bytes read 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::processes::Resource\fP\&.
.PP
Definition at line \fB136\fP of file \fBipc\&.cpp\fP\&..PP
.nf
136                                                                        {
137 
138     // Wait for a message
139     if(m_queue\&.empty())
140         return \-1 * (int)resource_error_base_t::SHOULD_BLOCK;
141 
142     // Read the message into the buffer
143     buffer_t* message = m_queue\&.pop_front();
144     size_t readable = size > message\->capacity() ? message\->capacity() : size;
145     memcpy(buffer, message \-> raw(), readable);
146 
147     return readable;
148 }
.fi

.PP
References \fBmemcpy()\fP\&.
.SS "\fBint\fP SharedMessageEndpoint::write (\fBconst\fP \fBvoid\fP * buffer, \fBsize_t\fP size, \fBsize_t\fP flags)\fC [final]\fP, \fC [virtual]\fP"

.PP
Handles writing to the message endpoint resource by writing the buffer as a message\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The message to write to the endpoint 
.br
\fIsize\fP The size of the message 
.br
\fIflags\fP Unused 
.RE
.PP
\fBReturns\fP
.RS 4
The amount of bytes written 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::processes::Resource\fP\&.
.PP
Definition at line \fB158\fP of file \fBipc\&.cpp\fP\&..PP
.nf
158                                                                               {
159 
160     m_message_lock\&.lock();
161 
162     // Create the message
163     auto* new_message = new buffer_t(size);
164     new_message\->copy_from(buffer, size);
165     m_queue\&.push_back(new_message);
166 
167     m_message_lock\&.unlock();
168     return size;
169 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

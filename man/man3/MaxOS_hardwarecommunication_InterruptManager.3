.TH "MaxOS::hardwarecommunication::InterruptManager" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptManager \- Handles all interrupts and passes them to the correct handler\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBset_interrupt_handler\fP (\fBuint8_t\fP interrupt, \fBInterruptHandler\fP *\fBhandler\fP)"
.br
.RI "Sets the interrupt handler for the interrupt\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_interrupt_handler\fP (\fBuint8_t\fP interrupt)"
.br
.RI "Removes the interrupt handler for the interrupt\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_apic\fP (\fBAdvancedProgrammableInterruptController\fP *apic)"
.br
.RI "Sets the APIC\&. "
.ti -1c
.RI "\fBAdvancedProgrammableInterruptController\fP * \fBactive_apic\fP ()"
.br
.RI "Gets the APIC\&. "
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP ()"
.br
.RI "Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) "
.ti -1c
.RI "\fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "Deactivates the interrupt manager and stops interrupts\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBInterruptManager\fP * \fBactive_interrupt_manager\fP ()"
.br
.RI "Gets the active interrupt manager\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBload_current\fP ()"
.br
.RI "Tell the processor to use the current \fBInterruptManager\fP\&. "
.ti -1c
.RI "static void \fBForceInterruptReturn\fP (system::cpu_status_t *\fBstate\fP)"
.br
.RI "Force the CPU to return from an interrupt (see interrupts\&.s) "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "system::cpu_status_t * \fBhandle_interrupt_request\fP (system::cpu_status_t *status)"
.br
.RI "Handles the interrupt request by passing it to the appropriate handler\&. "
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBset_interrupt_descriptor_table_entry\fP (\fBuint8_t\fP interrupt, \fBvoid\fP(*\fBhandler\fP)(), \fBuint8_t\fP \fBdescriptor_privilege_level\fP)"
.br
.RI "Sets an entry in the Interrupt Descriptor Table\&. "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x00\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x01\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x02\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x03\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x04\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x05\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x06\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x07\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x08\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x09\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x80\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x31\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x60\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x00\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x01\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x02\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x03\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x04\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x05\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x06\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x07\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x08\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x09\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x0F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x10\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x11\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x12\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x13\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x14\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x15\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x16\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x17\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x18\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x19\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "\fBstatic\fP system::cpu_status_t * \fBHandleInterrupt\fP (system::cpu_status_t *status)"
.br
.RI "Handles the interrupt request by passing it to the interrupt manager\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP * \fBm_interrupt_handlers\fP [\fBMAX_INTERRUPT_HANDLERS\fP] = {}"
.br
.RI "A map of index-to-interrupt of interrupt handlers to fire when an interrupt occurs\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBInterruptManager\fP * \fBs_active_interrupt_manager\fP = nullptr"
.br
.RI "The interrupt manger that is currently handling interrupts and is loaded into the \fBIDTR\fP\&. "
.ti -1c
.RI "static \fBInterruptDescriptor\fP \fBs_interrupt_descriptor_table\fP [\fBMAX_INTERRUPT_HANDLERS\fP] = {}"
.br
.RI "The Interrupt Descriptor Table (IDT) "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInterruptHandler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles all interrupts and passes them to the correct handler\&. 


.PP
\fBTodo\fP
.RS 4
Remove the max array of handler make vector, add static handlers for page faults and gpe\&. Make it so that multiple handlers can be registered for the same interrupt 
.PP
Have a single stub so that we don't need to have 256 different functions for each interrupt 
.RE
.PP

.PP
Definition at line \fB78\fP of file \fBinterrupts\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptManager::InterruptManager ()"

.PP
Definition at line \fB85\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
85                                    {
86 
87     Logger::INFO() << "Setting up Interrupt Manager\\n";
88     s_active_interrupt_manager = this;
89 
90     // Clear the table
91     for (auto& descriptor: s_interrupt_descriptor_table) {
92         descriptor\&.address_low_bits = 0;
93         descriptor\&.address_mid_bits = 0;
94         descriptor\&.address_high_bits = 0;
95         descriptor\&.segment_selector = 0;
96         descriptor\&.ist = 0;
97         descriptor\&.flags = 0;
98     }
99 
100     //Set Up the base interrupts
101     set_interrupt_descriptor_table_entry(0x00, &HandleException0x00, 0);   // Division by zero
102     set_interrupt_descriptor_table_entry(0x01, &HandleException0x01, 0);   // Debug
103     set_interrupt_descriptor_table_entry(0x02, &HandleException0x02, 0);   // Non\-maskable interrupt
104     set_interrupt_descriptor_table_entry(0x03, &HandleException0x03, 0);   // Breakpoint
105     set_interrupt_descriptor_table_entry(0x04, &HandleException0x04, 0);   // Overflow
106     set_interrupt_descriptor_table_entry(0x05, &HandleException0x05, 0);   // Bound Range Exceeded
107     set_interrupt_descriptor_table_entry(0x06, &HandleException0x06, 0);   // Invalid Opcode
108     set_interrupt_descriptor_table_entry(0x06, &HandleException0x07, 0);   // Device Not Available
109     set_interrupt_descriptor_table_entry(0x08, &HandleInterruptError0x08, 0);   // Double Fault
110     set_interrupt_descriptor_table_entry(0x09, &HandleException0x09, 0);   // Coprocessor Segment Overrun
111     set_interrupt_descriptor_table_entry(0x0A, &HandleInterruptError0x0A, 0);   // Invalid TSS
112     set_interrupt_descriptor_table_entry(0x0B, &HandleInterruptError0x0B, 0);   // Segment Not Present
113     set_interrupt_descriptor_table_entry(0x0C, &HandleInterruptError0x0C, 0);   // Stack\-Segment Fault
114     set_interrupt_descriptor_table_entry(0x0D, &HandleInterruptError0x0D, 0);   // General Protection Fault
115     set_interrupt_descriptor_table_entry(0x0E, &HandleInterruptError0x0E, 0);   // Page Fault
116     set_interrupt_descriptor_table_entry(0x0F, &HandleException0x0F, 0);   // Reserved
117     set_interrupt_descriptor_table_entry(0x10, &HandleException0x10, 0);   // x87 Floating\-Point Exception
118     set_interrupt_descriptor_table_entry(0x11, &HandleInterruptError0x11, 0);   // Alignment Check
119     set_interrupt_descriptor_table_entry(0x12, &HandleException0x12, 0);   // Machine Check
120     set_interrupt_descriptor_table_entry(0x13, &HandleException0x13, 0);   // SIMD Floating\-Point Exception
121     set_interrupt_descriptor_table_entry(0x14, &HandleException0x14, 0);   // Reserved: Virtualization Exception
122     set_interrupt_descriptor_table_entry(0x15, &HandleException0x15, 0);   // Reserved
123     set_interrupt_descriptor_table_entry(0x16, &HandleException0x16, 0);   // Reserved
124     set_interrupt_descriptor_table_entry(0x17, &HandleException0x17, 0);   // Reserved
125     set_interrupt_descriptor_table_entry(0x18, &HandleException0x18, 0);   // Reserved
126     set_interrupt_descriptor_table_entry(0x19, &HandleException0x19, 0);   // Reserved
127     set_interrupt_descriptor_table_entry(0x1A, &HandleException0x1A, 0);   // Reserved
128     set_interrupt_descriptor_table_entry(0x1B, &HandleException0x1B, 0);   // Reserved
129     set_interrupt_descriptor_table_entry(0x1C, &HandleException0x1C, 0);   // Reserved
130     set_interrupt_descriptor_table_entry(0x1D, &HandleException0x1D, 0);   // Reserved
131     set_interrupt_descriptor_table_entry(0x1E, &HandleException0x1E, 0);   // Security Exception
132     set_interrupt_descriptor_table_entry(0x1F, &HandleException0x1F, 0);   // Reserved
133 
134     // Set up the hardware interrupts
135     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x00, &HandleInterruptRequest0x00, 0);   // APIC Timer Interrupt
136     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x01, &HandleInterruptRequest0x01, 0);   // Keyboard Interrupt
137     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x02, &HandleInterruptRequest0x02, 0);   // PIT Interrupt
138     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x0C, &HandleInterruptRequest0x0C, 0);   // Mouse Interrupt
139 
140     // Set up the system call interrupt
141     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x60, &HandleInterruptRequest0x60, 3);   // System Call Interrupt \- Privilege Level 3 so that user space can call it
142 
143     // Tell the processor to use the IDT
144     load_current();
145 }
.fi

.SS "InterruptManager::~InterruptManager ()"

.PP
Definition at line \fB147\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
147                                     {
148     deactivate();
149 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InterruptManager::activate ()"

.PP
Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) 
.PP
Definition at line \fB193\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
193                                 {
194 
195     Logger::INFO() << "Activating Interrupts \\n";
196 
197     // Deactivate the current (old) interrupt manager
198     if (s_active_interrupt_manager != nullptr)
199         s_active_interrupt_manager\->deactivate();
200 
201     // Set the current interrupt manager and start interrupts
202     s_active_interrupt_manager = this;
203     asm("sti");
204 }
.fi

.PP
References \fBLogger::INFO()\fP, and \fBs_active_interrupt_manager\fP\&.
.SS "\fBAdvancedProgrammableInterruptController\fP * InterruptManager::active_apic ()"

.PP
Gets the APIC\&. 
.PP
\fBReturns\fP
.RS 4
The APIC 
.RE
.PP

.PP
Definition at line \fB375\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
375                                                                        {
376 
377     return m_apic;
378 }
.fi

.SS "\fBInterruptManager\fP * InterruptManager::active_interrupt_manager ()\fC [static]\fP"

.PP
Gets the active interrupt manager\&. 
.PP
\fBReturns\fP
.RS 4
The active interrupt manager 
.RE
.PP

.PP
Definition at line \fB385\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
385                                                              {
386 
387     return s_active_interrupt_manager;
388 }
.fi

.PP
References \fBs_active_interrupt_manager\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\fP\&.
.SS "\fBvoid\fP InterruptManager::deactivate ()"

.PP
Deactivates the interrupt manager and stops interrupts\&. 
.PP
Definition at line \fB209\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
209                                   {
210 
211     // Cant deactivate if it isn't the system one
212     if (s_active_interrupt_manager != nullptr)
213         return;
214 
215     // Prevent interrupts from firing when nothing is set up to handle them
216     asm("cli");
217     s_active_interrupt_manager = nullptr;
218 }
.fi

.PP
References \fBs_active_interrupt_manager\fP\&.
.SS "\fBcpu_status_t\fP * InterruptManager::handle_interrupt_request (system::cpu_status_t * status)\fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the appropriate handler\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current cpu status 
.RE
.PP
\fBReturns\fP
.RS 4
The updated cpu status 
.RE
.PP

.PP
Definition at line \fB277\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
277                                                                              {
278 
279     // Where to go afterward
280     cpu_status_t* new_status = status;
281 
282     // If there is an interrupt manager, handle the interrupt
283     if (m_interrupt_handlers[status\->interrupt_number] != nullptr)
284         new_status = m_interrupt_handlers[status\->interrupt_number]\->handle_interrupt(status);
285     else
286         Logger::WARNING() << "Interrupt " << (int) status\->interrupt_number << " not handled\\n";
287 
288     // Send the EOI to the APIC
289     if (HARDWARE_INTERRUPT_OFFSET <= status\->interrupt_number && status\->interrupt_number < HARDWARE_INTERRUPT_OFFSET + 16)
290         CPU::executing_core()\->local_apic\->send_eoi();
291 
292     // Return the status
293     return new_status;
294 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP, \fBMaxOS::hardwarecommunication::InterruptHandler::handle_interrupt()\fP, \fBMaxOS::hardwarecommunication::HARDWARE_INTERRUPT_OFFSET\fP, \fBm_interrupt_handlers\fP, and \fBLogger::WARNING()\fP\&.
.SS "system::cpu_status_t * InterruptManager::HandleInterrupt (system::cpu_status_t * status)\fC [static]\fP, \fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the interrupt manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current cpu status 
.RE
.PP
\fBReturns\fP
.RS 4
The updated cpu status 
.RE
.PP

.PP
Definition at line \fB226\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
226                                                                                 {
227 
228     // Default Fault Handlers
229     switch (status\->interrupt_number) {
230 
231         case 0x7:
232             CPU::PANIC("Device Not Available: FPU Not Enabled", status);
233             break;
234 
235         case 0x0D:
236             return general_protection_fault(status);
237 
238         case 0x0E:
239             return page_fault(status);
240     }
241 
242     // If there is an interrupt manager handle interrupt
243     if (s_active_interrupt_manager != nullptr)
244         return s_active_interrupt_manager\->handle_interrupt_request(status);
245 
246     // CPU Can continue
247     return status;
248 }
.fi

.PP
References \fBMaxOS::system::CPU::PANIC()\fP, and \fBs_active_interrupt_manager\fP\&.
.SS "\fBvoid\fP InterruptManager::load_current ()\fC [static]\fP"

.PP
Tell the processor to use the current \fBInterruptManager\fP\&. 
.PP
Definition at line \fB182\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
182                                     {
183 
184     IDTR idt = {};
185     idt\&.limit = 256 * sizeof(InterruptDescriptor) \- 1;
186     idt\&.base = (uint64_t) s_interrupt_descriptor_table;
187     asm volatile("lidt %0" : : "m" (idt));
188 }
.fi

.PP
References \fBs_interrupt_descriptor_table\fP\&.
.PP
Referenced by \fBMaxOS::system::Core::init()\fP\&.
.SS "\fBvoid\fP InterruptManager::remove_interrupt_handler (\fBuint8_t\fP interrupt)"

.PP
Removes the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.RE
.PP

.PP
Definition at line \fB266\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
266                                                                  {
267 
268     m_interrupt_handlers[interrupt] = nullptr;
269 }
.fi

.PP
References \fBm_interrupt_handlers\fP\&.
.SS "\fBvoid\fP InterruptManager::set_apic (\fBAdvancedProgrammableInterruptController\fP * apic)"

.PP
Sets the APIC\&. 
.PP
\fBParameters\fP
.RS 4
\fIapic\fP The APIC 
.RE
.PP

.PP
Definition at line \fB301\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
301                                                                              {
302 
303     m_apic = apic;
304 }
.fi

.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\fP\&.
.SS "\fBvoid\fP InterruptManager::set_interrupt_descriptor_table_entry (\fBuint8_t\fP interrupt, \fBvoid\fP(*)() handler, \fBuint8_t\fP descriptor_privilege_level)\fC [static]\fP, \fC [protected]\fP"

.PP
Sets an entry in the Interrupt Descriptor Table\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP Interrupt number 
.br
\fIhandler\fP Interrupt Handler 
.br
\fIdescriptor_privilege_level\fP Descriptor Privilege Level 
.RE
.PP

.PP
Definition at line \fB158\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
158                                                                                                                                      {
159 
160     // Get the address of the handler and the entry in the IDT
161     auto handler_address = (uint64_t) handler;
162     InterruptDescriptor* interrupt_descriptor = &s_interrupt_descriptor_table[interrupt];
163 
164     // Set the handler address
165     interrupt_descriptor\->address_low_bits = handler_address & 0xFFFF;
166     interrupt_descriptor\->address_mid_bits = (handler_address >> 16) & 0xFFFF;
167     interrupt_descriptor\->address_high_bits = (handler_address >> 32) & 0xFFFFFFFF;
168 
169     // Set the kernel code segment offset
170     interrupt_descriptor\->segment_selector = 0x08;
171 
172     // Disable IST
173     interrupt_descriptor\->ist = 0;
174 
175     // Set the flags (Trap Gate, Present and the Descriptor Privilege Level)
176     interrupt_descriptor\->flags = 0b1110 | ((descriptor_privilege_level & 0b11) << 5) | (1 << 7);
177 }
.fi

.PP
References \fBs_interrupt_descriptor_table\fP\&.
.SS "\fBvoid\fP InterruptManager::set_interrupt_handler (\fBuint8_t\fP interrupt, \fBInterruptHandler\fP * handler)"

.PP
Sets the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.br
\fIhandler\fP The interrupt handler 
.RE
.PP

.PP
Definition at line \fB256\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
256                                                                                          {
257 
258     m_interrupt_handlers[interrupt] = handler;
259 }
.fi

.PP
References \fBm_interrupt_handlers\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBInterruptHandler\fP\fC [friend]\fP"

.PP
Definition at line \fB79\fP of file \fBinterrupts\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInterruptHandler\fP* MaxOS::hardwarecommunication::InterruptManager::m_interrupt_handlers[\fBMAX_INTERRUPT_HANDLERS\fP] = {}\fC [protected]\fP"

.PP
A map of index-to-interrupt of interrupt handlers to fire when an interrupt occurs\&. 
.PP
Definition at line \fB91\fP of file \fBinterrupts\&.h\fP\&..PP
.nf
91 {};                                    
.fi

.PP
Referenced by \fBhandle_interrupt_request()\fP, \fBremove_interrupt_handler()\fP, and \fBset_interrupt_handler()\fP\&.
.SS "\fBInterruptManager\fP* MaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager = nullptr\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
The interrupt manger that is currently handling interrupts and is loaded into the \fBIDTR\fP\&. 
.PP
Definition at line \fB89\fP of file \fBinterrupts\&.h\fP\&.
.PP
Referenced by \fBactivate()\fP, \fBactive_interrupt_manager()\fP, \fBdeactivate()\fP, \fBHandleInterrupt()\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\fP\&.
.SS "\fBInterruptDescriptor\fP MaxOS::hardwarecommunication::InterruptManager::s_interrupt_descriptor_table[\fBMAX_INTERRUPT_HANDLERS\fP] = {}\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
The Interrupt Descriptor Table (IDT) 
.PP
Definition at line \fB92\fP of file \fBinterrupts\&.h\fP\&..PP
.nf
92 {};            
.fi

.PP
Referenced by \fBload_current()\fP, and \fBset_interrupt_descriptor_table_entry()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::hardwarecommunication::InterruptManager" 3 "Mon Jan 29 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptManager \- Handles all interrupts and passes them to the correct handler\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.PP
Inherits \fBMaxOS::common::InputStream\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptManager\fP (uint16_t \fBhardware_interrupt_offset\fP, \fBcommon::OutputStream\fP *handler)"
.br
.RI "\fBManger\fP "
.ti -1c
.RI "\fB~InterruptManager\fP ()"
.br
.ti -1c
.RI "uint16_t \fBhardware_interrupt_offset\fP ()"
.br
.RI "Returns the offset of the hardware interrupt\&. "
.ti -1c
.RI "void \fBset_interrupt_handler\fP (uint8_t interrupt, \fBInterruptHandler\fP *handler)"
.br
.RI "Sets the interrupt handler for the interrupt\&. "
.ti -1c
.RI "void \fBremove_interrupt_handler\fP (uint8_t interrupt)"
.br
.RI "Removes the interrupt handler for the interrupt\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "Deactivates the interrupt manager and stops interrupts\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "system::cpu_status_t * \fBhandle_interrupt_request\fP (system::cpu_status_t *)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBset_interrupt_descriptor_table_entry\fP (uint8_t interrupt, void(*handler)(), uint8_t descriptor_privilege_level)"
.br
.RI "Sets an entry in the Interrupt Descriptor Table\&. "
.ti -1c
.RI "static void \fBInterruptIgnore\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x00\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x01\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x02\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x03\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x04\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x05\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x06\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x07\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x08\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x09\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x80\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0F\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x31\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x60\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x00\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x01\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x02\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x03\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x04\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x05\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x06\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x07\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x08\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x09\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x0F\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x10\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x11\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x12\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x13\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x14\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x15\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x16\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x17\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x18\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x19\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1F\fP ()"
.br
.ti -1c
.RI "static system::cpu_status_t * \fBHandleInterrupt\fP (system::cpu_status_t *\fBstatus\fP)"
.br
.RI "Handles the interrupt request by passing it to the interrupt manager\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint16_t \fBm_hardware_interrupt_offset\fP"
.br
.ti -1c
.RI "\fBInterruptHandler\fP * \fBm_interrupt_handlers\fP [256]"
.br
.ti -1c
.RI "\fBsystem::ThreadManager\fP * \fBm_thread_manager\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBInterruptManager\fP * \fBs_active_interrupt_manager\fP = 0"
.br
.ti -1c
.RI "static \fBcommon::OutputStream\fP * \fBs_error_messages\fP = 0"
.br
.ti -1c
.RI "static \fBInterruptDescriptor\fP \fBs_interrupt_descriptor_table\fP [256]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInterruptHandler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles all interrupts and passes them to the correct handler\&. 
.PP
Definition at line 64 of file interrupts\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptManager::InterruptManager (uint16_t hardware_interrupt_offset, \fBcommon::OutputStream\fP * handler)"

.PP
\fBManger\fP 
.PP
Definition at line 47 of file interrupts\&.cpp\&.
.PP
.nf
48 : common::InputStream(handler),
49   m_hardware_interrupt_offset(hardware_interrupt_offset)
50 {
51 
52      // Full the table of interrupts with 0
53      for(uint16_t i = 0; i < 256; i++) {
54         s_interrupt_descriptor_table[i]\&.address_low_bits = 0;
55         s_interrupt_descriptor_table[i]\&.address_mid_bits = 0;
56         s_interrupt_descriptor_table[i]\&.address_high_bits = 0;
57         s_interrupt_descriptor_table[i]\&.segment_selector = 0;
58         s_interrupt_descriptor_table[i]\&.ist = 0;
59         s_interrupt_descriptor_table[i]\&.flags = 0;
60      }
61 
62      //Set Up the base interrupts
63     set_interrupt_descriptor_table_entry(0x00, &HandleException0x00, 0);   // Division by zero
64     set_interrupt_descriptor_table_entry(0x01, &HandleException0x01, 0);   // Debug
65     set_interrupt_descriptor_table_entry(0x02, &HandleException0x02, 0);   // Non-maskable interrupt
66     set_interrupt_descriptor_table_entry(0x03, &HandleException0x03, 0);   // Breakpoint
67     set_interrupt_descriptor_table_entry(0x04, &HandleException0x04, 0);   // Overflow
68     set_interrupt_descriptor_table_entry(0x05, &HandleException0x05, 0);   // Bound Range Exceeded
69     set_interrupt_descriptor_table_entry(0x06, &HandleException0x06, 0);   // Invalid Opcode
70     set_interrupt_descriptor_table_entry(0x06, &HandleException0x07, 0);   // Device Not Available
71     set_interrupt_descriptor_table_entry(0x08, &HandleInterruptError0x08, 0);   // Double Fault
72     set_interrupt_descriptor_table_entry(0x09, &HandleException0x09, 0);   // Coprocessor Segment Overrun
73     set_interrupt_descriptor_table_entry(0x0A, &HandleInterruptError0x0A, 0);   // Invalid TSS
74     set_interrupt_descriptor_table_entry(0x0B, &HandleInterruptError0x0B, 0);   // Segment Not Present
75     set_interrupt_descriptor_table_entry(0x0C, &HandleInterruptError0x0C, 0);   // Stack-Segment Fault
76     set_interrupt_descriptor_table_entry(0x0D, &HandleInterruptError0x0D, 0);   // General Protection Fault
77     set_interrupt_descriptor_table_entry(0x0E, &HandleInterruptError0x0E, 0);   // Page Fault
78     set_interrupt_descriptor_table_entry(0x0F, &HandleException0x0F, 0);   // Reserved
79     set_interrupt_descriptor_table_entry(0x10, &HandleException0x10, 0);   // x87 Floating-Point Exception
80     set_interrupt_descriptor_table_entry(0x11, &HandleInterruptError0x11, 0);   // Alignment Check
81     set_interrupt_descriptor_table_entry(0x12, &HandleException0x12, 0);   // Machine Check
82     set_interrupt_descriptor_table_entry(0x13, &HandleException0x13, 0);   // SIMD Floating-Point Exception
83     set_interrupt_descriptor_table_entry(0x14, &HandleException0x14, 0);   // Reserved: Virtualization Exception
84     set_interrupt_descriptor_table_entry(0x15, &HandleException0x15, 0);   // Reserved
85     set_interrupt_descriptor_table_entry(0x16, &HandleException0x16, 0);   // Reserved
86     set_interrupt_descriptor_table_entry(0x17, &HandleException0x17, 0);   // Reserved
87     set_interrupt_descriptor_table_entry(0x18, &HandleException0x18, 0);   // Reserved
88     set_interrupt_descriptor_table_entry(0x19, &HandleException0x19, 0);   // Reserved
89     set_interrupt_descriptor_table_entry(0x1A, &HandleException0x1A, 0);   // Reserved
90     set_interrupt_descriptor_table_entry(0x1B, &HandleException0x1B, 0);   // Reserved
91     set_interrupt_descriptor_table_entry(0x1C, &HandleException0x1C, 0);   // Reserved
92     set_interrupt_descriptor_table_entry(0x1D, &HandleException0x1D, 0);   // Reserved
93     set_interrupt_descriptor_table_entry(0x1E, &HandleException0x1E, 0);   // Security Exception
94     set_interrupt_descriptor_table_entry(0x1F, &HandleException0x1F, 0);   // Reserved
95 
96     // Set up the hardware interrupts
97     set_interrupt_descriptor_table_entry(hardware_interrupt_offset + 0x00, &HandleInterruptRequest0x00, 0);   // Advanced Programmable Interrupt Controller (APIC) Timer Interrupt
98     set_interrupt_descriptor_table_entry(hardware_interrupt_offset + 0x01, &HandleInterruptRequest0x01, 0);   // Keyboard Interrupt
99     set_interrupt_descriptor_table_entry(hardware_interrupt_offset + 0x02, &HandleInterruptRequest0x02, 0);   // Cascade (used internally by the two PICs\&. never raised)
100     set_interrupt_descriptor_table_entry(hardware_interrupt_offset + 0x0C, &HandleInterruptRequest0x0C, 0);   // Mouse Interrupt
101 
102     // Set up the system call interrupt
103     set_interrupt_descriptor_table_entry(hardware_interrupt_offset + 0x60, &HandleInterruptRequest0x60, 0);   // System Call Interrupt
104 
105     //Tell the processor to use the IDT
106     IDTR idt;
107     idt\&.limit = 256 * sizeof(InterruptDescriptor) - 1;
108     idt\&.base = (uint64_t)s_interrupt_descriptor_table;
109     asm volatile("lidt %0" : : "m" (idt));
110 };
.fi
.PP
References MaxOS::hardwarecommunication::InterruptDescriptor::address_high_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_low_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_mid_bits, MaxOS::hardwarecommunication::IDTR::base, MaxOS::hardwarecommunication::InterruptDescriptor::flags, HandleException0x00(), HandleException0x01(), HandleException0x02(), HandleException0x03(), HandleException0x04(), HandleException0x05(), HandleException0x06(), HandleException0x07(), HandleException0x09(), HandleException0x0F(), HandleException0x10(), HandleException0x12(), HandleException0x13(), HandleException0x14(), HandleException0x15(), HandleException0x16(), HandleException0x17(), HandleException0x18(), HandleException0x19(), HandleException0x1A(), HandleException0x1B(), HandleException0x1C(), HandleException0x1D(), HandleException0x1E(), HandleException0x1F(), HandleInterruptError0x08(), HandleInterruptError0x0A(), HandleInterruptError0x0B(), HandleInterruptError0x0C(), HandleInterruptError0x0D(), HandleInterruptError0x0E(), HandleInterruptError0x11(), HandleInterruptRequest0x00(), HandleInterruptRequest0x01(), HandleInterruptRequest0x02(), HandleInterruptRequest0x0C(), HandleInterruptRequest0x60(), hardware_interrupt_offset(), MaxOS::drivers::peripherals::i, MaxOS::hardwarecommunication::InterruptDescriptor::ist, MaxOS::hardwarecommunication::IDTR::limit, s_interrupt_descriptor_table, MaxOS::hardwarecommunication::InterruptDescriptor::segment_selector, and set_interrupt_descriptor_table_entry()\&.
.SS "InterruptManager::~InterruptManager ()"

.PP
Definition at line 112 of file interrupts\&.cpp\&.
.PP
.nf
113 {
114   deactivate();
115 }
.fi
.PP
References deactivate()\&.
.SH "Member Function Documentation"
.PP 
.SS "void InterruptManager::activate ()"

.PP
Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) 
.PP
Definition at line 153 of file interrupts\&.cpp\&.
.PP
.nf
153                                 {
154 
155     // Deactivate the current interrupt manager
156     if(s_active_interrupt_manager != 0)
157       s_active_interrupt_manager->deactivate();
158 
159     // Set the current interrupt manager and start interrupts
160     s_active_interrupt_manager = this;
161     asm("sti");
162 }
.fi
.PP
References deactivate(), and s_active_interrupt_manager\&.
.PP
Referenced by kernelMain()\&.
.SS "void InterruptManager::deactivate ()"

.PP
Deactivates the interrupt manager and stops interrupts\&. 
.PP
Definition at line 167 of file interrupts\&.cpp\&.
.PP
.nf
168 {
169 
170     // If this is the active interrupt manager, deactivate it and stop interrupts
171     if(s_active_interrupt_manager == this){
172       s_active_interrupt_manager = 0;
173       asm("cli");
174     }
175 }
.fi
.PP
References s_active_interrupt_manager\&.
.PP
Referenced by activate(), and ~InterruptManager()\&.
.SS "cpu_status_t * InterruptManager::handle_interrupt_request (system::cpu_status_t *)\fC [protected]\fP"

.PP
Definition at line 256 of file interrupts\&.cpp\&.
.PP
.nf
256                                                                              {
257 
258   _kprintf("Interrupt: 0x%x\n", status->interrupt_number);
259 
260   // If there is an interrupt manager, handle the interrupt
261   if(m_interrupt_handlers[status -> interrupt_number] != 0)
262       m_interrupt_handlers[status -> interrupt_number]->handle_interrupt();
263 
264   else if(status->interrupt_number < m_hardware_interrupt_offset){
265     _kprintf("Exception: %s, Error Code: 0x%x\n", exceptions[status->interrupt_number], status->error_code);
266     CPU::stack_trace(10);
267   }
268 
269 
270   else
271     _kprintf("Unhandled Interrupt: 0x%x\n", status->interrupt_number);
272 
273   // Debug the General Protection Fault
274   if(status->interrupt_number == 0x0D) {
275 
276     // Define masks for each field
277     uint32_t E_MASK = 0b10000000000000000000000000000000;
278     uint32_t Tbl_MASK = 0b01100000000000000000000000000000;
279     uint32_t Index_MASK = 0b00011111111111110000000000000000;
280 
281     // Use bit shifting and masking to extract values
282     int E = (status -> error_code & E_MASK) >> 31;
283     int Tbl = (status -> error_code & Tbl_MASK) >> 29;
284     int Index = (status -> error_code & Index_MASK) >> 16;
285 
286     // If bit 0 is set, the exception was caused by external event
287     _kprintf("General Protection Fault: External Event: %s\n", (E) ? "Yes" : "No");
288 
289     switch(Tbl) {
290       case 0b00: _kprintf("General Protection Fault: Table: GDT\n"); break;
291       case 0b01: _kprintf("General Protection Fault: Table: IDT\n"); break;
292       case 0b10: _kprintf("General Protection Fault: Table: LDT\n"); break;
293       case 0b11: _kprintf("General Protection Fault: Table: IDT\n"); break;
294     }
295 
296     // Find the selector index (next 13 bits)
297     _kprintf("General Protection Fault: Selector Index: 0x%x\n", Index);
298 
299     // Hang
300     while(true);
301   }
302 
303 
304   //TODO: Send SMP interrupt
305   //todo: send eoi
306 
307   // Return the status
308   return status;
309 }
.fi
.PP
References _kprintf(), MaxOS::hardwarecommunication::InterruptHandler::handle_interrupt(), m_hardware_interrupt_offset, m_interrupt_handlers, and status\&.
.PP
Referenced by HandleInterrupt()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x00 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x01 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x02 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x03 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x04 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x05 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x06 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x07 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x09 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x0F ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x10 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x12 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x13 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x14 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x15 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x16 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x17 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x18 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x19 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1A ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1B ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1D ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1E ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1F ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "system::cpu_status_t * InterruptManager::HandleInterrupt (system::cpu_status_t * status)\fC [static]\fP, \fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the interrupt manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current stack pointer 
.RE
.PP
\fBReturns\fP
.RS 4
The stack pointer 
.RE
.PP

.PP
Definition at line 183 of file interrupts\&.cpp\&.
.PP
.nf
183                                                                                 {
184 
185   // If there is an interrupt manager handle interrupt
186   if(s_active_interrupt_manager != 0)
187     return s_active_interrupt_manager->handle_interrupt_request(status);
188 
189   // CPU Can continue
190   return status;
191 }
.fi
.PP
References handle_interrupt_request(), s_active_interrupt_manager, and status\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x08 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0A ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0B ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0D ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0E ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x11 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x00 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x01 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x02 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x03 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x04 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x05 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x06 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x07 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x08 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x09 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0A ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0B ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0D ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0E ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0F ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x31 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x60 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x80 ()\fC [static]\fP, \fC [protected]\fP"

.SS "uint16_t InterruptManager::hardware_interrupt_offset ()"

.PP
Returns the offset of the hardware interrupt\&. 
.PP
\fBReturns\fP
.RS 4
The offset of the hardware interrupt 
.RE
.PP

.PP
Definition at line 198 of file interrupts\&.cpp\&.
.PP
.nf
198                                                      {
199     return m_hardware_interrupt_offset;
200 }
.fi
.PP
References m_hardware_interrupt_offset\&.
.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::InterruptIgnore ()\fC [static]\fP, \fC [protected]\fP"

.SS "void InterruptManager::remove_interrupt_handler (uint8_t interrupt)"

.PP
Removes the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.RE
.PP

.PP
Definition at line 217 of file interrupts\&.cpp\&.
.PP
.nf
217                                                                  {
218   m_interrupt_handlers[interrupt] = 0;
219 }
.fi
.PP
References m_interrupt_handlers\&.
.PP
Referenced by MaxOS::hardwarecommunication::InterruptHandler::~InterruptHandler()\&.
.SS "void InterruptManager::set_interrupt_descriptor_table_entry (uint8_t interrupt, void(*)() handler, uint8_t descriptor_privilege_level)\fC [static]\fP, \fC [protected]\fP"

.PP
Sets an entry in the Interrupt Descriptor Table\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP Interrupt number 
.br
\fIcode_segment_selector_offset\fP Code segment 
.br
\fIhandler\fP Interrupt Handler 
.br
\fIdescriptor_privilege_level\fP Descriptor Privilege Level 
.br
\fIdescriptor_type\fP Descriptor Type 
.RE
.PP

.PP
Definition at line 127 of file interrupts\&.cpp\&.
.PP
.nf
128 {
129 
130   // Get the address of the handler and the entry in the IDT
131   uint64_t handler_address = (uint64_t)handler;
132   InterruptDescriptor* interrupt_descriptor = &s_interrupt_descriptor_table[interrupt];
133 
134   // Set the handler address
135   interrupt_descriptor->address_low_bits = handler_address & 0xFFFF;
136   interrupt_descriptor->address_mid_bits = (handler_address >> 16) & 0xFFFF;
137   interrupt_descriptor->address_high_bits = (handler_address >> 32) & 0xFFFFFFFF;
138 
139   // Set the kernel code segment offset
140   interrupt_descriptor->segment_selector = 0x08;
141 
142   // Disable IST
143   interrupt_descriptor->ist = 0;
144 
145   // Set the flags (Trap Gate, Present and the Descriptor Privilege Level)
146   interrupt_descriptor->flags = 0b1110 | ((descriptor_privilege_level & 0b11) << 5) | (1 << 7);
147 }
.fi
.PP
References MaxOS::hardwarecommunication::InterruptDescriptor::address_high_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_low_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_mid_bits, MaxOS::hardwarecommunication::InterruptDescriptor::flags, MaxOS::hardwarecommunication::InterruptDescriptor::ist, s_interrupt_descriptor_table, and MaxOS::hardwarecommunication::InterruptDescriptor::segment_selector\&.
.PP
Referenced by InterruptManager()\&.
.SS "void InterruptManager::set_interrupt_handler (uint8_t interrupt, \fBInterruptHandler\fP * handler)"

.PP
Sets the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.br
\fIhandler\fP The interrupt handler 
.RE
.PP

.PP
Definition at line 208 of file interrupts\&.cpp\&.
.PP
.nf
208                                                                                          {
209   m_interrupt_handlers[interrupt] = handler;
210 }
.fi
.PP
References m_interrupt_handlers\&.
.PP
Referenced by MaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBInterruptHandler\fP\fC [friend]\fP"

.PP
Definition at line 65 of file interrupts\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "uint16_t MaxOS::hardwarecommunication::InterruptManager::m_hardware_interrupt_offset\fC [protected]\fP"

.PP
Definition at line 71 of file interrupts\&.h\&.
.PP
Referenced by handle_interrupt_request(), and hardware_interrupt_offset()\&.
.SS "\fBInterruptHandler\fP* MaxOS::hardwarecommunication::InterruptManager::m_interrupt_handlers[256]\fC [protected]\fP"

.PP
Definition at line 72 of file interrupts\&.h\&.
.PP
Referenced by handle_interrupt_request(), remove_interrupt_handler(), and set_interrupt_handler()\&.
.SS "\fBsystem::ThreadManager\fP* MaxOS::hardwarecommunication::InterruptManager::m_thread_manager\fC [protected]\fP"

.PP
Definition at line 73 of file interrupts\&.h\&.
.SS "\fBInterruptManager\fP * InterruptManager::s_active_interrupt_manager = 0\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 69 of file interrupts\&.h\&.
.PP
Referenced by activate(), deactivate(), and HandleInterrupt()\&.
.SS "OutputStream * InterruptManager::s_error_messages = 0\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 70 of file interrupts\&.h\&.
.SS "\fBInterruptDescriptor\fP InterruptManager::s_interrupt_descriptor_table\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 75 of file interrupts\&.h\&.
.PP
Referenced by InterruptManager(), and set_interrupt_descriptor_table_entry()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

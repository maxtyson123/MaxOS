.TH "MaxOS::hardwarecommunication::InterruptManager" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptManager \- Handles all interrupts and passes them to the correct handler\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptManager\fP ()"
.br
.RI "\fBManger\fP "
.ti -1c
.RI "\fB~InterruptManager\fP ()"
.br
.ti -1c
.RI "uint16_t \fBhardware_interrupt_offset\fP ()"
.br
.RI "Returns the offset of the hardware interrupt\&. "
.ti -1c
.RI "void \fBset_interrupt_handler\fP (uint8_t interrupt, \fBInterruptHandler\fP *handler)"
.br
.RI "Sets the interrupt handler for the interrupt\&. "
.ti -1c
.RI "void \fBremove_interrupt_handler\fP (uint8_t interrupt)"
.br
.RI "Removes the interrupt handler for the interrupt\&. "
.ti -1c
.RI "void \fBset_apic\fP (\fBLocalAPIC\fP *apic)"
.br
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "Deactivates the interrupt manager and stops interrupts\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "system::cpu_status_t * \fBhandle_interrupt_request\fP (system::cpu_status_t *)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBset_interrupt_descriptor_table_entry\fP (uint8_t interrupt, void(*handler)(), uint8_t descriptor_privilege_level)"
.br
.RI "Sets an entry in the Interrupt Descriptor Table\&. "
.ti -1c
.RI "static void \fBInterruptIgnore\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x00\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x01\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x02\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x03\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x04\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x05\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x06\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x07\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x08\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x09\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x80\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0F\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x31\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptRequest0x60\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x00\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x01\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x02\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x03\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x04\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x05\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x06\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x07\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x08\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x09\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x0E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x0F\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x10\fP ()"
.br
.ti -1c
.RI "static void \fBHandleInterruptError0x11\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x12\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x13\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x14\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x15\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x16\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x17\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x18\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x19\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1A\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1B\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1C\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1D\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1E\fP ()"
.br
.ti -1c
.RI "static void \fBHandleException0x1F\fP ()"
.br
.ti -1c
.RI "static system::cpu_status_t * \fBHandleInterrupt\fP (system::cpu_status_t *\fBstatus\fP)"
.br
.RI "Handles the interrupt request by passing it to the interrupt manager\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP * \fBm_interrupt_handlers\fP [256]"
.br
.ti -1c
.RI "\fBsystem::ThreadManager\fP * \fBm_thread_manager\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBInterruptManager\fP * \fBs_active_interrupt_manager\fP = 0"
.br
.ti -1c
.RI "static \fBcommon::OutputStream\fP * \fBs_error_messages\fP = 0"
.br
.ti -1c
.RI "const static uint16_t \fBs_hardware_interrupt_offset\fP {0x20}"
.br
.ti -1c
.RI "static \fBInterruptDescriptor\fP \fBs_interrupt_descriptor_table\fP [256]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInterruptHandler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles all interrupts and passes them to the correct handler\&. 
.PP
Definition at line 65 of file interrupts\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptManager::InterruptManager ()"

.PP
\fBManger\fP 
.PP
Definition at line 47 of file interrupts\&.cpp\&.
.PP
.nf
48 : m_local_apic(nullptr)
49 {
50 
51      // Full the table of interrupts with 0
52      for(uint16_t i = 0; i < 256; i++) {
53         s_interrupt_descriptor_table[i]\&.address_low_bits = 0;
54         s_interrupt_descriptor_table[i]\&.address_mid_bits = 0;
55         s_interrupt_descriptor_table[i]\&.address_high_bits = 0;
56         s_interrupt_descriptor_table[i]\&.segment_selector = 0;
57         s_interrupt_descriptor_table[i]\&.ist = 0;
58         s_interrupt_descriptor_table[i]\&.flags = 0;
59      }
60 
61      //Set Up the base interrupts
62     set_interrupt_descriptor_table_entry(0x00, &HandleException0x00, 0);   // Division by zero
63     set_interrupt_descriptor_table_entry(0x01, &HandleException0x01, 0);   // Debug
64     set_interrupt_descriptor_table_entry(0x02, &HandleException0x02, 0);   // Non-maskable interrupt
65     set_interrupt_descriptor_table_entry(0x03, &HandleException0x03, 0);   // Breakpoint
66     set_interrupt_descriptor_table_entry(0x04, &HandleException0x04, 0);   // Overflow
67     set_interrupt_descriptor_table_entry(0x05, &HandleException0x05, 0);   // Bound Range Exceeded
68     set_interrupt_descriptor_table_entry(0x06, &HandleException0x06, 0);   // Invalid Opcode
69     set_interrupt_descriptor_table_entry(0x06, &HandleException0x07, 0);   // Device Not Available
70     set_interrupt_descriptor_table_entry(0x08, &HandleInterruptError0x08, 0);   // Double Fault
71     set_interrupt_descriptor_table_entry(0x09, &HandleException0x09, 0);   // Coprocessor Segment Overrun
72     set_interrupt_descriptor_table_entry(0x0A, &HandleInterruptError0x0A, 0);   // Invalid TSS
73     set_interrupt_descriptor_table_entry(0x0B, &HandleInterruptError0x0B, 0);   // Segment Not Present
74     set_interrupt_descriptor_table_entry(0x0C, &HandleInterruptError0x0C, 0);   // Stack-Segment Fault
75     set_interrupt_descriptor_table_entry(0x0D, &HandleInterruptError0x0D, 0);   // General Protection Fault
76     set_interrupt_descriptor_table_entry(0x0E, &HandleInterruptError0x0E, 0);   // Page Fault
77     set_interrupt_descriptor_table_entry(0x0F, &HandleException0x0F, 0);   // Reserved
78     set_interrupt_descriptor_table_entry(0x10, &HandleException0x10, 0);   // x87 Floating-Point Exception
79     set_interrupt_descriptor_table_entry(0x11, &HandleInterruptError0x11, 0);   // Alignment Check
80     set_interrupt_descriptor_table_entry(0x12, &HandleException0x12, 0);   // Machine Check
81     set_interrupt_descriptor_table_entry(0x13, &HandleException0x13, 0);   // SIMD Floating-Point Exception
82     set_interrupt_descriptor_table_entry(0x14, &HandleException0x14, 0);   // Reserved: Virtualization Exception
83     set_interrupt_descriptor_table_entry(0x15, &HandleException0x15, 0);   // Reserved
84     set_interrupt_descriptor_table_entry(0x16, &HandleException0x16, 0);   // Reserved
85     set_interrupt_descriptor_table_entry(0x17, &HandleException0x17, 0);   // Reserved
86     set_interrupt_descriptor_table_entry(0x18, &HandleException0x18, 0);   // Reserved
87     set_interrupt_descriptor_table_entry(0x19, &HandleException0x19, 0);   // Reserved
88     set_interrupt_descriptor_table_entry(0x1A, &HandleException0x1A, 0);   // Reserved
89     set_interrupt_descriptor_table_entry(0x1B, &HandleException0x1B, 0);   // Reserved
90     set_interrupt_descriptor_table_entry(0x1C, &HandleException0x1C, 0);   // Reserved
91     set_interrupt_descriptor_table_entry(0x1D, &HandleException0x1D, 0);   // Reserved
92     set_interrupt_descriptor_table_entry(0x1E, &HandleException0x1E, 0);   // Security Exception
93     set_interrupt_descriptor_table_entry(0x1F, &HandleException0x1F, 0);   // Reserved
94 
95     // Set up the hardware interrupts
96     set_interrupt_descriptor_table_entry(s_hardware_interrupt_offset + 0x00, &HandleInterruptRequest0x00, 0);   // APIC Timer Interrupt
97     set_interrupt_descriptor_table_entry(s_hardware_interrupt_offset + 0x01, &HandleInterruptRequest0x01, 0);   // Keyboard Interrupt
98     set_interrupt_descriptor_table_entry(s_hardware_interrupt_offset + 0x02, &HandleInterruptRequest0x02, 0);   // PIT Interrupt
99     set_interrupt_descriptor_table_entry(s_hardware_interrupt_offset + 0x0C, &HandleInterruptRequest0x0C, 0);   // Mouse Interrupt
100 
101     // Set up the system call interrupt
102     set_interrupt_descriptor_table_entry(s_hardware_interrupt_offset + 0x60, &HandleInterruptRequest0x60, 0);   // System Call Interrupt
103 
104     //Tell the processor to use the IDT
105     IDTR idt;
106     idt\&.limit = 256 * sizeof(InterruptDescriptor) - 1;
107     idt\&.base = (uint64_t)s_interrupt_descriptor_table;
108     asm volatile("lidt %0" : : "m" (idt));
109 };
.fi
.PP
References MaxOS::hardwarecommunication::InterruptDescriptor::address_high_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_low_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_mid_bits, MaxOS::hardwarecommunication::IDTR::base, MaxOS::hardwarecommunication::InterruptDescriptor::flags, HandleException0x00(), HandleException0x01(), HandleException0x02(), HandleException0x03(), HandleException0x04(), HandleException0x05(), HandleException0x06(), HandleException0x07(), HandleException0x09(), HandleException0x0F(), HandleException0x10(), HandleException0x12(), HandleException0x13(), HandleException0x14(), HandleException0x15(), HandleException0x16(), HandleException0x17(), HandleException0x18(), HandleException0x19(), HandleException0x1A(), HandleException0x1B(), HandleException0x1C(), HandleException0x1D(), HandleException0x1E(), HandleException0x1F(), HandleInterruptError0x08(), HandleInterruptError0x0A(), HandleInterruptError0x0B(), HandleInterruptError0x0C(), HandleInterruptError0x0D(), HandleInterruptError0x0E(), HandleInterruptError0x11(), HandleInterruptRequest0x00(), HandleInterruptRequest0x01(), HandleInterruptRequest0x02(), HandleInterruptRequest0x0C(), HandleInterruptRequest0x60(), MaxOS::drivers::peripherals::i, MaxOS::hardwarecommunication::InterruptDescriptor::ist, MaxOS::hardwarecommunication::IDTR::limit, s_hardware_interrupt_offset, s_interrupt_descriptor_table, MaxOS::hardwarecommunication::InterruptDescriptor::segment_selector, and set_interrupt_descriptor_table_entry()\&.
.SS "InterruptManager::~InterruptManager ()"

.PP
Definition at line 111 of file interrupts\&.cpp\&.
.PP
.nf
112 {
113   deactivate();
114 }
.fi
.PP
References deactivate()\&.
.SH "Member Function Documentation"
.PP 
.SS "void InterruptManager::activate ()"

.PP
Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) 
.PP
Definition at line 152 of file interrupts\&.cpp\&.
.PP
.nf
152                                 {
153 
154     // Deactivate the current interrupt manager
155     if(s_active_interrupt_manager != 0)
156       s_active_interrupt_manager->deactivate();
157 
158     // Set the current interrupt manager and start interrupts
159     s_active_interrupt_manager = this;
160     asm("sti");
161 }
.fi
.PP
References deactivate(), and s_active_interrupt_manager\&.
.PP
Referenced by kernelMain()\&.
.SS "void InterruptManager::deactivate ()"

.PP
Deactivates the interrupt manager and stops interrupts\&. 
.PP
Definition at line 166 of file interrupts\&.cpp\&.
.PP
.nf
167 {
168 
169     // If this is the active interrupt manager, deactivate it and stop interrupts
170     if(s_active_interrupt_manager == this){
171       s_active_interrupt_manager = 0;
172       asm("cli");
173     }
174 }
.fi
.PP
References s_active_interrupt_manager\&.
.PP
Referenced by activate(), and ~InterruptManager()\&.
.SS "cpu_status_t * InterruptManager::handle_interrupt_request (system::cpu_status_t *)\fC [protected]\fP"

.PP
Definition at line 228 of file interrupts\&.cpp\&.
.PP
.nf
228                                                                              {
229 
230   // If there is an interrupt manager, handle the interrupt
231   if(m_interrupt_handlers[status -> interrupt_number] != 0)
232       m_interrupt_handlers[status -> interrupt_number]->handle_interrupt();
233   else
234     _kprintf("Unhandled Interrupt 0x%x\n", status->interrupt_number);
235 
236   // Send the EOI to the APIC
237   if(s_hardware_interrupt_offset <= status->interrupt_number && status->interrupt_number < s_hardware_interrupt_offset + 16)
238       m_local_apic->send_eoi();
239 
240   // Return the status
241   return status;
242 }
.fi
.PP
References _kprintf, MaxOS::hardwarecommunication::InterruptHandler::handle_interrupt(), m_interrupt_handlers, s_hardware_interrupt_offset, MaxOS::hardwarecommunication::LocalAPIC::send_eoi(), and status\&.
.PP
Referenced by HandleInterrupt()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x00 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x01 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x02 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x03 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x04 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x05 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x06 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x07 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x09 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x0F ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x10 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x12 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x13 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x14 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x15 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x16 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x17 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x18 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x19 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1A ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1B ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1D ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1E ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleException0x1F ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "system::cpu_status_t * InterruptManager::HandleInterrupt (system::cpu_status_t * status)\fC [static]\fP, \fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the interrupt manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current stack pointer 
.RE
.PP
\fBReturns\fP
.RS 4
The stack pointer 
.RE
.PP

.PP
Definition at line 182 of file interrupts\&.cpp\&.
.PP
.nf
182                                                                                 {
183 
184   // System Handlers
185   switch (status->interrupt_number) {
186     case 0x0E:
187       page_fault(status);
188       break;
189 
190   }
191 
192   // If there is an interrupt manager handle interrupt
193   if(s_active_interrupt_manager != 0)
194     return s_active_interrupt_manager->handle_interrupt_request(status);
195 
196   // CPU Can continue
197   return status;
198 }
.fi
.PP
References handle_interrupt_request(), s_active_interrupt_manager, and status\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x08 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0A ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0B ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0D ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x0E ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptError0x11 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x00 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x01 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x02 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x03 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x04 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x05 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x06 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x07 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x08 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x09 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0A ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0B ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0C ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0D ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0E ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x0F ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x31 ()\fC [static]\fP, \fC [protected]\fP"

.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x60 ()\fC [static]\fP, \fC [protected]\fP"

.PP
Referenced by InterruptManager()\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::HandleInterruptRequest0x80 ()\fC [static]\fP, \fC [protected]\fP"

.SS "uint16_t InterruptManager::hardware_interrupt_offset ()"

.PP
Returns the offset of the hardware interrupt\&. 
.PP
\fBReturns\fP
.RS 4
The offset of the hardware interrupt 
.RE
.PP

.PP
Definition at line 205 of file interrupts\&.cpp\&.
.PP
.nf
205                                                      {
206     return s_hardware_interrupt_offset;
207 }
.fi
.PP
References s_hardware_interrupt_offset\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::InterruptIgnore ()\fC [static]\fP, \fC [protected]\fP"

.SS "void InterruptManager::remove_interrupt_handler (uint8_t interrupt)"

.PP
Removes the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.RE
.PP

.PP
Definition at line 224 of file interrupts\&.cpp\&.
.PP
.nf
224                                                                  {
225   m_interrupt_handlers[interrupt] = 0;
226 }
.fi
.PP
References m_interrupt_handlers\&.
.PP
Referenced by MaxOS::hardwarecommunication::InterruptHandler::~InterruptHandler()\&.
.SS "void InterruptManager::set_apic (\fBLocalAPIC\fP * apic)"

.PP
Definition at line 244 of file interrupts\&.cpp\&.
.PP
.nf
244                                                {
245     m_local_apic = apic;
246 }
.fi
.PP
Referenced by kernelMain()\&.
.SS "void InterruptManager::set_interrupt_descriptor_table_entry (uint8_t interrupt, void(*)() handler, uint8_t descriptor_privilege_level)\fC [static]\fP, \fC [protected]\fP"

.PP
Sets an entry in the Interrupt Descriptor Table\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP Interrupt number 
.br
\fIcode_segment_selector_offset\fP Code segment 
.br
\fIhandler\fP Interrupt Handler 
.br
\fIdescriptor_privilege_level\fP Descriptor Privilege Level 
.br
\fIdescriptor_type\fP Descriptor Type 
.RE
.PP

.PP
Definition at line 126 of file interrupts\&.cpp\&.
.PP
.nf
127 {
128 
129   // Get the address of the handler and the entry in the IDT
130   uint64_t handler_address = (uint64_t)handler;
131   InterruptDescriptor* interrupt_descriptor = &s_interrupt_descriptor_table[interrupt];
132 
133   // Set the handler address
134   interrupt_descriptor->address_low_bits = handler_address & 0xFFFF;
135   interrupt_descriptor->address_mid_bits = (handler_address >> 16) & 0xFFFF;
136   interrupt_descriptor->address_high_bits = (handler_address >> 32) & 0xFFFFFFFF;
137 
138   // Set the kernel code segment offset
139   interrupt_descriptor->segment_selector = 0x08;
140 
141   // Disable IST
142   interrupt_descriptor->ist = 0;
143 
144   // Set the flags (Trap Gate, Present and the Descriptor Privilege Level)
145   interrupt_descriptor->flags = 0b1110 | ((descriptor_privilege_level & 0b11) << 5) | (1 << 7);
146 }
.fi
.PP
References MaxOS::hardwarecommunication::InterruptDescriptor::address_high_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_low_bits, MaxOS::hardwarecommunication::InterruptDescriptor::address_mid_bits, MaxOS::hardwarecommunication::InterruptDescriptor::flags, MaxOS::hardwarecommunication::InterruptDescriptor::ist, s_interrupt_descriptor_table, and MaxOS::hardwarecommunication::InterruptDescriptor::segment_selector\&.
.PP
Referenced by InterruptManager()\&.
.SS "void InterruptManager::set_interrupt_handler (uint8_t interrupt, \fBInterruptHandler\fP * handler)"

.PP
Sets the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.br
\fIhandler\fP The interrupt handler 
.RE
.PP

.PP
Definition at line 215 of file interrupts\&.cpp\&.
.PP
.nf
215                                                                                          {
216   m_interrupt_handlers[interrupt] = handler;
217 }
.fi
.PP
References m_interrupt_handlers\&.
.PP
Referenced by MaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBInterruptHandler\fP\fC [friend]\fP"

.PP
Definition at line 66 of file interrupts\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInterruptHandler\fP* MaxOS::hardwarecommunication::InterruptManager::m_interrupt_handlers[256]\fC [protected]\fP"

.PP
Definition at line 78 of file interrupts\&.h\&.
.PP
Referenced by handle_interrupt_request(), remove_interrupt_handler(), and set_interrupt_handler()\&.
.SS "\fBsystem::ThreadManager\fP* MaxOS::hardwarecommunication::InterruptManager::m_thread_manager\fC [protected]\fP"

.PP
Definition at line 79 of file interrupts\&.h\&.
.SS "\fBInterruptManager\fP * InterruptManager::s_active_interrupt_manager = 0\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 75 of file interrupts\&.h\&.
.PP
Referenced by activate(), deactivate(), and HandleInterrupt()\&.
.SS "OutputStream * InterruptManager::s_error_messages = 0\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 76 of file interrupts\&.h\&.
.SS "const static uint16_t MaxOS::hardwarecommunication::InterruptManager::s_hardware_interrupt_offset {0x20}\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 77 of file interrupts\&.h\&.
.PP
Referenced by handle_interrupt_request(), hardware_interrupt_offset(), and InterruptManager()\&.
.SS "\fBInterruptDescriptor\fP InterruptManager::s_interrupt_descriptor_table\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line 81 of file interrupts\&.h\&.
.PP
Referenced by InterruptManager(), and set_interrupt_descriptor_table_entry()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

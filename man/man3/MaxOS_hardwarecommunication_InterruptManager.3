.TH "MaxOS::hardwarecommunication::InterruptManager" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::InterruptManager \- Handles all interrupts and passes them to the correct handler\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <interrupts\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptManager\fP ()"
.br
.RI "Constructs the Interrupt Manager and sets up the interrupt descriptor table (does not activate interrupts) "
.ti -1c
.RI "\fB~InterruptManager\fP ()"
.br
.RI "Destroys the Interrupt Manager and deactivates interrupts\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_interrupt_handler\fP (\fBuint8_t\fP interrupt, \fBInterruptHandler\fP *\fBhandler\fP)"
.br
.RI "Sets the interrupt handler for the interrupt\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_interrupt_handler\fP (\fBuint8_t\fP interrupt)"
.br
.RI "Removes the interrupt handler for the interrupt\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_apic\fP (\fBAdvancedProgrammableInterruptController\fP *apic)"
.br
.RI "Sets the APIC\&. "
.ti -1c
.RI "\fBAdvancedProgrammableInterruptController\fP * \fBactive_apic\fP ()"
.br
.RI "Gets the APIC\&. "
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP ()"
.br
.RI "Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBInterruptManager\fP * \fBactive_interrupt_manager\fP ()"
.br
.RI "Gets the active interrupt manager\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBload_current\fP ()"
.br
.RI "Tell the processor to use the current \fBInterruptManager\fP\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "Deactivates the interrupt manager and stops interrupts\&. "
.ti -1c
.RI "static void \fBForceInterruptReturn\fP (\fBsystem::cpu_status_t\fP *state)"
.br
.RI "Force the CPU to return from an interrupt (see interrupts\&.s) "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBsystem::cpu_status_t\fP * \fBhandle_interrupt_request\fP (\fBsystem::cpu_status_t\fP *status)"
.br
.RI "Handles the interrupt request by passing it to the appropriate handler\&. "
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBset_interrupt_descriptor_table_entry\fP (\fBuint8_t\fP interrupt, \fBvoid\fP(*\fBhandler\fP)(), \fBuint8_t\fP \fBdescriptor_privilege_level\fP)"
.br
.RI "Sets an entry in the Interrupt Descriptor Table\&. "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x00\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x01\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x02\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x03\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x04\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x05\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x06\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x07\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x08\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x09\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x80\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x0F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x31\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptRequest0x60\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x00\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x01\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x02\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x03\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x04\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x05\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x06\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x07\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x08\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x09\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x0E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x0F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x10\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleInterruptError0x11\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x12\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x13\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x14\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x15\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x16\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x17\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x18\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x19\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1A\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1B\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1C\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1D\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1E\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "static void \fBHandleException0x1F\fP ()"
.br
.RI "Stub (see interrupts\&.s) "
.ti -1c
.RI "\fBstatic\fP \fBsystem::cpu_status_t\fP * \fBHandleInterrupt\fP (\fBsystem::cpu_status_t\fP *status)"
.br
.RI "Handles the interrupt request by passing it to the interrupt manager\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP * \fBm_interrupt_handlers\fP [\fBMAX_INTERRUPT_HANDLERS\fP] = { }"
.br
.RI "A map of index-to-interrupt of interrupt handlers to fire when an interrupt occurs\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBInterruptManager\fP * \fBs_active_interrupt_manager\fP = nullptr"
.br
.RI "The interrupt manger that is currently handling interrupts and is loaded into the \fBIDTR\fP\&. "
.ti -1c
.RI "static \fBInterruptDescriptor\fP \fBs_interrupt_descriptor_table\fP [\fBMAX_INTERRUPT_HANDLERS\fP] = { }"
.br
.RI "The Interrupt Descriptor Table (IDT) "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInterruptHandler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles all interrupts and passes them to the correct handler\&. 


.PP
\fBTodo\fP
.RS 4
Remove the max array of handler make vector, add static handlers for page faults and gpe\&. Make it so that multiple handlers can be registered for the same interrupt 
.PP
Have a single stub so that we don't need to have 256 different functions for each interrupt 
.RE
.PP

.PP
Definition at line \fB84\fP of file \fBinterrupts\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InterruptManager::InterruptManager ()"

.PP
Constructs the Interrupt Manager and sets up the interrupt descriptor table (does not activate interrupts) 
.PP
Definition at line \fB90\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
90                                    {
91 
92     Logger::INFO() << "Setting up Interrupt Manager\\n";
93     s_active_interrupt_manager = this;
94 
95     // Clear the table
96     for (auto& descriptor: s_interrupt_descriptor_table) {
97         descriptor\&.address_low_bits = 0;
98         descriptor\&.address_mid_bits = 0;
99         descriptor\&.address_high_bits = 0;
100         descriptor\&.segment_selector = 0;
101         descriptor\&.ist = 0;
102         descriptor\&.flags = 0;
103     }
104 
105     //Set Up the base interrupts
106     set_interrupt_descriptor_table_entry(0x00, &HandleException0x00, 0);   // Division by zero
107     set_interrupt_descriptor_table_entry(0x01, &HandleException0x01, 0);   // Debug
108     set_interrupt_descriptor_table_entry(0x02, &HandleException0x02, 0);   // Non\-maskable interrupt
109     set_interrupt_descriptor_table_entry(0x03, &HandleException0x03, 0);   // Breakpoint
110     set_interrupt_descriptor_table_entry(0x04, &HandleException0x04, 0);   // Overflow
111     set_interrupt_descriptor_table_entry(0x05, &HandleException0x05, 0);   // Bound Range Exceeded
112     set_interrupt_descriptor_table_entry(0x06, &HandleException0x06, 0);   // Invalid Opcode
113     set_interrupt_descriptor_table_entry(0x06, &HandleException0x07, 0);   // Device Not Available
114     set_interrupt_descriptor_table_entry(0x08, &HandleInterruptError0x08, 0);   // Double Fault
115     set_interrupt_descriptor_table_entry(0x09, &HandleException0x09, 0);   // Coprocessor Segment Overrun
116     set_interrupt_descriptor_table_entry(0x0A, &HandleInterruptError0x0A, 0);   // Invalid TSS
117     set_interrupt_descriptor_table_entry(0x0B, &HandleInterruptError0x0B, 0);   // Segment Not Present
118     set_interrupt_descriptor_table_entry(0x0C, &HandleInterruptError0x0C, 0);   // Stack\-Segment Fault
119     set_interrupt_descriptor_table_entry(0x0D, &HandleInterruptError0x0D, 0);   // General Protection Fault
120     set_interrupt_descriptor_table_entry(0x0E, &HandleInterruptError0x0E, 0);   // Page Fault
121     set_interrupt_descriptor_table_entry(0x0F, &HandleException0x0F, 0);   // Reserved
122     set_interrupt_descriptor_table_entry(0x10, &HandleException0x10, 0);   // x87 Floating\-Point Exception
123     set_interrupt_descriptor_table_entry(0x11, &HandleInterruptError0x11, 0);   // Alignment Check
124     set_interrupt_descriptor_table_entry(0x12, &HandleException0x12, 0);   // Machine Check
125     set_interrupt_descriptor_table_entry(0x13, &HandleException0x13, 0);   // SIMD Floating\-Point Exception
126     set_interrupt_descriptor_table_entry(0x14, &HandleException0x14, 0);   // Reserved: Virtualization Exception
127     set_interrupt_descriptor_table_entry(0x15, &HandleException0x15, 0);   // Reserved
128     set_interrupt_descriptor_table_entry(0x16, &HandleException0x16, 0);   // Reserved
129     set_interrupt_descriptor_table_entry(0x17, &HandleException0x17, 0);   // Reserved
130     set_interrupt_descriptor_table_entry(0x18, &HandleException0x18, 0);   // Reserved
131     set_interrupt_descriptor_table_entry(0x19, &HandleException0x19, 0);   // Reserved
132     set_interrupt_descriptor_table_entry(0x1A, &HandleException0x1A, 0);   // Reserved
133     set_interrupt_descriptor_table_entry(0x1B, &HandleException0x1B, 0);   // Reserved
134     set_interrupt_descriptor_table_entry(0x1C, &HandleException0x1C, 0);   // Reserved
135     set_interrupt_descriptor_table_entry(0x1D, &HandleException0x1D, 0);   // Reserved
136     set_interrupt_descriptor_table_entry(0x1E, &HandleException0x1E, 0);   // Security Exception
137     set_interrupt_descriptor_table_entry(0x1F, &HandleException0x1F, 0);   // Reserved
138 
139     // Set up the hardware interrupts
140     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x00, &HandleInterruptRequest0x00, 0);   // APIC Timer Interrupt
141     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x01, &HandleInterruptRequest0x01, 0);   // Keyboard Interrupt
142     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x02, &HandleInterruptRequest0x02, 0);   // PIT Interrupt
143     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x0C, &HandleInterruptRequest0x0C, 0);   // Mouse Interrupt
144 
145     // Set up the system call interrupt
146     set_interrupt_descriptor_table_entry(HARDWARE_INTERRUPT_OFFSET + 0x60, &HandleInterruptRequest0x60, 3);   // System Call Interrupt \- Privilege Level 3 so that user space can call it
147 
148     // Tell the processor to use the IDT
149     load_current();
150 }
.fi

.PP
References \fBHandleException0x00()\fP, \fBHandleException0x01()\fP, \fBHandleException0x02()\fP, \fBHandleException0x03()\fP, \fBHandleException0x04()\fP, \fBHandleException0x05()\fP, \fBHandleException0x06()\fP, \fBHandleException0x07()\fP, \fBHandleException0x09()\fP, \fBHandleException0x0F()\fP, \fBHandleException0x10()\fP, \fBHandleException0x12()\fP, \fBHandleException0x13()\fP, \fBHandleException0x14()\fP, \fBHandleException0x15()\fP, \fBHandleException0x16()\fP, \fBHandleException0x17()\fP, \fBHandleException0x18()\fP, \fBHandleException0x19()\fP, \fBHandleException0x1A()\fP, \fBHandleException0x1B()\fP, \fBHandleException0x1C()\fP, \fBHandleException0x1D()\fP, \fBHandleException0x1E()\fP, \fBHandleException0x1F()\fP, \fBHandleInterruptError0x08()\fP, \fBHandleInterruptError0x0A()\fP, \fBHandleInterruptError0x0B()\fP, \fBHandleInterruptError0x0C()\fP, \fBHandleInterruptError0x0D()\fP, \fBHandleInterruptError0x0E()\fP, \fBHandleInterruptError0x11()\fP, \fBHandleInterruptRequest0x00()\fP, \fBHandleInterruptRequest0x01()\fP, \fBHandleInterruptRequest0x02()\fP, \fBHandleInterruptRequest0x0C()\fP, \fBHandleInterruptRequest0x60()\fP, \fBMaxOS::hardwarecommunication::HARDWARE_INTERRUPT_OFFSET\fP, \fBMaxOS::Logger::INFO()\fP, \fBload_current()\fP, \fBs_active_interrupt_manager\fP, \fBs_interrupt_descriptor_table\fP, and \fBset_interrupt_descriptor_table_entry()\fP\&.
.SS "InterruptManager::~InterruptManager ()"

.PP
Destroys the Interrupt Manager and deactivates interrupts\&. 
.PP
Definition at line \fB155\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
155                                     {
156     deactivate();
157 }
.fi

.PP
References \fBdeactivate()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InterruptManager::activate ()"

.PP
Activates the interrupt manager and starts interrupts (also deactivates the current interrupt manager) 
.PP
Definition at line \fB201\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
201                                 {
202 
203     Logger::INFO() << "Activating Interrupts \\n";
204 
205     // Deactivate the current (old) interrupt manager
206     InterruptManager::deactivate();
207 
208     // Set the current interrupt manager and start interrupts
209     s_active_interrupt_manager = this;
210     asm("sti");
211 }
.fi

.PP
References \fBdeactivate()\fP, \fBMaxOS::Logger::INFO()\fP, and \fBs_active_interrupt_manager\fP\&.
.SS "\fBAdvancedProgrammableInterruptController\fP * InterruptManager::active_apic ()"

.PP
Gets the APIC\&. 
.PP
\fBReturns\fP
.RS 4
The APIC 
.RE
.PP

.PP
Definition at line \fB382\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
382                                                                        {
383 
384     return m_apic;
385 }
.fi

.SS "\fBInterruptManager\fP * InterruptManager::active_interrupt_manager ()\fC [static]\fP"

.PP
Gets the active interrupt manager\&. 
.PP
\fBReturns\fP
.RS 4
The active interrupt manager 
.RE
.PP

.PP
Definition at line \fB392\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
392                                                              {
393 
394     return s_active_interrupt_manager;
395 }
.fi

.PP
References \fBs_active_interrupt_manager\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\fP\&.
.SS "\fBvoid\fP InterruptManager::deactivate ()\fC [static]\fP"

.PP
Deactivates the interrupt manager and stops interrupts\&. 
.PP
Definition at line \fB216\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
216                                   {
217 
218     // Cant deactivate if it isn't the system one
219     if (s_active_interrupt_manager != nullptr)
220         return;
221 
222     // Prevent interrupts from firing when nothing is set up to handle them
223     asm("cli");
224     s_active_interrupt_manager = nullptr;
225 }
.fi

.PP
References \fBs_active_interrupt_manager\fP\&.
.PP
Referenced by \fBactivate()\fP, and \fB~InterruptManager()\fP\&.
.SS "static void MaxOS::hardwarecommunication::InterruptManager::ForceInterruptReturn (\fBsystem::cpu_status_t\fP * state)\fC [static]\fP"

.PP
Force the CPU to return from an interrupt (see interrupts\&.s) 
.PP
\fBParameters\fP
.RS 4
\fIstate\fP the state to return to 
.RE
.PP

.PP
Referenced by \fBMaxOS::common::BlockingLock::acquire()\fP\&.
.SS "\fBcpu_status_t\fP * InterruptManager::handle_interrupt_request (\fBsystem::cpu_status_t\fP * status)\fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the appropriate handler\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current cpu status 
.RE
.PP
\fBReturns\fP
.RS 4
The updated cpu status 
.RE
.PP

.PP
Definition at line \fB284\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
284                                                                              {
285 
286     // Where to go afterward
287     cpu_status_t* new_status = status;
288 
289     // If there is an interrupt manager, handle the interrupt
290     if (m_interrupt_handlers[status\->interrupt_number] != nullptr)
291         new_status = m_interrupt_handlers[status\->interrupt_number]\->handle_interrupt(status);
292     else
293         Logger::WARNING() << "Interrupt " << (int) status\->interrupt_number << " not handled\\n";
294 
295     // Send the EOI to the APIC
296     if (HARDWARE_INTERRUPT_OFFSET <= status\->interrupt_number && status\->interrupt_number < HARDWARE_INTERRUPT_OFFSET + 16)
297         CPU::executing_core()\->local_apic\->send_eoi();
298 
299     // Return the status
300     return new_status;
301 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP, \fBMaxOS::hardwarecommunication::InterruptHandler::handle_interrupt()\fP, \fBMaxOS::hardwarecommunication::HARDWARE_INTERRUPT_OFFSET\fP, \fBm_interrupt_handlers\fP, and \fBMaxOS::Logger::WARNING()\fP\&.
.SS "\fBsystem::cpu_status_t\fP * InterruptManager::HandleInterrupt (\fBsystem::cpu_status_t\fP * status)\fC [static]\fP, \fC [protected]\fP"

.PP
Handles the interrupt request by passing it to the interrupt manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current cpu status 
.RE
.PP
\fBReturns\fP
.RS 4
The updated cpu status 
.RE
.PP

.PP
Definition at line \fB233\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
233                                                                                 {
234 
235     // Default Fault Handlers
236     switch (status\->interrupt_number) {
237 
238         case 0x7:
239             CPU::PANIC("Device Not Available: FPU Not Enabled", status);
240             break;
241 
242         case 0x0D:
243             return general_protection_fault(status);
244 
245         case 0x0E:
246             return page_fault(status);
247     }
248 
249     // If there is an interrupt manager handle interrupt
250     if (s_active_interrupt_manager != nullptr)
251         return s_active_interrupt_manager\->handle_interrupt_request(status);
252 
253     // CPU Can continue
254     return status;
255 }
.fi

.PP
References \fBMaxOS::system::CPU::PANIC()\fP, and \fBs_active_interrupt_manager\fP\&.
.SS "\fBvoid\fP InterruptManager::load_current ()\fC [static]\fP"

.PP
Tell the processor to use the current \fBInterruptManager\fP\&. 
.PP
Definition at line \fB190\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
190                                     {
191 
192     IDTR idt = {};
193     idt\&.limit = 256 * sizeof(InterruptDescriptor) \- 1;
194     idt\&.base = (uint64_t) s_interrupt_descriptor_table;
195     asm volatile("lidt %0" : : "m" (idt));
196 }
.fi

.PP
References \fBs_interrupt_descriptor_table\fP\&.
.PP
Referenced by \fBMaxOS::system::Core::init()\fP, and \fBInterruptManager()\fP\&.
.SS "\fBvoid\fP InterruptManager::remove_interrupt_handler (\fBuint8_t\fP interrupt)"

.PP
Removes the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.RE
.PP

.PP
Definition at line \fB273\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
273                                                                  {
274 
275     m_interrupt_handlers[interrupt] = nullptr;
276 }
.fi

.PP
References \fBm_interrupt_handlers\fP\&.
.SS "\fBvoid\fP InterruptManager::set_apic (\fBAdvancedProgrammableInterruptController\fP * apic)"

.PP
Sets the APIC\&. 
.PP
\fBParameters\fP
.RS 4
\fIapic\fP The APIC 
.RE
.PP

.PP
Definition at line \fB308\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
308                                                                              {
309 
310     m_apic = apic;
311 }
.fi

.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\fP\&.
.SS "\fBvoid\fP InterruptManager::set_interrupt_descriptor_table_entry (\fBuint8_t\fP interrupt, \fBvoid\fP(*)() handler, \fBuint8_t\fP descriptor_privilege_level)\fC [static]\fP, \fC [protected]\fP"

.PP
Sets an entry in the Interrupt Descriptor Table\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP Interrupt number 
.br
\fIhandler\fP Interrupt Handler 
.br
\fIdescriptor_privilege_level\fP Descriptor Privilege Level 
.RE
.PP

.PP
Definition at line \fB166\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
166                                                                                                                                      {
167 
168     // Get the address of the handler and the entry in the IDT
169     auto handler_address = (uint64_t) handler;
170     InterruptDescriptor* interrupt_descriptor = &s_interrupt_descriptor_table[interrupt];
171 
172     // Set the handler address
173     interrupt_descriptor\->address_low_bits = handler_address & 0xFFFF;
174     interrupt_descriptor\->address_mid_bits = (handler_address >> 16) & 0xFFFF;
175     interrupt_descriptor\->address_high_bits = (handler_address >> 32) & 0xFFFFFFFF;
176 
177     // Set the kernel code segment offset
178     interrupt_descriptor\->segment_selector = 0x08;
179 
180     // Disable IST
181     interrupt_descriptor\->ist = 0;
182 
183     // Set the flags (Trap Gate, Present and the Descriptor Privilege Level)
184     interrupt_descriptor\->flags = 0b1110 | ((descriptor_privilege_level & 0b11) << 5) | (1 << 7);
185 }
.fi

.PP
References \fBs_interrupt_descriptor_table\fP\&.
.PP
Referenced by \fBInterruptManager()\fP\&.
.SS "\fBvoid\fP InterruptManager::set_interrupt_handler (\fBuint8_t\fP interrupt, \fBInterruptHandler\fP * handler)"

.PP
Sets the interrupt handler for the interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterrupt\fP The interrupt number 
.br
\fIhandler\fP The interrupt handler 
.RE
.PP

.PP
Definition at line \fB263\fP of file \fBinterrupts\&.cpp\fP\&..PP
.nf
263                                                                                          {
264 
265     m_interrupt_handlers[interrupt] = handler;
266 }
.fi

.PP
References \fBm_interrupt_handlers\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBInterruptHandler\fP\fC [friend]\fP"

.PP
Definition at line \fB85\fP of file \fBinterrupts\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInterruptHandler\fP* MaxOS::hardwarecommunication::InterruptManager::m_interrupt_handlers[\fBMAX_INTERRUPT_HANDLERS\fP] = { }\fC [protected]\fP"

.PP
A map of index-to-interrupt of interrupt handlers to fire when an interrupt occurs\&. 
.PP
Definition at line \fB97\fP of file \fBinterrupts\&.h\fP\&..PP
.nf
97 { };                                    
.fi

.PP
Referenced by \fBhandle_interrupt_request()\fP, \fBremove_interrupt_handler()\fP, and \fBset_interrupt_handler()\fP\&.
.SS "\fBInterruptManager\fP* MaxOS::hardwarecommunication::InterruptManager::s_active_interrupt_manager = nullptr\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
The interrupt manger that is currently handling interrupts and is loaded into the \fBIDTR\fP\&. 
.PP
Definition at line \fB95\fP of file \fBinterrupts\&.h\fP\&.
.PP
Referenced by \fBactivate()\fP, \fBactive_interrupt_manager()\fP, \fBdeactivate()\fP, \fBHandleInterrupt()\fP, \fBMaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\fP, \fBInterruptManager()\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler::~InterruptHandler()\fP\&.
.SS "\fBInterruptDescriptor\fP MaxOS::hardwarecommunication::InterruptManager::s_interrupt_descriptor_table[\fBMAX_INTERRUPT_HANDLERS\fP] = { }\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
The Interrupt Descriptor Table (IDT) 
.PP
Definition at line \fB98\fP of file \fBinterrupts\&.h\fP\&..PP
.nf
98 { };            
.fi

.PP
Referenced by \fBInterruptManager()\fP, \fBload_current()\fP, and \fBset_interrupt_descriptor_table_entry()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

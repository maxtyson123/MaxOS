.TH "MaxOS::drivers::ethernet::intel_i217" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::ethernet::intel_i217
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <intel_i217\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriver\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBintel_i217\fP (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP *deviceDescriptor, \fBhardwarecommunication::InterruptManager\fP *interruptManager, \fBcommon::OutputStream\fP *intelNetMessageStream=0)"
.br
.RI "__DRIVER___ "
.ti -1c
.RI "\fB~intel_i217\fP ()"
.br
.ti -1c
.RI "uint32_t \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "activate the driver "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "deactivate the driver "
.ti -1c
.RI "void \fBhandle_interrupt\fP ()"
.br
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP ()"
.br
.RI "Get the vendor name of the driver\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP ()"
.br
.RI "Get the device name of the driver\&. "
.ti -1c
.RI "void \fBDoSend\fP (uint8_t *buffer, uint32_t \fBsize\fP)"
.br
.RI "(Device Side) Send the data "
.ti -1c
.RI "uint64_t \fBGetMediaAccessControlAddress\fP ()"
.br
.RI "Get the MAC address\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 29 of file intel_i217\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "intel_i217::intel_i217 (\fBhardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor\fP * deviceDescriptor, \fBhardwarecommunication::InterruptManager\fP * interruptManager, \fBcommon::OutputStream\fP * intelNetMessageStream = \fC0\fP)"

.PP
__DRIVER___ 
.PP
Definition at line 25 of file intel_i217\&.cpp\&.
.PP
.nf
26 : EthernetDriver(intelNetMessageStream),
27   InterruptHandler(deviceDescriptor->interrupt +
28                            interruptManager->hardware_interrupt_offset(), interruptManager)
29 
30 {
31 
32     //Set the registers
33     controlRegister = 0x0000;
34     statusRegister = 0x0008;
35     epromRegister = 0x0014;
36     controlExtRegister = 0x0018;
37     interruptMaskRegister = 0x00D0;
38 
39     receiveControlRegister = 0x0100;
40     receiveDescriptorLowRegister = 0x2800;
41     receiveDescriptorHighRegister = 0x2804;
42     receiveDescriptorLengthRegister = 0x2808;
43     receiveDescriptorHeadRegister = 0x2810;
44     receiveDescriptorTailRegister = 0x2818;
45 
46     sendControlRegister = 0x0400;
47     sendDescriptorLowRegister = 0x3800;
48     sendDescriptorHighRegister = 0x3804;
49     sendDescriptorLengthRegister = 0x3808;
50     sendDescriptorHeadRegister = 0x3810;
51     sendDescriptorTailRegister = 0x3818;
52 
53     // Get BAR0 type, io_base address and MMIO base address
54     bar_type = 1; // deviceDescriptor -> has_memory_base ? 0 : 1;  //TODO: Fix memory mapping from PCI as it is unable to get MAC from memory
55     portBase = deviceDescriptor ->port_base;
56     //TODO: memBase = deviceDescriptor -> memory_base;
57 
58     initDone = false;
59     active = false;
60 
61     //Clear eprom
62     epromPresent = false;
63 
64     //Detect eprom
65     detectEEProm ();
66 
67     if (readMACAddress()){
68 
69         ownMAC = CreateMediaAccessControlAddress(macAddress[0], macAddress[1], macAddress[2], macAddress[3], macAddress[4], macAddress[5]);
70 
71     }else{
72 
73       error_message("ERROR, INIT FAILED, MAC ADDRESS NOT FOUND");
74         while (true);
75     }
76 
77     for(int i = 0; i < 0x80; i++)               //Loop through all the registers
78         Write(0x5200 + i*4, 0);     //Clear the receive descriptor array
79 
80 
81 
82 
83 }
.fi
.PP
References MaxOS::drivers::ethernet::EthernetDriver::CreateMediaAccessControlAddress(), MaxOS::drivers::Driver::error_message(), MaxOS::drivers::peripherals::i, and MaxOS::hardwarecommunication::PeripheralComponentInterconnectDeviceDescriptor::port_base\&.
.SS "intel_i217::~intel_i217 ()"

.PP
Definition at line 85 of file intel_i217\&.cpp\&.
.PP
.nf
85                         {
86 
87 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void intel_i217::activate ()\fC [virtual]\fP"

.PP
activate the driver 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 291 of file intel_i217\&.cpp\&.
.PP
.nf
291                           {
292 
293   m_driver_message_stream-> write("Activating Intel i217\n");
294 
295     //Enable interrupts
296     Write(interruptMaskRegister ,0x1F6DC);                     //Enable all interrupts
297     Write(interruptMaskRegister ,0xff & ~4);                   //Enable all interrupts except link status change
298     Read(0xc0);                                                     //Clear all interrupts
299 
300     //while (!initDone);                                           //Wait for the init to be done
301 
302     //Initialise the send and receive descriptors
303     receiveInit();
304     sendInit();
305 
306     active = true;                                               // Set active to true
307     m_driver_message_stream-> write("Intel i217 INIT DONE\n");
308 
309 }
.fi
.PP
References MaxOS::drivers::Driver::m_driver_message_stream, write, and MaxOS::memory::Write\&.
.SS "void intel_i217::deactivate ()\fC [virtual]\fP"

.PP
deactivate the driver 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 391 of file intel_i217\&.cpp\&.
.PP
.nf
391                             {
392     Driver::deactivate();
393 }
.fi
.PP
References MaxOS::drivers::Driver::deactivate()\&.
.SS "void intel_i217::DoSend (uint8_t * buffer, uint32_t size)\fC [virtual]\fP"

.PP
(Device Side) Send the data 
.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line 353 of file intel_i217\&.cpp\&.
.PP
.nf
353                                                       {
354 
355   m_driver_message_stream-> write("Sending package\&.\&.\&. ");
356     while(!active);
357 
358     //Put params into send buffer
359     sendDsrctrs[currentSendBuffer] -> bufferAddress = (uint64_t)buffer;
360     sendDsrctrs[currentSendBuffer] -> length = size;
361 
362     //Set the commands
363     sendDsrctrs[currentSendBuffer] -> cmd = (1 << 0)    // End of Packet
364                                           | (1 << 1)    // Insert FCS
365                                           | (1 << 3)    // Report Status
366                                           ;
367 
368     sendDsrctrs[currentSendBuffer] -> status = 0;
369 
370     uint8_t old_cur = currentSendBuffer;                                    //Save the current send buffer
371     currentSendBuffer = (currentSendBuffer + 1) % 8;                        //Increment the current send buffer
372     Write(sendDescriptorTailRegister, currentSendBuffer);       //write the current send buffer to the tail register
373 
374     //Wait for the packet to be sent
375     while(!(sendDsrctrs[old_cur]->status & 0xff));
376     m_driver_message_stream-> write(" Done\n");
377 
378 }
.fi
.PP
References bufferAddress, cmd, length, MaxOS::drivers::Driver::m_driver_message_stream, size, status, write, and MaxOS::memory::Write\&.
.SS "\fBstring\fP intel_i217::get_device_name ()\fC [virtual]\fP"

.PP
Get the device name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The device name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 399 of file intel_i217\&.cpp\&.
.PP
.nf
399                                    {
400     return "E1000 (i217)";
401 }
.fi
.SS "\fBstring\fP intel_i217::get_vendor_name ()\fC [virtual]\fP"

.PP
Get the vendor name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The vendor name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 395 of file intel_i217\&.cpp\&.
.PP
.nf
395                                    {
396     return "Intel";
397 }
.fi
.SS "uint64_t intel_i217::GetMediaAccessControlAddress ()\fC [virtual]\fP"

.PP
Get the MAC address\&. 
.PP
\fBReturns\fP
.RS 4
the MAC address 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line 380 of file intel_i217\&.cpp\&.
.PP
.nf
380                                                   {
381   m_driver_message_stream-> write("Getting MAC address\&.\&.\&. ");
382     while(ownMAC == 0);
383     return ownMAC;
384 
385 }
.fi
.PP
References MaxOS::drivers::Driver::m_driver_message_stream, and write\&.
.SS "void intel_i217::handle_interrupt ()\fC [virtual]\fP"

.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line 311 of file intel_i217\&.cpp\&.
.PP
.nf
311                                   {
312 
313     Write(interruptMaskRegister, 0x1);      //Clear the interrupt or it will hang
314     uint32_t temp = Read(0xc0);                //read the interrupt status register
315 
316     m_driver_message_stream-> write("Interrupt from INTEL i217");
317 
318     if(temp & 0x04)
319       m_driver_message_stream-> write("INTEL i217 START LINK");//initDone = true;
320     if(temp & 0x10)
321       m_driver_message_stream-> write("INTEL i217 GOOD THRESHOLD");
322     if(temp & 0x80) FetchDataReceived();
323 }
.fi
.PP
References MaxOS::drivers::Driver::m_driver_message_stream, write, and MaxOS::memory::Write\&.
.SS "uint32_t intel_i217::reset ()\fC [virtual]\fP"

.PP
Reset the driver\&. 
.PP
\fBReturns\fP
.RS 4
How long in milliseconds it took to reset the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 387 of file intel_i217\&.cpp\&.
.PP
.nf
387                            {
388     return Driver::reset();
389 }
.fi
.PP
References MaxOS::drivers::Driver::reset()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

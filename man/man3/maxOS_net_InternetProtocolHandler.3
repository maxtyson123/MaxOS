.TH "maxOS::net::InternetProtocolHandler" 3 "Fri Jan 5 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::net::InternetProtocolHandler
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ipv4\&.h>\fP
.PP
Inherits \fBmaxOS::net::EthernetFramePayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInternetProtocolHandler\fP (\fBEthernetFrameHandler\fP *backend, \fBInternetProtocolAddress\fP \fBownInternetProtocolAddress\fP, \fBInternetProtocolAddress\fP \fBdefaultGatewayInternetProtocolAddress\fP, \fBSubnetMask\fP \fBsubnetMask\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.ti -1c
.RI "\fB~InternetProtocolHandler\fP ()"
.br
.ti -1c
.RI "bool \fBhandleEthernetframePayload\fP (uint8_t *ethernetframePayload, uint32_t \fBsize\fP) override"
.br
.RI "Called when an IP packet is received\&. "
.ti -1c
.RI "void \fBsendInternetProtocolPacket\fP (uint32_t dstIP_BE, uint8_t \fBprotocol\fP, uint8_t *\fBdata\fP, uint32_t \fBsize\fP)"
.br
.RI "Sends an IP packet\&. "
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBGetInternetProtocolAddress\fP ()"
.br
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBGetMediaAccessControlAddress\fP ()"
.br
.ti -1c
.RI "void \fBconnectInternetProtocolPayloadHandler\fP (\fBInternetProtocolPayloadHandler\fP *internetProtocolPayloadHandler)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static uint16_t \fBChecksum\fP (uint16_t *\fBdata\fP, uint32_t lengthInBytes)"
.br
.RI "Creates a checksum for the given data\&. "
.ti -1c
.RI "static \fBInternetProtocolAddress\fP \fBCreateInternetProtocolAddress\fP (uint8_t digit1, uint8_t digit2, uint8_t digit3, uint8_t digit4)"
.br
.ti -1c
.RI "static \fBInternetProtocolAddress\fP \fBParse\fP (\fBstring\fP \fBaddress\fP)"
.br
.ti -1c
.RI "static \fBSubnetMask\fP \fBCreateSubnetMask\fP (uint8_t digit1, uint8_t digit2, uint8_t digit3, uint8_t digit4)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBRegisterInternetProtocolAddressResolver\fP (\fBInternetProtocolAddressResolver\fP *\fBresolver\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint8_t, \fBInternetProtocolPayloadHandler\fP * > \fBinternetProtocolPayloadHandlers\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddressResolver\fP * \fBresolver\fP"
.br
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBownInternetProtocolAddress\fP"
.br
.ti -1c
.RI "\fBInternetProtocolAddress\fP \fBdefaultGatewayInternetProtocolAddress\fP"
.br
.ti -1c
.RI "\fBSubnetMask\fP \fBsubnetMask\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBInternetProtocolAddressResolver\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 62 of file ipv4\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InternetProtocolHandler::InternetProtocolHandler (\fBEthernetFrameHandler\fP * backend, \fBInternetProtocolAddress\fP ownInternetProtocolAddress, \fBInternetProtocolAddress\fP defaultGatewayInternetProtocolAddress, \fBSubnetMask\fP subnetMask, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line 92 of file ipv4\&.cpp\&.
.PP
.nf
93         : EthernetFramePayloadHandler(backend, 0x0800)
94 {
95     //Store vars
96     this -> ownInternetProtocolAddress = ownInternetProtocolAddress;
97     this -> defaultGatewayInternetProtocolAddress = defaultGatewayInternetProtocolAddress;
98     this -> subnetMask = subnetMask;
99     this -> errorMessages = errorMessages;
100 }
.fi
.PP
References defaultGatewayInternetProtocolAddress, errorMessages, ownInternetProtocolAddress, and subnetMask\&.
.SS "InternetProtocolHandler::~InternetProtocolHandler ()"

.PP
Definition at line 102 of file ipv4\&.cpp\&.
.PP
.nf
102                                                   {
103 
104 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "uint16_t InternetProtocolHandler::Checksum (uint16_t * data, uint32_t lengthInBytes)\fC [static]\fP"

.PP
Creates a checksum for the given data\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP The data to create a checksum for\&. 
.br
\fIlengthInBytes\fP The length of the data in bytes\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The checksum\&. 
.RE
.PP

.PP
Definition at line 221 of file ipv4\&.cpp\&.
.PP
.nf
221                                                                                  {
222 
223     uint32_t temp = 0;                                                                             //Init sum
224 
225     for(int i = 0; i < lengthInBytes/2; i++)                                                       //Loop through data (/2 bc bytes)
226         temp += ((data[i] & 0xFF00) >> 8) | ((data[i] & 0x00FF) << 8);                             //Add data to sum in big endian
227 
228     if(lengthInBytes % 2)                                                                          //If there is an odd number of bytes
229         temp += ((uint16_t)((string)data)[lengthInBytes-1]) << 8;                                   //Add the last byte to the sum
230 
231     while(temp & 0xFFFF0000)                                                                       //While there is a carry
232         temp = (temp & 0xFFFF) + (temp >> 16);                                                     //Add the carry to the sum
233 
234     return ((~temp & 0xFF00) >> 8) | ((~temp & 0x00FF) << 8);
235 }
.fi
.PP
References data, and maxOS::drivers::peripherals::i\&.
.PP
Referenced by handleEthernetframePayload(), maxOS::net::InternetControlMessageProtocol::handleInternetProtocolPayload(), maxOS::net::InternetControlMessageProtocol::RequestEchoReply(), sendInternetProtocolPacket(), and maxOS::net::TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket()\&.
.SS "void InternetProtocolHandler::connectInternetProtocolPayloadHandler (\fBInternetProtocolPayloadHandler\fP * internetProtocolPayloadHandler)"

.PP
Definition at line 287 of file ipv4\&.cpp\&.
.PP
.nf
287                                                                                                                                    {
288     internetProtocolPayloadHandlers\&.insert(internetProtocolPayloadHandler -> ipProtocol, internetProtocolPayloadHandler);
289 }
.fi
.PP
References internetProtocolPayloadHandlers\&.
.PP
Referenced by maxOS::net::InternetProtocolPayloadHandler::InternetProtocolPayloadHandler()\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::CreateInternetProtocolAddress (uint8_t digit1, uint8_t digit2, uint8_t digit3, uint8_t digit4)\fC [static]\fP"

.PP
Definition at line 243 of file ipv4\&.cpp\&.
.PP
.nf
243                                                                                                                                              {
244     InternetProtocolAddress result = digit4;
245     result = (result << 8) | digit3;
246     result = (result << 8) | digit2;
247     result = (result << 8) | digit1;
248     return result;
249 }
.fi
.PP
Referenced by CreateSubnetMask(), and Parse()\&.
.SS "\fBSubnetMask\fP InternetProtocolHandler::CreateSubnetMask (uint8_t digit1, uint8_t digit2, uint8_t digit3, uint8_t digit4)\fC [static]\fP"

.PP
Definition at line 275 of file ipv4\&.cpp\&.
.PP
.nf
275                                                                                                                    {
276     return (SubnetMask)CreateInternetProtocolAddress(digit1, digit2, digit3, digit4);
277 }
.fi
.PP
References CreateInternetProtocolAddress()\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::GetInternetProtocolAddress ()"

.PP
Definition at line 279 of file ipv4\&.cpp\&.
.PP
.nf
279                                                                             {
280     return ownInternetProtocolAddress;
281 }
.fi
.PP
References ownInternetProtocolAddress\&.
.PP
Referenced by handleEthernetframePayload(), and sendInternetProtocolPacket()\&.
.SS "\fBMediaAccessControlAddress\fP InternetProtocolHandler::GetMediaAccessControlAddress ()"

.PP
Definition at line 283 of file ipv4\&.cpp\&.
.PP
.nf
283                                                                                 {
284     return frameHandler -> getMAC();
285 }
.fi
.PP
References maxOS::net::EthernetFramePayloadHandler::frameHandler\&.
.SS "bool InternetProtocolHandler::handleEthernetframePayload (uint8_t * ethernetframePayload, uint32_t size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when an IP packet is received\&. 
.PP
\fBParameters\fP
.RS 4
\fIetherframePayload\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if the packet is to be sent back, false otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::net::EthernetFramePayloadHandler\fP\&.
.PP
Definition at line 113 of file ipv4\&.cpp\&.
.PP
.nf
113                                                                                                     {
114 
115     errorMessages ->write("IP: Handling packet\n");
116 
117     //Check if the size is big enough to contain an ethernet frame
118     if(size < sizeof(InternetProtocolV4Header))
119         return false;
120 
121     //Convert to struct for easier use
122     InternetProtocolV4Header* ipMessage = (InternetProtocolV4Header*)ethernetframePayload;
123     bool sendBack = false;
124 
125     //Only handle if it is for this device
126     if(ipMessage -> destinationIP == GetInternetProtocolAddress())
127     {
128         int length = ipMessage -> totalLength;                          //Get length of the message
129         if(length > size)                                               //Check if the length is bigger than the size of the message
130             length = size;                                              //If so, set length to size (this stops heartbleed attacks as it will not read past the end of the message, which the attacker could have filled with data)
131 
132         // Get the handler for the protocol
133         Map<uint8_t, InternetProtocolPayloadHandler*>::iterator handlerIterator = internetProtocolPayloadHandlers\&.find(ipMessage -> protocol);
134         if(handlerIterator != internetProtocolPayloadHandlers\&.end()) {
135             InternetProtocolPayloadHandler* handler = handlerIterator -> second;
136             if(handler != 0) {
137                 sendBack = handler -> handleInternetProtocolPayload(ipMessage -> sourceIP, ipMessage -> destinationIP, ethernetframePayload + sizeof(InternetProtocolV4Header), length - sizeof(InternetProtocolV4Header));
138             }
139         }
140 
141 
142     }
143 
144     //If the data is to be sent back again
145     if(sendBack){
146 
147         //Swap source and destination
148         uint32_t temp = ipMessage -> destinationIP;                                                                                     //Store destination IP
149         ipMessage -> destinationIP = ipMessage -> sourceIP;                                                                                //Set destination IP to source IP
150         ipMessage -> sourceIP = temp;                                                                                              //Set source IP to destination IP
151 
152         ipMessage -> timeToLive = 0x40;                                                                                         //Reset TTL
153         ipMessage -> checksum = Checksum((uint16_t*)ipMessage, 4 * ipMessage -> headerLength);                  //Reset checksum as the source and destination IP have changed so has the time to live and therefore there is a different header
154 
155 
156         // TODO: Set the identifier
157     }
158 
159     errorMessages ->write("IP: Handled packet\n");
160     return sendBack;
161 }
.fi
.PP
References checksum, Checksum(), destinationIP, errorMessages, GetInternetProtocolAddress(), headerLength, internetProtocolPayloadHandlers, length, protocol, size, sourceIP, timeToLive, totalLength, and maxOS::common::OutputStream::write()\&.
.SS "\fBInternetProtocolAddress\fP InternetProtocolHandler::Parse (\fBstring\fP address)\fC [static]\fP"

.PP
Definition at line 251 of file ipv4\&.cpp\&.
.PP
.nf
251                                                                      {
252     uint8_t digits[4];
253 
254     uint8_t currentDigit = 0;
255     for(int i = 0; i < 4; i++)
256         digits[i] = 0;
257     for(string i = (string)address; *i != '\0'; ++i)
258     {
259         if('0' <= *i && *i <= '9')
260         {
261             digits[currentDigit] = digits[currentDigit] * 10 + *i - '0';
262         }
263         else
264         {
265             if(currentDigit >= 3)
266                 break;
267             currentDigit++;
268         }
269 
270     }
271 
272     return CreateInternetProtocolAddress(digits[0], digits[1], digits[2], digits[3]);
273 }
.fi
.PP
References address, CreateInternetProtocolAddress(), and maxOS::drivers::peripherals::i\&.
.PP
Referenced by maxOS::net::UserDatagramProtocolHandler::Connect(), and maxOS::net::TransmissionControlProtocolHandler::Connect()\&.
.SS "void InternetProtocolHandler::RegisterInternetProtocolAddressResolver (\fBInternetProtocolAddressResolver\fP * resolver)\fC [protected]\fP"

.PP
Definition at line 237 of file ipv4\&.cpp\&.
.PP
.nf
237                                                                                                                {
238 
239     this -> resolver = resolver;
240 
241 }
.fi
.PP
References resolver\&.
.SS "void InternetProtocolHandler::sendInternetProtocolPacket (uint32_t dstIP_BE, uint8_t protocol, uint8_t * data, uint32_t size)"

.PP
Sends an IP packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIdstIP_BE\fP The destination IP address\&. 
.br
\fIprotocol\fP The protocol of the IP packet\&. 
.br
\fIdata\fP The payload of the IP packet\&. 
.br
\fIsize\fP The size of the IP packet\&. 
.RE
.PP

.PP
Definition at line 172 of file ipv4\&.cpp\&.
.PP
.nf
172                                                                                                                           {
173 
174     uint8_t* buffer = (uint8_t*)MemoryManager::s_active_memory_manager-> malloc(sizeof(InternetProtocolV4Header) + size);                           //Allocate memory for the message
175     InternetProtocolV4Header *message = (InternetProtocolV4Header*)buffer;                                                                            //Convert to struct for easier use
176 
177     message -> version = 4;                                                                                                                           //Set version
178     message -> headerLength = sizeof(InternetProtocolV4Header)/4;                                                                                     //Set header length
179     message -> typeOfService = 0;                                                                                                                     //Set type of service (not priv)
180 
181     message -> totalLength = size + sizeof(InternetProtocolV4Header);                                                                                 //Set total length
182     message -> totalLength = ((message -> totalLength & 0xFF00) >> 8)                                                                                 // Convert to big endian (Swap bytes)
183                              | ((message -> totalLength & 0x00FF) << 8);                                                                              // Convert to big endian (Swap bytes)
184 
185     message -> identifier = 0x100;                                                                                                                    //Set identification TODO: do properly
186     message -> flagsAndOffset = 0x0040;                                                                                                               //Set flags/offset, 0x40 because we are not fragmenting (TODO: doesnt work for packets bigger than 1500 bytes)
187 
188     message -> timeToLive = 0x40;                                                                                                                     //Set time to live
189     message -> protocol = protocol;                                                                                                                   //Set protocol
190 
191     message -> destinationIP = dstIP_BE;                                                                                                                      //Set destination IP
192     message -> sourceIP = GetInternetProtocolAddress();                                                                                                  //Set source IP
193 
194     message -> checksum = 0;                                                                                                                          //Set checksum to 0, init with 0 as checksum funct will also add this value
195     message -> checksum = Checksum((uint16_t*)message, sizeof(InternetProtocolV4Header));                                             //Calculate checksum
196 
197     //Copy data
198     uint8_t* databuffer = buffer + sizeof(InternetProtocolV4Header);                                                                                  //Get pointer to the data
199     for(int i = 0; i < size; i++)                                                                                                                            //Loop through data
200         databuffer[i] = data[i];                                                                                                                             //Copy data
201 
202     //Check if the destination is on the same subnet, The if condition determines if the destination device is on the same Local network as the source device \&. and if they are not on the same local network then we resolve the ip address of the gateway \&.
203     InternetProtocolAddress route = dstIP_BE;                                                                                                                               //Set route to destination IP by default
204     if((dstIP_BE & subnetMask) != (ownInternetProtocolAddress & subnetMask))                                                                                             //Check if the destination is on the same subnet
205         route = defaultGatewayInternetProtocolAddress;                                                                                                                                   //If not, set route to gateway IP
206                                                                                                                     //Print debug info
207     uint32_t MAC = resolver ->Resolve(route);
208 
209     //Send message
210     frameHandler -> sendEthernetFrame(MAC, this -> handledType, buffer, size + sizeof(InternetProtocolV4Header));      //Send message
211     MemoryManager::s_active_memory_manager->free(buffer);                                                                                                 //Free memory
212 }
.fi
.PP
References checksum, Checksum(), data, defaultGatewayInternetProtocolAddress, destinationIP, flagsAndOffset, maxOS::net::EthernetFramePayloadHandler::frameHandler, GetInternetProtocolAddress(), maxOS::net::EthernetFramePayloadHandler::handledType, headerLength, maxOS::drivers::peripherals::i, identifier, ownInternetProtocolAddress, protocol, maxOS::net::InternetProtocolAddressResolver::Resolve(), resolver, size, sourceIP, subnetMask, timeToLive, totalLength, typeOfService, and version\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBInternetProtocolAddressResolver\fP\fC [friend]\fP"

.PP
Definition at line 64 of file ipv4\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBInternetProtocolAddress\fP maxOS::net::InternetProtocolHandler::defaultGatewayInternetProtocolAddress\fC [protected]\fP"

.PP
Definition at line 74 of file ipv4\&.h\&.
.PP
Referenced by InternetProtocolHandler(), and sendInternetProtocolPacket()\&.
.SS "\fBcommon::OutputStream\fP* maxOS::net::InternetProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Definition at line 71 of file ipv4\&.h\&.
.PP
Referenced by handleEthernetframePayload(), and InternetProtocolHandler()\&.
.SS "\fBcommon::Map\fP<uint8_t, \fBInternetProtocolPayloadHandler\fP*> maxOS::net::InternetProtocolHandler::internetProtocolPayloadHandlers\fC [protected]\fP"

.PP
Definition at line 68 of file ipv4\&.h\&.
.PP
Referenced by connectInternetProtocolPayloadHandler(), and handleEthernetframePayload()\&.
.SS "\fBInternetProtocolAddress\fP maxOS::net::InternetProtocolHandler::ownInternetProtocolAddress\fC [protected]\fP"

.PP
Definition at line 73 of file ipv4\&.h\&.
.PP
Referenced by GetInternetProtocolAddress(), InternetProtocolHandler(), and sendInternetProtocolPacket()\&.
.SS "\fBInternetProtocolAddressResolver\fP* maxOS::net::InternetProtocolHandler::resolver\fC [protected]\fP"

.PP
Definition at line 70 of file ipv4\&.h\&.
.PP
Referenced by RegisterInternetProtocolAddressResolver(), and sendInternetProtocolPacket()\&.
.SS "\fBSubnetMask\fP maxOS::net::InternetProtocolHandler::subnetMask\fC [protected]\fP"

.PP
Definition at line 75 of file ipv4\&.h\&.
.PP
Referenced by InternetProtocolHandler(), and sendInternetProtocolPacket()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

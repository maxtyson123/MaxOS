.TH "MaxOS::hardwarecommunication::LocalAPIC" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::LocalAPIC \- Handles the local APIC for the current core\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "uint32_t \fBread\fP (uint32_t reg) const"
.br
.RI "Read a value from the apic register using the MSR or memory I/O depending on the local apic version\&. "
.ti -1c
.RI "void \fBwrite\fP (uint32_t reg, uint32_t value) const"
.br
.RI "Write a value to the apic register using the MSR or memory I/O depending on the local apic version\&. "
.ti -1c
.RI "uint32_t \fBid\fP () const"
.br
.RI "Get the id of the local apic\&. "
.ti -1c
.RI "void \fBsend_eoi\fP () const"
.br
.RI "Acknowledge that the interrupt has been handled, allowing the PIC to process the next interrupt\&. "
.ti -1c
.RI "void \fBsend_init\fP (uint8_t \fBapic_id\fP, bool assert)"
.br
.RI "Send the init IPI to another apic\&. "
.ti -1c
.RI "void \fBsend_startup\fP (uint8_t \fBapic_id\fP, uint8_t \fBvector\fP)"
.br
.RI "Send the start up IPI to another apic\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the local APIC for the current core\&. 
.PP
Definition at line \fB23\fP of file \fBapic\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "LocalAPIC::LocalAPIC ()"

.PP
Definition at line \fB18\fP of file \fBapic\&.cpp\fP\&..PP
.nf
18                      {
19 
20     // Get the APIC base address
21     uint64_t msr_info = CPU::read_msr(0x1B);
22     m_apic_base = msr_info & 0xFFFFF000;
23 
24     // Reserve the base address once
25     static bool bsp_setup = false;
26     if(!bsp_setup)
27         PhysicalMemoryManager::s_current_manager\->reserve(m_apic_base);
28 
29     // Check if the APIC supports x2APIC
30     uint32_t ignored, xleaf, x2leaf;
31     CPU::cpuid(0x01, &ignored, &ignored, &x2leaf, &xleaf);
32 
33     if (x2leaf & (1 << 21)) {
34 
35         // Enable x2APIC
36         m_x2apic = true;
37         msr_info |= (1 << 10);
38         CPU::write_msr(0x1B, msr_info);
39         Logger::DEBUG() << "CPU supports x2APIC\\n";
40 
41     } else if (xleaf & (1 << 9)) {
42 
43         m_x2apic = false;
44         Logger::DEBUG() << "CPU supports xAPIC\\n";
45 
46         // Map the APIC base address to the higher half
47         m_apic_base_high = (uint64_t) PhysicalMemoryManager::to_io_region(m_apic_base);
48         PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) m_apic_base, (virtual_address_t*) m_apic_base_high, PRESENT | WRITE);
49         Logger::DEBUG() << "APIC Base: phy=0x" << m_apic_base << ", virt=0x" << m_apic_base_high << "\\n";
50     } else {
51         ASSERT(false, "CPU does not support xAPIC");
52     }
53 
54     if (!(msr_info & (1 << 11))) {
55         Logger::WARNING() << "APIC is not enabled\\n";
56         return;
57     }
58 
59     // Enable the APIC
60     write(0xF0, (1 << 8) | 0x100);
61     bsp_setup = true;
62     Logger::DEBUG() << "APIC Enabled\\n";
63 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "uint32_t LocalAPIC::id () const"

.PP
Get the id of the local apic\&. 
.PP
\fBReturns\fP
.RS 4
The id of the local apic 
.RE
.PP

.PP
Definition at line \fB105\fP of file \fBapic\&.cpp\fP\&..PP
.nf
105                              {
106 
107     // Read the id
108     uint32_t id = read(0x20);
109 
110     // Return the id
111     return m_x2apic ? id : (id >> 24);
112 }
.fi

.PP
References \fBid()\fP, and \fBread()\fP\&.
.PP
Referenced by \fBid()\fP\&.
.SS "uint32_t LocalAPIC::read (uint32_t reg) const"

.PP
Read a value from the apic register using the MSR or memory I/O depending on the local apic version\&. 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to read 
.RE
.PP
\fBReturns\fP
.RS 4
The value of the register 
.RE
.PP

.PP
Definition at line \fB73\fP of file \fBapic\&.cpp\fP\&..PP
.nf
73                                            {
74 
75     // If x2APIC is enabled I/O is done through the MSR
76     if (m_x2apic)
77         return (uint32_t) CPU::read_msr((reg >> 4) + 0x800);
78 
79     return *(volatile uint32_t*) ((uintptr_t) m_apic_base_high + reg);
80 }
.fi

.PP
References \fBMaxOS::system::CPU::read_msr()\fP\&.
.PP
Referenced by \fBid()\fP, \fBsend_init()\fP, and \fBsend_startup()\fP\&.
.SS "void LocalAPIC::send_eoi () const"

.PP
Acknowledge that the interrupt has been handled, allowing the PIC to process the next interrupt\&. 
.PP
Definition at line \fB117\fP of file \fBapic\&.cpp\fP\&..PP
.nf
117                                {
118 
119     write(0xB0, 0);
120 }
.fi

.PP
References \fBwrite\fP\&.
.SS "void LocalAPIC::send_init (uint8_t apic_id, bool assert)"

.PP
Send the init IPI to another apic\&. 
.PP
\fBParameters\fP
.RS 4
\fIapic_id\fP The id of the apic to send to 
.br
\fIassert\fP Is this an assert code (drive / release the signal) 
.RE
.PP

.PP
Definition at line \fB128\fP of file \fBapic\&.cpp\fP\&..PP
.nf
128                                                       {
129 
130     uint32_t icr_low = 0;
131 
132     // Delivery mode = INIT (101b at bits 8\-10)
133     icr_low |= (0b101 << 8);
134 
135     // Level (bit 14): 1 = assert, 0 = de\-assert
136     if (assert)
137         icr_low |= (1 << 14);
138 
139     // Trigger mode: Level = 1
140     icr_low |= (1 << 15);
141 
142     if (!m_x2apic) {
143 
144         // Select target core
145         write(0x310, apic_id << 24);
146 
147         // Send INIT (Delivery mode = INIT, Level = 1)
148         write(0x300, icr_low);
149 
150         // Wait for delivery
151         while (read(0x300) & (1 << 12))
152             asm volatile("pause");
153 
154     } else {
155 
156         // x2APIC
157         CPU::write_msr(0x830, apic_id << 32 | icr_low);
158     }
159 }
.fi

.PP
References \fBapic_id\fP, \fBread()\fP, \fBwrite\fP, and \fBMaxOS::system::CPU::write_msr()\fP\&.
.SS "void LocalAPIC::send_startup (uint8_t apic_id, uint8_t vector)"

.PP
Send the start up IPI to another apic\&. 
.PP
\fBParameters\fP
.RS 4
\fIapic_id\fP The apic to send it to 
.br
\fIvector\fP Where to start executing 
.RE
.PP

.PP
Definition at line \fB167\fP of file \fBapic\&.cpp\fP\&..PP
.nf
167                                                             {
168 
169     if (!m_x2apic) {
170 
171         // Select target core
172         write(0x310, apic_id << 24);
173 
174         // Send SIPI (Delivery mode = STARTUP)
175         write(0x300, 0x4600 | vector);
176 
177         // Wait for delivery
178         while (read(0x300) & (1 << 12))
179             asm volatile("pause");
180 
181     } else {
182 
183         // x2APIC
184         CPU::write_msr(0x831, apic_id << 32 | 0x4600 | vector);
185     }
186 
187 
188 }
.fi

.PP
References \fBapic_id\fP, \fBread()\fP, \fBvector\fP, \fBwrite\fP, and \fBMaxOS::system::CPU::write_msr()\fP\&.
.SS "void LocalAPIC::write (uint32_t reg, uint32_t value) const"

.PP
Write a value to the apic register using the MSR or memory I/O depending on the local apic version\&. 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to write to 
.br
\fIvalue\fP The value to write 
.RE
.PP

.PP
Definition at line \fB88\fP of file \fBapic\&.cpp\fP\&..PP
.nf
88                                                         {
89 
90     // If x2APIC is enabled I/O is done through the MSR
91     if (m_x2apic){
92         CPU::write_msr((reg >> 4) + 0x800, value);
93         return;
94     }
95 
96     // Default to memory I/O
97     *(volatile uint32_t*) ((uintptr_t) m_apic_base_high + reg) = value;
98 }
.fi

.PP
References \fBMaxOS::system::CPU::write_msr()\fP\&.
.PP
Referenced by \fBMaxOS::drivers::clock::Clock::setup_apic_clock()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

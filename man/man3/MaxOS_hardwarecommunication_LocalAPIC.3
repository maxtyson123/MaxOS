.TH "MaxOS::hardwarecommunication::LocalAPIC" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::LocalAPIC \- Handles the local APIC for the current core\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLocalAPIC\fP ()"
.br
.RI "Construct a new Local APIC object and map the APIC base address to the higher half if needed as well as enabling the APIC\&. "
.ti -1c
.RI "uint32_t \fBread\fP (uint32_t reg) const"
.br
.RI "read a value from the apic register using the MSR or memory I/O depending on the local apic version "
.ti -1c
.RI "void \fBwrite\fP (uint32_t reg, uint32_t value) const"
.br
.RI "write a value to the apic register using the MSR or memory I/O depending on the local apic version "
.ti -1c
.RI "uint32_t \fBid\fP () const"
.br
.RI "Get the id of the local apic\&. "
.ti -1c
.RI "void \fBsend_eoi\fP () const"
.br
.RI "Acknowledge that the interrupt has been handled, allowing the PIC to process the next interrupt\&. "
.ti -1c
.RI "void \fBsend_init\fP (uint8_t apic_id, bool assert) const"
.br
.RI "send the init IPI to another apic "
.ti -1c
.RI "void \fBsend_startup\fP (uint8_t apic_id, uint8_t vector) const"
.br
.RI "send the start up IPI to another apic "
.in -1c
.SH "Detailed Description"
.PP 
Handles the local APIC for the current core\&. 
.PP
Definition at line \fB24\fP of file \fBapic\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "LocalAPIC::LocalAPIC ()"

.PP
Construct a new Local APIC object and map the APIC base address to the higher half if needed as well as enabling the APIC\&. 
.PP
Definition at line \fB21\fP of file \fBapic\&.cpp\fP\&..PP
.nf
21                      {
22 
23     // Get the APIC base address
24     uint64_t msr_info = CPU::read_msr(0x1B);
25     m_apic_base = msr_info & 0xFFFFF000;
26 
27     // Reserve the base address once
28     static bool bsp_setup = false;
29     if(!bsp_setup)
30         PhysicalMemoryManager::s_current_manager\->reserve(m_apic_base);
31 
32     // Check if the APIC supports x2APIC
33     uint32_t ignored, xleaf, x2leaf;
34     CPU::cpuid(0x01, &ignored, &ignored, &x2leaf, &xleaf);
35 
36     if (x2leaf & (1 << 21)) {
37 
38         // Enable x2APIC
39         m_x2apic = true;
40         msr_info |= (1 << 10);
41         CPU::write_msr(0x1B, msr_info);
42         Logger::DEBUG() << "CPU supports x2APIC\\n";
43 
44     } else if (xleaf & (1 << 9)) {
45 
46         m_x2apic = false;
47         Logger::DEBUG() << "CPU supports xAPIC\\n";
48 
49         // Map the APIC base address to the higher half
50         m_apic_base_high = (uint64_t) PhysicalMemoryManager::to_io_region(m_apic_base);
51         PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) m_apic_base, (virtual_address_t*) m_apic_base_high, PRESENT | WRITE);
52         Logger::DEBUG() << "APIC Base: phy=0x" << m_apic_base << ", virt=0x" << m_apic_base_high << "\\n";
53     } else {
54         ASSERT(false, "CPU does not support xAPIC");
55     }
56 
57     if (!(msr_info & (1 << 11))) {
58         Logger::WARNING() << "APIC is not enabled\\n";
59         return;
60     }
61 
62     // Enable the APIC
63     write(0xF0, (1 << 8) | 0x100);
64     bsp_setup = true;
65     Logger::DEBUG() << "APIC Enabled\\n";
66 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::system::CPU::cpuid()\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBMaxOS::memory::PhysicalMemoryManager::map()\fP, \fBMaxOS::memory::PRESENT\fP, \fBMaxOS::system::CPU::read_msr()\fP, \fBMaxOS::memory::PhysicalMemoryManager::reserve()\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_io_region()\fP, \fBMaxOS::Logger::WARNING()\fP, \fBwrite()\fP, \fBMaxOS::memory::WRITE\fP, and \fBMaxOS::system::CPU::write_msr()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "uint32_t LocalAPIC::id () const"

.PP
Get the id of the local apic\&. 
.PP
\fBReturns\fP
.RS 4
The id of the local apic 
.RE
.PP

.PP
Definition at line \fB108\fP of file \fBapic\&.cpp\fP\&..PP
.nf
108                              {
109 
110     // Read the id
111     uint32_t id = read(0x20);
112 
113     // Return the id
114     return m_x2apic ? id : (id >> 24);
115 }
.fi

.PP
References \fBid()\fP, and \fBread()\fP\&.
.PP
Referenced by \fBid()\fP\&.
.SS "uint32_t LocalAPIC::read (uint32_t reg) const"

.PP
read a value from the apic register using the MSR or memory I/O depending on the local apic version 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to read 
.RE
.PP
\fBReturns\fP
.RS 4
The value of the register 
.RE
.PP

.PP
Definition at line \fB76\fP of file \fBapic\&.cpp\fP\&..PP
.nf
76                                            {
77 
78     // If x2APIC is enabled I/O is done through the MSR
79     if (m_x2apic)
80         return (uint32_t) CPU::read_msr((reg >> 4) + 0x800);
81 
82     return *(volatile uint32_t*) ((uintptr_t) m_apic_base_high + reg);
83 }
.fi

.PP
References \fBMaxOS::system::CPU::read_msr()\fP\&.
.PP
Referenced by \fBid()\fP, \fBsend_init()\fP, and \fBsend_startup()\fP\&.
.SS "void LocalAPIC::send_eoi () const"

.PP
Acknowledge that the interrupt has been handled, allowing the PIC to process the next interrupt\&. 
.PP
Definition at line \fB120\fP of file \fBapic\&.cpp\fP\&..PP
.nf
120                                {
121 
122     write(0xB0, 0);
123 }
.fi

.PP
References \fBwrite()\fP\&.
.SS "void LocalAPIC::send_init (uint8_t apic_id, bool assert) const"

.PP
send the init IPI to another apic 
.PP
\fBParameters\fP
.RS 4
\fIapic_id\fP The id of the apic to send to 
.br
\fIassert\fP Is this an assert code (drive / release the signal) 
.RE
.PP

.PP
Definition at line \fB131\fP of file \fBapic\&.cpp\fP\&..PP
.nf
131                                                             {
132 
133     uint32_t icr_low = 0;
134 
135     // Delivery mode = INIT (101b at bits 8\-10)
136     icr_low |= (0b101 << 8);
137 
138     // Level (bit 14): 1 = assert, 0 = de\-assert
139     if (assert)
140         icr_low |= (1 << 14);
141 
142     // Trigger mode: Level = 1
143     icr_low |= (1 << 15);
144 
145     if (!m_x2apic) {
146 
147         // Select target core
148         write(0x310, apic_id << 24);
149 
150         // Send INIT (Delivery mode = INIT, Level = 1)
151         write(0x300, icr_low);
152 
153         // Wait for delivery
154         while (read(0x300) & (1 << 12))
155             asm volatile("pause");
156 
157     } else {
158 
159         // x2APIC
160         CPU::write_msr(0x830, (uint64_t)apic_id << 32 | icr_low);
161     }
162 }
.fi

.PP
References \fBread()\fP, \fBwrite()\fP, and \fBMaxOS::system::CPU::write_msr()\fP\&.
.SS "void LocalAPIC::send_startup (uint8_t apic_id, uint8_t vector) const"

.PP
send the start up IPI to another apic 
.PP
\fBParameters\fP
.RS 4
\fIapic_id\fP The apic to send it to 
.br
\fIvector\fP Where to start executing 
.RE
.PP

.PP
Definition at line \fB170\fP of file \fBapic\&.cpp\fP\&..PP
.nf
170                                                                   {
171 
172     if (!m_x2apic) {
173 
174         // Select target core
175         write(0x310, apic_id << 24);
176 
177         // Send SIPI (Delivery mode = STARTUP)
178         write(0x300, 0x4600 | vector);
179 
180         // Wait for delivery
181         while (read(0x300) & (1 << 12))
182             asm volatile("pause");
183 
184     } else {
185 
186         // x2APIC
187         CPU::write_msr(0x831, (uint64_t)apic_id << 32 | 0x4600 | vector);
188     }
189 
190 
191 }
.fi

.PP
References \fBread()\fP, \fBwrite()\fP, and \fBMaxOS::system::CPU::write_msr()\fP\&.
.SS "void LocalAPIC::write (uint32_t reg, uint32_t value) const"

.PP
write a value to the apic register using the MSR or memory I/O depending on the local apic version 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to write to 
.br
\fIvalue\fP The value to write 
.RE
.PP

.PP
Definition at line \fB91\fP of file \fBapic\&.cpp\fP\&..PP
.nf
91                                                         {
92 
93     // If x2APIC is enabled I/O is done through the MSR
94     if (m_x2apic){
95         CPU::write_msr((reg >> 4) + 0x800, value);
96         return;
97     }
98 
99     // Default to memory I/O
100     *(volatile uint32_t*) ((uintptr_t) m_apic_base_high + reg) = value;
101 }
.fi

.PP
References \fBMaxOS::system::CPU::write_msr()\fP\&.
.PP
Referenced by \fBLocalAPIC()\fP, \fBsend_eoi()\fP, \fBsend_init()\fP, \fBsend_startup()\fP, and \fBMaxOS::drivers::clock::Clock::setup_apic_clock()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

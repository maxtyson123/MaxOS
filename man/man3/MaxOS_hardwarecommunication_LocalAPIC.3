.TH "MaxOS::hardwarecommunication::LocalAPIC" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::LocalAPIC
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLocalAPIC\fP ()"
.br
.ti -1c
.RI "\fB~LocalAPIC\fP ()"
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.ti -1c
.RI "uint32_t \fBread\fP (uint32_t reg)"
.br
.ti -1c
.RI "void \fBwrite\fP (uint32_t reg, uint32_t value)"
.br
.ti -1c
.RI "uint32_t \fBid\fP ()"
.br
.ti -1c
.RI "void \fBsend_eoi\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint64_t \fBm_apic_base\fP"
.br
.ti -1c
.RI "uint64_t \fBm_apic_base_high\fP"
.br
.ti -1c
.RI "uint32_t \fBm_id\fP"
.br
.ti -1c
.RI "bool \fBm_x2apic\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 17 of file apic\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "LocalAPIC::LocalAPIC ()"

.PP
Definition at line 12 of file apic\&.cpp\&.
.PP
.nf
12                      {
13 
14 }
.fi
.SS "LocalAPIC::~LocalAPIC ()"

.PP
Definition at line 16 of file apic\&.cpp\&.
.PP
.nf
16                       {
17 
18 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "uint32_t LocalAPIC::id ()"

.PP
Definition at line 100 of file apic\&.cpp\&.
.PP
.nf
100                        {
101 
102   // Read the id
103   uint32_t id = read(0x20);
104 
105   // Return the id
106   return m_x2apic ? id : (id >> 24);
107 
108 }
.fi
.SS "void LocalAPIC::init ()"

.PP
Definition at line 20 of file apic\&.cpp\&.
.PP
.nf
20                      {
21 
22   // Read information about the local APIC
23   uint64_t msr_info = CPU::read_msr(0x1B);
24 
25   // Get the APIC base address
26   m_apic_base = msr_info & 0xFFFFF000;
27 
28   // Read if the APIC supports x2APIC
29   uint32_t ignored, xleaf, x2leaf;
30   CPU::cpuid(0x01, &ignored, &ignored, &x2leaf, &xleaf);
31 
32   if(x2leaf & (1 << 21)) {
33 
34     // Enable x2APIC
35     m_x2apic = true;
36     msr_info |= (1 << 10);
37     CPU::write_msr(0x1B, msr_info);
38     _kprintf("CPU supports x2APIC\n");
39 
40   } else if (xleaf & (1 << 9)) {
41 
42     m_x2apic = false;
43     _kprintf("CPU supports xAPIC\n");
44 
45     // Map the APIC base address to the higher half
46     m_apic_base_high = (uint64_t)MemoryManager::to_io_region(m_apic_base);
47     PhysicalMemoryManager::s_current_manager->map((physical_address_t*)m_apic_base, (virtual_address_t*)m_apic_base_high, Write | Present);
48     _kprintf("APIC Base: phy=0x%x, virt=0x%x\n", m_apic_base, m_apic_base_high);
49 
50   } else {
51     ASSERT(false, "CPU does not support xAPIC")
52   }
53 
54   // Get information about the APIC
55   uint32_t spurious_vector = read(0xF0);
56   bool is_enabled = msr_info & (1 << 11);
57   bool is_bsp = msr_info & (1 << 8);
58   _kprintf("APIC: boot processor: %d, enabled (globally): %d, spurious vector: 0x%x\n", is_bsp, is_enabled, spurious_vector);
59 
60   if(!is_enabled) {
61     _kprintf("APIC is not enabled\n");
62     return;
63   }
64 
65   // Enable the APIC
66   write(0xF0, (1 << 8) | 0x100);
67   _kprintf("APIC Enabled\n");
68 
69   // Reserve the APIC base
70   PhysicalMemoryManager::s_current_manager->reserve(m_apic_base);
71 
72   // Read the APIC version
73   uint32_t version = read(0x30);
74   _kprintf("APIC Version: 0x%x\n", version & 0xFF);
75 
76 }
.fi
.PP
References _kprintf, ASSERT, MaxOS::memory::Present, version, write, and MaxOS::memory::Write\&.
.PP
Referenced by MaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\&.
.SS "uint32_t LocalAPIC::read (uint32_t reg)"

.PP
Definition at line 78 of file apic\&.cpp\&.
.PP
.nf
78                                      {
79 
80   // If x2APIC is enabled, use the x2APIC MSR
81   if(m_x2apic) {
82       return (uint32_t)CPU::read_msr((reg >> 4) + 0x800);
83   } else {
84       return (*(volatile uint32_t*)((uintptr_t)m_apic_base_high + reg));
85 
86   }
87 
88 }
.fi
.SS "void LocalAPIC::send_eoi ()"

.PP
Definition at line 110 of file apic\&.cpp\&.
.PP
.nf
110                          {
111 
112     // Send the EOI
113     write(0xB0, 0);
114 }
.fi
.PP
References write\&.
.PP
Referenced by MaxOS::hardwarecommunication::InterruptManager::handle_interrupt_request()\&.
.SS "void LocalAPIC::write (uint32_t reg, uint32_t value)"

.PP
Definition at line 90 of file apic\&.cpp\&.
.PP
.nf
90                                                   {
91 
92   // If x2APIC is enabled, use the x2APIC MSR
93   if(m_x2apic) {
94       CPU::write_msr((reg >> 4) + 0x800, value);
95   } else {
96       (*(volatile uint32_t*)((uintptr_t)m_apic_base_high + reg)) = value;
97     }
98 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "uint64_t MaxOS::hardwarecommunication::LocalAPIC::m_apic_base\fC [protected]\fP"

.PP
Definition at line 20 of file apic\&.h\&.
.SS "uint64_t MaxOS::hardwarecommunication::LocalAPIC::m_apic_base_high\fC [protected]\fP"

.PP
Definition at line 21 of file apic\&.h\&.
.SS "uint32_t MaxOS::hardwarecommunication::LocalAPIC::m_id\fC [protected]\fP"

.PP
Definition at line 22 of file apic\&.h\&.
.SS "bool MaxOS::hardwarecommunication::LocalAPIC::m_x2apic\fC [protected]\fP"

.PP
Definition at line 23 of file apic\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::system::CPU" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::system::CPU
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cpu\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCPU\fP ()"
.br
.RI "Constructor for the \fBCPU\fP class\&. "
.ti -1c
.RI "\fB~CPU\fP ()"
.br
.RI "Destructor for the \fBCPU\fP class\&. "
.ti -1c
.RI "void \fBinit_tss\fP ()"
.br
.RI "Initialises the TSS for interrupt handling\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static cpu_status_t * \fBprepare_for_panic\fP (cpu_status_t *\fBstatus\fP=nullptr)"
.br
.RI "Ensure the \fBCPU\fP must panic and prepare for it if so\&. "
.ti -1c
.RI "static void \fBPANIC\fP (const char *message, cpu_status_t *\fBstatus\fP=nullptr)"
.br
.ti -1c
.RI "static void \fBhalt\fP ()"
.br
.ti -1c
.RI "static \fBCPU\fP * \fBget_instance\fP ()"
.br
.RI "Gets the \fBCPU\fP instance\&. "
.ti -1c
.RI "static void \fBget_status\fP (cpu_status_t *\fBstatus\fP)"
.br
.ti -1c
.RI "static void \fBset_status\fP (cpu_status_t *\fBstatus\fP)"
.br
.ti -1c
.RI "static void \fBprint_registers\fP (cpu_status_t *\fBstatus\fP)"
.br
.ti -1c
.RI "static uint64_t \fBread_msr\fP (uint32_t msr)"
.br
.ti -1c
.RI "static void \fBwrite_msr\fP (uint32_t msr, uint64_t value)"
.br
.ti -1c
.RI "static void \fBcpuid\fP (uint32_t leaf, uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)"
.br
.ti -1c
.RI "static void \fBstack_trace\fP (size_t)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "tss_t \fBtss\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static bool \fBis_panicking\fP = { false }"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 69 of file cpu\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "CPU::CPU ()"

.PP
Constructor for the \fBCPU\fP class\&. 
.PP
Definition at line 252 of file cpu\&.cpp\&.
.PP
.nf
252          {
253 
254   // Set the instance
255   s_instance = this;
256 
257   // TODO = Multicore support
258 
259 }
.fi
.SS "CPU::~CPU ()"

.PP
Destructor for the \fBCPU\fP class\&. 
.PP
Definition at line 264 of file cpu\&.cpp\&.
.PP
.nf
264           {
265 
266   // Clear the instance
267   s_instance = nullptr;
268 
269 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void CPU::cpuid (uint32_t leaf, uint32_t * eax, uint32_t * ebx, uint32_t * ecx, uint32_t * edx)\fC [static]\fP"

.PP
Definition at line 112 of file cpu\&.cpp\&.
.PP
.nf
112                                                                                          {
113 
114   // Call the cpuid instruction
115   __get_cpuid(leaf, eax, ebx, ecx, edx);
116 }
.fi
.SS "\fBCPU\fP * CPU::get_instance ()\fC [static]\fP"

.PP
Gets the \fBCPU\fP instance\&. 
.PP
\fBReturns\fP
.RS 4
The \fBCPU\fP instance 
.RE
.PP

.PP
Definition at line 275 of file cpu\&.cpp\&.
.PP
.nf
275                        {
276 
277   if(s_instance)
278     return s_instance;
279 
280   return new CPU();
281 
282 }
.fi
.PP
Referenced by MaxOS::processes::Scheduler::schedule_next(), and MaxOS::processes::Thread::Thread()\&.
.SS "void CPU::get_status (cpu_status_t * status)\fC [static]\fP"

.PP
Definition at line 23 of file cpu\&.cpp\&.
.PP
.nf
23                                          {
24 
25     // Get the registers
26     asm volatile("mov %%r15, %0" : "=r" (status->r15));
27     asm volatile("mov %%r14, %0" : "=r" (status->r14));
28     asm volatile("mov %%r13, %0" : "=r" (status->r13));
29     asm volatile("mov %%r12, %0" : "=r" (status->r12));
30     asm volatile("mov %%r11, %0" : "=r" (status->r11));
31     asm volatile("mov %%r10, %0" : "=r" (status->r10));
32     asm volatile("mov %%r9, %0" : "=r" (status->r9));
33     asm volatile("mov %%r8, %0" : "=r" (status->r8));
34     asm volatile("mov %%rdi, %0" : "=r" (status->rdi));
35     asm volatile("mov %%rsi, %0" : "=r" (status->rsi));
36     asm volatile("mov %%rbp, %0" : "=r" (status->rbp));
37     asm volatile("mov %%rdx, %0" : "=r" (status->rdx));
38     asm volatile("mov %%rcx, %0" : "=r" (status->rcx));
39     asm volatile("mov %%rbx, %0" : "=r" (status->rbx));
40     asm volatile("mov %%rax, %0" : "=r" (status->rax));
41 
42 }
.fi
.PP
References status\&.
.SS "void CPU::halt ()\fC [static]\fP"

.PP
Definition at line 19 of file cpu\&.cpp\&.
.PP
.nf
19                {
20   asm volatile("hlt");
21 }
.fi
.SS "void CPU::init_tss ()"

.PP
Initialises the TSS for interrupt handling\&. 
.PP
Definition at line 191 of file cpu\&.cpp\&.
.PP
.nf
191                    {
192 
193   // The reserved have to be 0
194   tss\&.reserved0 = 0;
195   tss\&.reserved1 = 0;
196   tss\&.reserved2 = 0;
197   tss\&.reserved3 = 0;
198   tss\&.reserved4 = 0;
199 
200   // The stacks
201   tss\&.rsp0 = (uint64_t)stack + 16384;       // Kernel stack (scheduler will set the threads stack)
202   tss\&.rsp1 = 0;
203   tss\&.rsp2 = 0;
204 
205   // Interrupt stacks can all be 0
206   tss\&.ist1 = 0;
207   tss\&.ist2 = 0;
208   tss\&.ist3 = 0;
209   tss\&.ist4 = 0;
210   tss\&.ist5 = 0;
211   tss\&.ist6 = 0;
212   tss\&.ist7 = 0;
213 
214   // Ports TODO when setting up userspace drivers come back to this
215   tss\&.io_bitmap_offset = 0;
216 
217   // Split the base into 4 parts (16 bits, 8 bits, 8 bits, 32 bits)
218   uint64_t base = (uint64_t)&tss;
219   uint16_t base_1 = base & 0xFFFF;
220   uint8_t base_2 = (base >> 16) & 0xFF;
221   uint8_t base_3 = (base >> 24) & 0xFF;
222   uint32_t base_4 = (base >> 32) & 0xFFFFFFFF;
223 
224   uint16_t limit_low = sizeof(tss);
225 
226   // Flags: 1 - Type = 0x9, Descriptor Privilege Level = 0, Present = 1
227   //        2 - Available = 0, Granularity = 0
228   uint8_t flags_1 = 0x89;
229   uint8_t flags_2 = 0;
230 
231 
232   // Create the TSS descriptors
233   uint64_t tss_descriptor_low = (uint64_t) base_3 << 56 | (uint64_t) flags_2 << 48 | (uint64_t) flags_1 << 40 | (uint64_t) base_2 << 32 | (uint64_t) base_1 << 16 | (uint64_t) limit_low;
234   uint64_t tss_descriptor_high = base_4;
235 
236   // Store in the GDT
237   gdt64[5] = tss_descriptor_low;
238   gdt64[6] = tss_descriptor_high;
239 
240   // Load the TSS
241   _kprintf("Loading TSS: 0x0%x 0x0%x at 0x%x\n", tss_descriptor_low, tss_descriptor_high, &tss);
242   asm volatile("ltr %%ax" : : "a" (0x28));
243 
244   //TODO: For smp - load the TSS for each core or find a better way to do this
245 
246 
247 }
.fi
.PP
References _kprintf, base, gdt64, MaxOS::system::tss::io_bitmap_offset, MaxOS::system::tss::ist1, MaxOS::system::tss::ist2, MaxOS::system::tss::ist3, MaxOS::system::tss::ist4, MaxOS::system::tss::ist5, MaxOS::system::tss::ist6, MaxOS::system::tss::ist7, MaxOS::system::tss::reserved0, MaxOS::system::tss::reserved1, MaxOS::system::tss::reserved2, MaxOS::system::tss::reserved3, MaxOS::system::tss::reserved4, MaxOS::system::tss::rsp0, MaxOS::system::tss::rsp1, MaxOS::system::tss::rsp2, and stack\&.
.PP
Referenced by kernelMain()\&.
.SS "void CPU::PANIC (const char * message, cpu_status_t * status = \fCnullptr\fP)\fC [static]\fP"

.PP
Definition at line 140 of file cpu\&.cpp\&.
.PP
.nf
140                                                          {
141 
142   // Get the current process
143   Process* process = Scheduler::get_current_process();
144 
145   // Ensure ready to panic  - At this point it is not an issue if it is possible can avoid the panic as it is most likely called by a place that cant switch to the avoidable state
146   if(!is_panicking)
147     prepare_for_panic();
148 
149   // Print using the backend
150   _kpanicf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
151   _kpanicf("Kernel Panic: %s\n", message);
152 
153   // Info about the running process
154   _kpanicf("Process: %s\n", process ? process->name\&.c_str() : "Kernel");
155   _kpanicf("After running for %d ticks (system uptime: %d ticks)\n", process -> get_total_ticks(), Scheduler::get_system_scheduler()->get_ticks());
156 
157   // Stack trace
158   _kpanicf("----------------------------\n");
159   _kpanicf("Stack Trace:\n");
160   stack_trace(10);
161 
162   // Register dump
163   _kpanicf("----------------------------\n");
164   _kpanicf("Register Dump:\n");
165 
166   if(!status){
167     cpu_status_t* new_status = new cpu_status_t();                              // Who cares about freeing we're fucked anyway at this point
168     get_status(new_status);
169     status = new_status;
170   }
171   print_registers(status);
172 
173   // Print some text to the user
174   _kpanicf("----------------------------\n");
175   _kpanicf("%hThere has been a fatal error in MaxOS and the system has been halted\&.\n");
176   _kpanicf("%hPlease restart the system\&. \n");
177 
178 
179   // Print the logo
180   _kpanicf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
181   _kpanicf("print_logo_kernel_panic();\n\067");
182 
183   // Halt
184   halt();
185 
186 }
.fi
.PP
References _kpanicf, MaxOS::String::c_str(), MaxOS::processes::Process::name, and status\&.
.SS "cpu_status_t * CPU::prepare_for_panic (cpu_status_t * status = \fCnullptr\fP)\fC [static]\fP"

.PP
Ensure the \fBCPU\fP must panic and prepare for it if so\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The status of the \fBCPU\fP (if available) 
.RE
.PP
\fBReturns\fP
.RS 4
A \fBCPU\fP status to avoid having to panic or a nullptr if the \fBCPU\fP must panic 
.RE
.PP

.PP
Definition at line 290 of file cpu\&.cpp\&.
.PP
.nf
290                                                          {
291 
292   // Get the current process
293   Process* process = Scheduler::get_current_process();
294 
295   // If the faulting address is in lower half just kill the process and move on
296   if(status && !memory::MemoryManager::in_higher_region(status->rip)){
297     _kprintf("CPU Panicked in process %s at 0x%x - killing process\n", process->name\&.c_str(), status->rip);
298     return Scheduler::get_system_scheduler()->force_remove_process(process);
299   }
300 
301   // Don't get interrupted (can cause a loop)
302 //  asm("cli");
303 
304   // We are panicking
305   is_panicking = true;
306 
307   // Clear the first line
308   _kpanicf("%h\n\n\n");
309 
310   return nullptr;
311 
312 }
.fi
.PP
References _kpanicf, _kprintf, MaxOS::String::c_str(), MaxOS::memory::MemoryManager::in_higher_region(), MaxOS::processes::Process::name, and status\&.
.SS "void CPU::print_registers (cpu_status_t * status)\fC [static]\fP"

.PP
Definition at line 64 of file cpu\&.cpp\&.
.PP
.nf
64                                               {
65 
66     // Print the registers
67     _kpanicf("%hR15: \t0x%x\n", status->r15);
68     _kpanicf("%hR14: \t0x%x\n", status->r14);
69     _kpanicf("%hR13: \t0x%x\n", status->r13);
70     _kpanicf("%hR12: \t0x%x\n", status->r12);
71     _kpanicf("%hR11: \t0x%x\n", status->r11);
72     _kpanicf("%hR10: \t0x%x\n", status->r10);
73     _kpanicf("%hR9: \t0x%x\n", status->r9);
74     _kpanicf("%hR8: \t0x%x\n", status->r8);
75     _kpanicf("%hRDI: \t0x%x\n", status->rdi);
76     _kpanicf("%hRSI: \t0x%x\n", status->rsi);
77     _kpanicf("%hRBP: \t0x%x\n", status->rbp);
78     _kpanicf("%hRDX: \t0x%x\n", status->rdx);
79     _kpanicf("%hRCX: \t0x%x\n", status->rcx);
80     _kpanicf("%hRBX: \t0x%x\n", status->rbx);
81     _kpanicf("%hRAX: \t0x%x\n", status->rax);
82     _kpanicf("%hINT: \t0x%x\n", status->interrupt_number);
83     _kpanicf("%hERRCD: \t0x%x\n", status->error_code);
84     _kpanicf("%hRIP: \t0x%x\n", status->rip);
85     _kpanicf("%hCS: \t0x%x\n", status->cs);
86     _kpanicf("%hRFlGS: \t0x%x\n", status->rflags);
87     _kpanicf("%hRSP: \t0x%x\n", status->rsp);
88     _kpanicf("%hSS: \t0x%x\n", status->ss);
89 
90 }
.fi
.PP
References _kpanicf, and status\&.
.SS "uint64_t CPU::read_msr (uint32_t msr)\fC [static]\fP"

.PP
Definition at line 93 of file cpu\&.cpp\&.
.PP
.nf
93                                    {
94 
95   // Low and high parts of the MSR
96   uint32_t low, high;
97 
98   // Read the MSR
99   asm volatile("rdmsr" : "=a" (low), "=d" (high) : "c" (msr));
100 
101   // Return the value
102   return (uint64_t) low | ((uint64_t) high << 32);
103 
104 }
.fi
.SS "void CPU::set_status (cpu_status_t * status)\fC [static]\fP"

.PP
Definition at line 43 of file cpu\&.cpp\&.
.PP
.nf
43                                          {
44 
45   // Set the registers
46   asm volatile("mov %0, %%r15" : : "r" (status->r15));
47   asm volatile("mov %0, %%r14" : : "r" (status->r14));
48   asm volatile("mov %0, %%r13" : : "r" (status->r13));
49   asm volatile("mov %0, %%r12" : : "r" (status->r12));
50   asm volatile("mov %0, %%r11" : : "r" (status->r11));
51   asm volatile("mov %0, %%r10" : : "r" (status->r10));
52   asm volatile("mov %0, %%r9" : : "r" (status->r9));
53   asm volatile("mov %0, %%r8" : : "r" (status->r8));
54   asm volatile("mov %0, %%rdi" : : "r" (status->rdi));
55   asm volatile("mov %0, %%rsi" : : "r" (status->rsi));
56   asm volatile("mov %0, %%rbp" : : "r" (status->rbp));
57   asm volatile("mov %0, %%rdx" : : "r" (status->rdx));
58   asm volatile("mov %0, %%rcx" : : "r" (status->rcx));
59   asm volatile("mov %0, %%rbx" : : "r" (status->rbx));
60   asm volatile("mov %0, %%rax" : : "r" (status->rax));
61 
62 }
.fi
.PP
References status\&.
.SS "void CPU::stack_trace (size_t level)\fC [static]\fP"

.PP
Definition at line 118 of file cpu\&.cpp\&.
.PP
.nf
118                                   {
119 
120     // Get the first stack frame
121     stack_frame_t* frame = (stack_frame_t*)__builtin_frame_address(0);
122     size_t current_level = 0;
123 
124     // Loop through the frames logging
125     while (current_level < level && frame != nullptr){
126 
127         // Print the frame
128         _kpanicf("%h(%d):\t at 0x%x\n", current_level, frame->rip);
129 
130         // Next frame
131         frame = frame -> next;
132         current_level++;
133 
134     }
135 }
.fi
.PP
References _kpanicf, and next\&.
.SS "void CPU::write_msr (uint32_t msr, uint64_t value)\fC [static]\fP"

.PP
Definition at line 106 of file cpu\&.cpp\&.
.PP
.nf
106                                                 {
107 
108   // Write the MSR
109   asm volatile("wrmsr" : : "a" ((uint32_t) value), "d" ((uint32_t) (value >> 32)), "c" (msr));
110 
111 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "bool MaxOS::system::CPU::is_panicking = { false }\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 78 of file cpu\&.h\&.
.SS "tss_t MaxOS::system::CPU::tss"

.PP
Definition at line 84 of file cpu\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::gui::widgets::InputBox" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::gui::widgets::InputBox \- A box that can be used to input text\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <inputbox\&.h>\fP
.PP
Inherits \fBMaxOS::gui::Widget\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInputBox\fP (int32_t left, int32_t top, uint32_t width, uint32_t height)"
.br
.RI "___ \fBInputBox\fP ___ /// "
.ti -1c
.RI "\fBInputBox\fP (int32_t left, int32_t top, uint32_t width, uint32_t height, \fBstring\fP text)"
.br
.ti -1c
.RI "\fB~InputBox\fP ()"
.br
.ti -1c
.RI "void \fBdraw\fP (\fBcommon::GraphicsContext\fP *gc, \fBcommon::Rectangle\fP< int32_t > &area) override"
.br
.RI "Draw the widget on the screen\&. "
.ti -1c
.RI "void \fBon_focus\fP () override"
.br
.RI "Handles the event when the widget is focussed\&. "
.ti -1c
.RI "void \fBon_focus_lost\fP () override"
.br
.RI "Handles the event when the widget is unfocused\&. "
.ti -1c
.RI "void \fBon_key_down\fP (\fBdrivers::peripherals::KeyCode\fP keyDownCode, \fBdrivers::peripherals::KeyboardState\fP keyDownState) override"
.br
.RI "Handle the key down event\&. "
.ti -1c
.RI "void \fBupdate_text\fP (\fBstring\fP)"
.br
.ti -1c
.RI "\fBstring\fP \fBget_text\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Colour\fP \fBbackground_colour\fP"
.br
.ti -1c
.RI "\fBcommon::Colour\fP \fBforeground_colour\fP"
.br
.ti -1c
.RI "\fBcommon::Colour\fP \fBborder_colour\fP"
.br
.ti -1c
.RI "\fBgui::Font\fP \fBfont\fP"
.br
.ti -1c
.RI "uint32_t \fBcursor_position\fP { 0 }"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBstring\fP \fBm_widget_text\fP = ' '"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
A box that can be used to input text\&. 
.PP
Definition at line 53 of file inputbox\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InputBox::InputBox (int32_t left, int32_t top, uint32_t width, uint32_t height)"

.PP
___ \fBInputBox\fP ___ /// 
.PP
Definition at line 40 of file inputbox\&.cpp\&.
.PP
.nf
41 : Widget(left, top, width, height),
42   background_colour(Colour(0xFF, 0xFF, 0xFF)),
43   foreground_colour(Colour(0x00, 0x00, 0x00)),
44   border_colour(Colour(0x57, 0x57, 0x57)),
45   font((uint8_t*)AMIGA_FONT)
46 {
47 
48 }
.fi
.SS "InputBox::InputBox (int32_t left, int32_t top, uint32_t width, uint32_t height, \fBstring\fP text)"

.PP
Definition at line 50 of file inputbox\&.cpp\&.
.PP
.nf
51 : Widget(left, top, width, height),
52   background_colour(Colour(0xFF, 0xFF, 0xFF)),
53   foreground_colour(Colour(0x00, 0x00, 0x00)),
54   border_colour(Colour(0x57, 0x57, 0x57)),
55   font((uint8_t*)AMIGA_FONT)
56 {
57 
58     // Update the text
59     update_text(text);
60 
61 }
.fi
.SS "InputBox::~InputBox ()"

.PP
Definition at line 63 of file inputbox\&.cpp\&.
.PP
.nf
63                     {
64 
65 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void InputBox::draw (\fBcommon::GraphicsContext\fP * gc, \fBcommon::Rectangle\fP< int32_t > & area)\fC [override]\fP, \fC [virtual]\fP"

.PP
Draw the widget on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIgc\fP The graphics context to draw the widgets pixels on 
.br
\fIarea\fP The area of the widget to draw 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line 67 of file inputbox\&.cpp\&.
.PP
.nf
67                                                                  {
68 
69     // Default Draw
70     Widget::draw(gc, area);
71 
72     // Get the absolute m_position of the input box
73     Coordinates inputBoxCoordinates = absolute_coordinates(Coordinates(0, 0));
74     Rectangle<int32_t> inputBoxPosition = position();
75 
76     // Get the x and y m_position of the input box
77     int32_t x = inputBoxCoordinates\&.first;
78     int32_t y = inputBoxCoordinates\&.second;
79 
80     // Draw the background for the input box
81     gc->fill_rectangle(x + area\&.left, y + area\&.top, x + area\&.left + area\&.width,
82                        y + area\&.top + area\&.height, background_colour);
83 
84     // Draw the border  (TODO: Make this a function because it is used in multiple places)
85 
86     // Top Border
87     if(area\&.intersects(Rectangle<int32_t>(0,0,inputBoxPosition\&.width,1))){
88 
89         // Start in the top left corner of the button and end in the top right corner
90         gc->draw_line(x + area\&.left, y, x + area\&.left + area\&.width - 1, y,
91                       border_colour);
92     }
93 
94     // Left Border
95     if(area\&.intersects(Rectangle<int32_t>(0,0,1,inputBoxPosition\&.height))){
96 
97         // Start in the top left corner and end in the bottom left corner
98         gc->draw_line(x, y + area\&.top, x, y + area\&.top + area\&.height - 1,
99                       border_colour);
100     }
101 
102     // Right Border
103     if(area\&.intersects(Rectangle<int32_t>(0,inputBoxPosition\&.height - 1,inputBoxPosition\&.width,1))){
104 
105         // Start in the top right corner and end in the bottom right corner
106         gc->draw_line(x + area\&.left, y + inputBoxPosition\&.height - 1,
107                       x + area\&.left + area\&.width - 1,
108                       y + inputBoxPosition\&.height - 1, border_colour);
109     }
110 
111     // Bottom Border
112     if(area\&.intersects(Rectangle<int32_t>(inputBoxPosition\&.width - 1,0,1,inputBoxPosition\&.height))){
113 
114         // Start in the bottom left corner and end in the bottom right corner
115         gc->draw_line(x + inputBoxPosition\&.width - 1, y + area\&.top,
116                       x + inputBoxPosition\&.width - 1,
117                       y + area\&.top + area\&.height - 1, border_colour);
118     }
119 
120     // Draw the text
121     common::Rectangle<int32_t> textArea(area\&.left - 1, area\&.top - 1, area\&.width, area\&.height);
122     font\&.draw_text(x + 1, y + 1, foreground_colour, background_colour, gc, m_widget_text, textArea);
123 }
.fi
.PP
References MaxOS::gui::Widget::absolute_coordinates(), background_colour, border_colour, MaxOS::gui::Widget::draw(), MaxOS::common::GraphicsContext::draw_line(), MaxOS::gui::Font::draw_text(), MaxOS::common::GraphicsContext::fill_rectangle(), MaxOS::common::Pair< First, Second >::first, font, foreground_colour, MaxOS::common::Rectangle< Type >::height, MaxOS::common::Rectangle< Type >::intersects(), MaxOS::common::Rectangle< Type >::left, m_widget_text, MaxOS::gui::Widget::position(), MaxOS::common::Pair< First, Second >::second, MaxOS::common::Rectangle< Type >::top, MaxOS::common::Rectangle< Type >::width, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "\fBstring\fP InputBox::get_text ()"

.PP
Definition at line 238 of file inputbox\&.cpp\&.
.PP
.nf
238                           {
239     return m_widget_text;
240 }
.fi
.PP
References m_widget_text\&.
.SS "void InputBox::on_focus ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Handles the event when the widget is focussed\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line 125 of file inputbox\&.cpp\&.
.PP
.nf
125                         {
126 
127     // Make the border black on focus
128     border_colour = Colour(0x00, 0x00, 0x00);
129     invalidate();
130 }
.fi
.PP
References border_colour, and MaxOS::gui::Widget::invalidate()\&.
.SS "void InputBox::on_focus_lost ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Handles the event when the widget is unfocused\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line 132 of file inputbox\&.cpp\&.
.PP
.nf
132                              {
133 
134     // Reset the border colour
135     border_colour = Colour(0x57, 0x57, 0x57);
136     invalidate();
137 }
.fi
.PP
References border_colour, and MaxOS::gui::Widget::invalidate()\&.
.SS "void InputBox::on_key_down (\fBdrivers::peripherals::KeyCode\fP, \fBdrivers::peripherals::KeyboardState\fP)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle the key down event\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey_down_code\fP The keycode of the key that was pressed 
.br
\fIkey_down_state\fP The state of the keyboard when the key was pressed 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::peripherals::KeyboardEventHandler\fP\&.
.PP
Definition at line 139 of file inputbox\&.cpp\&.
.PP
.nf
139                                                              {
140 
141     // Handle the key press
142     switch(keyDownCode)
143     {
144         case KeyCode::backspace:
145         {
146             if(cursor_position == 0)
147                 break;
148 
149             cursor_position--;
150             // no break - we move the cursor to the left and use the <Delete> code
151             [[fallthrough]];
152         }
153         case KeyCode::deleteKey:
154         {
155             // Move the text to the left
156             for (int i = cursor_position; i < m_widget_text\&.length(); ++i)
157               m_widget_text[i] = m_widget_text[i+1];
158 
159             // Put a null character at the end of the string
160             m_widget_text[m_widget_text\&.length() - 1] = '\0';
161 
162             break;
163         }
164         case KeyCode::leftArrow:
165         {
166             // If the cursor is not at the beginning of the text, move it to the left
167             if(cursor_position > 0)
168               cursor_position--;
169             break;
170         }
171         case KeyCode::rightArrow:
172         {
173 
174             // If the cursor is not at the end of the text, move it to the right
175             if(m_widget_text[cursor_position] != '\0')
176               cursor_position++;
177             break;
178         }
179         default:
180         {
181 
182             // If the key is a printable character, add it to the text
183             if(31 < keyDownCode && keyDownCode < 127)
184             {
185                 uint32_t length = cursor_position;
186 
187                 // Find the length of the text buffer
188                 while (m_widget_text[length] != '\0') {
189                   ++length;
190                 }
191 
192                 // Check if we need to make space for the new character
193                 if (length >= (uint32_t)m_widget_text\&.length()) {
194                   m_widget_text += " ";
195                 }
196 
197                 // Shift elements to the right
198                 while (length > cursor_position) {
199                   m_widget_text[length + 1] = m_widget_text[length];
200                   --length;
201                 }
202 
203                 // Insert the new character
204                 m_widget_text[cursor_position + 1] = m_widget_text[cursor_position];
205                 m_widget_text[cursor_position] = (uint8_t)keyDownCode;
206                 cursor_position++;
207             }else{
208 
209                 // Dont want to redraw the widget if nothing has changed
210                 return;
211             }
212             break;
213         }
214     }
215 
216     // Redraw the widget
217     invalidate();
218 
219     // Fire the text changed event
220     if(keyDownCode != KeyCode::leftArrow && keyDownCode != KeyCode::rightArrow)
221       raise_event(new InputBoxTextChangedEvent(m_widget_text));
222 
223 }
.fi
.PP
References MaxOS::drivers::peripherals::backspace, cursor_position, MaxOS::drivers::peripherals::deleteKey, MaxOS::drivers::peripherals::i, MaxOS::gui::Widget::invalidate(), MaxOS::drivers::peripherals::leftArrow, length, MaxOS::String::length(), m_widget_text, MaxOS::common::EventManager< InputBoxEvents >::raise_event(), and MaxOS::drivers::peripherals::rightArrow\&.
.SS "void InputBox::update_text (\fBstring\fP new_text)"

.PP
Definition at line 225 of file inputbox\&.cpp\&.
.PP
.nf
225                                           {
226 
227     m_widget_text\&.copy(new_text);
228     cursor_position = m_widget_text\&.length();
229 
230     // Redraw the widget
231     invalidate();
232 
233     // Fire the text changed event
234     raise_event(new InputBoxTextChangedEvent(new_text));
235 
236 }
.fi
.PP
References MaxOS::String::copy(), cursor_position, MaxOS::gui::Widget::invalidate(), MaxOS::String::length(), m_widget_text, and MaxOS::common::EventManager< InputBoxEvents >::raise_event()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::background_colour"

.PP
Definition at line 74 of file inputbox\&.h\&.
.PP
Referenced by draw()\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::border_colour"

.PP
Definition at line 76 of file inputbox\&.h\&.
.PP
Referenced by draw(), on_focus(), and on_focus_lost()\&.
.SS "uint32_t MaxOS::gui::widgets::InputBox::cursor_position { 0 }"

.PP
Definition at line 78 of file inputbox\&.h\&.
.PP
Referenced by on_key_down(), and update_text()\&.
.SS "\fBgui::Font\fP MaxOS::gui::widgets::InputBox::font"

.PP
Definition at line 77 of file inputbox\&.h\&.
.PP
Referenced by draw()\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::foreground_colour"

.PP
Definition at line 75 of file inputbox\&.h\&.
.PP
Referenced by draw()\&.
.SS "\fBstring\fP MaxOS::gui::widgets::InputBox::m_widget_text = ' '\fC [protected]\fP"

.PP
Definition at line 56 of file inputbox\&.h\&.
.PP
Referenced by draw(), get_text(), on_key_down(), and update_text()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::gui::widgets::InputBox" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::gui::widgets::InputBox \- A box that can be used to input text\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <inputbox\&.h>\fP
.PP
Inherits \fBMaxOS::gui::Widget\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInputBox\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"
.br
.RI "Construct a new Input Box object at a specific position and size\&. "
.ti -1c
.RI "\fBInputBox\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height, \fBconst\fP \fBstring\fP &\fBtext\fP)"
.br
.RI "Construct a new Input Box object at a specific position and size with initial text\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw\fP (\fBcommon::GraphicsContext\fP *\fBgc\fP, \fBcommon::Rectangle\fP< \fBint32_t\fP > &\fBarea\fP) \fBoverride\fP"
.br
.RI "Draw an area of the input box onto a graphics context\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_focus\fP () \fBoverride\fP"
.br
.RI "Update the border when the input box is focussed\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_focus_lost\fP () \fBoverride\fP"
.br
.RI "Reset to the original input box style when it is no longer focussed\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_key_down\fP (\fBdrivers::peripherals::KeyCode\fP \fBkey_down_code\fP, \fBconst\fP \fBdrivers::peripherals::KeyboardState\fP &\fBkey_down_state\fP) \fBoverride\fP"
.br
.RI "Handles a keypress event by updating the rendered text in the input box\&. "
.ti -1c
.RI "\fBvoid\fP \fBupdate_text\fP (\fBconst\fP \fBstring\fP &)"
.br
.RI "Update the text in the input box\&. "
.ti -1c
.RI "\fBstring\fP \fBtext\fP ()"
.br
.RI "Get the text currently in the input box\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBWidget\fP ()"
.br
.RI "Construct a new \fBWidget\fP object\&. "
.ti -1c
.RI "\fBWidget\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"
.br
.RI "Construct a new \fBWidget\fP object at a specific position and size\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvalidate\fP ()"
.br
.RI "Invalidates the entire widget\&. This forces the widget to be redrawn on the next screen update\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinvalidate\fP (\fBcommon::Rectangle\fP< \fBint32_t\fP > &\fBarea\fP)"
.br
.RI "Invalidates a specific area of the widget\&. This forces that part of the screen to be redrawn on the next screen update\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBadd_child\fP (\fBWidget\fP *\fBchild\fP)"
.br
.RI "Set the parent of a widget to this widget, making it into a child\&. "
.ti -1c
.RI "\fBvirtual\fP \fBcommon::Coordinates\fP \fBabsolute_coordinates\fP (\fBcommon::Coordinates\fP \fBcoordinates\fP)"
.br
.RI "Get the absolute coordinates of the widget (relative to the screen) "
.ti -1c
.RI "\fBvirtual\fP \fBbool\fP \fBcontains_coordinate\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Check if the widget contains a specific coordinate\&. "
.ti -1c
.RI "\fBcommon::Rectangle\fP< \fBint32_t\fP > \fBposition\fP ()"
.br
.RI "Get the position of the widget\&. "
.ti -1c
.RI "\fBvoid\fP \fBmove\fP (\fBint32_t\fP left, \fBint32_t\fP top)"
.br
.RI "Set the position of the widget, and invalidate the old and new positions so they are redrawn\&. "
.ti -1c
.RI "\fBvoid\fP \fBresize\fP (\fBint32_t\fP width, \fBint32_t\fP height)"
.br
.RI "Set the size of the widget, and invalidate the old and new positions so they are redrawn\&. "
.ti -1c
.RI "\fBvoid\fP \fBfocus\fP ()"
.br
.RI "Set the current focused widget to be this widget\&. "
.ti -1c
.RI "\fBvoid\fP \fBbring_to_front\fP ()"
.br
.RI "Brings this widget to the front of the screen\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_enter_widget\fP (\fBuint32_t\fP \fBto_x\fP, \fBuint32_t\fP \fBto_y\fP)"
.br
.RI "Handles the event when the mouse is moved on to the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_leave_widget\fP (\fBuint32_t\fP \fBfrom_x\fP, \fBuint32_t\fP \fBfrom_y\fP)"
.br
.RI "Handles the event when the mouse is moved out of the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_move_widget\fP (\fBuint32_t\fP \fBfrom_x\fP, \fBuint32_t\fP \fBfrom_y\fP, \fBuint32_t\fP \fBto_x\fP, \fBuint32_t\fP \fBto_y\fP)"
.br
.RI "Handles the event when the mouse is moved over the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBdrivers::peripherals::MouseEventHandler\fP * \fBon_mouse_button_pressed\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP button)"
.br
.RI "Handles the event when the mouse is pressed on the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_button_released\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP button)"
.br
.RI "Handles the event when the mouse is released on the widget\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::peripherals::KeyboardEventHandler\fP
.in +1c
.ti -1c
.RI "\fBcommon::Event\fP< \fBKeyboardEvents\fP > * \fBon_event\fP (\fBcommon::Event\fP< \fBKeyboardEvents\fP > *) \fBoverride\fP"
.br
.RI "Handle the trigger of an event\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_key_up\fP (\fBKeyCode\fP, \fBconst\fP \fBKeyboardState\fP &)"
.br
.RI "Handle the key up event\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventHandler< KeyboardEvents >\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBEvent\fP< KeyboardEvents > * \fBon_event\fP (\fBEvent\fP< KeyboardEvents > *\fBevent\fP)"
.br
.RI "This function is called when an event is raised\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventManager< InputBoxEvents >\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBconnect_event_handler\fP (\fBEventHandler\fP< InputBoxEvents > *\fBhandler\fP)"
.br
.RI "connect an event handler to the event manager if it is not already connected "
.ti -1c
.RI "\fBvoid\fP \fBdisconnect_event_handler\fP (\fBEventHandler\fP< InputBoxEvents > *\fBhandler\fP)"
.br
.RI "disconnect an event handler from the event manager if it is connected "
.ti -1c
.RI "\fBVector\fP< \fBEvent\fP< InputBoxEvents > * > \fBraise_event\fP (\fBEvent\fP< InputBoxEvents > *\fBevent\fP)"
.br
.RI "Calls the on_event function of all the event m_handlers connected to the event manager and returns a list of the results\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Colour\fP \fBbackground_colour\fP"
.br
.RI "The background colour of the input box\&. "
.ti -1c
.RI "\fBcommon::Colour\fP \fBforeground_colour\fP"
.br
.RI "The colour of the text in the input box\&. "
.ti -1c
.RI "\fBcommon::Colour\fP \fBborder_colour\fP"
.br
.RI "The colour of the bar around the input box\&. "
.ti -1c
.RI "\fBgui::Font\fP \fBfont\fP"
.br
.RI "The font to use for the input box text\&. "
.ti -1c
.RI "uint32_t \fBcursor_position\fP { 0 }"
.br
.RI "How many characters into the text the cursor is\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBstring\fP \fBm_widget_text\fP = ' '"
.br
.RI "The text in the input box\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBcommon::Rectangle\fP< int32_t > \fBm_position\fP"
.br
.RI "The position and size of the widget (relative to its parent) "
.ti -1c
.RI "\fBWidget\fP * \fBm_parent\fP { nullptr }"
.br
.RI "The widget that owns this widget\&. "
.ti -1c
.RI "bool \fBm_valid\fP { false }"
.br
.RI "Is the widget drawn to the screen and up to date\&. "
.ti -1c
.RI "uint32_t \fBm_min_width\fP { 5 }"
.br
.RI "The smallest m_width the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_min_height\fP { 5 }"
.br
.RI "The smallest m_height the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_max_width\fP { 0x8FFFFFFF }"
.br
.RI "The largest m_width the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_max_height\fP { 0x8FFFFFFF }"
.br
.RI "The largest m_height the widget can be resized to\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::common::EventManager< InputBoxEvents >\fP
.in +1c
.ti -1c
.RI "\fBVector\fP< \fBEventHandler\fP< InputBoxEvents > * > \fBm_handlers\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBset_focus\fP (\fBWidget\fP *)"
.br
.RI "Sets the widget that is currently focussed\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBbring_to_front\fP (\fBWidget\fP *)"
.br
.RI "Brings a specific widget to the front of the screen\&. "
.in -1c
.SH "Detailed Description"
.PP 
A box that can be used to input text\&. 
.PP
Definition at line \fB58\fP of file \fBinputbox\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InputBox::InputBox (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"

.PP
Construct a new Input Box object at a specific position and size\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP How many pixels from the left of the parent widget the input box is 
.br
\fItop\fP How many pixels from the top of the parent widget the input box is 
.br
\fIwidth\fP How many pixels wide the input box is 
.br
\fIheight\fP How many pixels tall the input box is 
.RE
.PP

.PP
Definition at line \fB56\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
57 : Widget(left, top, width, height),
58   background_colour(Colour(0xFF, 0xFF, 0xFF)),
59   foreground_colour(Colour(0x00, 0x00, 0x00)),
60   border_colour(Colour(0x57, 0x57, 0x57)),
61   font((uint8_t*) AMIGA_FONT)
62 {
63 
64 }
.fi

.SS "InputBox::InputBox (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height, \fBconst\fP \fBstring\fP & text)"

.PP
Construct a new Input Box object at a specific position and size with initial text\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP The left position of the input box 
.br
\fItop\fP The top position of the input box 
.br
\fIwidth\fP The width of the input box 
.br
\fIheight\fP The height of the input box 
.br
\fItext\fP The initial text in the input box 
.RE
.PP

.PP
Definition at line \fB75\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
76 : Widget(left, top, width, height),
77   background_colour(Colour(0xFF, 0xFF, 0xFF)),
78   foreground_colour(Colour(0x00, 0x00, 0x00)),
79   border_colour(Colour(0x57, 0x57, 0x57)),
80   font((uint8_t*) AMIGA_FONT)
81 {
82 
83     // Update the text
84     update_text(text);
85 
86 }
.fi

.PP
References \fBtext()\fP, and \fBupdate_text()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InputBox::draw (\fBcommon::GraphicsContext\fP * gc, \fBcommon::Rectangle\fP< \fBint32_t\fP > & area)\fC [override]\fP, \fC [virtual]\fP"

.PP
Draw an area of the input box onto a graphics context\&. 
.PP
\fBParameters\fP
.RS 4
\fIgc\fP The context to draw onto 
.br
\fIarea\fP What part of the input box to draw 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB96\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
96                                                                  {
97 
98     // Default Draw
99     Widget::draw(gc, area);
100 
101     // Get the absolute m_position of the input box
102     Coordinates input_box_coordinates = absolute_coordinates(Coordinates(0, 0));
103     Rectangle<int32_t> input_box_position = position();
104 
105     // Get the x and y m_position of the input box
106     int32_t x = input_box_coordinates\&.first;
107     int32_t y = input_box_coordinates\&.second;
108 
109     // Draw the background for the input box
110     gc\->fill_rectangle(x + area\&.left, y + area\&.top, x + area\&.left + area\&.width,
111                        y + area\&.top + area\&.height, background_colour);
112 
113     // Draw the border
114 
115     // Top Border
116     if (area\&.intersects(Rectangle<int32_t>(0, 0, input_box_position\&.width, 1))) {
117 
118         // Start in the top left corner of the button and end in the top right corner
119         gc\->draw_line(x + area\&.left, y, x + area\&.left + area\&.width \- 1, y,
120                       border_colour);
121     }
122 
123     // Left Border
124     if (area\&.intersects(Rectangle<int32_t>(0, 0, 1, input_box_position\&.height))) {
125 
126         // Start in the top left corner and end in the bottom left corner
127         gc\->draw_line(x, y + area\&.top, x, y + area\&.top + area\&.height \- 1,
128                       border_colour);
129     }
130 
131     // Right Border
132     if (area\&.intersects(Rectangle<int32_t>(0, input_box_position\&.height \- 1, input_box_position\&.width, 1))) {
133 
134         // Start in the top right corner and end in the bottom right corner
135         gc\->draw_line(x + area\&.left, y + input_box_position\&.height \- 1,
136                       x + area\&.left + area\&.width \- 1,
137                       y + input_box_position\&.height \- 1, border_colour);
138     }
139 
140     // Bottom Border
141     if (area\&.intersects(Rectangle<int32_t>(input_box_position\&.width \- 1, 0, 1, input_box_position\&.height))) {
142 
143         // Start in the bottom left corner and end in the bottom right corner
144         gc\->draw_line(x + input_box_position\&.width \- 1, y + area\&.top,
145                       x + input_box_position\&.width \- 1,
146                       y + area\&.top + area\&.height \- 1, border_colour);
147     }
148 
149     // Draw the text
150     common::Rectangle<int32_t> text_area(area\&.left \- 1, area\&.top \- 1, area\&.width, area\&.height);
151     font\&.draw_text(x + 1, y + 1, foreground_colour, background_colour, gc, m_widget_text, text_area);
152 }
.fi

.PP
References \fBMaxOS::gui::Widget::absolute_coordinates()\fP, \fBbackground_colour\fP, \fBborder_colour\fP, \fBMaxOS::gui::Widget::draw()\fP, \fBMaxOS::gui::Font::draw_text()\fP, \fBfont\fP, \fBforeground_colour\fP, \fBMaxOS::common::Rectangle< Type >::height\fP, \fBMaxOS::common::Rectangle< Type >::intersects()\fP, \fBMaxOS::common::Rectangle< Type >::left\fP, \fBm_widget_text\fP, \fBMaxOS::gui::Widget::position()\fP, \fBMaxOS::common::Rectangle< Type >::top\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.SS "\fBvoid\fP InputBox::on_focus ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Update the border when the input box is focussed\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB157\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
157                         {
158 
159     // Make the border black on focus
160     border_colour = Colour(0x00, 0x00, 0x00);
161     invalidate();
162 }
.fi

.PP
References \fBborder_colour\fP, and \fBMaxOS::gui::Widget::invalidate()\fP\&.
.SS "\fBvoid\fP InputBox::on_focus_lost ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Reset to the original input box style when it is no longer focussed\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB167\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
167                              {
168 
169     // Reset the border colour
170     border_colour = Colour(0x57, 0x57, 0x57);
171     invalidate();
172 }
.fi

.PP
References \fBborder_colour\fP, and \fBMaxOS::gui::Widget::invalidate()\fP\&.
.SS "\fBvoid\fP InputBox::on_key_down (\fBdrivers::peripherals::KeyCode\fP key_down_code, \fBconst\fP \fBdrivers::peripherals::KeyboardState\fP & key_down_state)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handles a keypress event by updating the rendered text in the input box\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey_down_code\fP The key being pressed 
.br
\fIkey_down_state\fP The state of the key being pressed 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::peripherals::KeyboardEventHandler\fP\&.
.PP
Definition at line \fB180\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
180                                                                                      {
181 
182     // Handle the key press
183     switch (key_down_code) {
184         case KeyCode::backspace: {
185             if (cursor_position == 0)
186                 break;
187 
188             cursor_position\-\-;
189             // no break \- we move the cursor to the left and use the <Delete> code
190             [[fallthrough]];
191         }
192         case KeyCode::deleteKey: {
193             // Move the text to the left
194             for (size_t i = cursor_position; i < m_widget_text\&.length(); ++i)
195                 m_widget_text[i] = m_widget_text[i + 1];
196 
197             // Put a null character at the end of the string
198             m_widget_text[m_widget_text\&.length() \- 1] = '\\0';
199 
200             break;
201         }
202         case KeyCode::leftArrow: {
203             // If the cursor is not at the beginning of the text, move it to the left
204             if (cursor_position > 0)
205                 cursor_position\-\-;
206             break;
207         }
208         case KeyCode::rightArrow: {
209 
210             // If the cursor is not at the end of the text, move it to the right
211             if (m_widget_text[cursor_position] != '\\0')
212                 cursor_position++;
213             break;
214         }
215         default: {
216 
217             // If the key is a printable character, add it to the text
218             if (31 < (int) key_down_code && (int) key_down_code < 127) {
219                 uint32_t length = cursor_position;
220 
221                 // Find the length of the text buffer
222                 while (m_widget_text[length] != '\\0') {
223                     ++length;
224                 }
225 
226                 // Check if we need to make space for the new character
227                 if (length >= (uint32_t) m_widget_text\&.length()) {
228                     m_widget_text += " ";
229                 }
230 
231                 // Shift elements to the right
232                 while (length > cursor_position) {
233                     m_widget_text[length + 1] = m_widget_text[length];
234                     \-\-length;
235                 }
236 
237                 // Insert the new character
238                 m_widget_text[cursor_position + 1] = m_widget_text[cursor_position];
239                 m_widget_text[cursor_position] = (char)key_down_code;
240                 cursor_position++;
241             } else {
242 
243                 // Don't want to redraw the widget if nothing has changed
244                 return;
245             }
246             break;
247         }
248     }
249 
250     // Redraw the widget
251     invalidate();
252 
253     // Fire the text changed event
254     if (key_down_code != KeyCode::leftArrow && key_down_code != KeyCode::rightArrow)
255         raise_event(new InputBoxTextChangedEvent(m_widget_text));
256 
257 }
.fi

.PP
References \fBcursor_position\fP, \fBMaxOS::gui::Widget::invalidate()\fP, \fBm_widget_text\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >::raise_event()\fP\&.
.SS "\fBstring\fP InputBox::text ()"

.PP
Get the text currently in the input box\&. 
.PP
\fBReturns\fP
.RS 4
The text in the input box 
.RE
.PP

.PP
Definition at line \fB281\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
281                       {
282 
283     return m_widget_text;
284 }
.fi

.PP
References \fBm_widget_text\fP\&.
.PP
Referenced by \fBInputBox()\fP\&.
.SS "\fBvoid\fP InputBox::update_text (\fBconst\fP \fBstring\fP & new_text)"

.PP
Update the text in the input box\&. 
.PP
\fBParameters\fP
.RS 4
\fInew_text\fP The new text to display 
.RE
.PP

.PP
Definition at line \fB264\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
264                                                  {
265 
266     m_widget_text\&.copy(new_text);
267     cursor_position = m_widget_text\&.length();
268 
269     // Redraw the widget
270     invalidate();
271 
272     // Fire the text changed event
273     raise_event(new InputBoxTextChangedEvent(new_text));
274 }
.fi

.PP
References \fBcursor_position\fP, \fBMaxOS::gui::Widget::invalidate()\fP, \fBm_widget_text\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >::raise_event()\fP\&.
.PP
Referenced by \fBInputBox()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::background_colour"

.PP
The background colour of the input box\&. 
.PP
Definition at line \fB80\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::border_colour"

.PP
The colour of the bar around the input box\&. 
.PP
Definition at line \fB82\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP, \fBon_focus()\fP, and \fBon_focus_lost()\fP\&.
.SS "uint32_t MaxOS::gui::widgets::InputBox::cursor_position { 0 }"

.PP
How many characters into the text the cursor is\&. 
.PP
Definition at line \fB84\fP of file \fBinputbox\&.h\fP\&..PP
.nf
84 { 0 };              
.fi

.PP
Referenced by \fBon_key_down()\fP, and \fBupdate_text()\fP\&.
.SS "\fBgui::Font\fP MaxOS::gui::widgets::InputBox::font"

.PP
The font to use for the input box text\&. 
.PP
Definition at line \fB83\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::foreground_colour"

.PP
The colour of the text in the input box\&. 
.PP
Definition at line \fB81\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBstring\fP MaxOS::gui::widgets::InputBox::m_widget_text = ' '\fC [protected]\fP"

.PP
The text in the input box\&. 
.PP
Definition at line \fB62\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP, \fBon_key_down()\fP, \fBtext()\fP, and \fBupdate_text()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

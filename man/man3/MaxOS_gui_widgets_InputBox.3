.TH "MaxOS::gui::widgets::InputBox" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::gui::widgets::InputBox \- A box that can be used to input text\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <inputbox\&.h>\fP
.PP
Inherits \fBMaxOS::gui::Widget\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInputBox\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"
.br
.RI "Construct a new Input Box object at a specific position and size\&. "
.ti -1c
.RI "\fBInputBox\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height, \fBconst\fP \fBstring\fP &\fBtext\fP)"
.br
.RI "Construct a new Input Box object at a specific position and size with initial text\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw\fP (\fBcommon::GraphicsContext\fP *\fBgc\fP, \fBcommon::Rectangle\fP< \fBint32_t\fP > &\fBarea\fP) \fBoverride\fP"
.br
.RI "Draw an area of the input box onto a graphics context\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_focus\fP () \fBoverride\fP"
.br
.RI "Update the border when the input box is focussed\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_focus_lost\fP () \fBoverride\fP"
.br
.RI "Reset to the original input box style when it is no longer focussed\&. "
.ti -1c
.RI "\fBvoid\fP \fBon_key_down\fP (\fBdrivers::peripherals::KeyCode\fP \fBkey_down_code\fP, \fBdrivers::peripherals::KeyboardState\fP \fBkey_down_state\fP) \fBoverride\fP"
.br
.RI "Handles a keypress event by updating the rendered text in the input box\&. "
.ti -1c
.RI "\fBvoid\fP \fBupdate_text\fP (\fBconst\fP \fBstring\fP &)"
.br
.RI "Update the text in the input box\&. "
.ti -1c
.RI "\fBstring\fP \fBtext\fP ()"
.br
.RI "Get the text currently in the input box\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBWidget\fP (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"
.br
.RI "Construct a new \fBWidget\fP object at a specific position and size\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvalidate\fP ()"
.br
.RI "Invalidates the entire widget\&. This forces the widget to be redrawn on the next screen update\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinvalidate\fP (\fBcommon::Rectangle\fP< \fBint32_t\fP > &\fBarea\fP)"
.br
.RI "Invalidates a specific area of the widget\&. This forces that part of the screen to be redrawn on the next screen update\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBadd_child\fP (\fBWidget\fP *\fBchild\fP)"
.br
.RI "Set the parent of a widget to this widget, making it into a child\&. "
.ti -1c
.RI "\fBvirtual\fP \fBcommon::Coordinates\fP \fBabsolute_coordinates\fP (\fBcommon::Coordinates\fP \fBcoordinates\fP)"
.br
.RI "Get the absolute coordinates of the widget (relative to the screen) "
.ti -1c
.RI "\fBvirtual\fP \fBbool\fP \fBcontains_coordinate\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Check if the widget contains a specific coordinate\&. "
.ti -1c
.RI "\fBcommon::Rectangle\fP< \fBint32_t\fP > \fBposition\fP ()"
.br
.RI "Get the position of the widget\&. "
.ti -1c
.RI "\fBvoid\fP \fBmove\fP (\fBint32_t\fP left, \fBint32_t\fP top)"
.br
.RI "Set the position of the widget, and invalidate the old and new positions so they are redrawn\&. "
.ti -1c
.RI "\fBvoid\fP \fBresize\fP (\fBint32_t\fP width, \fBint32_t\fP height)"
.br
.RI "Set the size of the widget, and invalidate the old and new positions so they are redrawn\&. "
.ti -1c
.RI "\fBvoid\fP \fBfocus\fP ()"
.br
.RI "Set the current focused widget to be this widget\&. "
.ti -1c
.RI "\fBvoid\fP \fBbring_to_front\fP ()"
.br
.RI "Brings this widget to the front of the screen\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_enter_widget\fP (\fBuint32_t\fP \fBtoX\fP, \fBuint32_t\fP \fBtoY\fP)"
.br
.RI "Handles the event when the mouse is moved on to the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_leave_widget\fP (\fBuint32_t\fP \fBfromX\fP, \fBuint32_t\fP \fBfromY\fP)"
.br
.RI "Handles the event when the mouse is moved out of the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_move_widget\fP (\fBuint32_t\fP \fBfromX\fP, \fBuint32_t\fP \fBfromY\fP, \fBuint32_t\fP \fBtoX\fP, \fBuint32_t\fP \fBtoY\fP)"
.br
.RI "Handles the event when the mouse is moved over the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBdrivers::peripherals::MouseEventHandler\fP * \fBon_mouse_button_pressed\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP button)"
.br
.RI "Handles the event when the mouse is pressed on the widget\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_mouse_button_released\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP button)"
.br
.RI "Handles the event when the mouse is released on the widget\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::peripherals::KeyboardEventHandler\fP
.in +1c
.ti -1c
.RI "\fBcommon::Event\fP< KeyboardEvents > * \fBon_event\fP (\fBcommon::Event\fP< KeyboardEvents > *) \fBoverride\fP"
.br
.RI "Handle the trigger of an event\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBon_key_up\fP (\fBKeyCode\fP, \fBKeyboardState\fP)"
.br
.RI "Handle the key up event\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventHandler< KeyboardEvents >\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBEvent\fP< KeyboardEvents > * \fBon_event\fP (\fBEvent\fP< KeyboardEvents > *\fBevent\fP)"
.br
.RI "This function is called when an event is raised\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventManager< InputBoxEvents >\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBconnect_event_handler\fP (\fBEventHandler\fP< InputBoxEvents > *\fBhandler\fP)"
.br
.RI "Connect an event handler to the event manager if it is not already connected\&. "
.ti -1c
.RI "\fBvoid\fP \fBdisconnect_event_handler\fP (\fBEventHandler\fP< InputBoxEvents > *\fBhandler\fP)"
.br
.RI "Disconnect an event handler from the event manager if it is connected\&. "
.ti -1c
.RI "\fBVector\fP< \fBEvent\fP< InputBoxEvents > * > \fBraise_event\fP (\fBEvent\fP< InputBoxEvents > *\fBevent\fP)"
.br
.RI "Calls the on_event function of all the event m_handlers connected to the event manager and returns a list of the results\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Colour\fP \fBbackground_colour\fP"
.br
.RI "The background colour of the input box\&. "
.ti -1c
.RI "\fBcommon::Colour\fP \fBforeground_colour\fP"
.br
.RI "The colour of the text in the input box\&. "
.ti -1c
.RI "\fBcommon::Colour\fP \fBborder_colour\fP"
.br
.RI "The colour of the bar around the input box\&. "
.ti -1c
.RI "\fBgui::Font\fP \fBfont\fP"
.br
.RI "The font to use for the input box text\&. "
.ti -1c
.RI "int32_t \fBcursor_position\fP { 0 }"
.br
.RI "How many characters into the text the cursor is\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBstring\fP \fBm_widget_text\fP = ' '"
.br
.RI "The text in the input box\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBcommon::Rectangle\fP< int32_t > \fBm_position\fP"
.br
.RI "The position and size of the widget (relative to its parent) "
.ti -1c
.RI "\fBWidget\fP * \fBm_parent\fP { nullptr }"
.br
.RI "The widget that owns this widget\&. "
.ti -1c
.RI "bool \fBm_valid\fP { false }"
.br
.RI "Is the widget drawn to the screen and up to date\&. "
.ti -1c
.RI "uint32_t \fBm_min_width\fP { 5 }"
.br
.RI "The smallest m_width the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_min_height\fP { 5 }"
.br
.RI "The smallest m_height the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_max_width\fP { 0x8FFFFFFF }"
.br
.RI "The largest m_width the widget can be resized to\&. "
.ti -1c
.RI "uint32_t \fBm_max_height\fP { 0x8FFFFFFF }"
.br
.RI "The largest m_height the widget can be resized to\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::common::EventManager< InputBoxEvents >\fP
.in +1c
.ti -1c
.RI "\fBVector\fP< \fBEventHandler\fP< InputBoxEvents > * > \fBm_handlers\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBMaxOS::gui::Widget\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBset_focus\fP (\fBWidget\fP *)"
.br
.RI "Sets the widget that is currently focussed\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBbring_to_front\fP (\fBWidget\fP *)"
.br
.RI "Brings a specific widget to the front of the screen\&. "
.in -1c
.SH "Detailed Description"
.PP 
A box that can be used to input text\&. 
.PP
Definition at line \fB61\fP of file \fBinputbox\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "InputBox::InputBox (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height)"

.PP
Construct a new Input Box object at a specific position and size\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP How many pixels from the left of the parent widget the input box is 
.br
\fItop\fP How many pixels from the top of the parent widget the input box is 
.br
\fIwidth\fP How many pixels wide the input box is 
.br
\fIheight\fP How many pixels tall the input box is 
.RE
.PP

.PP
Definition at line \fB54\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
55 : Widget(left, top, width, height),
56   background_colour(Colour(0xFF, 0xFF, 0xFF)),
57   foreground_colour(Colour(0x00, 0x00, 0x00)),
58   border_colour(Colour(0x57, 0x57, 0x57)),
59   font((uint8_t*) AMIGA_FONT)
60 {
61 
62 }
.fi

.SS "InputBox::InputBox (\fBint32_t\fP left, \fBint32_t\fP top, \fBuint32_t\fP width, \fBuint32_t\fP height, \fBconst\fP \fBstring\fP & text)"

.PP
Construct a new Input Box object at a specific position and size with initial text\&. 
.PP
\fBParameters\fP
.RS 4
\fIleft\fP The left position of the input box 
.br
\fItop\fP The top position of the input box 
.br
\fIwidth\fP The width of the input box 
.br
\fIheight\fP The height of the input box 
.br
\fItext\fP The initial text in the input box 
.RE
.PP

.PP
Definition at line \fB73\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
74 : Widget(left, top, width, height),
75   background_colour(Colour(0xFF, 0xFF, 0xFF)),
76   foreground_colour(Colour(0x00, 0x00, 0x00)),
77   border_colour(Colour(0x57, 0x57, 0x57)),
78   font((uint8_t*) AMIGA_FONT)
79 {
80 
81     // Update the text
82     update_text(text);
83 
84 }
.fi

.PP
References \fBtext()\fP, and \fBupdate_text()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP InputBox::draw (\fBcommon::GraphicsContext\fP * gc, \fBcommon::Rectangle\fP< \fBint32_t\fP > & area)\fC [override]\fP, \fC [virtual]\fP"

.PP
Draw an area of the input box onto a graphics context\&. 
.PP
\fBParameters\fP
.RS 4
\fIgc\fP The context to draw onto 
.br
\fIarea\fP What part of the input box to draw 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB94\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
94                                                                  {
95 
96     // Default Draw
97     Widget::draw(gc, area);
98 
99     // Get the absolute m_position of the input box
100     Coordinates inputBoxCoordinates = absolute_coordinates(Coordinates(0, 0));
101     Rectangle<int32_t> inputBoxPosition = position();
102 
103     // Get the x and y m_position of the input box
104     int32_t x = inputBoxCoordinates\&.first;
105     int32_t y = inputBoxCoordinates\&.second;
106 
107     // Draw the background for the input box
108     gc\->fill_rectangle(x + area\&.left, y + area\&.top, x + area\&.left + area\&.width,
109                        y + area\&.top + area\&.height, background_colour);
110 
111     // Draw the border
112 
113     // Top Border
114     if (area\&.intersects(Rectangle<int32_t>(0, 0, inputBoxPosition\&.width, 1))) {
115 
116         // Start in the top left corner of the button and end in the top right corner
117         gc\->draw_line(x + area\&.left, y, x + area\&.left + area\&.width \- 1, y,
118                       border_colour);
119     }
120 
121     // Left Border
122     if (area\&.intersects(Rectangle<int32_t>(0, 0, 1, inputBoxPosition\&.height))) {
123 
124         // Start in the top left corner and end in the bottom left corner
125         gc\->draw_line(x, y + area\&.top, x, y + area\&.top + area\&.height \- 1,
126                       border_colour);
127     }
128 
129     // Right Border
130     if (area\&.intersects(Rectangle<int32_t>(0, inputBoxPosition\&.height \- 1, inputBoxPosition\&.width, 1))) {
131 
132         // Start in the top right corner and end in the bottom right corner
133         gc\->draw_line(x + area\&.left, y + inputBoxPosition\&.height \- 1,
134                       x + area\&.left + area\&.width \- 1,
135                       y + inputBoxPosition\&.height \- 1, border_colour);
136     }
137 
138     // Bottom Border
139     if (area\&.intersects(Rectangle<int32_t>(inputBoxPosition\&.width \- 1, 0, 1, inputBoxPosition\&.height))) {
140 
141         // Start in the bottom left corner and end in the bottom right corner
142         gc\->draw_line(x + inputBoxPosition\&.width \- 1, y + area\&.top,
143                       x + inputBoxPosition\&.width \- 1,
144                       y + area\&.top + area\&.height \- 1, border_colour);
145     }
146 
147     // Draw the text
148     common::Rectangle<int32_t> textArea(area\&.left \- 1, area\&.top \- 1, area\&.width, area\&.height);
149     font\&.draw_text(x + 1, y + 1, foreground_colour, background_colour, gc, m_widget_text, textArea);
150 }
.fi

.PP
References \fBMaxOS::gui::Widget::absolute_coordinates()\fP, \fBbackground_colour\fP, \fBborder_colour\fP, \fBMaxOS::gui::Widget::draw()\fP, \fBMaxOS::gui::Font::draw_text()\fP, \fBfont\fP, \fBforeground_colour\fP, \fBMaxOS::common::Rectangle< Type >::height\fP, \fBMaxOS::common::Rectangle< Type >::intersects()\fP, \fBMaxOS::common::Rectangle< Type >::left\fP, \fBm_widget_text\fP, \fBMaxOS::gui::Widget::position()\fP, \fBMaxOS::common::Rectangle< Type >::top\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.SS "\fBvoid\fP InputBox::on_focus ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Update the border when the input box is focussed\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB155\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
155                         {
156 
157     // Make the border black on focus
158     border_colour = Colour(0x00, 0x00, 0x00);
159     invalidate();
160 }
.fi

.PP
References \fBborder_colour\fP, and \fBMaxOS::gui::Widget::invalidate()\fP\&.
.SS "\fBvoid\fP InputBox::on_focus_lost ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Reset to the original input box style when it is no longer focussed\&. 
.PP
Reimplemented from \fBMaxOS::gui::Widget\fP\&.
.PP
Definition at line \fB165\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
165                              {
166 
167     // Reset the border colour
168     border_colour = Colour(0x57, 0x57, 0x57);
169     invalidate();
170 }
.fi

.PP
References \fBborder_colour\fP, and \fBMaxOS::gui::Widget::invalidate()\fP\&.
.SS "\fBvoid\fP InputBox::on_key_down (\fBdrivers::peripherals::KeyCode\fP key_down_code, \fBdrivers::peripherals::KeyboardState\fP key_down_state)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handles a keypress event by updating the rendered text in the input box\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey_down_code\fP The key being pressed 
.br
\fIkey_down_state\fP The state of the key being pressed 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::peripherals::KeyboardEventHandler\fP\&.
.PP
Definition at line \fB178\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
178                                                                               {
179 
180     // Handle the key press
181     switch (key_down_code) {
182         case KeyCode::backspace: {
183             if (cursor_position == 0)
184                 break;
185 
186             cursor_position\-\-;
187             // no break \- we move the cursor to the left and use the <Delete> code
188             [[fallthrough]];
189         }
190         case KeyCode::deleteKey: {
191             // Move the text to the left
192             for (int i = cursor_position; i < m_widget_text\&.length(); ++i)
193                 m_widget_text[i] = m_widget_text[i + 1];
194 
195             // Put a null character at the end of the string
196             m_widget_text[m_widget_text\&.length() \- 1] = '\\0';
197 
198             break;
199         }
200         case KeyCode::leftArrow: {
201             // If the cursor is not at the beginning of the text, move it to the left
202             if (cursor_position > 0)
203                 cursor_position\-\-;
204             break;
205         }
206         case KeyCode::rightArrow: {
207 
208             // If the cursor is not at the end of the text, move it to the right
209             if (m_widget_text[cursor_position] != '\\0')
210                 cursor_position++;
211             break;
212         }
213         default: {
214 
215             // If the key is a printable character, add it to the text
216             if (31 < (int) key_down_code && (int) key_down_code < 127) {
217                 uint32_t length = cursor_position;
218 
219                 // Find the length of the text buffer
220                 while (m_widget_text[length] != '\\0') {
221                     ++length;
222                 }
223 
224                 // Check if we need to make space for the new character
225                 if (length >= (uint32_t) m_widget_text\&.length()) {
226                     m_widget_text += " ";
227                 }
228 
229                 // Shift elements to the right
230                 while (length > cursor_position) {
231                     m_widget_text[length + 1] = m_widget_text[length];
232                     \-\-length;
233                 }
234 
235                 // Insert the new character
236                 m_widget_text[cursor_position + 1] = m_widget_text[cursor_position];
237                 m_widget_text[cursor_position] = (uint8_t) key_down_code;
238                 cursor_position++;
239             } else {
240 
241                 // Don't want to redraw the widget if nothing has changed
242                 return;
243             }
244             break;
245         }
246     }
247 
248     // Redraw the widget
249     invalidate();
250 
251     // Fire the text changed event
252     if (key_down_code != KeyCode::leftArrow && key_down_code != KeyCode::rightArrow)
253         raise_event(new InputBoxTextChangedEvent(m_widget_text));
254 
255 }
.fi

.PP
References \fBcursor_position\fP, \fBMaxOS::gui::Widget::invalidate()\fP, \fBlength\fP, \fBm_widget_text\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >::raise_event()\fP\&.
.SS "\fBstring\fP InputBox::text ()"

.PP
Get the text currently in the input box\&. 
.PP
\fBReturns\fP
.RS 4
The text in the input box 
.RE
.PP

.PP
Definition at line \fB279\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
279                       {
280 
281     return m_widget_text;
282 }
.fi

.PP
References \fBm_widget_text\fP\&.
.PP
Referenced by \fBInputBox()\fP\&.
.SS "\fBvoid\fP InputBox::update_text (\fBconst\fP \fBstring\fP & new_text)"

.PP
Update the text in the input box\&. 
.PP
\fBParameters\fP
.RS 4
\fInew_text\fP The new text to display 
.RE
.PP

.PP
Definition at line \fB262\fP of file \fBinputbox\&.cpp\fP\&..PP
.nf
262                                                  {
263 
264     m_widget_text\&.copy(new_text);
265     cursor_position = m_widget_text\&.length();
266 
267     // Redraw the widget
268     invalidate();
269 
270     // Fire the text changed event
271     raise_event(new InputBoxTextChangedEvent(new_text));
272 }
.fi

.PP
References \fBcursor_position\fP, \fBMaxOS::gui::Widget::invalidate()\fP, \fBm_widget_text\fP, and \fBMaxOS::common::EventManager< InputBoxEvents >::raise_event()\fP\&.
.PP
Referenced by \fBInputBox()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::background_colour"

.PP
The background colour of the input box\&. 
.PP
Definition at line \fB82\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::border_colour"

.PP
The colour of the bar around the input box\&. 
.PP
Definition at line \fB84\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP, \fBon_focus()\fP, and \fBon_focus_lost()\fP\&.
.SS "int32_t MaxOS::gui::widgets::InputBox::cursor_position { 0 }"

.PP
How many characters into the text the cursor is\&. 
.PP
Definition at line \fB86\fP of file \fBinputbox\&.h\fP\&..PP
.nf
86 { 0 };              
.fi

.PP
Referenced by \fBon_key_down()\fP, and \fBupdate_text()\fP\&.
.SS "\fBgui::Font\fP MaxOS::gui::widgets::InputBox::font"

.PP
The font to use for the input box text\&. 
.PP
Definition at line \fB85\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBcommon::Colour\fP MaxOS::gui::widgets::InputBox::foreground_colour"

.PP
The colour of the text in the input box\&. 
.PP
Definition at line \fB83\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP\&.
.SS "\fBstring\fP MaxOS::gui::widgets::InputBox::m_widget_text = ' '\fC [protected]\fP"

.PP
The text in the input box\&. 
.PP
Definition at line \fB64\fP of file \fBinputbox\&.h\fP\&.
.PP
Referenced by \fBdraw()\fP, \fBon_key_down()\fP, \fBtext()\fP, and \fBupdate_text()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

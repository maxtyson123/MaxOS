.TH "MaxOS::memory::PhysicalMemoryManager" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::PhysicalMemoryManager \- Manages the physical memory of the system such as what pages are allocated/free and mapping of virtual to physical addresses\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <physical\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPhysicalMemoryManager\fP (\fBsystem::Multiboot\fP *\fBmultiboot\fP)"
.br
.ti -1c
.RI "\fB~PhysicalMemoryManager\fP ()"
.br
.ti -1c
.RI "\fBuint64_t\fP \fBmemory_size\fP () \fBconst\fP"
.br
.RI "Gets total the memory size available for use (allocated or not) "
.ti -1c
.RI "\fBuint64_t\fP \fBmemory_used\fP () \fBconst\fP"
.br
.RI "Gets the memory currently used\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBpml4_root_address\fP ()"
.br
.RI "Gets the pml4 root address for the kernel\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate_frame\fP ()"
.br
.RI "Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_frame\fP (\fBvoid\fP *\fBaddress\fP)"
.br
.RI "Frees a frame in the bit map\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate_area\fP (\fBuint64_t\fP start_address, \fBsize_t\fP \fBsize\fP)"
.br
.RI "Allocate an area of physical memory (ie reserve it) "
.ti -1c
.RI "\fBvoid\fP \fBfree_area\fP (\fBuint64_t\fP start_address, \fBsize_t\fP \fBsize\fP)"
.br
.RI "Frees an area of physical memory\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP \fBflags\fP)"
.br
.RI "Allocates a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *\fBphysical\fP, \fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP \fBflags\fP)"
.br
.RI "Maps a physical address to a virtual address, using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *\fBphysical\fP, \fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP \fBflags\fP, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Maps a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBmap_area\fP (\fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP \fBlength\fP, \fBsize_t\fP \fBflags\fP)"
.br
.RI "Allocates a new area physical memory to a area virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBmap_area\fP (\fBphysical_address_t\fP *\fBphysical_address_start\fP, \fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP \fBlength\fP, \fBsize_t\fP \fBflags\fP)"
.br
.RI "Maps an area of physical memory to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBidentity_map\fP (\fBphysical_address_t\fP *\fBphysical_address\fP, \fBsize_t\fP \fBflags\fP)"
.br
.RI "Maps a physical address to its virtual address counter-part\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address)"
.br
.RI "Unmaps a virtual address using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Unmaps a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap_area\fP (\fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP \fBlength\fP)"
.br
.RI "Unmaps an area of virtual memory\&. "
.ti -1c
.RI "\fBbool\fP \fBis_anonymous_available\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Checks if a physical address is reserved by multiboot mmap\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve\fP (\fBuint64_t\fP \fBaddress\fP)"
.br
.RI "Reserves a physical address\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve\fP (\fBuint64_t\fP \fBaddress\fP, \fBsize_t\fP \fBsize\fP)"
.br
.RI "Reserves an area of physical memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve_kernel_regions\fP (\fBsystem::Multiboot\fP *\fBmultiboot\fP)"
.br
.ti -1c
.RI "\fBphysical_address_t\fP * \fBget_physical_address\fP (\fBvirtual_address_t\fP *virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Gets the physical address from a virtual address (if it exists) "
.ti -1c
.RI "\fBbool\fP \fBis_mapped\fP (\fBuintptr_t\fP \fBphysical_address\fP, \fBuintptr_t\fP virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Checks if a physical address is mapped to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_page_flags\fP (\fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP \fBflags\fP, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Changes the flags of a page\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBunmap_lower_kernel\fP ()"
.br
.RI "Unmaps the kernel physical memory from the lower half that was set up during the kernel boot\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBsize_to_frames\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Converts a size to the number of frames\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_to_page\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Aligns a size to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_direct_to_page\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Aligns a address to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_up_to_page\fP (\fBsize_t\fP \fBsize\fP, \fBsize_t\fP \fBs_page_size\fP)"
.br
.RI "Aligns a size up to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBbool\fP \fBcheck_aligned\fP (\fBsize_t\fP \fBsize\fP)"
.br
.RI "Checks if an address is aligned\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBclean_page_table\fP (\fBuint64_t\fP *table)"
.br
.RI "Cleans a page table (fills it with 0 or null entries) "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_higher_region\fP (\fBuintptr_t\fP \fBphysical_address\fP)"
.br
.RI "Converts a physical address to a higher region address if it is in the lower region using the higher half kernel offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_lower_region\fP (\fBuintptr_t\fP virtual_address)"
.br
.RI "Converts a virtual address to a lower region address if it is in the higher region using the higher half kernel offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_io_region\fP (\fBuintptr_t\fP \fBphysical_address\fP)"
.br
.RI "Converts a physical address to an IO region address if it is in the lower region using the higher half memory offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_dm_region\fP (\fBuintptr_t\fP \fBphysical_address\fP)"
.br
.RI "Converts a physical address to a direct map region address if it is in the lower region using the higher half direct map offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBfrom_dm_region\fP (\fBuintptr_t\fP \fBphysical_address\fP)"
.br
.RI "Converts a direct map region address to a physical address if it is in the higher region using the higher half direct map offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBbool\fP \fBin_higher_region\fP (\fBuintptr_t\fP virtual_address)"
.br
.RI "Checks if a virtual address is in the higher region\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const uint32_t \fBs_page_size\fP = 0x1000"
.br
.ti -1c
.RI "static const uint8_t \fBs_row_bits\fP = 64"
.br
.ti -1c
.RI "static const uint64_t \fBs_higher_half_kernel_offset\fP = 0xFFFFFFFF80000000"
.br
.ti -1c
.RI "static const uint64_t \fBs_higher_half_mem_offset\fP = 0xFFFF800000000000"
.br
.ti -1c
.RI "static const uint64_t \fBs_higher_half_mem_reserved\fP = 0x280000000"
.br
.ti -1c
.RI "static const uint64_t \fBs_higher_half_offset\fP = \fBs_higher_half_mem_offset\fP + \fBs_higher_half_mem_reserved\fP"
.br
.ti -1c
.RI "static const uint64_t \fBs_hh_direct_map_offset\fP = \fBs_higher_half_offset\fP + \fBs_page_size\fP"
.br
.ti -1c
.RI "static \fBPhysicalMemoryManager\fP * \fBs_current_manager\fP = nullptr"
.br
.in -1c
.SH "Detailed Description"
.PP 
Manages the physical memory of the system such as what pages are allocated/free and mapping of virtual to physical addresses\&. 
.PP
Definition at line \fB74\fP of file \fBphysical\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PhysicalMemoryManager::PhysicalMemoryManager (\fBsystem::Multiboot\fP * multiboot)"

.PP
Definition at line \fB23\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
24 : m_kernel_end((uint64_t) &_kernel_physical_end),
25   m_multiboot(multiboot),
26   m_pml4_root_address((uint64_t*) p4_table),
27   m_pml4_root((pte_t*) p4_table)
28 {
29 
30     Logger::INFO() << "Setting up Physical Memory Manager\\n";
31     Logger::DEBUG() << "Kernel Memory: kernel_end = 0x" << (uint64_t) &_kernel_end << ", kernel_size = 0x" << (uint64_t) &_kernel_size << ", kernel_physical_end = 0x" << (uint64_t) &_kernel_physical_end << "\\n";
32 
33     // Set up the current manager
34     unmap_lower_kernel();
35     m_lock\&.unlock();
36     s_current_manager = this;
37     m_nx_allowed = CPU::check_nx();
38 
39     // Store the information about the bitmap
40     m_memory_size = (m_multiboot\->basic_meminfo()\->mem_upper + 1024) * 1024;
41     m_bitmap_size = m_memory_size / s_page_size + 1;
42     m_total_entries = m_bitmap_size / s_row_bits + 1;
43     Logger::DEBUG() << "Memory Info: size = " << (int) (m_memory_size / 1024 / 1024) << "mb, bitmap size = 0x" << (uint64_t) m_bitmap_size << ", total entries = " << (int) m_total_entries << ", page size = 0x" << (uint64_t) s_page_size << "\\n";
44 
45     // Find a region of memory available to be used
46     m_mmap_tag = m_multiboot\->mmap();
47     for (multiboot_mmap_entry *entry = m_mmap_tag\->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag\->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag\->entry_size)) {
48 
49         // Skip if the region is not free or there is not enough space
50         if (entry\->type != MULTIBOOT_MEMORY_AVAILABLE)
51             continue;
52 
53         // Store the entry\&. (note: don't break here as it is desired to find the last usable entry as that is normally biggest)
54         m_mmap = entry;
55     }
56     Logger::DEBUG() << "Mmap in use: 0x" << (uint64_t) m_mmap\->addr << " \- 0x" << (uint64_t) (m_mmap\->addr + m_mmap\->len) << "\\n";
57 
58     // Memory after the kernel to be used for direct mapping (the bitmap is not ready while mapping the higher half so have to use this)
59     m_anonymous_memory_physical_address = align_up_to_page((size_t) &_kernel_physical_end + s_page_size, s_page_size);
60     m_anonymous_memory_virtual_address = align_up_to_page((size_t) &_kernel_end + s_page_size, s_page_size);
61     Logger::DEBUG() << "Anonymous Memory: physical = " << (uint64_t) m_anonymous_memory_physical_address << ", virtual = " << (uint64_t) m_anonymous_memory_virtual_address << "\\n";
62 
63     // Map the physical memory into the virtual memory
64     for (uint64_t physical_address = 0; physical_address < (m_mmap\->addr + m_mmap\->len); physical_address += s_page_size)
65         map((physical_address_t*) physical_address, (virtual_address_t*) (s_hh_direct_map_offset + physical_address), Present | Write);
66 
67     m_anonymous_memory_physical_address += s_page_size;
68     Logger::DEBUG() << "Mapped physical memory to higher half direct map at offset 0x" << s_hh_direct_map_offset << "\\n";
69 
70     // Set up the bitmap
71     initialise_bit_map();
72     reserve_kernel_regions(multiboot);
73 
74     // Initialisation Done
75     m_initialized = true;
76 }
.fi

.PP
References \fB_kernel_end\fP, \fB_kernel_physical_end\fP, \fB_kernel_size\fP, \fBMaxOS::system::CPU::check_nx()\fP, \fBLogger::DEBUG()\fP, \fBLogger::INFO()\fP, \fBMULTIBOOT_MEMORY_AVAILABLE\fP, \fBphysical_address\fP, \fBMaxOS::memory::Present\fP, and \fBMaxOS::memory::Write\fP\&.
.SS "PhysicalMemoryManager::~PhysicalMemoryManager ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBsize_t\fP PhysicalMemoryManager::align_direct_to_page (\fBsize_t\fP size)\fC [static]\fP"

.PP
Aligns a address to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned address 
.RE
.PP

.PP
Definition at line \fB778\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
778                                                               {
779 
780     return (size & (~(s_page_size \- 1)));
781 }
.fi

.PP
References \fBs_page_size\fP, and \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::AdvancedConfigurationAndPowerInterface()\fP, \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::map_tables()\fP, \fBreserve()\fP, and \fBreserve()\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::align_to_page (\fBsize_t\fP size)\fC [static]\fP"

.PP
Aligns a size to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line \fB140\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
140                                                        {
141 
142     return ((size + s_page_size \- 1) / s_page_size) * s_page_size;
143 }
.fi

.PP
References \fBs_page_size\fP, and \fBsize\fP\&.
.PP
Referenced by \fBsize_to_frames()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::align_up_to_page (\fBsize_t\fP size, \fBsize_t\fP page_size)\fC [static]\fP"

.PP
Aligns a size up to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.br
\fIpage_size\fP The page size to align to 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line \fB152\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
152                                                                             {
153 
154     return (size + page_size \- 1) & ~(page_size \- 1);
155 }
.fi

.PP
References \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, and \fBreserve()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::allocate_area (\fBuint64_t\fP start_address, \fBsize_t\fP size)"

.PP
Allocate an area of physical memory (ie reserve it) 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the start of the block (physical address) 
.RE
.PP

.PP
Definition at line \fB257\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
257                                                                               {
258 
259     m_lock\&.lock();
260 
261     // Store the information about the frames needed to be allocated for this size
262     size_t frame_count = size_to_frames(size);
263     uint32_t start_row = 0;
264     uint32_t start_column = 0;
265     size_t adjacent_frames = 0;
266 
267     for (uint32_t row = 0; row < m_total_entries; ++row) {
268 
269         // Skip full rows
270         if (m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
271             continue;
272 
273         for (uint32_t column = 0; column < s_row_bits; ++column) {
274 
275             // Not enough adjacent frames
276             if (m_bit_map[row] & (1ULL << column)) {
277                 adjacent_frames = 0;
278                 continue;
279             }
280 
281             // Store the address of the first frame in set of adjacent ones
282             if (adjacent_frames == 0) {
283                 start_row = row;
284                 start_column = column;
285             }
286 
287             // Make sure there are enough frames in a row found
288             adjacent_frames++;
289             if (adjacent_frames != frame_count)
290                 continue;
291 
292             // Mark the frames as used
293             m_used_frames += frame_count;
294             for (uint32_t i = 0; i < frame_count; ++i) {
295 
296                 // Get the location of the bit
297                 uint32_t index = start_row + (start_column + i) / s_row_bits;
298                 uint32_t bit = (start_column + i) % s_row_bits;
299 
300                 // Check bounds
301                 ASSERT(index >= m_total_entries || bit >= s_row_bits, "Index out of bounds\\n");
302 
303                 // Mark the bit as used
304                 m_bit_map[index] |= (1ULL << bit);
305             }
306 
307             // Return start of the block of adjacent frames
308             m_lock\&.unlock();
309             return (void*) (start_address + (start_row * s_row_bits + start_column) * s_page_size);
310 
311         }
312     }
313 
314     // Not enough free frames adjacent to each other
315     m_lock\&.unlock();
316     ASSERT(false, "Cannot allocate that much memory\\n");
317     return nullptr;
318 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBs_page_size\fP, \fBs_row_bits\fP, \fBsize\fP, \fBsize_to_frames()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::allocate_frame ()"

.PP
Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. 
.PP
\fBReturns\fP
.RS 4
The physical address of the page 
.RE
.PP

.PP
Definition at line \fB173\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
173                                             {
174 
175     // Wait for the lock
176     m_lock\&.lock();
177 
178     // If not initialised, cant use the bitmap or higher half mapped physical memory so use leftover kernel memory already
179     // mapped in loader\&.s
180     if (!m_initialized) {
181         // TODO: This seems to destroy the multiboot memory map, need to fix this
182 
183         // Find the first free frame
184         while ((!is_anonymous_available(m_anonymous_memory_physical_address)) && (m_anonymous_memory_physical_address < m_memory_size)) {
185             m_anonymous_memory_physical_address += s_page_size;
186             m_anonymous_memory_virtual_address += s_page_size;
187         }
188 
189         // Mark frame as used
190         m_anonymous_memory_physical_address += s_page_size;
191         m_anonymous_memory_virtual_address += s_page_size;
192 
193         // Return the address
194         m_lock\&.unlock();
195         return (void*) (m_anonymous_memory_physical_address \- s_page_size);
196 
197     }
198 
199     // Check if there are enough frames
200     ASSERT(m_used_frames < m_bitmap_size, "No more frames available\\n");
201 
202     for (uint32_t row = 0; row < m_total_entries; ++row) {
203 
204         // If the row is full continue
205         if (m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
206             continue;
207 
208         for (uint32_t column = 0; column < s_row_bits; ++column) {
209 
210             // Entry isn't free
211             if (m_bit_map[row] & (1ULL << column))
212                 continue;
213 
214             // Mark the frame as used
215             m_bit_map[row] |= (1ULL << column);
216             m_used_frames++;
217 
218             // Thread safe
219             m_lock\&.unlock();
220 
221             // Return the address
222             uint64_t frame_address = (row * s_row_bits) + column;
223             return (void*) (frame_address * s_page_size);
224         }
225     }
226 
227     // Error frame not found
228     ASSERT(false, "Frame not found\\n");
229     m_lock\&.unlock();
230     return nullptr;
231 }
.fi

.PP
References \fBASSERT\fP, \fBis_anonymous_available()\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBs_page_size\fP, \fBs_row_bits\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.PP
Referenced by \fBmap()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::change_page_flags (\fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP * pml4_root)"

.PP
Changes the flags of a page\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address of the page 
.br
\fIflags\fP The flags to set the page to 
.RE
.PP

.PP
Definition at line \fB860\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
860                                                                                                                    {
861 
862     pte_t* entry = get_entry(virtual_address, (pml_t*) pml4_root);
863 
864     // Cant edit a non\-present entry (will page fault)
865     if (!entry\->present)
866         return;
867 
868     *entry = create_page_table_entry(physical_address_of_entry(entry), flags);
869 
870     // Flush the TLB (cache)
871     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
872 
873 }
.fi

.PP
References \fBflags\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::check_aligned (\fBsize_t\fP size)\fC [static]\fP"

.PP
Checks if an address is aligned\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is aligned 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
163                                                      {
164 
165     return (size % s_page_size) == 0;
166 }
.fi

.PP
References \fBs_page_size\fP, and \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::clean_page_table (\fBuint64_t\fP * table)\fC [static]\fP"

.PP
Cleans a page table (fills it with 0 or null entries) 
.PP
\fBParameters\fP
.RS 4
\fItable\fP The table to clean 
.RE
.PP

.PP
Definition at line \fB620\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
620                                                             {
621 
622     // Null the table (prevents false mappings when re\-using frames)
623     for (int i = 0; i < 512; i++)
624         table[i] = 0x00l;
625 }
.fi

.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::free_area (\fBuint64_t\fP start_address, \fBsize_t\fP size)"

.PP
Frees an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to free 
.RE
.PP

.PP
Definition at line \fB326\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
326                                                                          {
327 
328     // Convert address into frames
329     size_t frame_count = size_to_frames(size);
330     uint64_t frame_address = start_address / s_page_size;
331 
332     // Check bounds
333     if (frame_address >= m_bitmap_size)
334         return;
335 
336     // Wait until other threads have finished other memory operations
337     m_lock\&.lock();
338 
339     // Mark the frames as not used
340     m_used_frames \-= frame_count;
341     for (uint32_t i = 0; i < frame_count; ++i)
342         m_bit_map[(frame_address + i) / s_row_bits] &= ~(1 << ((frame_address + i) % s_row_bits));
343 
344     m_lock\&.unlock();
345 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, \fBs_page_size\fP, \fBs_row_bits\fP, \fBsize\fP, \fBsize_to_frames()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::free_frame (\fBvoid\fP * address)"

.PP
Frees a frame in the bit map\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to free 
.RE
.PP

.PP
Definition at line \fB238\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
238                                                     {
239 
240     m_lock\&.lock();
241 
242     // Mark the frame as not used
243     m_used_frames\-\-;
244     uint64_t frame_address = (uint64_t) address / s_page_size;
245     m_bit_map[frame_address / s_row_bits] &= ~(1 << (frame_address % s_row_bits));
246 
247     m_lock\&.unlock();
248 }
.fi

.PP
References \fBaddress\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBs_page_size\fP, \fBs_row_bits\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::from_dm_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a direct map region address to a physical address if it is in the higher region using the higher half direct map offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address in the direct map region 
.RE
.PP
\fBReturns\fP
.RS 4
The physical address 
.RE
.PP

.PP
Definition at line \fB957\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
957                                                                       {
958 
959     if (physical_address > s_hh_direct_map_offset)
960         return (void*) (physical_address \- s_hh_direct_map_offset);
961 
962     // Must be in the lower half
963     return (void*) physical_address;
964 }
.fi

.PP
References \fBphysical_address\fP, and \fBs_hh_direct_map_offset\fP\&.
.PP
Referenced by \fBreserve_kernel_regions()\fP\&.
.SS "\fBphysical_address_t\fP * PhysicalMemoryManager::get_physical_address (\fBvirtual_address_t\fP * virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Gets the physical address from a virtual address (if it exists) 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to get the physical address from 
.RE
.PP
\fBReturns\fP
.RS 4
The physical address or nullptr if it does not exist 
.RE
.PP

.PP
Definition at line \fB843\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
843                                                                                                                        {
844 
845     pte_t* entry = get_entry(virtual_address, (pml_t*) pml4_root);
846 
847     // Cant get a physical address if its inst free
848     if (!entry\->present)
849         return nullptr;
850 
851     return (physical_address_t*) physical_address_of_entry(entry);
852 }
.fi

.PP
Referenced by \fBis_mapped()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::identity_map (\fBphysical_address_t\fP * physical_address, \fBsize_t\fP flags)"

.PP
Maps a physical address to its virtual address counter-part\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB563\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
563                                                                                            {
564 
565     // Map the physical address to its virtual address counter\-part
566     map(physical_address, physical_address, flags);
567 }
.fi

.PP
References \fBflags\fP, \fBmap()\fP, and \fBphysical_address\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::in_higher_region (\fBuintptr_t\fP virtual_address)\fC [static]\fP"

.PP
Checks if a virtual address is in the higher region\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is in the higher region, false otherwise 
.RE
.PP

.PP
Definition at line \fB973\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
973                                                                       {
974 
975     return virtual_address & (1l << 62);
976 }
.fi

.PP
Referenced by \fBmap()\fP, and \fBMaxOS::system::CPU::prepare_for_panic()\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::is_anonymous_available (\fBsize_t\fP address)"

.PP
Checks if a physical address is reserved by multiboot mmap\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is reserved 
.RE
.PP

.PP
Definition at line \fB666\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
666                                                                  {
667 
668     // Make sure the address isn't (entirely) within or overlapping with the multiboot memory chunk
669     if ((address > m_multiboot\->start_address && address + s_page_size < m_multiboot\->end_address)
670      || (address + s_page_size > m_multiboot\->start_address && address < m_multiboot\->end_address)) {
671         return false;
672     }
673 
674     // Make sure the address isn't used by a multiboot module
675     if (m_multiboot\->is_reserved(address))
676         return false;
677 
678     // Make sure the address doesn't overlap with a reserved chunk of physical memory
679     for (multiboot_mmap_entry* entry = m_mmap_tag\->entries; (multiboot_uint8_t*) entry < (multiboot_uint8_t*) m_mmap_tag + m_mmap_tag\->size; entry = (multiboot_mmap_entry*) ((unsigned long) entry + m_mmap_tag\->entry_size)) {
680 
681         // This entry doesnt contain the address
682         if ((entry\->addr + entry\->len) < (address + s_page_size))
683             continue;
684 
685         // This entry is not free
686         if (entry\->type != MULTIBOOT_MEMORY_AVAILABLE)
687             continue;
688 
689         // This entry must contain the address and must be free so it can be used
690         return true;
691 
692     }
693 
694     // Memory is not available (it was not found in a free region)
695     return false;
696 }
.fi

.PP
References \fBaddress\fP, \fBmultiboot_tag_mmap::entries\fP, \fBmultiboot_tag_mmap::entry_size\fP, \fBMaxOS::system::Multiboot::is_reserved()\fP, \fBMULTIBOOT_MEMORY_AVAILABLE\fP, \fBs_page_size\fP, \fBmultiboot_tag_mmap::size\fP, and \fBMaxOS::system::Multiboot::start_address\fP\&.
.PP
Referenced by \fBallocate_frame()\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::is_mapped (\fBuintptr_t\fP physical_address, \fBuintptr_t\fP virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Checks if a physical address is mapped to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to check 
.br
\fIvirtual_address\fP The virtual address to check 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
True if the physical address is mapped to the virtual address 
.RE
.PP

.PP
Definition at line \fB883\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
883                                                                                                                 {
884 
885     return get_physical_address((virtual_address_t*) virtual_address, pml4_root) == (physical_address_t*) physical_address;
886 
887 }
.fi

.PP
References \fBget_physical_address()\fP, and \fBphysical_address\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags)"

.PP
Maps a physical address to a virtual address, using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIvirtual_address\fP The virtual address to map to 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB478\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
478                                                                                                                                     {
479 
480     // Map using the kernel's pml4 table
481     return map(physical_address, virtual_address, flags, m_pml4_root_address);
482 }
.fi

.PP
References \fBflags\fP, \fBmap()\fP, and \fBphysical_address\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP * pml4_table)"

.PP
Maps a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical\fP The physical address 
.br
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.br
\fIpml4_table\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB493\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
493                                                                                                                                                           {
494 
495     // If it is in a lower region then assume it is the user space
496     if (!in_higher_region((uint64_t) virtual_address))
497         flags |= User;
498 
499     // If the entry already exists then the mapping is already done
500     pte_t* pte = get_entry(virtual_address, (pml_t*) pml4_table);
501     if (pte\->present)
502         return virtual_address;
503 
504     // Map the physical address to the virtual address
505     *pte = create_page_table_entry((uint64_t) physical_address, flags);
506 
507     // Flush the TLB (cache)
508     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
509 
510     return virtual_address;
511 }
.fi

.PP
References \fBflags\fP, \fBin_higher_region()\fP, \fBphysical_address\fP, and \fBMaxOS::memory::User\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags)"

.PP
Allocates a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB520\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
520                                                                                               {
521 
522     // Map a new physical address to the requested virtual address
523     return map(allocate_frame(), virtual_address, flags);
524 
525 }
.fi

.PP
References \fBallocate_frame()\fP, \fBflags\fP, and \fBmap()\fP\&.
.PP
Referenced by \fBidentity_map()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, \fBmap()\fP, \fBmap()\fP, \fBmap_area()\fP, and \fBmap_area()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::map_area (\fBphysical_address_t\fP * physical_address_start, \fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length, \fBsize_t\fP flags)"

.PP
Maps an area of physical memory to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address_start\fP The start of the physical address 
.br
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB550\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
550                                                                                                                                                       {
551 
552     // Map the required frames
553     for (size_t i = 0; i < size_to_frames(length); ++i)
554         map(physical_address_start + (i * s_page_size), virtual_address_start + (i * s_page_size), flags);
555 }
.fi

.PP
References \fBflags\fP, \fBlength\fP, \fBmap()\fP, \fBs_page_size\fP, and \fBsize_to_frames()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::map_area (\fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length, \fBsize_t\fP flags)"

.PP
Allocates a new area physical memory to a area virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB534\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
534                                                                                                           {
535 
536     // Map the required frames
537     for (size_t i = 0; i < size_to_frames(length); ++i)
538         map(virtual_address_start + (i * s_page_size), flags);
539 
540 }
.fi

.PP
References \fBflags\fP, \fBlength\fP, \fBmap()\fP, \fBs_page_size\fP, and \fBsize_to_frames()\fP\&.
.SS "\fBuint64_t\fP PhysicalMemoryManager::memory_size () const"

.PP
Gets total the memory size available for use (allocated or not) 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line \fB757\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
757                                                   {
758 
759     return m_memory_size;
760 }
.fi

.SS "\fBuint64_t\fP PhysicalMemoryManager::memory_used () const"

.PP
Gets the memory currently used\&. 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line \fB767\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
767                                                   {
768 
769     return m_used_frames * s_page_size;
770 }
.fi

.PP
References \fBs_page_size\fP\&.
.SS "\fBuint64_t\fP * PhysicalMemoryManager::pml4_root_address ()"

.PP
Gets the pml4 root address for the kernel\&. 
.PP
\fBReturns\fP
.RS 4
The pml4 root address 
.RE
.PP

.PP
Definition at line \fB747\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
747                                                    {
748 
749     return m_pml4_root_address;
750 }
.fi

.SS "\fBvoid\fP PhysicalMemoryManager::reserve (\fBuint64_t\fP address)"

.PP
Reserves a physical address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to reserve 
.RE
.PP

.PP
Definition at line \fB788\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
788                                                     {
789 
790     // Cant reserve virtual addresses (ensure the address is physical)
791     if (address >= m_memory_size)
792         return;
793 
794     // Mark as used in the bitmap
795     address = align_direct_to_page(address);
796     m_bit_map[address / s_row_bits] |= (1 << (address % s_row_bits));
797 
798     Logger::DEBUG() << "Reserved Address: 0x" << address << "\\n";
799 }
.fi

.PP
References \fBaddress\fP, \fBalign_direct_to_page()\fP, \fBLogger::DEBUG()\fP, and \fBs_row_bits\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, and \fBreserve_kernel_regions()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::reserve (\fBuint64_t\fP address, \fBsize_t\fP size)"

.PP
Reserves an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The start of the area 
.br
\fIsize\fP The size of the area 
.RE
.PP

.PP
Definition at line \fB807\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
807                                                                  {
808 
809     // Cant reserve virtual addresses (ensure the address is physical)
810     if (address >= m_memory_size)
811         return;
812 
813     // Wait to be able to reserve
814     m_lock\&.lock();
815 
816     // Ensure the area is a range of pages
817     address = align_direct_to_page(address);
818     size = align_up_to_page(size, s_page_size);
819 
820     // Convert in to amount of pages
821     size_t page_count = size / s_page_size;
822     uint64_t frame_index = address / s_page_size;
823 
824     // Mark all as free
825     for (size_t i = 0; i < page_count; ++i)
826         m_bit_map[(frame_index + i) / s_row_bits] |= (1ULL << ((frame_index + i) % s_row_bits));
827 
828 
829     // Update the used frames
830     m_used_frames += page_count;
831 
832     // Clear the lock
833     m_lock\&.unlock();
834     Logger::DEBUG() << "Reserved Address: 0x" << address << " \- 0x" << address + size << " (length of 0x" << size << ")\\n";
835 }
.fi

.PP
References \fBaddress\fP, \fBalign_direct_to_page()\fP, \fBalign_up_to_page()\fP, \fBLogger::DEBUG()\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBs_page_size\fP, \fBs_row_bits\fP, \fBsize\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::reserve_kernel_regions (\fBsystem::Multiboot\fP * multiboot)"

.PP
Definition at line \fB81\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
81                                                                        {
82 
83     // Reserve the area for the bitmap
84     Logger::DEBUG() << "Bitmap: location: 0x" << (uint64_t) m_bit_map << " \- 0x" << (uint64_t) (m_bit_map + m_bitmap_size / 8) << " (range of 0x" << (uint64_t) m_bitmap_size / 8 << ")\\n";
85     reserve((uint64_t) from_dm_region((uint64_t) m_bit_map), m_bitmap_size / 8);
86 
87     // Calculate how much space the kernel takes up
88     uint32_t kernel_entries = (m_anonymous_memory_physical_address / s_page_size) + 1;
89     if ((((uint32_t) (m_anonymous_memory_physical_address)) % s_page_size) != 0)
90         kernel_entries += 1;
91 
92     // Reserve the kernel entries
93     Logger::DEBUG() << "Kernel: location: 0x" << (uint64_t) m_anonymous_memory_physical_address << " \- 0x" << (uint64_t) (m_anonymous_memory_physical_address + kernel_entries * s_page_size) << " (range of 0x" << (uint64_t) kernel_entries * s_page_size << ")\\n";
94     reserve(0, kernel_entries * s_page_size);
95 
96     // Reserve the area for the mmap
97     uint64_t mem_end = m_mmap\->addr + m_mmap\->len;
98     for (multiboot_mmap_entry* entry = m_mmap_tag\->entries; (multiboot_uint8_t*) entry < (multiboot_uint8_t*) m_mmap_tag + m_mmap_tag\->size; entry = (multiboot_mmap_entry*) ((unsigned long) entry + m_mmap_tag\->entry_size)) {
99 
100         // Dont reserve free regions
101         if (entry\->type <= MULTIBOOT_MEMORY_AVAILABLE)
102             continue;
103 
104         // Don't reserve the memory being managed by pmm
105         if (entry\->addr >= mem_end)
106             continue;
107 
108         reserve(entry\->addr, entry\->len);
109     }
110 
111     // Reserve the area for each multiboot module
112     for (multiboot_tag* tag = multiboot\->start_tag(); tag\->type != MULTIBOOT_TAG_TYPE_END; tag = (struct multiboot_tag*) ((multiboot_uint8_t*) tag + ((tag\->size + 7) & ~7))) {
113 
114         if (tag\->type != MULTIBOOT_TAG_TYPE_MODULE)
115             continue;
116 
117         // Reserve the module's address
118         auto* module = (struct multiboot_tag_module*) tag;
119         reserve(module\->mod_start, module\->mod_end \- module\->mod_start);
120     }
121 }
.fi

.PP
References \fBmultiboot_mmap_entry::addr\fP, \fBLogger::DEBUG()\fP, \fBmultiboot_tag_mmap::entries\fP, \fBmultiboot_tag_mmap::entry_size\fP, \fBfrom_dm_region()\fP, \fBmultiboot_mmap_entry::len\fP, \fBMULTIBOOT_MEMORY_AVAILABLE\fP, \fBMULTIBOOT_TAG_TYPE_END\fP, \fBMULTIBOOT_TAG_TYPE_MODULE\fP, \fBreserve()\fP, \fBs_page_size\fP, and \fBmultiboot_tag_mmap::size\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::size_to_frames (\fBsize_t\fP size)\fC [static]\fP"

.PP
Converts a size to the number of frames\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The number of frames 
.RE
.PP

.PP
Definition at line \fB129\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
129                                                         {
130 
131     return align_to_page(size) / s_page_size;
132 }
.fi

.PP
References \fBalign_to_page()\fP, \fBs_page_size\fP, and \fBsize\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBallocate_area()\fP, \fBfree_area()\fP, \fBMaxOS::memory::VirtualMemoryManager::load_physical_into_address_space()\fP, \fBmap_area()\fP, \fBmap_area()\fP, \fBunmap_area()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, and \fBMaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_dm_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to a direct map region address if it is in the lower region using the higher half direct map offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The direct map region address 
.RE
.PP

.PP
Definition at line \fB942\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
942                                                                     {
943 
944     if (physical_address < s_higher_half_offset)
945         return (void*) (physical_address + s_hh_direct_map_offset);
946 
947     // Must be in the higher half
948     return (void*) physical_address;
949 }
.fi

.PP
References \fBphysical_address\fP, \fBs_hh_direct_map_offset\fP, and \fBs_higher_half_offset\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::load_multiboot_elfs()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_higher_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to a higher region address if it is in the lower region using the higher half kernel offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The higher region address 
.RE
.PP

.PP
Definition at line \fB895\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
895                                                                         {
896 
897     // If it's in the lower half then add the offset
898     if (physical_address < s_higher_half_kernel_offset)
899         return (void*) (physical_address + s_higher_half_kernel_offset);
900 
901     // Must be in the higher half
902     return (void*) physical_address;
903 }
.fi

.PP
References \fBphysical_address\fP, and \fBs_higher_half_kernel_offset\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::AdvancedConfigurationAndPowerInterface()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_io_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to an IO region address if it is in the lower region using the higher half memory offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The IO region address 
.RE
.PP

.PP
Definition at line \fB927\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
927                                                                     {
928 
929     if (physical_address < s_higher_half_mem_offset)
930         return (void*) (physical_address + s_higher_half_mem_offset);
931 
932     // Must be in the higher half
933     return (void*) physical_address;
934 }
.fi

.PP
References \fBphysical_address\fP, and \fBs_higher_half_mem_offset\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, and \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::map_tables()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_lower_region (\fBuintptr_t\fP virtual_address)\fC [static]\fP"

.PP
Converts a virtual address to a lower region address if it is in the higher region using the higher half kernel offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.RE
.PP
\fBReturns\fP
.RS 4
The lower region address 
.RE
.PP

.PP
Definition at line \fB911\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
911                                                                       {
912 
913     // If it's in the lower half then add the offset
914     if (virtual_address > s_higher_half_kernel_offset)
915         return (void*) (virtual_address \- s_higher_half_kernel_offset);
916 
917     // Must be in the lower half
918     return (void*) virtual_address;
919 }
.fi

.PP
References \fBs_higher_half_kernel_offset\fP\&.
.PP
Referenced by \fBMaxOS::system::Multiboot::Multiboot()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address)"

.PP
Unmaps a virtual address using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.RE
.PP

.PP
Definition at line \fB574\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
574                                                                     {
575 
576     // Pass the kernel's pml4 table
577     unmap(virtual_address, m_pml4_root_address);
578 }
.fi

.PP
References \fBunmap()\fP\&.
.PP
Referenced by \fBunmap()\fP, and \fBunmap_area()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Unmaps a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP

.PP
Definition at line \fB586\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
586                                                                                          {
587 
588     // Get the entry
589     pte_t* pte = get_entry(virtual_address, (pml_t*) pml4_root);
590 
591     // Make sure the address is actually mapped
592     if (!pte\->present)
593         return;
594 
595     // Unmap the entry
596     pte\->present = false;
597 
598     // Flush the TLB (cache)
599     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
600 }
.fi

.SS "\fBvoid\fP PhysicalMemoryManager::unmap_area (\fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length)"

.PP
Unmaps an area of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the area 
.br
\fIlength\fP The length of the area 
.RE
.PP

.PP
Definition at line \fB608\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
608                                                                                               {
609 
610     // Unmap the required frames
611     for (size_t i = 0; i < size_to_frames(length); ++i)
612         unmap(virtual_address_start + (i * s_page_size));
613 }
.fi

.PP
References \fBlength\fP, \fBs_page_size\fP, \fBsize_to_frames()\fP, and \fBunmap()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap_lower_kernel ()\fC [static]\fP"

.PP
Unmaps the kernel physical memory from the lower half that was set up during the kernel boot\&. 
.PP
Definition at line \fB982\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
982                                                {
983 
984     p4_table[0] = 0;
985 }
.fi

.SH "Member Data Documentation"
.PP 
.SS "\fBPhysicalMemoryManager\fP* MaxOS::memory::PhysicalMemoryManager::s_current_manager = nullptr\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB160\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::AdvancedConfigurationAndPowerInterface()\fP, \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBMaxOS::processes::SharedMemory::close()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, \fBMaxOS::memory::VirtualMemoryManager::load_physical_into_address_space()\fP, \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::map_tables()\fP, \fBMaxOS::processes::SharedMemory::SharedMemory()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP, \fBMaxOS::processes::Process::~Process()\fP, and \fBMaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\fP\&.
.SS "const uint64_t MaxOS::memory::PhysicalMemoryManager::s_hh_direct_map_offset = \fBs_higher_half_offset\fP + \fBs_page_size\fP\fC [static]\fP"

.PP
Definition at line \fB123\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBfrom_dm_region()\fP, \fBto_dm_region()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "const uint64_t MaxOS::memory::PhysicalMemoryManager::s_higher_half_kernel_offset = 0xFFFFFFFF80000000\fC [static]\fP"

.PP
Definition at line \fB119\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBMaxOS::system::Multiboot::start_tag()\fP, \fBto_higher_region()\fP, and \fBto_lower_region()\fP\&.
.SS "const uint64_t MaxOS::memory::PhysicalMemoryManager::s_higher_half_mem_offset = 0xFFFF800000000000\fC [static]\fP"

.PP
Definition at line \fB120\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBto_io_region()\fP\&.
.SS "const uint64_t MaxOS::memory::PhysicalMemoryManager::s_higher_half_mem_reserved = 0x280000000\fC [static]\fP"

.PP
Definition at line \fB121\fP of file \fBphysical\&.h\fP\&.
.SS "const uint64_t MaxOS::memory::PhysicalMemoryManager::s_higher_half_offset = \fBs_higher_half_mem_offset\fP + \fBs_higher_half_mem_reserved\fP\fC [static]\fP"

.PP
Definition at line \fB122\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBto_dm_region()\fP\&.
.SS "const uint32_t MaxOS::memory::PhysicalMemoryManager::s_page_size = 0x1000\fC [static]\fP"

.PP
Definition at line \fB116\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBalign_direct_to_page()\fP, \fBalign_to_page()\fP, \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBallocate_area()\fP, \fBallocate_frame()\fP, \fBcheck_aligned()\fP, \fBfree_area()\fP, \fBfree_frame()\fP, \fBis_anonymous_available()\fP, \fBMaxOS::memory::VirtualMemoryManager::load_physical_into_address_space()\fP, \fBmap_area()\fP, \fBmap_area()\fP, \fBmemory_used()\fP, \fBMaxOS::memory::MemoryManager::MemoryManager()\fP, \fBreserve()\fP, \fBreserve_kernel_regions()\fP, \fBsize_to_frames()\fP, \fBunmap_area()\fP, \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP, and \fBMaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\fP\&.
.SS "const uint8_t MaxOS::memory::PhysicalMemoryManager::s_row_bits = 64\fC [static]\fP"

.PP
Definition at line \fB117\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBallocate_area()\fP, \fBallocate_frame()\fP, \fBfree_area()\fP, \fBfree_frame()\fP, \fBreserve()\fP, and \fBreserve()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

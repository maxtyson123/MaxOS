.TH "MaxOS::memory::PhysicalMemoryManager" 3 "Sun Oct 13 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::PhysicalMemoryManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <physical\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPhysicalMemoryManager\fP (unsigned long \fBreserved\fP, \fBsystem::Multiboot\fP *multiboot, uint64_t pml4_root[512])"
.br
.ti -1c
.RI "\fB~PhysicalMemoryManager\fP ()"
.br
.ti -1c
.RI "uint64_t \fBget_memory_size\fP ()"
.br
.RI "Gets total the memory size available for use (allocated or not) "
.ti -1c
.RI "uint64_t * \fBget_pml4_root_address\fP ()"
.br
.RI "Gets the pml4 root address for the kernel\&. "
.ti -1c
.RI "void * \fBallocate_frame\fP ()"
.br
.RI "Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. "
.ti -1c
.RI "void \fBfree_frame\fP (void *\fBaddress\fP)"
.br
.RI "Frees a frame in the bit map\&. "
.ti -1c
.RI "void * \fBallocate_area\fP (uint64_t start_address, size_t \fBsize\fP)"
.br
.RI "Allocate an area of physical memory\&. "
.ti -1c
.RI "void \fBfree_area\fP (uint64_t start_address, size_t \fBsize\fP)"
.br
.RI "Frees an area of physical memory\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP)"
.br
.RI "Allocates a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *physical, \fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP)"
.br
.RI "Maps a physical address to a virtual address, using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *physical, \fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP, uint64_t *pml4_root)"
.br
.RI "Maps a physical address to a virtual address\&. "
.ti -1c
.RI "void \fBmap_area\fP (\fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP, size_t \fBflags\fP)"
.br
.RI "Allocates a new area physical memory to a area virtual address\&. "
.ti -1c
.RI "void \fBmap_area\fP (\fBphysical_address_t\fP *physical_address_start, \fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP, size_t \fBflags\fP)"
.br
.RI "Maps an area of physical memory to a virtual address\&. "
.ti -1c
.RI "void \fBidentity_map\fP (\fBphysical_address_t\fP *\fBphysical_address\fP, size_t \fBflags\fP)"
.br
.RI "Maps a physical address to its virtual address counter-part\&. "
.ti -1c
.RI "void \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address)"
.br
.RI "Unmaps a virtual address using the kernel's pml4 table\&. "
.ti -1c
.RI "void \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address, uint64_t *pml4_root)"
.br
.RI "Unmaps a virtual address\&. "
.ti -1c
.RI "void \fBunmap_area\fP (\fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP)"
.br
.RI "Unmaps an area of virtual memory\&. "
.ti -1c
.RI "bool \fBis_mapped\fP (uintptr_t \fBphysical_address\fP, uintptr_t virtual_address)"
.br
.RI "Checks if a virtual address is mapped and whether it points to the correct physical address\&. "
.ti -1c
.RI "bool \fBis_anonymous_available\fP (size_t \fBsize\fP)"
.br
.RI "Checks if a physical address is reserved by multiboot mmap\&. "
.ti -1c
.RI "bool \fBis_multiboot_reserved\fP (uint64_t \fBaddress\fP)"
.br
.RI "Checks if an address is reserved by a multiboot module\&. "
.ti -1c
.RI "void \fBclean_page_table\fP (uint64_t *table)"
.br
.RI "Cleans a page table (fills it with 0 or null entries) "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static size_t \fBsize_to_frames\fP (size_t \fBsize\fP)"
.br
.RI "Converts a size to the number of frames\&. "
.ti -1c
.RI "static size_t \fBalign_to_page\fP (size_t \fBsize\fP)"
.br
.RI "Aligns a size to the page size\&. "
.ti -1c
.RI "static size_t \fBalign_up_to_page\fP (size_t \fBsize\fP, size_t \fBs_page_size\fP)"
.br
.RI "Aligns a size up to the page size\&. "
.ti -1c
.RI "static bool \fBcheck_aligned\fP (size_t \fBsize\fP)"
.br
.RI "Checks if an address is aligned\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const uint32_t \fBs_page_size\fP = { 0x1000 }"
.br
.ti -1c
.RI "static \fBPhysicalMemoryManager\fP * \fBs_current_manager\fP = nullptr"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 63 of file physical\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MaxOS::memory::PhysicalMemoryManager::PhysicalMemoryManager (unsigned long reserved, \fBsystem::Multiboot\fP * multiboot, uint64_t pml4_root[512])"

.PP
Definition at line 19 of file physical\&.cpp\&.
.PP
.nf
19                                                                                                                              {
20 
21   // Set the current manager
22   s_current_manager = this;
23 
24   // SEE boot\&.s FOR SETUP OF PAGING
25   m_pml4_root = (pte_t *)pml4_root;
26   m_pml4_root_address = pml4_root;
27 
28   // Store the information about the bitmap
29   m_memory_size = (multiboot->get_basic_meminfo()->mem_upper + 1024) * 1000;
30   m_bitmap_size = m_memory_size / s_page_size + 1;
31   m_total_entries = m_bitmap_size / ROW_BITS + 1;
32   _kprintf("Mem Info: size = %dmb, bitmap size = %d, total entries = %d, page size = %db\n", ((m_memory_size / 1000) * 1024) / 1024 / 1024, m_bitmap_size, m_total_entries, s_page_size);
33 
34   // Get the mmap that stores the memory to use
35   m_mmap_tag = multiboot->get_mmap();
36   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
37 
38     // Skip if the region is not free or there is not enough space
39     if (entry->type != MULTIBOOT_MEMORY_AVAILABLE || (entry->addr + entry->len) < reserved)
40       continue;
41 
42     // We want the last entry
43     m_mmap = entry;
44   }
45   _kprintf("Mmap in use: 0x%x - 0x%x\n", m_mmap->addr, m_mmap->addr + m_mmap->len);
46 
47   // Kernel Memory (anonymous memory to the next page)
48   _kprintf("Kernel Memory: kernel_end = 0x%x, kernel_size = 0x%x, kernel_physical_end = 0x%x\n", &_kernel_end, &_kernel_size, &_kernel_physical_end);
49   m_anonymous_memory_physical_address = (uint64_t)align_up_to_page((size_t)(&_kernel_physical_end + s_page_size), s_page_size);
50   m_anonymous_memory_virtual_address = (uint64_t)align_up_to_page((size_t)(&_kernel_end + s_page_size), s_page_size);
51   _kprintf("Anonymous Memory: physical = 0x%x, virtual = 0x%x\n", m_anonymous_memory_physical_address, m_anonymous_memory_virtual_address);
52 
53   // Map the physical memory into the virtual memory
54   uint64_t physical_address = 0;
55   uint64_t virtual_address = MemoryManager::s_hh_direct_map_offset;
56   uint64_t mem_end = m_mmap->addr + m_mmap->len;
57 
58   while (physical_address < mem_end) {
59     map((physical_address_t *)physical_address, (virtual_address_t *)virtual_address, Present | Write);
60     physical_address += s_page_size;
61     virtual_address += s_page_size;
62   }
63   _kprintf("Mapped: physical = 0x%x-0x%x, virtual = 0x%x-0x%x\n", 0, physical_address, MemoryManager::s_hh_direct_map_offset, virtual_address); // TODO: FAILS WHEN TRYING WITH LIKE 2Gb Mem
64 
65   // Get the bitmap & clear it
66   m_anonymous_memory_physical_address += s_page_size;
67   m_bit_map = get_bitmap_address();
68 
69   for (uint32_t i = 0; i < m_total_entries; ++i)
70     m_bit_map[i] = 0;
71   _kprintf("Bitmap: location = 0x%x - 0x%x\n", m_bit_map, m_bit_map + m_bitmap_size / 8);
72 
73   // Calculate how much space the kernel takes up
74   uint32_t kernel_entries = (m_anonymous_memory_physical_address / s_page_size) + 1;
75   if ((((uint32_t)(m_anonymous_memory_physical_address)) % s_page_size) != 0) {
76     // If the kernel takes up more then a whole page(s)
77     kernel_entries += 1;
78   }
79 
80   // Reserve the kernel in the bitmap
81   uint32_t kernel_rows = kernel_entries / ROW_BITS;
82   for (uint32_t i = 0; i < kernel_rows; ++i)
83       m_bit_map[i] = 0xFFFFFFFF;
84 
85   // Change the final row to account for the remaining bits
86   m_bit_map[kernel_rows] = ~(0ul) << (kernel_entries - (kernel_rows * 64));
87   m_used_frames = kernel_entries;
88   _kprintf("Kernel: entries = %d, rows = %d, used = %d\n", kernel_entries, kernel_rows, m_used_frames);
89 
90   // Reserve the area for the bitmap
91   allocate_area((uint64_t)MemoryManager::to_lower_region((uint64_t)m_bit_map), m_bitmap_size / 8 + 1);
92 
93   // Reserve the area for the mmap
94   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
95 
96     // Check if the entry is to be mapped
97     if (entry->type <= 1)
98       continue;
99 
100     // Where our free mem starts
101     if(entry->addr >= mem_end)
102       continue;
103 
104     // Reserve the area
105 
106     allocate_area(entry->addr, entry->len);
107     _kprintf("Mmap Reserved: 0x%x - 0x%x\n", entry->addr, entry->addr + entry->len);
108   }
109 
110   // Initialisation Done
111   m_initialized = true;
112 }
.fi
.PP
References _kernel_end, _kernel_physical_end, _kernel_size, _kprintf, MaxOS::system::Multiboot::get_basic_meminfo(), MaxOS::system::Multiboot::get_mmap(), MaxOS::drivers::peripherals::i, multiboot_tag_basic_meminfo::mem_upper, MULTIBOOT_MEMORY_AVAILABLE, physical_address, MaxOS::memory::Present, reserved, MaxOS::memory::MemoryManager::s_hh_direct_map_offset, MaxOS::memory::MemoryManager::to_lower_region(), and MaxOS::memory::Write\&.
.SS "PhysicalMemoryManager::~PhysicalMemoryManager ()"

.PP
Definition at line 114 of file physical\&.cpp\&.
.PP
.nf
114                                               {
115 
116 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "size_t PhysicalMemoryManager::align_to_page (size_t size)\fC [static]\fP"

.PP
Aligns a size to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line 132 of file physical\&.cpp\&.
.PP
.nf
132                                                        {
133   return ((size + s_page_size - 1) /s_page_size) * s_page_size;
134 }
.fi
.PP
References size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "size_t PhysicalMemoryManager::align_up_to_page (size_t size, size_t page_size)\fC [static]\fP"

.PP
Aligns a size up to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.br
\fIpage_size\fP The page size to align to 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line 142 of file physical\&.cpp\&.
.PP
.nf
142                                                                             {
143   return (size + page_size - 1) & ~(page_size - 1);
144 }
.fi
.PP
References size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate()\&.
.SS "void * PhysicalMemoryManager::allocate_area (uint64_t start_address, size_t size)"

.PP
Allocate an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the start of the block (physical address) 
.RE
.PP

.PP
Definition at line 225 of file physical\&.cpp\&.
.PP
.nf
225                                                                               {
226 
227   // Check how many frames are needed
228   size_t frame_count = size_to_frames(size);
229 
230   // Store the information about the frames needed to be allocated for this size
231   uint16_t start_row = 0;
232   uint16_t start_column = 0;
233   size_t adjacent_frames = 0;
234 
235   // Loop through the bitmap
236   for (uint16_t row = 0; row < m_total_entries; ++row) {
237     for (uint16_t column = 0; column < ROW_BITS; ++column) {
238 
239       // If this bit is not free reset the adjacent frames
240       if((m_bit_map[row] & (1 << column))){
241         adjacent_frames = 0;
242         continue;
243       }
244 
245       // Store the start of the area if it is not already stored
246       if(adjacent_frames == 0){
247         start_row = row;
248         start_column = column;
249       }
250 
251       // Increment the adjacent frames
252       adjacent_frames++;
253 
254       // If enough frames are found we can allocate the area
255       if(adjacent_frames == frame_count){
256 
257         // Mark the frames as used
258         m_used_frames += frame_count;
259         for (uint16_t i = 0; i < frame_count; ++i)
260           m_bit_map[start_row + (start_column + i) / ROW_BITS] |= (1 << ((start_column + i) % ROW_BITS));
261 
262         // Return the address
263         return (void*)(start_address + (start_row * ROW_BITS + start_column) * s_page_size);
264       }
265     }
266   }
267 
268   // Error cant allocate that much
269   return nullptr;
270 }
.fi
.PP
References MaxOS::drivers::peripherals::i, and size\&.
.SS "void * PhysicalMemoryManager::allocate_frame ()"

.PP
Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. 
.PP
\fBReturns\fP
.RS 4
The physical address of the page 
.RE
.PP

.PP
Definition at line 159 of file physical\&.cpp\&.
.PP
.nf
159                                             {
160 
161   // Check if the pmm is initialized
162   if(!m_initialized){
163 
164     // Find the first free frame
165     while ((!is_anonymous_available(m_anonymous_memory_physical_address)) && (m_anonymous_memory_physical_address < m_memory_size)) {
166       m_anonymous_memory_physical_address += s_page_size;
167       m_anonymous_memory_virtual_address += s_page_size;
168     }
169 
170     // Mark frame as used
171     m_anonymous_memory_physical_address += s_page_size;
172     m_anonymous_memory_virtual_address += s_page_size;
173 
174     // Return the address
175     return (void*)(m_anonymous_memory_physical_address - s_page_size);
176 
177   }
178 
179   // Check if there are enough frames
180   ASSERT(m_used_frames < m_bitmap_size, "No more frames available")
181 
182   // Loop through the bitmap
183   for (uint16_t row = 0; row < m_total_entries; ++row) {
184     for (uint16_t column = 0; column < ROW_BITS; ++column) {
185 
186         // Check if this frame is free
187         if((m_bit_map[row] & (1 << column)))
188           continue;
189 
190         // Mark the frame as used
191         m_bit_map[row] |= (1 << column);
192         m_used_frames++;
193 
194         // Return the address
195         uint64_t frame_address = (row * ROW_BITS) + column;
196         return (void*)(frame_address * s_page_size);
197     }
198   }
199 
200   // Error frame not found
201   return nullptr;
202 
203 }
.fi
.PP
References ASSERT\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "bool PhysicalMemoryManager::check_aligned (size_t size)\fC [static]\fP"

.PP
Checks if an address is aligned\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is aligned 
.RE
.PP

.PP
Definition at line 151 of file physical\&.cpp\&.
.PP
.nf
151                                                     {
152     return (size % s_page_size) == 0;
153 }
.fi
.PP
References size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate()\&.
.SS "void PhysicalMemoryManager::clean_page_table (uint64_t * table)"

.PP
Cleans a page table (fills it with 0 or null entries) 
.PP
\fBParameters\fP
.RS 4
\fItable\fP The table to clean 
.RE
.PP

.PP
Definition at line 638 of file physical\&.cpp\&.
.PP
.nf
638                                                             {
639   for(int i = 0; i < 512; i++){
640         table[i] = 0x00l;
641   }
642 }
.fi
.PP
References MaxOS::drivers::peripherals::i, and MaxOS::drivers::peripherals::l\&.
.SS "void PhysicalMemoryManager::free_area (uint64_t start_address, size_t size)"

.PP
Frees an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to free 
.RE
.PP

.PP
Definition at line 277 of file physical\&.cpp\&.
.PP
.nf
277                                                                          {
278 
279     // Check how many frames are needed
280     size_t frame_count = size_to_frames(size);
281     uint64_t frame_address = start_address / s_page_size;
282 
283     // Check if the address is valid
284     if(frame_address >= m_bitmap_size)
285       return;
286 
287     // Mark the frames as not used
288     m_used_frames -= frame_count;
289     for (uint16_t i = 0; i < frame_count; ++i)
290       m_bit_map[(frame_address + i) / ROW_BITS] &= ~(1 << ((frame_address + i) % ROW_BITS));
291 
292 }
.fi
.PP
References MaxOS::drivers::peripherals::i, and size\&.
.SS "void PhysicalMemoryManager::free_frame (void * address)"

.PP
Frees a frame in the bit map\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to free 
.RE
.PP

.PP
Definition at line 209 of file physical\&.cpp\&.
.PP
.nf
209                                                     {
210 
211     // Mark the frame as not used
212     m_used_frames--;
213 
214     // Set the bit to 0
215     uint64_t frame_address = (uint64_t)address / s_page_size;
216     m_bit_map[frame_address / ROW_BITS] &= ~(1 << (frame_address % ROW_BITS));
217 }
.fi
.PP
References address\&.
.SS "uint64_t PhysicalMemoryManager::get_memory_size ()"

.PP
Gets total the memory size available for use (allocated or not) 
.PP
\fBReturns\fP
.RS 4
The memory size 
.RE
.PP

.PP
Definition at line 767 of file physical\&.cpp\&.
.PP
.nf
767                                                 {
768   return m_memory_size;
769 }
.fi
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "uint64_t * PhysicalMemoryManager::get_pml4_root_address ()"

.PP
Gets the pml4 root address for the kernel\&. 
.PP
\fBReturns\fP
.RS 4
The pml4 root address 
.RE
.PP

.PP
Definition at line 759 of file physical\&.cpp\&.
.PP
.nf
759                                                        {
760     return m_pml4_root_address;
761 }
.fi
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "void PhysicalMemoryManager::identity_map (\fBphysical_address_t\fP * physical_address, size_t flags)"

.PP
Maps a physical address to its virtual address counter-part\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 530 of file physical\&.cpp\&.
.PP
.nf
530                                                                                            {
531 
532   // Map the physical address to its virtual address counter-part
533   map(physical_address, physical_address, flags);
534 
535 }
.fi
.PP
References flags, and physical_address\&.
.SS "bool PhysicalMemoryManager::is_anonymous_available (size_t address)"

.PP
Checks if a physical address is reserved by multiboot mmap\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is reserved 
.RE
.PP

.PP
Definition at line 674 of file physical\&.cpp\&.
.PP
.nf
674                                                                  {
675 
676   // Return false if the address range is entirely within or overlaps with the multiboot reserved region
677   if ((address > multiboot_tag_start && address + s_page_size < multiboot_tag_end) || (address + s_page_size > multiboot_tag_start && address < multiboot_tag_end)) {
678     return false;
679   }
680 
681   // Loop through the mmmap entries
682   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
683 
684     // If it doesn't overlap with the mmap entry
685     if ((entry -> addr + entry -> len) < (address + s_page_size))
686       continue;
687 
688     // If it is not available
689     if(entry -> type != MULTIBOOT_MEMORY_AVAILABLE)
690       continue;
691 
692     // Check if the address is reserved by the multiboot module
693     if(is_multiboot_reserved(address))
694         continue;
695 
696     // Memory is available
697     return true;
698 
699   }
700 
701   // Memory is not available
702   return false;
703 }
.fi
.PP
References address, MULTIBOOT_MEMORY_AVAILABLE, multiboot_tag_end, multiboot_tag_start, and type\&.
.SS "bool PhysicalMemoryManager::is_mapped (uintptr_t physical_address, uintptr_t virtual_address)"

.PP
Checks if a virtual address is mapped and whether it points to the correct physical address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to check (if 0 then wont check if correct entry) 
.br
\fIvirtual_address\fP The address to check if it is mapped to 
.RE
.PP
\fBReturns\fP
.RS 4
True if the physical address is mapped to the virtual address 
.RE
.PP

.PP
Definition at line 629 of file physical\&.cpp\&.
.PP
.nf
629                                                                                            {
630   ASSERT(false, "Not implemented!")
631   // TODO: Implement
632 }
.fi
.PP
References ASSERT\&.
.SS "bool PhysicalMemoryManager::is_multiboot_reserved (uint64_t address)"

.PP
Checks if an address is reserved by a multiboot module\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is reserved 
.RE
.PP

.PP
Definition at line 710 of file physical\&.cpp\&.
.PP
.nf
710                                                                   {
711   //ASSERT(false, "Not implemented!")
712   // TODO: Check if address is reserve by multiboot module
713 
714   return false;
715 }
.fi
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * address, size_t flags)"

.PP
Maps a physical address to a virtual address, using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIaddress\fP The virtual address to map to 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 391 of file physical\&.cpp\&.
.PP
.nf
391                                                                                                                             {
392 
393   // Base information
394   pml_t* pml4_table = (pml_t *)m_pml4_root_address;
395   size_t base_addr = 0xFFFF000000000000;
396 
397   // Get the indexes
398   uint16_t pml4_index = PML4_GET_INDEX((uint64_t) address);
399   uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) address);
400   uint16_t pd_index   = PML2_GET_INDEX((uint64_t) address);
401   uint16_t pt_index   = PML1_GET_INDEX((uint64_t) address);
402 
403   // Get the tables
404   pml_t *pdpr_table =(pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l,510l, (uint64_t) pml4_index));
405   pml_t *pd_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l, (uint64_t) pml4_index, (uint64_t) pdpr_index));
406   pml_t *pt_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l, (uint64_t) pml4_index, (uint64_t) pdpr_index, (uint64_t) pd_index));
407 
408   // Create the tables
409   create_table(pml4_table, pdpr_table, pml4_index);
410   create_table(pdpr_table, pd_table, pdpr_index);
411   create_table(pd_table, pt_table, pd_index);
412 
413   // Get the entry
414   pte_t* pte = &pt_table -> entries[pt_index];
415 
416   // If it already exists return the address
417   if(pte -> present)
418     return address;
419 
420   // Map the physical address to the virtual address
421  *pte = create_page_table_entry((uint64_t)physical_address, flags);
422 
423 
424   // Flush the TLB
425   asm volatile("invlpg (%0)" ::"r" (address) : "memory");
426 
427   return address;
428 }
.fi
.PP
References address, entries, ENTRIES_TO_ADDRESS, flags, MaxOS::drivers::peripherals::l, physical_address, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, PML4_GET_INDEX, and present\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical, \fBvirtual_address_t\fP * virtual_address, size_t flags, uint64_t * pml4_table)"

.PP
Maps a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical\fP The physical address 
.br
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.br
\fIpml4_table\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 438 of file physical\&.cpp\&.
.PP
.nf
438                                                                                                                                                   {
439 
440     // Get the indexes
441     uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
442     uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
443     uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
444     uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
445 
446     // If it is in a lower region then assume it is the user space
447     uint8_t is_user = MemoryManager::in_higher_region((uint64_t)virtual_address);
448     if(is_user) {
449 
450       // Change the flags to user
451       flags |= User;
452       is_user = User;
453 
454     }
455 
456     // Store the tables
457     uint64_t* pdpr_table = get_or_create_table(pml4_table, pml4_index, Present | Write | is_user);
458     uint64_t* pd_table = get_or_create_table(pdpr_table, pdpr_index, Present | Write | is_user);
459     uint64_t* pt_table = get_or_create_table(pd_table, pd_index, Present | Write | is_user);
460 
461     // If the page is already mapped return the address
462     if(pt_table[pt_index] & 0b1)
463       return virtual_address;
464 
465     // Map the physical address to the virtual address
466     pt_table[pt_index] = (uint64_t) physical | flags;
467 
468     // Flush the TLB
469     asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
470 
471     return virtual_address;
472 }
.fi
.PP
References flags, MaxOS::memory::MemoryManager::in_higher_region(), PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, PML4_GET_INDEX, MaxOS::memory::Present, MaxOS::memory::User, and MaxOS::memory::Write\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBvirtual_address_t\fP * virtual_address, size_t flags)"

.PP
Allocates a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 480 of file physical\&.cpp\&.
.PP
.nf
480                                                                                               {
481 
482   // Create a new physical address for the frame
483   physical_address_t* physical_address = (physical_address_t *)allocate_frame();
484 
485   // Map the physical address to the virtual address
486   return map(physical_address, virtual_address, flags);
487 
488 }
.fi
.PP
References flags, and physical_address\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "void PhysicalMemoryManager::map_area (\fBphysical_address_t\fP * physical_address_start, \fBvirtual_address_t\fP * virtual_address_start, size_t length, size_t flags)"

.PP
Maps an area of physical memory to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address_start\fP The start of the physical address 
.br
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 514 of file physical\&.cpp\&.
.PP
.nf
514                                                                                                                                                       {
515 
516   // Get the size of the area
517   size_t size = size_to_frames(length);
518 
519   // Map the required frames
520   for (size_t i = 0; i < size; ++i)
521     map(physical_address_start + (i * s_page_size), virtual_address_start + (i * s_page_size), flags);
522 
523 }
.fi
.PP
References flags, MaxOS::drivers::peripherals::i, length, and size\&.
.SS "void PhysicalMemoryManager::map_area (\fBvirtual_address_t\fP * virtual_address_start, size_t length, size_t flags)"

.PP
Allocates a new area physical memory to a area virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 496 of file physical\&.cpp\&.
.PP
.nf
496                                                                                                           {
497 
498     // Get the size of the area
499     size_t size = size_to_frames(length);
500 
501     // Map the required frames
502     for (size_t i = 0; i < size; ++i)
503         map(virtual_address_start + (i * s_page_size), flags);
504 
505 }
.fi
.PP
References flags, MaxOS::drivers::peripherals::i, length, and size\&.
.SS "size_t PhysicalMemoryManager::size_to_frames (size_t size)\fC [static]\fP"

.PP
Converts a size to the number of frames\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The number of frames 
.RE
.PP

.PP
Definition at line 123 of file physical\&.cpp\&.
.PP
.nf
123                                                         {
124     return align_to_page(size) / s_page_size;
125 }
.fi
.PP
References size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), and MaxOS::memory::VirtualMemoryManager::free()\&.
.SS "void PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address)"

.PP
Unmaps a virtual address using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.RE
.PP

.PP
Definition at line 541 of file physical\&.cpp\&.
.PP
.nf
541                                                                     {
542 
543   // Base information
544   pml_t* pml4_table = (pml_t *)m_pml4_root_address;
545   size_t base_addr = 0xFFFF000000000000;
546 
547   // Get the indexes
548   uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
549   uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
550   uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
551   uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
552 
553   // Get the tables
554   pml_t *pdpr_table =(pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l,510l, (uint64_t) pml4_index));
555   pml_t *pd_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l, (uint64_t) pml4_index, (uint64_t) pdpr_index));
556   uint64_t* pt_table = (uint64_t *) (base_addr | ENTRIES_TO_ADDRESS(510l, (uint64_t) pml4_index, (uint64_t) pdpr_index, (uint64_t) pd_index));
557 
558   // Check if the entry is present
559   if(table_has_entry(pml4_table, pml4_index) && table_has_entry(pdpr_table, pdpr_index) && table_has_entry(pd_table, pd_index))
560     return;
561 
562   // Check if the entry isn't present
563   if(!(pt_table[pt_index] & 0b1))
564     return;
565 
566   // Unmap the entry
567   pt_table[pt_index] = 0x00l;
568 
569   // Flush the TLB
570   asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
571 }
.fi
.PP
References ENTRIES_TO_ADDRESS, MaxOS::drivers::peripherals::l, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, and PML4_GET_INDEX\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::free()\&.
.SS "void PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address, uint64_t * pml4_root)"

.PP
Unmaps a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP

.PP
Definition at line 578 of file physical\&.cpp\&.
.PP
.nf
578                                                                                          {
579 
580     // Get the indexes
581     uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
582     uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
583     uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
584     uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
585 
586     // Get the tables
587     uint64_t* pdpr_table = get_table_if_exists(pml4_root, pml4_index);
588     uint64_t* pd_table = get_table_if_exists(pdpr_table, pdpr_index);
589     uint64_t* pt_table = get_table_if_exists(pd_table, pd_index);
590 
591     // Check if the tables are present (if any are not then a pt entry will not be present)
592     if(pt_table == nullptr)
593       return;
594 
595 
596     // Check if the entry is present
597     if(!(pt_table[pt_index] & 0b1))
598       return;
599 
600     // Unmap the entry
601     pt_table[pt_index] = 0x00l;
602 
603     // Flush the TLB
604     asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
605 
606 }
.fi
.PP
References MaxOS::drivers::peripherals::l, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, and PML4_GET_INDEX\&.
.SS "void PhysicalMemoryManager::unmap_area (\fBvirtual_address_t\fP * virtual_address_start, size_t length)"

.PP
Unmaps an area of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the area 
.br
\fIlength\fP The length of the area 
.RE
.PP

.PP
Definition at line 613 of file physical\&.cpp\&.
.PP
.nf
613                                                                                               {
614 
615     // Get the size of the area
616     size_t size = size_to_frames(length);
617 
618     // Unmap the required frames
619     for (size_t i = 0; i < size; ++i)
620       unmap(virtual_address_start + (i * s_page_size));
621 }
.fi
.PP
References MaxOS::drivers::peripherals::i, length, and size\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBPhysicalMemoryManager\fP * PhysicalMemoryManager::s_current_manager = nullptr\fC [static]\fP"

.PP
Definition at line 136 of file physical\&.h\&.
.SS "const uint32_t MaxOS::memory::PhysicalMemoryManager::s_page_size = { 0x1000 }\fC [static]\fP"

.PP
Definition at line 102 of file physical\&.h\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), MaxOS::memory::VirtualMemoryManager::free(), MaxOS::memory::MemoryManager::MemoryManager(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

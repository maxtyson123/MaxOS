.TH "MaxOS::memory::PhysicalMemoryManager" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::PhysicalMemoryManager \- Manages the physical memory of the system such as what pages are allocated/free and mapping of virtual to physical addresses\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <physical\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPhysicalMemoryManager\fP (\fBsystem::Multiboot\fP *\fBmultiboot\fP)"
.br
.RI "Constructs a \fBPhysicalMemoryManager\fP\&. Unmaps the lower kernel and sets up the bitmap for physical memory management\&. Reserves the kernel and the multiboot regions\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBmemory_size\fP () \fBconst\fP"
.br
.RI "Gets total the memory size available for use (allocated or not) "
.ti -1c
.RI "\fBuint64_t\fP \fBmemory_used\fP () \fBconst\fP"
.br
.RI "Gets the memory currently used\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBpml4_root_address\fP ()"
.br
.RI "Gets the pml4 root address for the kernel\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate_frame\fP ()"
.br
.RI "Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_frame\fP (\fBvoid\fP *address)"
.br
.RI "Frees a frame in the bit map\&. "
.ti -1c
.RI "\fBvoid\fP * \fBallocate_area\fP (\fBuint64_t\fP start_address, \fBsize_t\fP size)"
.br
.RI "Allocate an area of physical memory (ie reserve it) "
.ti -1c
.RI "\fBvoid\fP \fBfree_area\fP (\fBuint64_t\fP start_address, \fBsize_t\fP size)"
.br
.RI "Frees an area of physical memory\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP flags)"
.br
.RI "Allocates a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *\fBphysical\fP, \fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP flags)"
.br
.RI "Maps a physical address to a virtual address, using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *\fBphysical\fP, \fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Maps a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBmap_area\fP (\fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP length, \fBsize_t\fP flags)"
.br
.RI "Allocates a new area physical memory to a area virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBmap_area\fP (\fBphysical_address_t\fP *\fBphysical_address_start\fP, \fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP length, \fBsize_t\fP flags)"
.br
.RI "Maps an area of physical memory to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBidentity_map\fP (\fBphysical_address_t\fP *physical_address, \fBsize_t\fP flags)"
.br
.RI "Maps a physical address to its virtual address counter-part\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address)"
.br
.RI "Unmaps a virtual address using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Unmaps a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmap_area\fP (\fBvirtual_address_t\fP *\fBvirtual_address_start\fP, \fBsize_t\fP length)"
.br
.RI "Unmaps an area of virtual memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve\fP (\fBuint64_t\fP address)"
.br
.RI "Reserves a physical address\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve\fP (\fBuint64_t\fP address, \fBsize_t\fP size, \fBconst\fP \fBchar\fP *='Unknown')"
.br
.RI "Reserves an area of physical memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve_kernel_regions\fP (\fBsystem::Multiboot\fP *\fBmultiboot\fP)"
.br
.RI "Reserves the kernel, multiboot modules, mmap regions and higher half mapping regions in the physical memory manager so that those pages arent overwritten later\&. "
.ti -1c
.RI "\fBphysical_address_t\fP * \fBget_physical_address\fP (\fBvirtual_address_t\fP *virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Gets the physical address from a virtual address (if it exists) "
.ti -1c
.RI "\fBbool\fP \fBis_mapped\fP (\fBuintptr_t\fP physical_address, \fBuintptr_t\fP virtual_address, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Checks if a physical address is mapped to a virtual address\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_page_flags\fP (\fBvirtual_address_t\fP *virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP *\fBpml4_root\fP)"
.br
.RI "Changes the flags of a page\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBunmap_lower_kernel\fP ()"
.br
.RI "Unmaps the kernel physical memory from the lower half that was set up during the kernel boot\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBsize_to_frames\fP (\fBsize_t\fP size)"
.br
.RI "Converts a size to the number of frames\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_to_page\fP (\fBsize_t\fP size)"
.br
.RI "Aligns a size to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_direct_to_page\fP (\fBsize_t\fP size)"
.br
.RI "Aligns a address to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBsize_t\fP \fBalign_up_to_page\fP (\fBsize_t\fP size, \fBsize_t\fP \fBs_page_size\fP)"
.br
.RI "Aligns a size up to the page size\&. "
.ti -1c
.RI "\fBstatic\fP \fBbool\fP \fBcheck_aligned\fP (\fBsize_t\fP size)"
.br
.RI "Checks if an address is aligned\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBclean_page_table\fP (\fBuint64_t\fP *table)"
.br
.RI "Cleans a page table (fills it with 0 or null entries) "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_higher_region\fP (\fBuintptr_t\fP physical_address)"
.br
.RI "Converts a physical address to a higher region address if it is in the lower region using the higher half kernel offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_lower_region\fP (\fBuintptr_t\fP virtual_address)"
.br
.RI "Converts a virtual address to a lower region address if it is in the higher region using the higher half kernel offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_io_region\fP (\fBuintptr_t\fP physical_address)"
.br
.RI "Converts a physical address to an IO region address if it is in the lower region using the higher half memory offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBto_dm_region\fP (\fBuintptr_t\fP physical_address)"
.br
.RI "Converts a physical address to a direct map region address if it is in the lower region using the higher half direct map offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP * \fBfrom_dm_region\fP (\fBuintptr_t\fP physical_address)"
.br
.RI "Converts a direct map region address to a physical address if it is in the higher region using the higher half direct map offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBbool\fP \fBin_higher_region\fP (\fBuintptr_t\fP virtual_address)"
.br
.RI "Checks if a virtual address is in the higher region\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBPhysicalMemoryManager\fP * \fBs_current_manager\fP = nullptr"
.br
.RI "The current physical memory manager in use\&. "
.in -1c
.SH "Detailed Description"
.PP 
Manages the physical memory of the system such as what pages are allocated/free and mapping of virtual to physical addresses\&. 


.PP
\fBTodo\fP
.RS 4
Global paging so dont have map in every process 
.RE
.PP

.PP
Definition at line \fB108\fP of file \fBphysical\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PhysicalMemoryManager::PhysicalMemoryManager (\fBsystem::Multiboot\fP * multiboot)\fC [explicit]\fP"

.PP
Constructs a \fBPhysicalMemoryManager\fP\&. Unmaps the lower kernel and sets up the bitmap for physical memory management\&. Reserves the kernel and the multiboot regions\&. 
.PP
\fBParameters\fP
.RS 4
\fImultiboot\fP The multiboot information structure to use for memory information such as the memory map\&. 
.RE
.PP

.PP
Definition at line \fB31\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
32 : m_kernel_end((uint64_t) &_kernel_physical_end),
33 m_multiboot(multiboot),
34 m_pml4_root_address((uint64_t*) p4_table),
35 m_pml4_root((pte_t*) p4_table) {
36 
37     Logger::INFO() << "Setting up Physical Memory Manager\\n";
38     Logger::DEBUG() << "Kernel Memory: kernel_end = 0x" << (uint64_t) &_kernel_end << ", kernel_size = 0x"
39                     << (uint64_t) &_kernel_size << ", kernel_physical_end = 0x" << (uint64_t) &_kernel_physical_end
40                     << "\\n";
41     m_kernel_start_page = align_up_to_page((size_t) &_kernel_physical_end + PAGE_SIZE, PAGE_SIZE);
42 
43     // Set up the current manager
44     unmap_lower_kernel();
45     m_lock\&.unlock();
46     s_current_manager = this;
47     m_nx_allowed = CPU::check_nx();
48 
49     // Find a region of memory available to be used
50     m_mmap_tag = m_multiboot\->mmap();
51     for(multiboot_mmap_entry* entry = m_mmap_tag\->entries; (multiboot_uint8_t*) entry <
52                                                            (multiboot_uint8_t*) m_mmap_tag +
53                                                            m_mmap_tag\->size; entry = (multiboot_mmap_entry*) (
54     (unsigned long) entry + m_mmap_tag\->entry_size)) {
55 
56         // Skip if the region is not free or there is not enough space
57         if(entry\->type != MULTIBOOT_MEMORY_AVAILABLE)
58             continue;
59 
60         // Store the entry\&. (note: don't break here as it is desired to find the last usable entry as that is normally biggest)
61         m_mmap = entry;
62     }
63 
64     // Store the information about the bitmap
65     m_memory_size = (m_mmap\->addr + m_mmap\->len);
66     m_bitmap_size = m_memory_size / PAGE_SIZE + 1;
67     m_total_entries = m_bitmap_size / ROW_BITS + 1;
68     Logger::DEBUG() << "Memory Info: size = " << (int) (m_memory_size / 1024 / 1024) << "mb, bitmap size = 0x"
69                     << (uint64_t) m_bitmap_size << ", total entries = " << (int) m_total_entries << ", page size = 0x"
70                     << (uint64_t) PAGE_SIZE << "\\n";
71 
72     // Map the physical memory into the virtual memory
73     Logger::DEBUG() << "Mapping from 0x0 to 0x" << (uint64_t) (m_mmap\->addr + m_mmap\->len)
74                     << " to higher half direct map at offset 0x" << HIGHER_HALF_DIRECT_MAP << "\\n";
75     for(uint64_t physical_address = 0; physical_address < (m_mmap\->addr + m_mmap\->len); physical_address += PAGE_SIZE)
76         map((physical_address_t*) physical_address, (virtual_address_t*) (HIGHER_HALF_DIRECT_MAP + physical_address),
77             PRESENT | WRITE);
78 
79     // Kernel Setup
80     initialise_bit_map();
81     reserve_kernel_regions(multiboot);
82 
83     // Initialisation Done
84     m_initialised = true;
85     Logger::DEBUG() << "Memory used at start: " << (int) (memory_used() / 1024 / 1024) << "mb \\n";
86 }
.fi

.PP
References \fB_kernel_end\fP, \fB_kernel_physical_end\fP, \fB_kernel_size\fP, \fBmultiboot_mmap_entry::addr\fP, \fBalign_up_to_page()\fP, \fBMaxOS::system::CPU::check_nx()\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBmultiboot_tag_mmap::entries\fP, \fBmultiboot_tag_mmap::entry_size\fP, \fBMaxOS::memory::HIGHER_HALF_DIRECT_MAP\fP, \fBMaxOS::Logger::INFO()\fP, \fBmultiboot_mmap_entry::len\fP, \fBmap()\fP, \fBmemory_used()\fP, \fBMaxOS::system::Multiboot::mmap()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::PRESENT\fP, \fBreserve_kernel_regions()\fP, \fBMaxOS::memory::ROW_BITS\fP, \fBs_current_manager\fP, \fBmultiboot_tag_mmap::size\fP, \fBMaxOS::common::Spinlock::unlock()\fP, \fBunmap_lower_kernel()\fP, and \fBMaxOS::memory::WRITE\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBsize_t\fP PhysicalMemoryManager::align_direct_to_page (\fBsize_t\fP size)\fC [static]\fP"

.PP
Aligns a address to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned address 
.RE
.PP

.PP
Definition at line \fB767\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
767                                                               {
768 
769     return (size & (~(PAGE_SIZE \- 1)));
770 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP\&.
.PP
Referenced by \fBreserve()\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::align_to_page (\fBsize_t\fP size)\fC [static]\fP"

.PP
Aligns a size to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line \fB167\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
167                                                        {
168 
169     return ((size + PAGE_SIZE \- 1) / PAGE_SIZE) * PAGE_SIZE;
170 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP\&.
.PP
Referenced by \fBsize_to_frames()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::align_up_to_page (\fBsize_t\fP size, \fBsize_t\fP page_size)\fC [static]\fP"

.PP
Aligns a size up to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.br
\fIpage_size\fP The page size to align to 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line \fB179\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
179                                                                             {
180 
181     return (size + page_size \- 1) & ~(page_size \- 1);
182 }
.fi

.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBPhysicalMemoryManager()\fP, and \fBreserve()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::allocate_area (\fBuint64_t\fP start_address, \fBsize_t\fP size)"

.PP
Allocate an area of physical memory (ie reserve it) 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the start of the block (physical address) 
.RE
.PP

.PP
Definition at line \fB275\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
275                                                                               {
276 
277     m_lock\&.lock();
278 
279     // Store the information about the frames needed to be allocated for this size
280     size_t frame_count = size_to_frames(size);
281     uint32_t start_row = 0;
282     uint32_t start_column = 0;
283     size_t adjacent_frames = 0;
284 
285     for(uint32_t row = 0; row < m_total_entries; ++row) {
286 
287         // Skip full rows
288         if(m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
289             continue;
290 
291         for(uint32_t column = 0; column < ROW_BITS; ++column) {
292 
293             // Not enough adjacent frames
294             if(m_bit_map[row] & (1ULL << column)) {
295                 adjacent_frames = 0;
296                 continue;
297             }
298 
299             // Store the address of the first frame in set of adjacent ones
300             if(adjacent_frames == 0) {
301                 start_row = row;
302                 start_column = column;
303             }
304 
305             // Make sure there are enough frames in a row found
306             adjacent_frames++;
307             if(adjacent_frames != frame_count)
308                 continue;
309 
310             // Mark the frames as used
311             m_used_frames += frame_count;
312             for(uint32_t i = 0; i < frame_count; ++i) {
313 
314                 // Get the location of the bit
315                 uint32_t index = start_row + (start_column + i) / ROW_BITS;
316                 uint32_t bit = (start_column + i) % ROW_BITS;
317 
318                 // Check bounds
319                 ASSERT(index >= m_total_entries || bit >= ROW_BITS, "Index out of bounds\\n");
320 
321                 // Mark the bit as used
322                 m_bit_map[index] |= (1ULL << bit);
323             }
324 
325             // Return start of the block of adjacent frames
326             m_lock\&.unlock();
327             return (void*) (start_address + (start_row * ROW_BITS + start_column) * PAGE_SIZE);
328 
329         }
330     }
331 
332     // Not enough free frames adjacent to each other
333     m_lock\&.unlock();
334     ASSERT(false, "Cannot allocate that much memory\\n");
335     return nullptr;
336 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::ROW_BITS\fP, \fBsize_to_frames()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::allocate_frame ()"

.PP
Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. 
.PP
\fBReturns\fP
.RS 4
The physical address of the page 
.RE
.PP

.PP
Definition at line \fB200\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
200                                             {
201 
202     // Wait for the lock
203     m_lock\&.lock();
204 
205     // If not initialised, cant use the bitmap or higher half mapped physical memory so use leftover kernel memory already
206     // mapped in loader\&.s
207     if(!m_initialised) {
208 
209         // Use frames at the start of the mmap free
210         void* address = (void*) ((uintptr_t) m_mmap\->addr + (m_setup_frames * PAGE_SIZE));
211         m_setup_frames++;
212 
213         m_lock\&.unlock();
214         return address;
215     }
216 
217     // Check if there are enough frames
218     ASSERT(m_used_frames < m_bitmap_size, "No more frames available\\n");
219 
220     for(uint32_t row = 0; row < m_total_entries; ++row) {
221 
222         // If the row is full continue
223         if(m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
224             continue;
225 
226         for(uint32_t column = 0; column < ROW_BITS; ++column) {
227 
228             // Entry isn't free
229             if(m_bit_map[row] & (1ULL << column))
230                 continue;
231 
232             // Mark the frame as used
233             m_bit_map[row] |= (1ULL << column);
234             m_used_frames++;
235 
236             // Thread safe
237             m_lock\&.unlock();
238 
239             // Return the address
240             uint64_t frame_address = (row * ROW_BITS) + column;
241             return (void*) (frame_address * PAGE_SIZE);
242         }
243     }
244 
245     // Error frame not found
246     ASSERT(false, "Frame not found\\n");
247     m_lock\&.unlock();
248     return nullptr;
249 }
.fi

.PP
References \fBmultiboot_mmap_entry::addr\fP, \fBASSERT\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::ROW_BITS\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.PP
Referenced by \fBmap()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::change_page_flags (\fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP * pml4_root)"

.PP
Changes the flags of a page\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address of the page 
.br
\fIflags\fP The flags to set the page to 
.br
\fIpml4_root\fP The address of the root pml to use 
.RE
.PP

.PP
Definition at line \fB847\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
847                                                                                                                    {
848 
849     pte_t* entry = get_entry(virtual_address, (pml_t*) pml4_root);
850 
851     // Cant edit a non\-present entry (will page fault)
852     if(!entry\->present)
853         return;
854 
855     *entry = create_page_table_entry(physical_address_of_entry(entry), flags);
856 
857     // Flush the TLB (cache)
858     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
859 
860 }
.fi

.SS "\fBbool\fP PhysicalMemoryManager::check_aligned (\fBsize_t\fP size)\fC [static]\fP"

.PP
Checks if an address is aligned\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is aligned 
.RE
.PP

.PP
Definition at line \fB190\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
190                                                      {
191 
192     return (size % PAGE_SIZE) == 0;
193 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::clean_page_table (\fBuint64_t\fP * table)\fC [static]\fP"

.PP
Cleans a page table (fills it with 0 or null entries) 
.PP
\fBParameters\fP
.RS 4
\fItable\fP The table to clean 
.RE
.PP

.PP
Definition at line \fB639\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
639                                                             {
640 
641     // Null the table (prevents false mappings when re\-using frames)
642     for(int i = 0; i < 512; i++)
643         table[i] = 0x00l;
644 }
.fi

.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::free_area (\fBuint64_t\fP start_address, \fBsize_t\fP size)"

.PP
Frees an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to free 
.RE
.PP

.PP
Definition at line \fB344\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
344                                                                          {
345 
346     // Convert address into frames
347     size_t frame_count = size_to_frames(size);
348     uint64_t frame_address = start_address / PAGE_SIZE;
349 
350     // Check bounds
351     if(frame_address >= m_bitmap_size)
352         return;
353 
354     // Wait until other threads have finished other memory operations
355     m_lock\&.lock();
356 
357     // Mark the frames as not used
358     m_used_frames \-= frame_count;
359     for(uint32_t i = 0; i < frame_count; ++i)
360         m_bit_map[(frame_address + i) / ROW_BITS] &= ~(1 << ((frame_address + i) % ROW_BITS));
361 
362     m_lock\&.unlock();
363 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::ROW_BITS\fP, \fBsize_to_frames()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::free_frame (\fBvoid\fP * address)"

.PP
Frees a frame in the bit map\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to free 
.RE
.PP

.PP
Definition at line \fB256\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
256                                                     {
257 
258     m_lock\&.lock();
259 
260     // Mark the frame as not used
261     m_used_frames\-\-;
262     uint64_t frame_address = (uint64_t) address / PAGE_SIZE;
263     m_bit_map[frame_address / ROW_BITS] &= ~(1 << (frame_address % ROW_BITS));
264 
265     m_lock\&.unlock();
266 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::ROW_BITS\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::from_dm_region (\fBuintptr_t\fP virtual_address)\fC [static]\fP"

.PP
Converts a direct map region address to a physical address if it is in the higher region using the higher half direct map offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The physical address in the direct map region 
.RE
.PP
\fBReturns\fP
.RS 4
The physical address 
.RE
.PP

.PP
Definition at line \fB945\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
945                                                                      {
946 
947     if(virtual_address > HIGHER_HALF_DIRECT_MAP)
948         return (void*) (virtual_address \- HIGHER_HALF_DIRECT_MAP);
949 
950     // Must be in the lower half
951     return (void*) virtual_address;
952 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_DIRECT_MAP\fP\&.
.PP
Referenced by \fBreserve_kernel_regions()\fP\&.
.SS "\fBphysical_address_t\fP * PhysicalMemoryManager::get_physical_address (\fBvirtual_address_t\fP * virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Gets the physical address from a virtual address (if it exists) 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to get the physical address from 
.br
\fIpml4_root\fP The address of the root pml to use 
.RE
.PP
\fBReturns\fP
.RS 4
The physical address or nullptr if it does not exist 
.RE
.PP

.PP
Definition at line \fB829\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
829                                                                                                                        {
830 
831     pte_t* entry = get_entry(virtual_address, (pml_t*) pml4_root);
832 
833     // Cant get a physical address if its inst free
834     if(!entry\->present)
835         return nullptr;
836 
837     return (physical_address_t*) physical_address_of_entry(entry);
838 }
.fi

.PP
Referenced by \fBis_mapped()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::identity_map (\fBphysical_address_t\fP * physical_address, \fBsize_t\fP flags)"

.PP
Maps a physical address to its virtual address counter-part\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB582\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
582                                                                                            {
583 
584     // Map the physical address to its virtual address counter\-part
585     map(physical_address, physical_address, flags);
586 }
.fi

.PP
References \fBmap()\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::in_higher_region (\fBuintptr_t\fP virtual_address)\fC [static]\fP"

.PP
Checks if a virtual address is in the higher region\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is in the higher region, false otherwise 
.RE
.PP

.PP
Definition at line \fB961\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
961                                                                       {
962 
963     return virtual_address & (1l << 62);
964 }
.fi

.PP
Referenced by \fBmap()\fP, and \fBMaxOS::system::CPU::prepare_for_panic()\fP\&.
.SS "\fBbool\fP PhysicalMemoryManager::is_mapped (\fBuintptr_t\fP physical_address, \fBuintptr_t\fP virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Checks if a physical address is mapped to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to check 
.br
\fIvirtual_address\fP The virtual address to check 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
True if the physical address is mapped to the virtual address 
.RE
.PP

.PP
Definition at line \fB870\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
870                                                                                                                 {
871 
872     return get_physical_address((virtual_address_t*) virtual_address, pml4_root) ==
873            (physical_address_t*) physical_address;
874 
875 }
.fi

.PP
References \fBget_physical_address()\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags)"

.PP
Maps a physical address to a virtual address, using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIvirtual_address\fP The virtual address to map to 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB496\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
496                                                                                                                                     {
497 
498     // Map using the kernel's pml4 table
499     return map(physical_address, virtual_address, flags, m_pml4_root_address);
500 }
.fi

.PP
References \fBmap()\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags, \fBuint64_t\fP * pml4_table)"

.PP
Maps a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.br
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.br
\fIpml4_table\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB511\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
511                                                                                                                                                           {
512 
513     // If it is in a lower region then assume it is the user space
514     if(!in_higher_region((uint64_t) virtual_address))
515         flags |= USER;
516 
517     // If the entry already exists then the mapping is already done
518     pte_t* pte = get_entry(virtual_address, (pml_t*) pml4_table);
519     if(pte\->present)
520         return virtual_address;
521 
522     // Map the physical address to the virtual address
523     *pte = create_page_table_entry((uint64_t) physical_address, flags);
524 
525     // Flush the TLB (cache)
526     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
527 
528     return virtual_address;
529 }
.fi

.PP
References \fBin_higher_region()\fP, and \fBMaxOS::memory::USER\fP\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBvirtual_address_t\fP * virtual_address, \fBsize_t\fP flags)"

.PP
Allocates a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line \fB538\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
538                                                                                               {
539 
540     // Map a new physical address to the requested virtual address
541     return map(allocate_frame(), virtual_address, flags);
542 
543 }
.fi

.PP
References \fBallocate_frame()\fP, and \fBmap()\fP\&.
.PP
Referenced by \fBidentity_map()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, \fBmap()\fP, \fBmap()\fP, \fBmap_area()\fP, \fBmap_area()\fP, and \fBPhysicalMemoryManager()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::map_area (\fBphysical_address_t\fP * physical_address_start, \fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length, \fBsize_t\fP flags)"

.PP
Maps an area of physical memory to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address_start\fP The start of the physical address 
.br
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB568\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
568                                                                                                                                                       {
569 
570     // Map the required frames
571     for(size_t i = 0; i < size_to_frames(length); ++i)
572         map((virtual_address_t*) ((uintptr_t) physical_address_start + (i * PAGE_SIZE)),
573             (virtual_address_t*) ((uintptr_t) virtual_address_start + (i * PAGE_SIZE)), flags);
574 }
.fi

.PP
References \fBmap()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, and \fBsize_to_frames()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::map_area (\fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length, \fBsize_t\fP flags)"

.PP
Allocates a new area physical memory to a area virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line \fB552\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
552                                                                                                           {
553 
554     // Map the required frames
555     for(size_t i = 0; i < size_to_frames(length); ++i)
556         map((virtual_address_t*) ((uintptr_t) virtual_address_start + (i * PAGE_SIZE)), flags);
557 
558 }
.fi

.PP
References \fBmap()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, and \fBsize_to_frames()\fP\&.
.SS "\fBuint64_t\fP PhysicalMemoryManager::memory_size () const"

.PP
Gets total the memory size available for use (allocated or not) 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line \fB746\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
746                                                   {
747 
748     return m_memory_size;
749 }
.fi

.SS "\fBuint64_t\fP PhysicalMemoryManager::memory_used () const"

.PP
Gets the memory currently used\&. 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line \fB756\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
756                                                   {
757 
758     return m_used_frames * PAGE_SIZE;
759 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP\&.
.PP
Referenced by \fBPhysicalMemoryManager()\fP\&.
.SS "\fBuint64_t\fP * PhysicalMemoryManager::pml4_root_address ()"

.PP
Gets the pml4 root address for the kernel\&. 
.PP
\fBReturns\fP
.RS 4
The pml4 root address 
.RE
.PP

.PP
Definition at line \fB736\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
736                                                    {
737 
738     return m_pml4_root_address;
739 }
.fi

.SS "\fBvoid\fP PhysicalMemoryManager::reserve (\fBuint64_t\fP address)"

.PP
Reserves a physical address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to reserve 
.RE
.PP

.PP
Definition at line \fB777\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
777                                                     {
778 
779     reserve(address, PAGE_SIZE);
780 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP, and \fBreserve()\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, \fBreserve()\fP, and \fBreserve_kernel_regions()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::reserve (\fBuint64_t\fP address, \fBsize_t\fP size, \fBconst\fP \fBchar\fP * type = \fC'Unknown'\fP)"

.PP
Reserves an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The start of the area 
.br
\fIsize\fP The size of the area 
.br
\fItype\fP The name for the region being reserved (not required, logging purposes only, defaults to unkown) 
.RE
.PP

.PP
Definition at line \fB789\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
789                                                                                    {
790 
791     // Cant reserve virtual addresses (ensure the address is physical)
792     ASSERT(address < m_memory_size, "Attempt to reserve address bigger then the memory can contain: 0x%x\\n", address);
793     ASSERT(address + size < m_memory_size, "Attempt to reserve region bigger then the memory can contain: 0x%x\-0x%x\\n",
794            address, address + size);
795 
796     // Wait to be able to reserve
797     m_lock\&.lock();
798 
799     // Align to a page, if rounding down need to correct the range
800     size_t aligned_address = align_direct_to_page(address);
801     if(aligned_address < address)
802         size += address \- aligned_address;
803 
804     // Convert in to amount of pages
805     size = align_up_to_page(size, PAGE_SIZE);
806     size_t page_count = size / PAGE_SIZE;
807     uint64_t frame_index = aligned_address / PAGE_SIZE;
808 
809     // Mark all as used
810     for(size_t i = 0; i < page_count; ++i)
811         m_bit_map[(frame_index + i) / ROW_BITS] |= (1ULL << ((frame_index + i) % ROW_BITS));
812 
813     // Update the used frames
814     m_used_frames += page_count;
815 
816     // Clear the lock
817     m_lock\&.unlock();
818     Logger::DEBUG() << "Reserved Address for " << type << ": 0x" << aligned_address << " \- 0x" << aligned_address + size
819                     << " (length of 0x" << size << ")\\n";
820 }
.fi

.PP
References \fBalign_direct_to_page()\fP, \fBalign_up_to_page()\fP, \fBASSERT\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBMaxOS::memory::ROW_BITS\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::reserve_kernel_regions (\fBsystem::Multiboot\fP * multiboot)"

.PP
Reserves the kernel, multiboot modules, mmap regions and higher half mapping regions in the physical memory manager so that those pages arent overwritten later\&. 
.PP
\fBParameters\fP
.RS 4
\fImultiboot\fP The multiboot information structure to use for memory information such as the memory map\&. 
.RE
.PP

.PP
Definition at line \fB96\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
96                                                                        {
97 
98     // Reserve the pages used by the higher half mapping
99     reserve((uint64_t) m_mmap\->addr, m_setup_frames * PAGE_SIZE, "HHDM");
100 
101     // Reserve the area for the bitmap
102     reserve((uint64_t) from_dm_region((uint64_t) m_bit_map), m_bitmap_size / 8, "Bitmap");
103 
104     // Calculate how much space the kernel takes up
105     uint32_t kernel_entries = (m_kernel_start_page / PAGE_SIZE) + 1;
106     if((((uint32_t) (m_kernel_start_page)) % PAGE_SIZE) != 0)
107         kernel_entries += 1;
108 
109     // Reserve the kernel entries
110     reserve(0, kernel_entries * PAGE_SIZE, "Kernel");
111 
112     // Reserve the area for the mmap
113     uint64_t mem_end = m_mmap\->addr + m_mmap\->len;
114     for(multiboot_mmap_entry* entry = m_mmap_tag\->entries; (multiboot_uint8_t*) entry <
115                                                            (multiboot_uint8_t*) m_mmap_tag +
116                                                            m_mmap_tag\->size; entry = (multiboot_mmap_entry*) (
117     (unsigned long) entry + m_mmap_tag\->entry_size)) {
118 
119         // Dont reserve free regions
120         if(entry\->type <= MULTIBOOT_MEMORY_AVAILABLE)
121             continue;
122 
123         // Don't reserve the memory being managed by pmm
124         if(entry\->addr >= mem_end)
125             continue;
126 
127         reserve(entry\->addr, entry\->len, "MMap");
128     }
129 
130     // Reserve the area for each multiboot module
131     for(multiboot_tag* tag = multiboot\->start_tag();
132         tag\->type != MULTIBOOT_TAG_TYPE_END; tag = (struct multiboot_tag*) ((multiboot_uint8_t*) tag +
133                                                                             ((tag\->size + 7) & ~7))) {
134 
135         if(tag\->type != MULTIBOOT_TAG_TYPE_MODULE)
136             continue;
137 
138         // Reserve the module's address
139         auto* module = (struct multiboot_tag_module*) tag;
140         reserve(module\->mod_start, module\->mod_end \- module\->mod_start, "Module");
141     }
142 
143     // Reserve all the tags
144     auto end_tag = (multiboot_tag*) to_higher_region(multiboot\->end_address);
145     auto start_tag = (uint64_t) to_lower_region((uintptr_t) multiboot\->start_tag());
146     size_t tags_size = multiboot\->end_address \- start_tag + ((end_tag\->size + 7) & ~7);
147     reserve(start_tag, tags_size, "Tags");
148 }
.fi

.PP
References \fBmultiboot_mmap_entry::addr\fP, \fBmultiboot_tag_mmap::entries\fP, \fBmultiboot_tag_mmap::entry_size\fP, \fBfrom_dm_region()\fP, \fBmultiboot_mmap_entry::len\fP, \fBMaxOS::memory::PAGE_SIZE\fP, \fBreserve()\fP, \fBmultiboot_tag_mmap::size\fP, \fBto_higher_region()\fP, and \fBto_lower_region()\fP\&.
.PP
Referenced by \fBPhysicalMemoryManager()\fP\&.
.SS "\fBsize_t\fP PhysicalMemoryManager::size_to_frames (\fBsize_t\fP size)\fC [static]\fP"

.PP
Converts a size to the number of frames\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The number of frames 
.RE
.PP

.PP
Definition at line \fB156\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
156                                                         {
157 
158     return align_to_page(size) / PAGE_SIZE;
159 }
.fi

.PP
References \fBalign_to_page()\fP, and \fBMaxOS::memory::PAGE_SIZE\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBallocate_area()\fP, \fBfree_area()\fP, \fBMaxOS::memory::VirtualMemoryManager::load_physical_into_address_space()\fP, \fBmap_area()\fP, \fBmap_area()\fP, \fBunmap_area()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, and \fBMaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_dm_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to a direct map region address if it is in the lower region using the higher half direct map offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The direct map region address 
.RE
.PP

.PP
Definition at line \fB930\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
930                                                                     {
931 
932     if(physical_address < HIGHER_HALF_OFFSET)
933         return (void*) (physical_address + HIGHER_HALF_DIRECT_MAP);
934 
935     // Must be in the higher half
936     return (void*) physical_address;
937 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_DIRECT_MAP\fP, and \fBMaxOS::memory::HIGHER_HALF_OFFSET\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::load_multiboot_elfs()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_higher_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to a higher region address if it is in the lower region using the higher half kernel offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The higher region address 
.RE
.PP

.PP
Definition at line \fB883\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
883                                                                         {
884 
885     // If it's in the lower half then add the offset
886     if(physical_address < HIGHER_HALF_KERNEL_OFFSET)
887         return (void*) (physical_address + HIGHER_HALF_KERNEL_OFFSET);
888 
889     // Must be in the higher half
890     return (void*) physical_address;
891 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_KERNEL_OFFSET\fP\&.
.PP
Referenced by \fBreserve_kernel_regions()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_io_region (\fBuintptr_t\fP physical_address)\fC [static]\fP"

.PP
Converts a physical address to an IO region address if it is in the lower region using the higher half memory offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address 
.RE
.PP
\fBReturns\fP
.RS 4
The IO region address 
.RE
.PP

.PP
Definition at line \fB915\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
915                                                                     {
916 
917     if(physical_address < HIGHER_HALF_MEM_OFFSET)
918         return (void*) (physical_address + HIGHER_HALF_MEM_OFFSET);
919 
920     // Must be in the higher half
921     return (void*) physical_address;
922 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_MEM_OFFSET\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, and \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP\&.
.SS "\fBvoid\fP * PhysicalMemoryManager::to_lower_region (\fBuintptr_t\fP virtual_address)\fC [static]\fP"

.PP
Converts a virtual address to a lower region address if it is in the higher region using the higher half kernel offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.RE
.PP
\fBReturns\fP
.RS 4
The lower region address 
.RE
.PP

.PP
Definition at line \fB899\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
899                                                                       {
900 
901     // If it's in the lower half then add the offset
902     if(virtual_address > HIGHER_HALF_KERNEL_OFFSET)
903         return (void*) (virtual_address \- HIGHER_HALF_KERNEL_OFFSET);
904 
905     // Must be in the lower half
906     return (void*) virtual_address;
907 }
.fi

.PP
References \fBMaxOS::memory::HIGHER_HALF_KERNEL_OFFSET\fP\&.
.PP
Referenced by \fBMaxOS::system::CPU::init_cores()\fP, \fBMaxOS::system::Multiboot::Multiboot()\fP, \fBreserve_kernel_regions()\fP, and \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address)"

.PP
Unmaps a virtual address using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.RE
.PP

.PP
Definition at line \fB593\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
593                                                                     {
594 
595     // Pass the kernel's pml4 table
596     unmap(virtual_address, m_pml4_root_address);
597 }
.fi

.PP
References \fBunmap()\fP\&.
.PP
Referenced by \fBunmap()\fP, and \fBunmap_area()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address, \fBuint64_t\fP * pml4_root)"

.PP
Unmaps a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP

.PP
Definition at line \fB605\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
605                                                                                          {
606 
607     // Get the entry
608     pte_t* pte = get_entry(virtual_address, (pml_t*) pml4_root);
609 
610     // Make sure the address is actually mapped
611     if(!pte\->present)
612         return;
613 
614     // Unmap the entry
615     pte\->present = false;
616 
617     // Flush the TLB (cache)
618     asm volatile("invlpg (%0)"::"r" (virtual_address) : "memory");
619 }
.fi

.SS "\fBvoid\fP PhysicalMemoryManager::unmap_area (\fBvirtual_address_t\fP * virtual_address_start, \fBsize_t\fP length)"

.PP
Unmaps an area of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the area 
.br
\fIlength\fP The length of the area 
.RE
.PP

.PP
Definition at line \fB627\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
627                                                                                               {
628 
629     // Unmap the required frames
630     for(size_t i = 0; i < size_to_frames(length); ++i)
631         unmap((virtual_address_t*) ((uintptr_t) virtual_address_start + (i * PAGE_SIZE)));
632 }
.fi

.PP
References \fBMaxOS::memory::PAGE_SIZE\fP, \fBsize_to_frames()\fP, and \fBunmap()\fP\&.
.SS "\fBvoid\fP PhysicalMemoryManager::unmap_lower_kernel ()\fC [static]\fP"

.PP
Unmaps the kernel physical memory from the lower half that was set up during the kernel boot\&. 
.PP
Definition at line \fB970\fP of file \fBphysical\&.cpp\fP\&..PP
.nf
970                                                {
971 
972     p4_table[0] = 0;
973 }
.fi

.PP
References \fBp4_table\fP\&.
.PP
Referenced by \fBPhysicalMemoryManager()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBPhysicalMemoryManager\fP* MaxOS::memory::PhysicalMemoryManager::s_current_manager = nullptr\fC [inline]\fP, \fC [static]\fP"

.PP
The current physical memory manager in use\&. 
.PP
\fBTodo\fP
.RS 4
Make private with getter, maybe make mapping static? 
.RE
.PP

.PP
Definition at line \fB185\fP of file \fBphysical\&.h\fP\&.
.PP
Referenced by \fBMaxOS::memory::VirtualMemoryManager::allocate()\fP, \fBMaxOS::processes::SharedMemory::close()\fP, \fBMaxOS::system::CPU::init_cores()\fP, \fBMaxOS::hardwarecommunication::IOAPIC::IOAPIC()\fP, \fBMaxOS::memory::VirtualMemoryManager::load_physical_into_address_space()\fP, \fBMaxOS::hardwarecommunication::LocalAPIC::LocalAPIC()\fP, \fBPhysicalMemoryManager()\fP, \fBMaxOS::processes::SharedMemory::SharedMemory()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP, \fBMaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\fP, \fBMaxOS::processes::Process::~Process()\fP, and \fBMaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

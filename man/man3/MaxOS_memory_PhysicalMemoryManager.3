.TH "MaxOS::memory::PhysicalMemoryManager" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::memory::PhysicalMemoryManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <physical\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPhysicalMemoryManager\fP (unsigned long \fBreserved\fP, \fBsystem::Multiboot\fP *multiboot, uint64_t pml4_root[512])"
.br
.ti -1c
.RI "\fB~PhysicalMemoryManager\fP ()"
.br
.ti -1c
.RI "uint64_t \fBget_memory_size\fP ()"
.br
.RI "Gets total the memory size available for use (allocated or not) "
.ti -1c
.RI "uint64_t \fBget_memory_used\fP ()"
.br
.RI "Gets the memory currently used\&. "
.ti -1c
.RI "uint64_t * \fBget_pml4_root_address\fP ()"
.br
.RI "Gets the pml4 root address for the kernel\&. "
.ti -1c
.RI "void * \fBallocate_frame\fP ()"
.br
.RI "Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. "
.ti -1c
.RI "void \fBfree_frame\fP (void *\fBaddress\fP)"
.br
.RI "Frees a frame in the bit map\&. "
.ti -1c
.RI "void * \fBallocate_area\fP (uint64_t start_address, size_t \fBsize\fP)"
.br
.RI "Allocate an area of physical memory (ie reserve it) "
.ti -1c
.RI "void \fBfree_area\fP (uint64_t start_address, size_t \fBsize\fP)"
.br
.RI "Frees an area of physical memory\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP)"
.br
.RI "Allocates a physical address to a virtual address\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *physical, \fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP)"
.br
.RI "Maps a physical address to a virtual address, using the kernel's pml4 table\&. "
.ti -1c
.RI "\fBvirtual_address_t\fP * \fBmap\fP (\fBphysical_address_t\fP *physical, \fBvirtual_address_t\fP *virtual_address, size_t \fBflags\fP, uint64_t *pml4_root)"
.br
.RI "Maps a physical address to a virtual address\&. "
.ti -1c
.RI "void \fBmap_area\fP (\fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP, size_t \fBflags\fP)"
.br
.RI "Allocates a new area physical memory to a area virtual address\&. "
.ti -1c
.RI "void \fBmap_area\fP (\fBphysical_address_t\fP *physical_address_start, \fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP, size_t \fBflags\fP)"
.br
.RI "Maps an area of physical memory to a virtual address\&. "
.ti -1c
.RI "void \fBidentity_map\fP (\fBphysical_address_t\fP *\fBphysical_address\fP, size_t \fBflags\fP)"
.br
.RI "Maps a physical address to its virtual address counter-part\&. "
.ti -1c
.RI "void \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address)"
.br
.RI "Unmaps a virtual address using the kernel's pml4 table\&. "
.ti -1c
.RI "void \fBunmap\fP (\fBvirtual_address_t\fP *virtual_address, uint64_t *pml4_root)"
.br
.RI "Unmaps a virtual address\&. "
.ti -1c
.RI "void \fBunmap_area\fP (\fBvirtual_address_t\fP *virtual_address_start, size_t \fBlength\fP)"
.br
.RI "Unmaps an area of virtual memory\&. "
.ti -1c
.RI "bool \fBis_anonymous_available\fP (size_t \fBsize\fP)"
.br
.RI "Checks if a physical address is reserved by multiboot mmap\&. "
.ti -1c
.RI "void \fBclean_page_table\fP (uint64_t *table)"
.br
.RI "Cleans a page table (fills it with 0 or null entries) "
.ti -1c
.RI "void \fBreserve\fP (uint64_t \fBaddress\fP)"
.br
.RI "Reserves a physical address\&. "
.ti -1c
.RI "void \fBreserve\fP (uint64_t \fBaddress\fP, size_t \fBsize\fP)"
.br
.RI "Reserves an area of physical memory\&. "
.ti -1c
.RI "\fBphysical_address_t\fP * \fBget_physical_address\fP (\fBvirtual_address_t\fP *virtual_address, uint64_t *pml4_root)"
.br
.RI "Gets the physical address from a virtual address (if it exists) "
.ti -1c
.RI "bool \fBis_mapped\fP (uintptr_t \fBphysical_address\fP, uintptr_t virtual_address, uint64_t *pml4_root)"
.br
.RI "Checks if a physical address is mapped to a virtual address\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static size_t \fBsize_to_frames\fP (size_t \fBsize\fP)"
.br
.RI "Converts a size to the number of frames\&. "
.ti -1c
.RI "static size_t \fBalign_to_page\fP (size_t \fBsize\fP)"
.br
.RI "Aligns a size to the page size\&. "
.ti -1c
.RI "static size_t \fBalign_direct_to_page\fP (size_t \fBsize\fP)"
.br
.RI "Aligns a address to the page size\&. "
.ti -1c
.RI "static size_t \fBalign_up_to_page\fP (size_t \fBsize\fP, size_t \fBs_page_size\fP)"
.br
.RI "Aligns a size up to the page size\&. "
.ti -1c
.RI "static bool \fBcheck_aligned\fP (size_t \fBsize\fP)"
.br
.RI "Checks if an address is aligned\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const uint32_t \fBs_page_size\fP = { 0x1000 }"
.br
.ti -1c
.RI "static \fBPhysicalMemoryManager\fP * \fBs_current_manager\fP = nullptr"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 64 of file physical\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MaxOS::memory::PhysicalMemoryManager::PhysicalMemoryManager (unsigned long reserved, \fBsystem::Multiboot\fP * multiboot, uint64_t pml4_root[512])"

.PP
Definition at line 22 of file physical\&.cpp\&.
.PP
.nf
23 : m_kernel_end((uint64_t)&_kernel_physical_end),
24   m_multiboot(multiboot),
25   m_pml4_root_address(pml4_root),
26   m_pml4_root((pte_t *)pml4_root)
27 {
28 
29   // Clear the spinlock
30   m_lock = Spinlock();
31   m_lock\&.unlock();
32 
33   // Set the current manager
34   s_current_manager = this;
35 
36   // SEE boot\&.s FOR SETUP OF PAGING
37   m_pml4_root = (pte_t *)pml4_root;
38   m_pml4_root_address = pml4_root;
39   _kprintf("PML4: 0x%x\n", m_pml4_root);
40 
41   // Store the information about the bitmap
42   m_memory_size = (m_multiboot->get_basic_meminfo()->mem_upper + 1024) * 1024;
43   m_bitmap_size = m_memory_size / s_page_size + 1;
44   m_total_entries = m_bitmap_size / ROW_BITS + 1;
45   _kprintf("Mem Info: size = %dmb, bitmap size = %d, total entries = %d, page size = %db\n", ((m_memory_size / 1000) * 1024) / 1024 / 1024, m_bitmap_size, m_total_entries, s_page_size);
46 
47   // Get the mmap that stores the memory to use
48   m_mmap_tag = m_multiboot->get_mmap();
49   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
50 
51     // Skip if the region is not free or there is not enough space
52     if (entry->type != MULTIBOOT_MEMORY_AVAILABLE || (entry->addr + entry->len) < reserved)
53       continue;
54 
55     // We want the last entry
56     m_mmap = entry;
57   }
58   _kprintf("Mmap in use: 0x%x - 0x%x\n", m_mmap->addr, m_mmap->addr + m_mmap->len);
59 
60   // Kernel Memory (anonymous memory to the next page)
61   _kprintf("Kernel Memory: kernel_end = 0x%x, kernel_size = 0x%x, kernel_physical_end = 0x%x\n", &_kernel_end, &_kernel_size, &_kernel_physical_end);
62   m_anonymous_memory_physical_address = (uint64_t)align_up_to_page((size_t)&_kernel_physical_end + s_page_size, s_page_size);
63   m_anonymous_memory_virtual_address  = (uint64_t)align_up_to_page((size_t)&_kernel_end + s_page_size, s_page_size);
64   _kprintf("Anonymous Memory: physical = 0x%x, virtual = 0x%x\n", m_anonymous_memory_physical_address, m_anonymous_memory_virtual_address);
65 
66   // Map the physical memory into the virtual memory
67   uint64_t physical_address = 0;
68   uint64_t virtual_address = MemoryManager::s_hh_direct_map_offset;
69   uint64_t mem_end = m_mmap->addr + m_mmap->len;
70 
71   while (physical_address < mem_end) {
72     map((physical_address_t *)physical_address, (virtual_address_t *)virtual_address, Present | Write);
73     physical_address += s_page_size;
74     virtual_address += s_page_size;
75   }
76   _kprintf("Mapped: physical = 0x%x-0x%x, virtual = 0x%x-0x%x\n", 0, physical_address, MemoryManager::s_hh_direct_map_offset, virtual_address); // TODO: FAILS WHEN TRYING WITH LIKE 2Gb Mem
77 
78   // Calculate the bitmap address
79   m_anonymous_memory_physical_address += s_page_size;
80   m_bit_map = get_bitmap_address();
81 
82   // Clear the bitmap
83   for (uint32_t i = 0; i < m_total_entries; ++i)
84     m_bit_map[i] = 0;
85 
86   // Reserve the area for the bitmap
87   _kprintf("Bitmap: location = 0x%x - 0x%x (range of 0x%x)\n", m_bit_map, m_bit_map + m_bitmap_size / 8, m_bitmap_size / 8);
88   reserve((uint64_t)MemoryManager::from_dm_region((uint64_t)m_bit_map), m_bitmap_size / 8 );
89 
90 
91   // Calculate how much space the kernel takes up
92   uint32_t kernel_entries = (m_anonymous_memory_physical_address / s_page_size) + 1;
93   if ((((uint32_t)(m_anonymous_memory_physical_address)) % s_page_size) != 0) {
94     // If the kernel takes up more then a whole page(s)
95     kernel_entries += 1;
96   }
97 
98   // Reserve the kernel in the bitmap
99   _kprintf("Kernel: location = 0x%x - 0x%x (range of 0x%x)\n", 0, m_anonymous_memory_physical_address, kernel_entries * s_page_size);
100   reserve(0, kernel_entries * s_page_size);
101 
102 
103   // Reserve the area for the mmap
104   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
105 
106     // Check if the entry is to be mapped
107     if (entry->type <= MULTIBOOT_MEMORY_AVAILABLE)
108       continue;
109 
110     // Where the free mem starts
111     if(entry->addr >= mem_end)
112       continue;
113 
114     // Reserve the area
115     reserve(entry->addr, entry->len);
116   }
117 
118   // Reserve the area for each multiboot module
119   for(multiboot_tag* tag = multiboot -> get_start_tag(); tag->type != MULTIBOOT_TAG_TYPE_END; tag = (struct multiboot_tag *) ((multiboot_uint8_t *) tag + ((tag->size + 7) & ~7))) {
120 
121     // Check if the tag is a module
122     if(tag -> type != MULTIBOOT_TAG_TYPE_MODULE)
123       continue;
124 
125     // Get the module tag
126     struct multiboot_tag_module* module = (struct multiboot_tag_module*)tag;
127 
128     // Reserve the address
129     reserve(module->mod_start, module->mod_end - module->mod_start);
130   }
131 
132   // Initialisation Done
133   m_initialized = true;
134 }
.fi
.PP
References _kernel_end, _kernel_physical_end, _kernel_size, _kprintf, multiboot_mmap_entry::addr, align_up_to_page(), multiboot_tag_mmap::entries, multiboot_tag_mmap::entry_size, MaxOS::memory::MemoryManager::from_dm_region(), MaxOS::system::Multiboot::get_basic_meminfo(), MaxOS::system::Multiboot::get_mmap(), MaxOS::drivers::peripherals::i, multiboot_mmap_entry::len, map(), multiboot_tag_basic_meminfo::mem_upper, multiboot_tag_module::mod_end, multiboot_tag_module::mod_start, MULTIBOOT_MEMORY_AVAILABLE, MULTIBOOT_TAG_TYPE_END, MULTIBOOT_TAG_TYPE_MODULE, physical_address, MaxOS::memory::Present, reserve(), reserved, s_current_manager, MaxOS::memory::MemoryManager::s_hh_direct_map_offset, s_page_size, multiboot_tag_mmap::size, type, MaxOS::common::Spinlock::unlock(), and MaxOS::memory::Write\&.
.SS "PhysicalMemoryManager::~PhysicalMemoryManager ()"

.PP
Definition at line 136 of file physical\&.cpp\&.
.PP
.nf
136                                               {
137 
138 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "size_t PhysicalMemoryManager::align_direct_to_page (size_t size)\fC [static]\fP"

.PP
Aligns a address to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned address 
.RE
.PP

.PP
Definition at line 854 of file physical\&.cpp\&.
.PP
.nf
854                                                               {
855   return (size & (~(s_page_size - 1)));
856 }
.fi
.PP
References s_page_size, and size\&.
.PP
Referenced by reserve()\&.
.SS "size_t PhysicalMemoryManager::align_to_page (size_t size)\fC [static]\fP"

.PP
Aligns a size to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line 154 of file physical\&.cpp\&.
.PP
.nf
154                                                        {
155   return ((size + s_page_size - 1) /s_page_size) * s_page_size;
156 }
.fi
.PP
References s_page_size, and size\&.
.PP
Referenced by size_to_frames(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "size_t PhysicalMemoryManager::align_up_to_page (size_t size, size_t page_size)\fC [static]\fP"

.PP
Aligns a size up to the page size\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to align 
.br
\fIpage_size\fP The page size to align to 
.RE
.PP
\fBReturns\fP
.RS 4
The aligned size 
.RE
.PP

.PP
Definition at line 164 of file physical\&.cpp\&.
.PP
.nf
164                                                                             {
165   return (size + page_size - 1) & ~(page_size - 1);
166 }
.fi
.PP
References size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), PhysicalMemoryManager(), and reserve()\&.
.SS "void * PhysicalMemoryManager::allocate_area (uint64_t start_address, size_t size)"

.PP
Allocate an area of physical memory (ie reserve it) 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the start of the block (physical address) 
.RE
.PP

.PP
Definition at line 278 of file physical\&.cpp\&.
.PP
.nf
278                                                                               {
279 
280   // Wait to be able to allocate
281   m_lock\&.lock();
282 
283   // Check how many frames are needed
284   size_t frame_count = size_to_frames(size);
285 
286   // Store the information about the frames needed to be allocated for this size
287   uint16_t start_row = 0;
288   uint16_t start_column = 0;
289   size_t adjacent_frames = 0;
290 
291   // Loop through the bitmap
292   for (uint16_t row = 0; row < m_total_entries; ++row) {
293 
294     // If the row is full continue
295     if(m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
296       continue;
297 
298     for (uint16_t column = 0; column < ROW_BITS; ++column) {
299 
300       // Prevent out-of-bounds shifts if column exceeds the bit-width of uint64_t
301       if (column >= ROW_BITS)
302         break;
303 
304       // If this bit is not free, reset the adjacent frames
305       if (m_bit_map[row] & (1ULL << column)) {
306         adjacent_frames = 0;
307         continue;
308       }
309 
310       // Store the start of the area if it is not already stored
311       if(adjacent_frames == 0){
312         start_row = row;
313         start_column = column;
314       }
315 
316       // Increment the adjacent frames
317       adjacent_frames++;
318 
319       // If enough frames are found we can allocate the area
320       if(adjacent_frames == frame_count){
321 
322         // Mark the frames as used
323         m_used_frames += frame_count;
324         for (uint16_t i = 0; i < frame_count; ++i) {
325 
326           // Get the location of the bit
327           uint16_t index = start_row + (start_column + i) / ROW_BITS;
328           uint16_t bit = (start_column + i) % ROW_BITS;
329 
330           // Skip if index exceeds bounds
331           if (index >= m_total_entries || bit >= ROW_BITS) {
332             ASSERT(false, "Index out of bounds\n")
333           }
334 
335           m_bit_map[index] |= (1ULL << bit); // Mark the bit as used
336         }
337 
338         // Clear the lock
339         m_lock\&.unlock();
340 
341         // Return the address
342         return (void*)(start_address + (start_row * ROW_BITS + start_column) * s_page_size);
343       }
344     }
345   }
346 
347   // Error cant allocate that much
348   m_lock\&.unlock();
349   ASSERT(false, "Cannot allocate that much memory\n")
350   return nullptr;
351 }
.fi
.PP
References ASSERT, MaxOS::drivers::peripherals::i, MaxOS::common::Spinlock::lock(), s_page_size, size, size_to_frames(), and MaxOS::common::Spinlock::unlock()\&.
.SS "void * PhysicalMemoryManager::allocate_frame ()"

.PP
Allocates a physical page of memory, if the PMM is not initalise it will use the anon memory instead of the bitmap\&. 
.PP
\fBReturns\fP
.RS 4
The physical address of the page 
.RE
.PP

.PP
Definition at line 181 of file physical\&.cpp\&.
.PP
.nf
181                                             {
182 
183   // Wait for the lock
184   m_lock\&.lock();
185 
186   // Check if the pmm is initialized
187   if(!m_initialized){
188 
189     // Find the first free frame
190     while ((!is_anonymous_available(m_anonymous_memory_physical_address)) && (m_anonymous_memory_physical_address < m_memory_size)) {
191       m_anonymous_memory_physical_address += s_page_size;
192       m_anonymous_memory_virtual_address += s_page_size;
193     }
194 
195     // Mark frame as used
196     m_anonymous_memory_physical_address += s_page_size;
197     m_anonymous_memory_virtual_address += s_page_size;
198 
199     // Clear the lock
200     m_lock\&.unlock();
201 
202     // Return the address
203     return (void*)(m_anonymous_memory_physical_address - s_page_size);
204 
205   }
206 
207   // Check if there are enough frames
208   ASSERT(m_used_frames < m_bitmap_size, "No more frames available\n")
209 
210   // Loop through the bitmap
211   for (uint16_t row = 0; row < m_total_entries; ++row) {
212 
213     // If the row is full continue
214     if(m_bit_map[row] == 0xFFFFFFFFFFFFFFF)
215       continue;
216 
217     for (uint16_t column = 0; column < ROW_BITS; ++column) {
218 
219       // Prevent out-of-bounds shifts if column exceeds the bit-width of uint64_t
220       if (column >= ROW_BITS)
221         break;
222 
223       // Check if the bitmap is free
224       if (m_bit_map[row] & (1ULL << column))
225         continue;
226 
227 
228       // Mark the frame as used
229       m_bit_map[row] |= (1ULL << column);
230       m_used_frames++;
231 
232       // Return the address
233       uint64_t frame_address = (row * ROW_BITS) + column;
234       frame_address *= s_page_size;
235 
236 
237       // Clear the lock
238       m_lock\&.unlock();
239 
240       // Return the address
241       return (void*)(frame_address);
242     }
243   }
244 
245   // Error frame not found
246   ASSERT(false, "Frame not found\n")
247   m_lock\&.unlock();
248   return nullptr;
249 
250 }
.fi
.PP
References ASSERT, is_anonymous_available(), MaxOS::common::Spinlock::lock(), s_page_size, and MaxOS::common::Spinlock::unlock()\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), map(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "bool PhysicalMemoryManager::check_aligned (size_t size)\fC [static]\fP"

.PP
Checks if an address is aligned\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is aligned 
.RE
.PP

.PP
Definition at line 173 of file physical\&.cpp\&.
.PP
.nf
173                                                     {
174     return (size % s_page_size) == 0;
175 }
.fi
.PP
References s_page_size, and size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate()\&.
.SS "void PhysicalMemoryManager::clean_page_table (uint64_t * table)"

.PP
Cleans a page table (fills it with 0 or null entries) 
.PP
\fBParameters\fP
.RS 4
\fItable\fP The table to clean 
.RE
.PP

.PP
Definition at line 718 of file physical\&.cpp\&.
.PP
.nf
718                                                             {
719   for(int i = 0; i < 512; i++){
720         table[i] = 0x00l;
721   }
722 }
.fi
.PP
References MaxOS::drivers::peripherals::i, and MaxOS::drivers::peripherals::l\&.
.SS "void PhysicalMemoryManager::free_area (uint64_t start_address, size_t size)"

.PP
Frees an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstart_address\fP The start of the block 
.br
\fIsize\fP The size to free 
.RE
.PP

.PP
Definition at line 358 of file physical\&.cpp\&.
.PP
.nf
358                                                                          {
359 
360     // Check how many frames are needed
361     size_t frame_count = size_to_frames(size);
362     uint64_t frame_address = start_address / s_page_size;
363 
364     // Check if the address is valid
365     if(frame_address >= m_bitmap_size)
366       return;
367 
368     // Wait to be able to free
369     m_lock\&.lock();
370 
371     // Mark the frames as not used
372     m_used_frames -= frame_count;
373     for (uint16_t i = 0; i < frame_count; ++i)
374       m_bit_map[(frame_address + i) / ROW_BITS] &= ~(1 << ((frame_address + i) % ROW_BITS));
375 
376 
377     // Clear the lock
378     m_lock\&.unlock();
379 }
.fi
.PP
References MaxOS::drivers::peripherals::i, MaxOS::common::Spinlock::lock(), s_page_size, size, size_to_frames(), and MaxOS::common::Spinlock::unlock()\&.
.SS "void PhysicalMemoryManager::free_frame (void * address)"

.PP
Frees a frame in the bit map\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to free 
.RE
.PP

.PP
Definition at line 256 of file physical\&.cpp\&.
.PP
.nf
256                                                     {
257 
258     // Wait for the lock
259     m_lock\&.lock();
260 
261     // Mark the frame as not used
262     m_used_frames--;
263 
264     // Set the bit to 0
265     uint64_t frame_address = (uint64_t)address / s_page_size;
266     m_bit_map[frame_address / ROW_BITS] &= ~(1 << (frame_address % ROW_BITS));
267 
268     // Clear the lock
269     m_lock\&.unlock();
270 }
.fi
.PP
References address, MaxOS::common::Spinlock::lock(), s_page_size, and MaxOS::common::Spinlock::unlock()\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\&.
.SS "uint64_t PhysicalMemoryManager::get_memory_size ()"

.PP
Gets total the memory size available for use (allocated or not) 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line 837 of file physical\&.cpp\&.
.PP
.nf
837                                                 {
838   return m_memory_size;
839 }
.fi
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "uint64_t PhysicalMemoryManager::get_memory_used ()"

.PP
Gets the memory currently used\&. 
.PP
\fBReturns\fP
.RS 4
The memory size in bytes 
.RE
.PP

.PP
Definition at line 845 of file physical\&.cpp\&.
.PP
.nf
845                                                 {
846     return m_used_frames * s_page_size;
847 }
.fi
.PP
References s_page_size\&.
.SS "\fBphysical_address_t\fP * PhysicalMemoryManager::get_physical_address (\fBvirtual_address_t\fP * virtual_address, uint64_t * pml4_root)"

.PP
Gets the physical address from a virtual address (if it exists) 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to get the physical address from 
.RE
.PP
\fBReturns\fP
.RS 4
The physical address or nullptr if it does not exist 
.RE
.PP

.PP
Definition at line 920 of file physical\&.cpp\&.
.PP
.nf
920                                                                                                                        {
921 
922 
923     // Get the indexes
924     uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
925     uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
926     uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
927     uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
928 
929     // Get the tables
930     uint64_t* pdpr_table = get_table_if_exists(pml4_root, pml4_index);
931     uint64_t* pd_table = get_table_if_exists(pdpr_table, pdpr_index);
932     uint64_t* pt_table = get_table_if_exists(pd_table, pd_index);
933 
934     // Check if the tables are present (if any are not then a pt entry will not be present)
935     if(pt_table == nullptr)
936       return nullptr;
937 
938 
939     // Check if the entry is present
940     if(!(pt_table[pt_index] & 0b1))
941       return nullptr;
942 
943     // Return the physical address
944     return (physical_address_t *)(pt_table[pt_index] & 0xFFFFFFFFFFFFF000);
945 }
.fi
.PP
References PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, and PML4_GET_INDEX\&.
.PP
Referenced by is_mapped(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "uint64_t * PhysicalMemoryManager::get_pml4_root_address ()"

.PP
Gets the pml4 root address for the kernel\&. 
.PP
\fBReturns\fP
.RS 4
The pml4 root address 
.RE
.PP

.PP
Definition at line 829 of file physical\&.cpp\&.
.PP
.nf
829                                                        {
830     return m_pml4_root_address;
831 }
.fi
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "void PhysicalMemoryManager::identity_map (\fBphysical_address_t\fP * physical_address, size_t flags)"

.PP
Maps a physical address to its virtual address counter-part\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 621 of file physical\&.cpp\&.
.PP
.nf
621                                                                                            {
622 
623   // Map the physical address to its virtual address counter-part
624   map(physical_address, physical_address, flags);
625 
626 }
.fi
.PP
References flags, map(), and physical_address\&.
.SS "bool PhysicalMemoryManager::is_anonymous_available (size_t address)"

.PP
Checks if a physical address is reserved by multiboot mmap\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the address is reserved 
.RE
.PP

.PP
Definition at line 754 of file physical\&.cpp\&.
.PP
.nf
754                                                                  {
755 
756   // Return false if the address range is entirely within or overlaps with the multiboot reserved region
757   if ((address > multiboot_tag_start && address + s_page_size < multiboot_tag_end) || (address + s_page_size > multiboot_tag_start && address < multiboot_tag_end)) {
758     return false;
759   }
760 
761   // Loop through the mmmap entries
762   for (multiboot_mmap_entry *entry = m_mmap_tag->entries; (multiboot_uint8_t *)entry < (multiboot_uint8_t *)m_mmap_tag + m_mmap_tag->size; entry = (multiboot_mmap_entry *)((unsigned long)entry + m_mmap_tag->entry_size)) {
763 
764     // If it doesn't overlap with the mmap entry
765     if ((entry -> addr + entry -> len) < (address + s_page_size))
766       continue;
767 
768     // If it is not available
769     if(entry -> type != MULTIBOOT_MEMORY_AVAILABLE)
770       continue;
771 
772     // Check if the address is overwriting with some reserved memory
773     if(m_multiboot -> is_reserved(address))
774        return false;
775 
776     // Memory is available
777     return true;
778 
779   }
780 
781   // Memory is not available
782   return false;
783 }
.fi
.PP
References address, multiboot_tag_mmap::entries, multiboot_tag_mmap::entry_size, MULTIBOOT_MEMORY_AVAILABLE, multiboot_tag_end, multiboot_tag_start, s_page_size, multiboot_tag_mmap::size, and type\&.
.PP
Referenced by allocate_frame()\&.
.SS "bool PhysicalMemoryManager::is_mapped (uintptr_t physical_address, uintptr_t virtual_address, uint64_t * pml4_root)"

.PP
Checks if a physical address is mapped to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to check 
.br
\fIvirtual_address\fP The virtual address to check 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
True if the physical address is mapped to the virtual address 
.RE
.PP

.PP
Definition at line 955 of file physical\&.cpp\&.
.PP
.nf
955                                                                                                                 {
956 
957   return get_physical_address((virtual_address_t*)virtual_address, pml4_root) == (physical_address_t*)physical_address;
958 
959 }
.fi
.PP
References get_physical_address(), and physical_address\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical_address, \fBvirtual_address_t\fP * address, size_t flags)"

.PP
Maps a physical address to a virtual address, using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address\fP The physical address to map 
.br
\fIaddress\fP The virtual address to map to 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 483 of file physical\&.cpp\&.
.PP
.nf
483                                                                                                                             {
484 
485   // Base information
486   pml_t* pml4_table = (pml_t *)m_pml4_root_address;
487   size_t base_addr = 0xFFFF000000000000;
488 
489   // Get the indexes
490   uint16_t pml4_index = PML4_GET_INDEX((uint64_t) address);
491   uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) address);
492   uint16_t pd_index   = PML2_GET_INDEX((uint64_t) address);
493   uint16_t pt_index   = PML1_GET_INDEX((uint64_t) address);
494 
495   // Get the tables
496   pml_t *pdpr_table =(pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l,510l, (uint64_t) pml4_index));
497   pml_t *pd_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l, (uint64_t) pml4_index, (uint64_t) pdpr_index));
498   pml_t *pt_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l, (uint64_t) pml4_index, (uint64_t) pdpr_index, (uint64_t) pd_index));
499 
500   // Create the tables
501   create_table(pml4_table, pdpr_table, pml4_index);
502   create_table(pdpr_table, pd_table, pdpr_index);
503   create_table(pd_table, pt_table, pd_index);
504 
505   // Get the entry
506   pte_t* pte = &pt_table -> entries[pt_index];
507 
508   // If it already exists return the address
509   if(pte -> present)
510     return address;
511 
512   // Map the physical address to the virtual address
513  *pte = create_page_table_entry((uint64_t)physical_address, flags);
514 
515 
516   // Flush the TLB
517   asm volatile("invlpg (%0)" ::"r" (address) : "memory");
518 
519   return address;
520 }
.fi
.PP
References address, entries, ENTRIES_TO_ADDRESS, flags, MaxOS::drivers::peripherals::l, physical_address, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, PML4_GET_INDEX, and present\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBphysical_address_t\fP * physical, \fBvirtual_address_t\fP * virtual_address, size_t flags, uint64_t * pml4_table)"

.PP
Maps a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical\fP The physical address 
.br
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.br
\fIpml4_table\fP The pml4 table to use 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 530 of file physical\&.cpp\&.
.PP
.nf
530                                                                                                                                                   {
531 
532     // Get the indexes
533     uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
534     uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
535     uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
536     uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
537 
538     // If it is in a lower region then assume it is the user space
539     uint8_t is_user = !(MemoryManager::in_higher_region((uint64_t)virtual_address));
540     if(is_user) {
541       // Change the flags to user
542       flags |= User;
543       is_user = User;
544 
545     }
546 
547     // Store the tables
548     uint64_t* pdpr_table = get_or_create_table(pml4_table, pml4_index, Present | Write | is_user);
549     uint64_t* pd_table = get_or_create_table(pdpr_table, pdpr_index, Present | Write | is_user);
550     uint64_t* pt_table = get_or_create_table(pd_table, pd_index, Present | Write | is_user);
551 
552     // If the page is already mapped return the address
553     if(pt_table[pt_index] & 0b1)
554       return virtual_address;
555 
556     // Map the physical address to the virtual address
557     pt_table[pt_index] = (uint64_t) physical | flags;
558 
559     // Flush the TLB
560     asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
561 
562     return virtual_address;
563 }
.fi
.PP
References flags, MaxOS::memory::MemoryManager::in_higher_region(), PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, PML4_GET_INDEX, MaxOS::memory::Present, MaxOS::memory::User, and MaxOS::memory::Write\&.
.SS "\fBvirtual_address_t\fP * PhysicalMemoryManager::map (\fBvirtual_address_t\fP * virtual_address, size_t flags)"

.PP
Allocates a physical address to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP
\fBReturns\fP
.RS 4
The virtual address 
.RE
.PP

.PP
Definition at line 571 of file physical\&.cpp\&.
.PP
.nf
571                                                                                               {
572 
573   // Create a new physical address for the frame
574   physical_address_t* physical_address = (physical_address_t *)allocate_frame();
575 
576   // Map the physical address to the virtual address
577   return map(physical_address, virtual_address, flags);
578 
579 }
.fi
.PP
References allocate_frame(), flags, and physical_address\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), identity_map(), MaxOS::memory::VirtualMemoryManager::load_physical_into_address_space(), map_area(), PhysicalMemoryManager(), and MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager()\&.
.SS "void PhysicalMemoryManager::map_area (\fBphysical_address_t\fP * physical_address_start, \fBvirtual_address_t\fP * virtual_address_start, size_t length, size_t flags)"

.PP
Maps an area of physical memory to a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIphysical_address_start\fP The start of the physical address 
.br
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 605 of file physical\&.cpp\&.
.PP
.nf
605                                                                                                                                                       {
606 
607   // Get the size of the area
608   size_t size = size_to_frames(length);
609 
610   // Map the required frames
611   for (size_t i = 0; i < size; ++i)
612     map(physical_address_start + (i * s_page_size), virtual_address_start + (i * s_page_size), flags);
613 
614 }
.fi
.PP
References flags, MaxOS::drivers::peripherals::i, length, map(), s_page_size, size, and size_to_frames()\&.
.SS "void PhysicalMemoryManager::map_area (\fBvirtual_address_t\fP * virtual_address_start, size_t length, size_t flags)"

.PP
Allocates a new area physical memory to a area virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the virtual address 
.br
\fIlength\fP The length of the area 
.br
\fIflags\fP The flags to set the mapping to 
.RE
.PP

.PP
Definition at line 587 of file physical\&.cpp\&.
.PP
.nf
587                                                                                                           {
588 
589     // Get the size of the area
590     size_t size = size_to_frames(length);
591 
592     // Map the required frames
593     for (size_t i = 0; i < size; ++i)
594         map(virtual_address_start + (i * s_page_size), flags);
595 
596 }
.fi
.PP
References flags, MaxOS::drivers::peripherals::i, length, map(), s_page_size, size, and size_to_frames()\&.
.SS "void PhysicalMemoryManager::reserve (uint64_t address)"

.PP
Reserves a physical address\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address to reserve 
.RE
.PP

.PP
Definition at line 862 of file physical\&.cpp\&.
.PP
.nf
862                                                     {
863 
864 
865   // If the address is not part of physical memory then return
866   if(address >= m_memory_size)
867     return;
868 
869   // Get the address to a page
870   address = align_direct_to_page(address);
871 
872   // Set the bit to 1 in the bitmap
873   m_bit_map[address / ROW_BITS] |= (1 << (address % ROW_BITS));
874 
875 
876   _kprintf("Reserved Address: 0x%x\n", address);
877 
878 }
.fi
.PP
References _kprintf, address, and align_direct_to_page()\&.
.PP
Referenced by PhysicalMemoryManager()\&.
.SS "void PhysicalMemoryManager::reserve (uint64_t address, size_t size)"

.PP
Reserves an area of physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The start of the area 
.br
\fIsize\fP The size of the area 
.RE
.PP

.PP
Definition at line 885 of file physical\&.cpp\&.
.PP
.nf
885                                                                  {
886 
887   if(address >= m_memory_size)
888     return;
889 
890   // Wait to be able to reserve
891   m_lock\&.lock();
892 
893   // Align address and size to page boundaries
894   address = align_direct_to_page(address);
895   size = align_up_to_page(size, s_page_size);
896 
897   // Calculate how many pages need to be reserved
898   size_t page_count = size / s_page_size;
899   // Convert the starting address to a frame index
900   uint64_t frame_index = address / s_page_size;
901 
902   for (size_t i = 0; i < page_count; ++i) {
903     m_bit_map[(frame_index + i) / ROW_BITS] |= (1ULL << ((frame_index + i) % ROW_BITS));
904   }
905 
906   // Update the used frames
907   m_used_frames += page_count;
908 
909   // Clear the lock
910   m_lock\&.unlock();
911   _kprintf("Reserved Address: 0x%x - 0x%x (length of 0x%x)\n", address, address + size, size);
912 }
.fi
.PP
References _kprintf, address, align_direct_to_page(), align_up_to_page(), MaxOS::drivers::peripherals::i, MaxOS::common::Spinlock::lock(), s_page_size, size, and MaxOS::common::Spinlock::unlock()\&.
.SS "size_t PhysicalMemoryManager::size_to_frames (size_t size)\fC [static]\fP"

.PP
Converts a size to the number of frames\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP The size to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The number of frames 
.RE
.PP

.PP
Definition at line 145 of file physical\&.cpp\&.
.PP
.nf
145                                                         {
146     return align_to_page(size) / s_page_size;
147 }
.fi
.PP
References align_to_page(), s_page_size, and size\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::allocate(), allocate_area(), MaxOS::memory::VirtualMemoryManager::free(), free_area(), MaxOS::memory::VirtualMemoryManager::load_physical_into_address_space(), map_area(), unmap_area(), and MaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\&.
.SS "void PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address)"

.PP
Unmaps a virtual address using the kernel's pml4 table\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.RE
.PP

.PP
Definition at line 632 of file physical\&.cpp\&.
.PP
.nf
632                                                                     {
633 
634   // Base information
635   pml_t* pml4_table = (pml_t *)m_pml4_root_address;
636   size_t base_addr = 0xFFFF000000000000;
637 
638   // Get the indexes
639   uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
640   uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
641   uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
642   uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
643 
644   // Get the tables
645   pml_t *pdpr_table =(pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l,510l, (uint64_t) pml4_index));
646   pml_t *pd_table = (pml_t *) (base_addr | ENTRIES_TO_ADDRESS(510l,510l, (uint64_t) pml4_index, (uint64_t) pdpr_index));
647   uint64_t* pt_table = (uint64_t *) (base_addr | ENTRIES_TO_ADDRESS(510l, (uint64_t) pml4_index, (uint64_t) pdpr_index, (uint64_t) pd_index));
648 
649   // Check if the entry is present
650   if(table_has_entry(pml4_table, pml4_index) && table_has_entry(pdpr_table, pdpr_index) && table_has_entry(pd_table, pd_index))
651     return;
652 
653   // Check if the entry isn't present
654   if(!(pt_table[pt_index] & 0b1))
655     return;
656 
657   // Unmap the entry
658   pt_table[pt_index] = 0x00l;
659 
660   // Flush the TLB
661   asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
662 }
.fi
.PP
References ENTRIES_TO_ADDRESS, MaxOS::drivers::peripherals::l, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, and PML4_GET_INDEX\&.
.PP
Referenced by MaxOS::memory::VirtualMemoryManager::free(), and unmap_area()\&.
.SS "void PhysicalMemoryManager::unmap (\fBvirtual_address_t\fP * virtual_address, uint64_t * pml4_root)"

.PP
Unmaps a virtual address\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address\fP The virtual address to unmap 
.br
\fIpml4_root\fP The pml4 table to use 
.RE
.PP

.PP
Definition at line 669 of file physical\&.cpp\&.
.PP
.nf
669                                                                                          {
670 
671     // Get the indexes
672     uint16_t pml4_index = PML4_GET_INDEX((uint64_t) virtual_address);
673     uint16_t pdpr_index = PML3_GET_INDEX((uint64_t) virtual_address);
674     uint16_t pd_index   = PML2_GET_INDEX((uint64_t) virtual_address);
675     uint16_t pt_index   = PML1_GET_INDEX((uint64_t) virtual_address);
676 
677     // Get the tables
678     uint64_t* pdpr_table = get_table_if_exists(pml4_root, pml4_index);
679     uint64_t* pd_table = get_table_if_exists(pdpr_table, pdpr_index);
680     uint64_t* pt_table = get_table_if_exists(pd_table, pd_index);
681 
682     // Check if the tables are present (if any are not then a pt entry will not be present)
683     if(pt_table == nullptr)
684       return;
685 
686 
687     // Check if the entry is present
688     if(!(pt_table[pt_index] & 0b1))
689       return;
690 
691     // Unmap the entry
692     pt_table[pt_index] = 0x00l;
693 
694     // Flush the TLB
695     asm volatile("invlpg (%0)" ::"r" (virtual_address) : "memory");
696 
697 }
.fi
.PP
References MaxOS::drivers::peripherals::l, PML1_GET_INDEX, PML2_GET_INDEX, PML3_GET_INDEX, and PML4_GET_INDEX\&.
.SS "void PhysicalMemoryManager::unmap_area (\fBvirtual_address_t\fP * virtual_address_start, size_t length)"

.PP
Unmaps an area of virtual memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirtual_address_start\fP The start of the area 
.br
\fIlength\fP The length of the area 
.RE
.PP

.PP
Definition at line 704 of file physical\&.cpp\&.
.PP
.nf
704                                                                                               {
705 
706     // Get the size of the area
707     size_t size = size_to_frames(length);
708 
709     // Unmap the required frames
710     for (size_t i = 0; i < size; ++i)
711       unmap(virtual_address_start + (i * s_page_size));
712 }
.fi
.PP
References MaxOS::drivers::peripherals::i, length, s_page_size, size, size_to_frames(), and unmap()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBPhysicalMemoryManager\fP * PhysicalMemoryManager::s_current_manager = nullptr\fC [static]\fP"

.PP
Definition at line 141 of file physical\&.h\&.
.PP
Referenced by PhysicalMemoryManager()\&.
.SS "const uint32_t MaxOS::memory::PhysicalMemoryManager::s_page_size = { 0x1000 }\fC [static]\fP"

.PP
Definition at line 107 of file physical\&.h\&.
.PP
Referenced by align_direct_to_page(), align_to_page(), MaxOS::memory::VirtualMemoryManager::allocate(), allocate_area(), allocate_frame(), check_aligned(), MaxOS::memory::VirtualMemoryManager::free(), free_area(), free_frame(), get_memory_used(), is_anonymous_available(), MaxOS::memory::VirtualMemoryManager::load_physical_into_address_space(), map_area(), MaxOS::memory::MemoryManager::MemoryManager(), PhysicalMemoryManager(), reserve(), size_to_frames(), unmap_area(), MaxOS::memory::VirtualMemoryManager::VirtualMemoryManager(), and MaxOS::memory::VirtualMemoryManager::~VirtualMemoryManager()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

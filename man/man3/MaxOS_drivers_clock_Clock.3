.TH "MaxOS::drivers::clock::Clock" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::clock::Clock \- \fBDriver\fP for the APIC clock\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <clock\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::Driver\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBClock\fP (\fBhardwarecommunication::AdvancedProgrammableInterruptController\fP *apic, \fBuint16_t\fP \fBtime_between_events\fP=10)"
.br
.RI "Constructor for the \fBClock\fP class\&. "
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP () \fBoverride\fP"
.br
.RI "Activates the clock, setting the binary coded decimal representation flag\&. "
.ti -1c
.RI "\fBvoid\fP \fBdelay\fP (\fBuint32_t\fP \fBmilliseconds\fP) \fBconst\fP"
.br
.RI "Delays the program for a specified number of milliseconds (rounded up to the nearest degree of accuracy - ensured the delay is at least the specified number of milliseconds)\&. This on the kernel level is a busy wait, for user level see the sleep function in the Thread class\&. "
.ti -1c
.RI "\fBvoid\fP \fBcalibrate\fP (\fBuint64_t\fP \fBms_per_tick\fP=1)"
.br
.RI "Configures the APIC clock to fire an interrupt at a specified interval in milliseconds\&. "
.ti -1c
.RI "\fBvoid\fP \fBsetup_apic_clock\fP (\fBhardwarecommunication::LocalAPIC\fP *local_apic) \fBconst\fP"
.br
.RI "Sets up the APIC clock to fire interrupts at the desired rate\&. "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBfinal\fP"
.br
.RI "Gets the vendor who created the device\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBfinal\fP"
.br
.RI "Gets the name of the device\&. "
.ti -1c
.RI "\fBcommon::Time\fP \fBget_time\fP ()"
.br
.RI "Reads the current time from the APIC clock (in 24hr time) "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "deactivate the driver "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP system::cpu_status_t * \fBhandle_interrupt\fP (system::cpu_status_t *status)"
.br
.RI "Handles an interrupt and returns the status\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBClock\fP * \fBactive_clock\fP ()"
.br
.RI "Gets the currently active clock\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "uint64_t \fBclock_accuracy\fP = 1"
.br
.RI "How accurate the clock is in microseconds (how often should an interrupt be raised) "
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP (\fBuint8_t\fP interrupt_number, \fBint64_t\fP \fBredirect\fP=\-1, \fBuint64_t\fP \fBredirect_index\fP=0)"
.br
.RI "Creates a new interrupt handler and registers it with the interrupt manager\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "uint8_t \fBm_interrupt_number\fP"
.br
.RI "The interrupt number this handler handles\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the APIC clock\&. 
.PP
Definition at line \fB121\fP of file \fBclock\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Clock::Clock (\fBhardwarecommunication::AdvancedProgrammableInterruptController\fP * apic, \fBuint16_t\fP time_between_events = \fC10\fP)"

.PP
Constructor for the \fBClock\fP class\&. 
.PP
\fBParameters\fP
.RS 4
\fIapic\fP The apic controller for this core 
.br
\fItime_between_events\fP The time between events in 10ths of a second 
.RE
.PP

.PP
Definition at line \fB24\fP of file \fBclock\&.cpp\fP\&..PP
.nf
25 : InterruptHandler(0x20),
26   m_apic(apic),
27   m_ticks_between_events(time_between_events)
28 {
29     Logger::INFO() << "Setting up Clock \\n";
30 }
.fi

.PP
References \fBLogger::INFO()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Clock::activate ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Activates the clock, setting the binary coded decimal representation flag\&. 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB88\fP of file \fBclock\&.cpp\fP\&..PP
.nf
88                      {
89 
90     s_active_clock = this;
91 
92     // Get the stats from the clock
93     uint8_t status = read_hardware_clock(0xB);
94 
95     // Store the clock status
96     m_24_hour_clock = status & 0x02;
97     m_binary = status & 0x04;
98 }
.fi

.SS "\fBClock\fP * Clock::active_clock ()\fC [static]\fP"

.PP
Gets the currently active clock\&. 
.PP
\fBReturns\fP
.RS 4
The clock being used by the kernel 
.RE
.PP

.PP
Definition at line \fB208\fP of file \fBclock\&.cpp\fP\&..PP
.nf
208                            {
209     return s_active_clock;
210 }
.fi

.PP
Referenced by \fBMaxOS::filesystem::format::ext2::Ext2Volume::create_inode()\fP, \fBMaxOS::system::Core::init()\fP, \fBMaxOS::system::Core::wake_up()\fP, and \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP\&.
.SS "\fBvoid\fP Clock::calibrate (\fBuint64_t\fP ms_per_tick = \fC1\fP)"

.PP
Configures the APIC clock to fire an interrupt at a specified interval in milliseconds\&. 
.PP
\fBParameters\fP
.RS 4
\fIms_per_tick\fP How many milliseconds per interrupt 
.RE
.PP

.PP
Definition at line \fB144\fP of file \fBclock\&.cpp\fP\&..PP
.nf
144                                           {
145 
146     Logger::INFO() << "Calibrating Clock \\n";
147     clock_accuracy = ms_per_tick;
148 
149     // Get the ticks per ms
150     PIT pit(m_apic);
151     m_pit_ticks_per_ms = pit\&.ticks_per_ms();
152 
153     // Calibrate the BSP apic to the desired time
154     setup_apic_clock(m_apic\->local_apic());
155 
156     Logger::DEBUG() << "Clock: Calibrated to " << ms_per_tick << "ms per kernel tick\\n";
157 }
.fi

.PP
References \fBclock_accuracy\fP, \fBLogger::DEBUG()\fP, \fBLogger::INFO()\fP, \fBMaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::local_apic()\fP, and \fBsetup_apic_clock()\fP\&.
.SS "\fBvoid\fP Clock::delay (\fBuint32_t\fP milliseconds) const"

.PP
Delays the program for a specified number of milliseconds (rounded up to the nearest degree of accuracy - ensured the delay is at least the specified number of milliseconds)\&. This on the kernel level is a busy wait, for user level see the sleep function in the Thread class\&. 
.PP
\fBSee also\fP
.RS 4
Thread::sleep
.RE
.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP How many milliseconds to delay the program for\&. 
.RE
.PP

.PP
Definition at line \fB110\fP of file \fBclock\&.cpp\fP\&..PP
.nf
110                                              {
111 
112     // Round the number of milliseconds UP to the nearest clock accuracy
113     uint64_t rounded_milliseconds = (milliseconds + clock_accuracy \- 1) / clock_accuracy;
114 
115     // Wait until the time has passed
116     uint64_t ticks_until_delay_is_over = m_ticks + rounded_milliseconds;
117     while (m_ticks < ticks_until_delay_is_over)
118         asm volatile("nop");
119 }
.fi

.PP
References \fBclock_accuracy\fP\&.
.SS "\fBstring\fP Clock::device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the name of the device\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB135\fP of file \fBclock\&.cpp\fP\&..PP
.nf
135                           {
136     return "Clock";
137 }
.fi

.SS "\fBcommon::Time\fP Clock::get_time ()"

.PP
Reads the current time from the APIC clock (in 24hr time) 
.PP
\fBReturns\fP
.RS 4
The current time in a Time struct format 
.RE
.PP

.PP
Definition at line \fB182\fP of file \fBclock\&.cpp\fP\&..PP
.nf
182                            {
183 
184     // Wait for the clock to be ready
185     while (read_hardware_clock(0xA) & 0x80)
186         asm volatile("nop");
187 
188     // Read the time from the clock
189     Time time{};
190     time\&.year = binary_representation(read_hardware_clock(0x9)) + 2000;
191     time\&.month = binary_representation(read_hardware_clock(0x8));
192     time\&.day = binary_representation(read_hardware_clock(0x7));
193     time\&.hour = binary_representation(read_hardware_clock(0x4));
194     time\&.minute = binary_representation(read_hardware_clock(0x2));
195     time\&.second = binary_representation(read_hardware_clock(0x0));
196 
197     // If the clock is using 12hr format and PM is set then add 12 to the hour
198     if (!m_24_hour_clock && (time\&.hour & 0x80) != 0)
199         time\&.hour = ((time\&.hour & 0x7F) + 12) % 24;
200 
201     return time;
202 }
.fi

.SS "\fBvoid\fP Clock::setup_apic_clock (\fBhardwarecommunication::LocalAPIC\fP * local_apic) const"

.PP
Sets up the APIC clock to fire interrupts at the desired rate\&. 
.PP
\fBParameters\fP
.RS 4
\fIlocal_apic\fP The local APIC to setup the clock on 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBclock\&.cpp\fP\&..PP
.nf
163                                                                              {
164 
165     // Configure the clock to periodic mode
166     uint32_t lvt = 0x20 | (1 << 17);
167     local_apic\->write(0x320, lvt);
168 
169     // Set the initial count
170     local_apic\->write(0x380, m_pit_ticks_per_ms * clock_accuracy);
171 
172     // Clear the interrupt mask for the clock
173     lvt &= ~(1 << 16);
174     local_apic\->write(0x320, lvt);
175 }
.fi

.PP
References \fBclock_accuracy\fP, and \fBMaxOS::hardwarecommunication::LocalAPIC::write()\fP\&.
.PP
Referenced by \fBcalibrate()\fP\&.
.SS "\fBstring\fP Clock::vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the vendor who created the device\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB126\fP of file \fBclock\&.cpp\fP\&..PP
.nf
126                           {
127     return "Generic";
128 }
.fi

.SH "Member Data Documentation"
.PP 
.SS "uint64_t MaxOS::drivers::clock::Clock::clock_accuracy = 1"

.PP
How accurate the clock is in microseconds (how often should an interrupt be raised) 
.PP
Definition at line \fB153\fP of file \fBclock\&.h\fP\&.
.PP
Referenced by \fBcalibrate()\fP, \fBdelay()\fP, and \fBsetup_apic_clock()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

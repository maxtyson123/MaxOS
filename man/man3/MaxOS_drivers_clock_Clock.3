.TH "MaxOS::drivers::clock::Clock" 3 "Mon Jan 29 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::clock::Clock \- \fBDriver\fP for the CMOS Real Time \fBClock\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <clock\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::Driver\fP, \fBMaxOS::hardwarecommunication::InterruptHandler\fP, and \fBMaxOS::common::EventManager< ClockEvents >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBClock\fP (\fBhardwarecommunication::InterruptManager\fP *interrupt_manager, uint16_t time_between_events=10)"
.br
.RI "\fB\fBClock\fP\fP "
.ti -1c
.RI "\fB~Clock\fP ()"
.br
.ti -1c
.RI "void \fBactivate\fP () override"
.br
.RI "Activates the clock, setting the binary coded decimal representation flag\&. "
.ti -1c
.RI "void \fBdelay\fP (uint32_t milliseconds)"
.br
.RI "Delays the program for a specified number of milliseconds (rounded to the nearest 100) "
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP () final"
.br
.RI "Gets the name of the vendor\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP () final"
.br
.RI "Gets the name of the device\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBhandle_interrupt\fP () final"
.br
.RI "Handle the RTC interrupt, raising the clock event if enough time has passed\&. "
.ti -1c
.RI "uint8_t \fBread_hardware_clock\fP (uint8_t \fBaddress\fP)"
.br
.RI "read the current time from the hardware clock and return it "
.ti -1c
.RI "uint8_t \fBbinary_representation\fP (uint8_t number)"
.br
.RI "The binary representation of a number\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBm_binary\fP"
.br
.ti -1c
.RI "bool \fBm_24_hour_clock\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_data_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_command_port\fP"
.br
.ti -1c
.RI "uint16_t \fBm_ticks_between_events\fP { 0 }"
.br
.ti -1c
.RI "uint16_t \fBm_ticks_until_next_event\fP { 1 }"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
\fBDriver\fP for the CMOS Real Time \fBClock\fP\&. 
.PP
Definition at line 56 of file clock\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Clock::Clock (\fBhardwarecommunication::InterruptManager\fP * interrupt_manager, uint16_t time_between_events = \fC10\fP)"

.PP
\fB\fBClock\fP\fP Constructor for the \fBClock\fP class
.PP
\fBParameters\fP
.RS 4
\fIinterrupt_manager\fP The interrupt manager 
.br
\fItime_between_events\fP The time between events in 10ths of a second 
.RE
.PP

.PP
Definition at line 54 of file clock\&.cpp\&.
.PP
.nf
55 : Driver(),
56   InterruptHandler(interrupt_manager->hardware_interrupt_offset(), interrupt_manager),
57   m_data_port(0x71), m_command_port(0x70),
58   m_ticks_between_events(time_between_events)
59 {
60   //TODO: Configure APIC Clock
61 }
.fi
.SS "Clock::~Clock ()"

.PP
Definition at line 63 of file clock\&.cpp\&.
.PP
.nf
63               {
64 
65 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Clock::activate ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Activates the clock, setting the binary coded decimal representation flag\&. 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 146 of file clock\&.cpp\&.
.PP
.nf
146                      {
147 
148     // read the status register
149     uint8_t status = read_hardware_clock(0xB);
150 
151     // Set the clock information
152     m_24_hour_clock = status & 0x02;
153     m_binary = status & 0x04;
154 }
.fi
.PP
References m_24_hour_clock, m_binary, read_hardware_clock(), and status\&.
.SS "uint8_t Clock::binary_representation (uint8_t number)\fC [protected]\fP"

.PP
The binary representation of a number\&. 
.PP
\fBParameters\fP
.RS 4
\fInumber\fP The number to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The binary representation of the number if the binary coded decimal representation is used, otherwise the number 
.RE
.PP

.PP
Definition at line 132 of file clock\&.cpp\&.
.PP
.nf
132                                                    {
133 
134     // If the binary coded decimal representation is not used, return the number
135     if(m_binary)
136         return number;
137 
138     // Otherwise, return the binary representation
139     return ((number / 16) * 10) + (number & 0x0f);
140 
141 }
.fi
.PP
References m_binary\&.
.PP
Referenced by handle_interrupt()\&.
.SS "void Clock::delay (uint32_t milliseconds)"

.PP
Delays the program for a specified number of milliseconds (rounded to the nearest 100) 
.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP How many milliseconds to delay the program for 
.RE
.PP

.PP
Definition at line 162 of file clock\&.cpp\&.
.PP
.nf
162                                        {
163 
164         // Round the number of milliseconds to the nearest 100
165         uint64_t rounded_milliseconds =  ((milliseconds+99)/100);
166 
167         // Calculate the number of ticks until the delay is over
168         uint64_t ticks_until_delay_is_over = m_ticks + rounded_milliseconds;
169 
170         // Wait until the number of ticks is equal to the number of ticks until the delay is over
171         while(m_ticks < ticks_until_delay_is_over)
172             asm volatile("nop"); // execute the "nop" assembly instruction, which does nothing, but prevents the compiler from optimizing away the loop
173 }
.fi
.PP
Referenced by kernelMain()\&.
.SS "\fBstring\fP Clock::get_device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the name of the device\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 187 of file clock\&.cpp\&.
.PP
.nf
187                               {
188     return "Clock";
189 }
.fi
.SS "\fBstring\fP Clock::get_vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Gets the name of the vendor\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line 179 of file clock\&.cpp\&.
.PP
.nf
179                               {
180     return "Generic";
181 }
.fi
.SS "void Clock::handle_interrupt ()\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Handle the RTC interrupt, raising the clock event if enough time has passed\&. 
.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line 71 of file clock\&.cpp\&.
.PP
.nf
71                              {
72 
73     // Increment the number of ticks and decrement the number of ticks until the next event
74     m_ticks++;
75     m_ticks_until_next_event--;
76 
77     // If the number of ticks until the next event is not 0 then return
78     if(m_ticks_until_next_event != 0)
79         return;
80 
81     // Otherwise, reset the number of ticks until the next event
82     m_ticks_until_next_event = m_ticks_between_events;
83 
84     // Wait for the clock to be ready
85     while((read_hardware_clock(0xA) & 0x80) != 0);
86 
87     // Create a time object
88     Time time;
89 
90     // read the time from the hardware clock
91     time\&.year = binary_representation(read_hardware_clock(0x9)) + 2000;              // Register 9 is the year
92     time\&.month = binary_representation(read_hardware_clock(0x8));                    // Register 8 is the month
93     time\&.day = binary_representation(read_hardware_clock(0x7));                      // Register 7 is the day
94     time\&.hour = binary_representation(read_hardware_clock(0x4));                     // Register 4 is the hour
95     time\&.minute = binary_representation(read_hardware_clock(0x2));                   // Register 2 is the minute
96     time\&.second = binary_representation(read_hardware_clock(0x0));                   // Register 0 is the second
97 
98     // If the clock is using 12hr format and PM is set then add 12 to the hour
99     if(!m_24_hour_clock && (time\&.hour & 0x80) != 0) {
100 
101        // Convert the time to 24hr format
102        time\&.hour = ((time\&.hour & 0x7F) + 12) % 24;
103 
104     }
105 
106     //Raise the clock event
107     raise_event(new TimeEvent(&time));
108 }
.fi
.PP
References binary_representation(), MaxOS::common::Time::day, MaxOS::common::Time::hour, m_24_hour_clock, m_ticks_between_events, m_ticks_until_next_event, MaxOS::common::Time::minute, MaxOS::common::Time::month, MaxOS::common::EventManager< ClockEvents >::raise_event(), read_hardware_clock(), MaxOS::common::Time::second, and MaxOS::common::Time::year\&.
.SS "uint8_t Clock::read_hardware_clock (uint8_t address)\fC [protected]\fP"

.PP
read the current time from the hardware clock and return it 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP The address of the register to read from 
.RE
.PP
\fBReturns\fP
.RS 4
The value of the register 
.RE
.PP

.PP
Definition at line 117 of file clock\&.cpp\&.
.PP
.nf
118 {
119     // Send the address to the hardware clock
120     m_command_port\&.write(address);
121 
122     // read the value from the hardware clock
123     return m_data_port\&.read();
124 }
.fi
.PP
References address, m_command_port, m_data_port, MaxOS::hardwarecommunication::Port8Bit::read(), and MaxOS::hardwarecommunication::Port8Bit::write()\&.
.PP
Referenced by activate(), and handle_interrupt()\&.
.SH "Member Data Documentation"
.PP 
.SS "bool MaxOS::drivers::clock::Clock::m_24_hour_clock\fC [protected]\fP"

.PP
Definition at line 64 of file clock\&.h\&.
.PP
Referenced by activate(), and handle_interrupt()\&.
.SS "bool MaxOS::drivers::clock::Clock::m_binary\fC [protected]\fP"

.PP
Definition at line 63 of file clock\&.h\&.
.PP
Referenced by activate(), and binary_representation()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::clock::Clock::m_command_port\fC [protected]\fP"

.PP
Definition at line 68 of file clock\&.h\&.
.PP
Referenced by read_hardware_clock()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::clock::Clock::m_data_port\fC [protected]\fP"

.PP
Definition at line 67 of file clock\&.h\&.
.PP
Referenced by read_hardware_clock()\&.
.SS "uint16_t MaxOS::drivers::clock::Clock::m_ticks_between_events { 0 }\fC [protected]\fP"

.PP
Definition at line 71 of file clock\&.h\&.
.PP
Referenced by handle_interrupt()\&.
.SS "uint16_t MaxOS::drivers::clock::Clock::m_ticks_until_next_event { 1 }\fC [protected]\fP"

.PP
Definition at line 72 of file clock\&.h\&.
.PP
Referenced by handle_interrupt()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "maxOS::system::Multiboot" 3 "Mon Jan 8 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::system::Multiboot \- Parses the multiboot header and provides access to the multiboot info structure, checks if the multiboot header is valid\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <multiboot\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMultiboot\fP (\fBmultiboot_info_t\fP *boot_info, uint32_t magic)"
.br
.ti -1c
.RI "\fB~Multiboot\fP ()"
.br
.ti -1c
.RI "\fBmultiboot_info_t\fP * \fBget_boot_info\fP ()"
.br
.RI "Returns the multiboot info structure\&. "
.ti -1c
.RI "bool \fBcheck_flags\fP (\fBcommon::OutputStream\fP *error_stream)"
.br
.RI "Performs checks on the multiboot info structure\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBcheck_flag\fP (uint32_t flag, uint32_t bit)"
.br
.RI "Checks if a flag is set in the multiboot info structure\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBmultiboot_info_t\fP * \fBm_boot_info\fP"
.br
.ti -1c
.RI "uint32_t \fBm_magic\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Parses the multiboot header and provides access to the multiboot info structure, checks if the multiboot header is valid\&. 
.PP
Definition at line 285 of file multiboot\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Multiboot::Multiboot (\fBmultiboot_info_t\fP * boot_info, uint32_t magic)"

.PP
Definition at line 10 of file multiboot\&.cpp\&.
.PP
.nf
11 : m_boot_info(boot_info),
12   m_magic(magic)
13 {
14 
15 }
.fi
.SS "Multiboot::~Multiboot ()"

.PP
Definition at line 16 of file multiboot\&.cpp\&.
.PP
.nf
16                       {
17 
18 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool Multiboot::check_flag (uint32_t flag, uint32_t bit)\fC [protected]\fP"

.PP
Checks if a flag is set in the multiboot info structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIflag\fP The flag to check 
.br
\fIbit\fP The bit to check 
.RE
.PP
\fBReturns\fP
.RS 4
True if the flag is set, false otherwise 
.RE
.PP

.PP
Definition at line 106 of file multiboot\&.cpp\&.
.PP
.nf
106                                                       {
107     return (flag & (1 << bit));
108 }
.fi
.PP
Referenced by check_flags()\&.
.SS "bool Multiboot::check_flags (\fBcommon::OutputStream\fP * error_stream)"

.PP
Performs checks on the multiboot info structure\&. 
.PP
\fBParameters\fP
.RS 4
\fIerror_stream\fP The stream to write errors to 
.RE
.PP
\fBReturns\fP
.RS 4
True if the checks passed, false otherwise 
.RE
.PP

.PP
Definition at line 35 of file multiboot\&.cpp\&.
.PP
.nf
35                                                             {
36 
37   bool passed = true;
38 
39   // Check if the magic number is correct
40   if (m_magic != MULTIBOOT_BOOTLOADER_MAGIC) {
41         error_stream->write("ERROR: Invalid magic number: ");
42         error_stream->write_hex(m_magic);
43         error_stream->write("\n");
44         passed = false;
45   }
46   error_stream->write("\&.");
47 
48   // Check if the memory pointers exist
49   if (!check_flag(m_boot_info->flags, 0)) {
50           error_stream->write("ERROR: Memory info not available\n");
51           passed = false;
52   }
53   error_stream->write("\&.");
54 
55   // Check if the boot device exists
56   if (!check_flag(m_boot_info->flags, 1)) {
57           error_stream->write("ERROR: Boot device not available\n");
58           passed = false;
59   }
60   error_stream->write("\&.");
61 
62   // FLAG 2: Skip command line check as it is not required
63   // FLAG 3: Skip module check as it is not required
64 
65   // Check if both the a\&.out and ELF symbols are available (can only have one)
66   if (check_flag(m_boot_info->flags, 4) && check_flag(m_boot_info->flags, 5)) {
67           error_stream->write("ERROR: Both a\&.out and ELF symbols are available, should be mutually exclusive\n");
68           passed = false;
69   }
70   error_stream->write("\&.");
71 
72   // Check if the a\&.out symbols are valid
73   if (check_flag(m_boot_info->flags, 4)) {
74       if (m_boot_info->u\&.aout_sym\&.tabsize == 0) {
75               error_stream->write("ERROR: a\&.out symbol table is empty\n");
76               passed = false;
77       }
78   }
79   error_stream->write("\&.");
80 
81   // Check if the ELF symbols are valid
82   if (check_flag(m_boot_info->flags, 5)) {
83     if (m_boot_info->u\&.elf_sec\&.num == 0) {
84             error_stream->write("ERROR: ELF section header table is empty\n");
85             passed = false;
86     }
87   }error_stream->write("\&.");
88 
89   // Check if the memory map is valid
90   if (!check_flag(m_boot_info->flags, 6)) {
91           error_stream->write("ERROR: Memory map not available\n");
92           passed = false;
93   }
94   error_stream->write("\&.");
95 
96   return passed;
97 }
.fi
.PP
References maxOS::system::multiboot_info::aout_sym, check_flag(), maxOS::system::multiboot_info::elf_sec, maxOS::system::multiboot_info::flags, m_boot_info, m_magic, MULTIBOOT_BOOTLOADER_MAGIC, maxOS::system::multiboot_elf_section_header_table::num, maxOS::system::multiboot_aout_symbol_table::tabsize, maxOS::system::multiboot_info::u, maxOS::common::OutputStream::write(), and maxOS::common::OutputStream::write_hex()\&.
.PP
Referenced by kernelMain()\&.
.SS "\fBmultiboot_info_t\fP * Multiboot::get_boot_info ()"

.PP
Returns the multiboot info structure\&. 
.PP
\fBReturns\fP
.RS 4
The multiboot info structure 
.RE
.PP

.PP
Definition at line 25 of file multiboot\&.cpp\&.
.PP
.nf
25                                            {
26   return m_boot_info;
27 }
.fi
.PP
References m_boot_info\&.
.PP
Referenced by kernelMain()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBmultiboot_info_t\fP* maxOS::system::Multiboot::m_boot_info\fC [protected]\fP"

.PP
Definition at line 288 of file multiboot\&.h\&.
.PP
Referenced by check_flags(), and get_boot_info()\&.
.SS "uint32_t maxOS::system::Multiboot::m_magic\fC [protected]\fP"

.PP
Definition at line 289 of file multiboot\&.h\&.
.PP
Referenced by check_flags()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::common::GraphicsContext" 3 "Mon Jan 29 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.ti -1c
.RI "\fB~GraphicsContext\fP ()"
.br
.ti -1c
.RI "uint32_t \fBcolour_to_int\fP (\fBColour\fP)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (uint32_t)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "uint32_t \fBget_width\fP ()"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "uint32_t \fBget_height\fP ()"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "void \fBput_pixel\fP (int32_t x, int32_t y, \fBColour\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "void \fBputPixel\fP (int32_t x, int32_t y, int32_t colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "void \fBinvert_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "void \fBdraw_line\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdrawLine\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBfill_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfillCircle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBrender_pixel\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_8_bit\fP (uint32_t x, uint32_t y, uint8_t colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_16_bit\fP (uint32_t x, uint32_t y, uint16_t colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_24_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_32_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "virtual uint8_t \fBget_rendered_pixel_8_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual uint16_t \fBget_rendered_pixel_16_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_24_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_32_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBmirror_y_axis\fP { false }"
.br
.ti -1c
.RI "uint32_t \fBm_width\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_height\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_color_depth\fP { 0 }"
.br
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line 19 of file graphicsContext\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Definition at line 11 of file graphicsContext\&.cpp\&.
.PP
.nf
12 {
13 
14 
15     // VirtualBox VGA palette
16     m_colour_pallet[0x00] = Colour(0x00,0x00,0x00);    // Black
17     m_colour_pallet[0x01] = Colour(0x00,0x00,0xA8);    // Duke Blue
18     m_colour_pallet[0x02] = Colour(0x00,0xA8,0x00);    // Islamic Green
19     m_colour_pallet[0x03] = Colour(0x00,0xA8,0xA8);    // Persian Green
20     m_colour_pallet[0x04] = Colour(0xA8,0x00,0x00);    // Dark Candy Apple Red
21     m_colour_pallet[0x05] = Colour(0xA8,0x00,0xA8);    // Heliotrope Magenta
22 
23     m_colour_pallet[0x06] = Colour(0xA8,0xA8,0x00);    // Light Gold
24     m_colour_pallet[0x07] = Colour(0xA8,0xA8,0xA8);    // Dark Gray (X11)
25     m_colour_pallet[0x08] = Colour(0x00,0x00,0x57);    // Cetacean Blue
26     m_colour_pallet[0x09] = Colour(0x00,0x00,0xFF);    // Blue
27     m_colour_pallet[0x0A] = Colour(0x00,0xA8,0x57);    // Green (Pigment)
28     m_colour_pallet[0x0B] = Colour(0x00,0xA8,0xFF);    // Vivid Cerulean
29     m_colour_pallet[0x0C] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
30     m_colour_pallet[0x0D] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
31     m_colour_pallet[0x0E] = Colour(0xA8,0xA8,0x57);    // Olive Green
32     m_colour_pallet[0x0F] = Colour(0xA8,0xA8,0xFF);    // Maximum Blue Purple
33 
34     m_colour_pallet[0x10] = Colour(0x00,0x57,0x00);    // Dark Green (X11)
35     m_colour_pallet[0x11] = Colour(0x00,0x57,0xA8);    // Cobalt Blue
36     m_colour_pallet[0x12] = Colour(0x00,0xFF,0x00);    // Electric Green
37     m_colour_pallet[0x13] = Colour(0x00,0xFF,0xA8);    // Medium Spring Green
38     m_colour_pallet[0x14] = Colour(0xA8,0x57,0x00);    // Windsor Tan
39     m_colour_pallet[0x15] = Colour(0xA8,0x57,0xA8);    // Purpureus
40     m_colour_pallet[0x16] = Colour(0xA8,0xFF,0x00);    // Spring Bud
41     m_colour_pallet[0x17] = Colour(0xA8,0xFF,0xA8);    // Mint Green
42     m_colour_pallet[0x18] = Colour(0x00,0x57,0x57);    // Midnight Green (Eagle Green)
43     m_colour_pallet[0x19] = Colour(0x00,0x57,0xFF);    // Blue (RYB)
44     m_colour_pallet[0x1A] = Colour(0x00,0xFF,0x57);    // Malachite
45     m_colour_pallet[0x1B] = Colour(0x00,0xFF,0xFF);    // Aqua
46     m_colour_pallet[0x1C] = Colour(0xA8,0x57,0x57);    // Middle Red Purple
47     m_colour_pallet[0x1D] = Colour(0xA8,0x57,0xFF);    // Lavender Indigo
48     m_colour_pallet[0x1E] = Colour(0xA8,0xFF,0x57);    // Olive Green
49     m_colour_pallet[0x1F] = Colour(0xA8,0xFF,0xFF);    // Celeste
50 
51     m_colour_pallet[0x20] = Colour(0x57,0x00,0x00);    // Blood Red
52     m_colour_pallet[0x21] = Colour(0x57,0x00,0xA8);    // Metallic Violet
53     m_colour_pallet[0x22] = Colour(0x57,0xA8,0x00);    // Kelly Green
54     m_colour_pallet[0x23] = Colour(0x57,0xA8,0xA8);    // Cadet Blue
55     m_colour_pallet[0x24] = Colour(0xFF,0x00,0x00);    // Red
56     m_colour_pallet[0x25] = Colour(0xFF,0x00,0xA8);    // Fashion Fuchsia
57     m_colour_pallet[0x26] = Colour(0xFF,0xA8,0x00);    // Chrome Yellow
58     m_colour_pallet[0x27] = Colour(0xFF,0xA8,0xA8);    // Light Salmon Pink
59     m_colour_pallet[0x28] = Colour(0x57,0x00,0x57);    // Imperial Purple
60     m_colour_pallet[0x29] = Colour(0x57,0x00,0xFF);    // Electric Indigo
61     m_colour_pallet[0x2A] = Colour(0x57,0xA8,0x57);    // Apple
62     m_colour_pallet[0x2B] = Colour(0x57,0xA8,0xFF);    // Blue Jeans
63     m_colour_pallet[0x2C] = Colour(0xFF,0x00,0x57);    // Folly
64     m_colour_pallet[0x2D] = Colour(0xFF,0x00,0xFF);    // Fuchsia
65     m_colour_pallet[0x2E] = Colour(0xFF,0xA8,0x57);    // Rajah
66     m_colour_pallet[0x2F] = Colour(0xFF,0xA8,0xFF);    // Rich Brilliant Lavender
67 
68     m_colour_pallet[0x30] = Colour(0x57,0x57,0x00);    // Dark Bronze (Coin)
69     m_colour_pallet[0x31] = Colour(0x57,0x57,0xA8);    // Liberty
70     m_colour_pallet[0x32] = Colour(0x57,0xFF,0x00);    // Chlorophyll Green
71     m_colour_pallet[0x33] = Colour(0x57,0xFF,0xA8);    // Medium Aquamarine
72     m_colour_pallet[0x34] = Colour(0xFF,0x57,0x00);    // Orange (Pantone)
73     m_colour_pallet[0x35] = Colour(0xFF,0x57,0xA8);    // Brilliant Rose
74     m_colour_pallet[0x36] = Colour(0xFF,0xFF,0x00);    // Yellow
75     m_colour_pallet[0x37] = Colour(0xFF,0xFF,0xA8);    // Calamansi
76     m_colour_pallet[0x38] = Colour(0x57,0x57,0x57);    // Davy's Grey
77     m_colour_pallet[0x39] = Colour(0x57,0x57,0xFF);    // Very Light Blue
78     m_colour_pallet[0x3A] = Colour(0x57,0xFF,0x57);    // Screamin' Green
79     m_colour_pallet[0x3B] = Colour(0x57,0xFF,0xFF);    // Electric Blue
80     m_colour_pallet[0x3C] = Colour(0xFF,0x57,0x57);    // Sunset Orange
81     m_colour_pallet[0x3D] = Colour(0xFF,0x57,0xFF);    // Shocking Pink (Crayola)
82     m_colour_pallet[0x3E] = Colour(0xFF,0xFF,0x57);    // Shocking Pink (Crayola)
83     m_colour_pallet[0x3F] = Colour(0xFF,0xFF,0xFF);    // White
84 
85 
86     // Set the rest of the palette to black
87     for(uint8_t color_code = 255; color_code >= 0x40; --color_code)
88       m_colour_pallet[color_code] = Colour(0,0,0);
89 
90 
91 }
.fi
.PP
References m_colour_pallet\&.
.SS "GraphicsContext::~GraphicsContext ()"

.PP
Definition at line 93 of file graphicsContext\&.cpp\&.
.PP
.nf
93                                   {
94 
95 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "uint32_t GraphicsContext::colour_to_int (\fBColour\fP colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line 242 of file graphicsContext\&.cpp\&.
.PP
.nf
242                                                      {
243 
244     switch(m_color_depth)
245     {
246         case 8:
247         {
248             uint32_t result = 0;
249             int mindistance = 0xfffffff;
250             for(uint32_t i = 0; i <= 255; ++i)
251             {
252                 Colour* c = &m_colour_pallet[i];
253                 int distance =
254                         ((int)colour\&.red-(int)c->red)*((int)colour\&.red-(int)c->red)
255                         +((int)colour\&.green-(int)c->green)*((int)colour\&.green-(int)c->green)
256                         +((int)colour\&.blue-(int)c->blue)*((int)colour\&.blue-(int)c->blue);
257                 if(distance < mindistance)
258                 {
259                     mindistance = distance;
260                     result = i;
261                 }
262             }
263             return result;
264         }
265         case 16:
266         {
267             // 16-Bit colours RRRRRGGGGGGBBBBB
268             return ((uint16_t)(colour\&.red   & 0xF8)) << 8
269                    | ((uint16_t)(colour\&.green & 0xFC)) << 3
270                    | ((uint16_t)(colour\&.blue  & 0xF8) >> 3);
271         }
272         case 24:
273         {
274             return (uint32_t)colour\&.red   << 16
275                    | (uint32_t)colour\&.green << 8
276                    | (uint32_t)colour\&.blue;
277         }
278         default:
279         case 32:
280         {
281             uint32_t red_hex = ((uint32_t)colour\&.red & 0xFF) << 16;
282             uint32_t green_hex = ((uint32_t)colour\&.green & 0xFF) << 8;
283             uint32_t blue_hex = (uint32_t)colour\&.blue & 0xFF;
284             uint32_t alpha_hex = ((uint32_t)colour\&.alpha & 0xFF) << 24;
285 
286             uint32_t hexValue = red_hex | green_hex | blue_hex | alpha_hex;
287 
288 
289             return hexValue;
290         }
291     }
292 }
.fi
.PP
References MaxOS::common::Colour::alpha, MaxOS::common::Colour::blue, MaxOS::drivers::peripherals::c, MaxOS::common::Colour::green, MaxOS::drivers::peripherals::i, m_color_depth, m_colour_pallet, and MaxOS::common::Colour::red\&.
.PP
Referenced by draw_circle(), draw_line(), draw_rectangle(), MaxOS::gui::Font::draw_text(), fill_circle(), fill_rectangle(), get_rendered_pixel(), and put_pixel()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 665 of file graphicsContext\&.cpp\&.
.PP
.nf
665                                                                                       {
666   draw_circle(x0, y0, radius, colour_to_int(colour));
667 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 677 of file graphicsContext\&.cpp\&.
.PP
.nf
677                                                                                          {
678 
679     // Make sure the circle is with in the width and height of the screen
680     if(x0 < 0) x0 = 0;
681     if((uint32_t)x0 > m_width) x0 = m_width;
682     if(y0 < 0) y0 = 0;
683     if((uint32_t)y0 > m_height) y0 = m_height;
684 
685     // Mirror the Y axis as directly calling put_pixel will not do this
686     if(mirror_y_axis)
687         y0 = m_height -y0-1;
688 
689 
690     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
691     for(int32_t x = -radius; x <= radius; ++x){
692 
693         // Draw a line from the top most point of the circle to the bottom most point of the circle
694         for(int32_t y = -radius; y <= radius; ++y){
695 
696             // If the point is within the circle, draw it but make sure it is only part of the outline
697             if(x*x + y*y <= radius*radius && x*x + y*y >= (radius-1)*(radius-1))
698                 putPixel(x0+x,y0+y,colour);
699         }
700     }
701 
702 
703 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::draw_line (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 459 of file graphicsContext\&.cpp\&.
.PP
.nf
459                                                                                              {
460     drawLine(x0,y0,x1,y1, colour_to_int(colour));
461 }
.fi
.PP
References colour_to_int(), and drawLine()\&.
.PP
Referenced by MaxOS::gui::widgets::InputBox::draw(), and MaxOS::gui::widgets::Button::draw()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 569 of file graphicsContext\&.cpp\&.
.PP
.nf
569                                                                                                   {
570   draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
571 
572 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 583 of file graphicsContext\&.cpp\&.
.PP
.nf
583                                                                                                     {
584 
585     // Ensure x and y 0 is smaller than x and y 1
586     --y0;
587     --x0;
588 
589     // Draw the rectangle
590     drawLine(x0,y0,x1,y0,colour); // Top
591     drawLine(x0,y1,x1,y1,colour); // Bottom
592     drawLine(x0,y0,x0,y1,colour); // Left
593     drawLine(x1,y0,x1,y1,colour); // Right
594 
595 }
.fi
.PP
References drawLine()\&.
.SS "void GraphicsContext::drawLine (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 472 of file graphicsContext\&.cpp\&.
.PP
.nf
472                                                                                               {
473 
474     // Store the minimum and maximum y values
475     bool y_0_is_smaller = y0 < y1;
476     int32_t y_min = y_0_is_smaller ? y0 : y1;
477     int32_t y_max = y_0_is_smaller ? y1 : y0;
478 
479     //Reverse the points to draw from left to right
480     if(x1 < x0){
481         drawLine(x1,y1,x0,y0,colour);
482         return;
483     }
484 
485     // Vertical line
486     if(x1 == x0)
487     {
488         // Force the line to be within the screen
489         if(y_min < 0) y_min = 0;
490         if((uint32_t)y_max >= m_height)
491           y_max = m_height - 1;
492 
493         // Mirror the Y axis as directly calling put_pixel will not do this
494         if(mirror_y_axis)
495         {
496             int32_t temp = y_max;
497             y_max = m_height - y_min - 1;
498             y_min = m_height - temp - 1;
499         }
500 
501         // Check that the line is within the screen
502         if (0 > x0 || (uint32_t) x0 >= m_width) {
503             return;
504         }
505 
506         // Draw the line
507         for(int32_t y = y_min; y <= y_max; ++y)
508             putPixel(x0, y, colour);
509 
510         return;
511     }
512 
513     // Horizontal line
514     if(y1 == y0)
515     {
516         // Ensure the line is within the screen
517         if(x0 < 0) x0 = 0;
518         if((uint32_t)x1 >= m_width) x1 = m_width -1;
519 
520         // Mirror the Y axis as directly calling put_pixel will not do this
521         if(mirror_y_axis)
522             y0 = m_height -y0-1;
523 
524         // Check that the line is within the screen
525         if (0 > y0 || (uint32_t) y0 >= m_height)
526             return;
527 
528         // Draw the line
529         for(int32_t x = x0; x <= x1; ++x)
530             putPixel(x,y0,colour);
531     }
532 
533     // TODO: Slope once SSE is implemented
534     return;
535 
536     // If the line is not horizontal or vertical then it must be a diagonal line
537     // Find the slope of the line
538     float slope = ((float)(y1-y0))/(x1-x0);
539 
540     // A slope that is more horizontal should be drawn by incrementing x
541     if(-1 <= slope && slope <= 1)
542     {
543         float y = y0;
544         for(int32_t x = x0; x <= x1; x++, y+=slope)
545             putPixel(x, (int32_t)y, colour);
546     }
547 
548     // A slope that is more vertical should be drawn by incrementing y
549     else
550     {
551         // Invert the slope
552         slope = 1\&.0f/slope;
553 
554         float x = x0;
555         for(int32_t y = y_min; y <= y_max; x+=slope, y++)
556             putPixel((int32_t)x, y, colour);
557     }
558 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_line(), and draw_rectangle()\&.
.SS "void GraphicsContext::fill_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 713 of file graphicsContext\&.cpp\&.
.PP
.nf
713                                                                                        {
714     fillCircle(x0,y0,radius, colour_to_int(colour));
715 
716 }
.fi
.PP
References colour_to_int(), and fillCircle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 606 of file graphicsContext\&.cpp\&.
.PP
.nf
606                                                                                                   {
607   fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
608 }
.fi
.PP
References colour_to_int()\&.
.PP
Referenced by MaxOS::gui::widgets::Text::draw(), MaxOS::gui::widgets::InputBox::draw(), MaxOS::gui::widgets::Button::draw(), MaxOS::gui::Desktop::draw_self(), MaxOS::gui::Window::draw_self(), and fill_rectangle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 619 of file graphicsContext\&.cpp\&.
.PP
.nf
619                                                                                                     {
620 
621     // Draw from left to right
622     if(y1 < y0){
623       fill_rectangle(x1, y1, x0, y0, colour);
624         return;
625     }
626 
627     // Make sure the rectangle is within the height of the screen
628     if(y0 < 0) y0 = 0;
629     if((uint32_t)y1 > m_height) y1 = m_height;
630 
631     // Make sure the rectangle is within the width of the screen
632     bool x_0_is_smaller = x0 < x1;
633     int32_t x_min = x_0_is_smaller ? x0 : x1;
634     int32_t x_max = x_0_is_smaller ? x1 : x0;
635 
636     if(x_min < 0) x_min = 0;
637     if((uint32_t)x_max > m_width)
638       x_max = m_width;
639 
640     // Mirror the Y axis as directly calling put_pixel will not do this
641     if(mirror_y_axis)
642     {
643         uint32_t temp = y1;
644         y1 = m_height - y0 - 1;
645         y0 = m_height - temp - 1;
646     }
647 
648     // Draw the rectangle
649     for(int32_t y = y0; y < y1; ++y){
650         for (int32_t x = x_min; x < x_max; ++x) {
651             putPixel(x, y, colour);
652         }
653     }
654 
655 }
.fi
.PP
References fill_rectangle(), m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::fillCircle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 726 of file graphicsContext\&.cpp\&.
.PP
.nf
726                                                                                         {
727 
728         // Make sure the circle is with in the width and height of the screen
729         if(x0 < 0) x0 = 0;
730         if((uint32_t)x0 > m_width) x0 = m_width;
731         if(y0 < 0) y0 = 0;
732         if((uint32_t)y0 > m_height) y0 = m_height;
733 
734         // Mirror the Y axis as directly calling put_pixel will not do this
735         if(mirror_y_axis)
736             y0 = m_height -y0-1;
737 
738         // Draw the circle
739 
740         // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
741         for(int32_t x = -radius; x <= radius; ++x){
742 
743             // Draw a line from the top most point of the circle to the bottom most point of the circle
744             for(int32_t y = -radius; y <= radius; ++y){
745 
746                 // Only draw the pixel if it is within the circle
747                 if(x*x + y*y <= radius*radius)
748                     putPixel(x0+x,y0+y,colour);
749             }
750         }
751 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by fill_circle()\&.
.SS "uint32_t GraphicsContext::get_height ()"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line 364 of file graphicsContext\&.cpp\&.
.PP
.nf
364                                      {
365     return m_height;
366 }
.fi
.PP
References m_height\&.
.PP
Referenced by MaxOS::gui::Desktop::Desktop(), and MaxOS::drivers::console::VESABootConsole::height()\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (int32_t x, int32_t y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line 411 of file graphicsContext\&.cpp\&.
.PP
.nf
411                                                       {
412 
413     // Check if the pixel is within the m_width of the screen
414     if (0 > x || (uint32_t)x >= m_width) {
415         return Colour(0,0,0);
416     }
417 
418     // Check if the pixel is within the m_height of the screen
419     if (0 > y || (uint32_t) y >= m_height) {
420         return Colour(0,0,0);
421     }
422 
423     // Get the pixel and convert it to a colour
424     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height - y - 1 : y);
425     return int_to_colour(translated_color);
426 
427 
428 }
.fi
.PP
References get_rendered_pixel(), int_to_colour(), m_height, m_width, mirror_y_axis, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line 176 of file graphicsContext\&.cpp\&.
.PP
.nf
176                                                                    {
177     // Call the correct get_pixel function based on the color depth
178     switch (m_color_depth) {
179         case 8:
180             return get_rendered_pixel_8_bit(x, y);
181         case 16:
182             return get_rendered_pixel_16_bit(x, y);
183         case 24:
184             return get_rendered_pixel_24_bit(x, y);
185         case 32:
186             return get_rendered_pixel_32_bit(x, y);
187     }
188 
189     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
190 }
.fi
.PP
References colour_to_int(), get_rendered_pixel_16_bit(), get_rendered_pixel_24_bit(), get_rendered_pixel_32_bit(), get_rendered_pixel_8_bit(), m_color_depth, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by get_pixel()\&.
.SS "uint16_t GraphicsContext::get_rendered_pixel_16_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 210 of file graphicsContext\&.cpp\&.
.PP
.nf
210                                                                       {
211     return 0;
212 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_24_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 221 of file graphicsContext\&.cpp\&.
.PP
.nf
221                                                                       {
222     return 0;
223 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_32_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 232 of file graphicsContext\&.cpp\&.
.PP
.nf
232                                                                       {
233     return 0;
234 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint8_t GraphicsContext::get_rendered_pixel_8_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 199 of file graphicsContext\&.cpp\&.
.PP
.nf
199                                                                     {
200     return 0;
201 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_width ()"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line 355 of file graphicsContext\&.cpp\&.
.PP
.nf
355                                     {
356     return m_width;
357 }
.fi
.PP
References m_width\&.
.PP
Referenced by MaxOS::gui::Desktop::Desktop(), and MaxOS::drivers::console::VESABootConsole::width()\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (uint32_t colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line 300 of file graphicsContext\&.cpp\&.
.PP
.nf
300                                                      {
301     switch (m_color_depth) {
302 
303         case 8:
304         {
305             // Return the colour from the palette
306             return m_colour_pallet[colour & 0xFF];
307         }
308 
309         case 16:
310         {
311             // 16-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
312             Colour result;
313 
314             result\&.red = (colour & 0xF800) >> 8;
315             result\&.green = (colour & 0x07E0) >> 3;
316             result\&.blue = (colour & 0x001F) << 3;
317 
318             return result;
319         }
320 
321         case 24:
322         {
323             // 24-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
324             Colour result;
325 
326             result\&.red = (colour & 0xFF0000) >> 16;
327             result\&.green = (colour & 0x00FF00) >> 8;
328             result\&.blue = (colour & 0x0000FF);
329 
330             return result;
331         }
332 
333         default:
334         case 32:
335         {
336             Colour result;
337 
338             uint32_t hex_value = colour;
339             result\&.red = (hex_value >> 16) & 0xFF;
340             result\&.green = (hex_value >> 8) & 0xFF;
341             result\&.blue = hex_value & 0xFF;
342             result\&.alpha = (hex_value >> 24) & 0xFF;
343 
344             return result;
345 
346         }
347     }
348 }
.fi
.PP
References MaxOS::common::Colour::alpha, MaxOS::common::Colour::blue, MaxOS::common::Colour::green, m_color_depth, m_colour_pallet, and MaxOS::common::Colour::red\&.
.PP
Referenced by get_pixel()\&.
.SS "void GraphicsContext::invert_pixel (int32_t x, int32_t y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line 436 of file graphicsContext\&.cpp\&.
.PP
.nf
436                                                        {
437     // Get the pixel
438     Colour colour = get_pixel(x, y);
439 
440     // Invert the pixel
441     colour\&.red = 255 - colour\&.red;
442     colour\&.green = 255 - colour\&.green;
443     colour\&.blue = 255 - colour\&.blue;
444 
445     // Render the pixel
446     put_pixel(x, y, colour);
447 }
.fi
.PP
References MaxOS::common::Colour::blue, get_pixel(), MaxOS::common::Colour::green, put_pixel(), MaxOS::common::Colour::red, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by MaxOS::gui::Desktop::invert_mouse_cursor()\&.
.SS "void GraphicsContext::put_pixel (int32_t x, int32_t y, \fBColour\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 375 of file graphicsContext\&.cpp\&.
.PP
.nf
375                                                                    {
376 
377     // Convert the colour to an integer and then print it
378     putPixel(x,y, colour_to_int(colour));
379 }
.fi
.PP
References colour_to_int(), putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "void GraphicsContext::putPixel (int32_t x, int32_t y, int32_t colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 388 of file graphicsContext\&.cpp\&.
.PP
.nf
388                                                                    {
389 
390     if (0 > x || (uint32_t)x >= m_width) {
391         return;
392     }
393 
394     // Check if the pixel is within the m_height of the screen
395     if (0 > y || (uint32_t) y >= m_height) {
396         return;
397     }
398 
399     // Render the pixel
400     render_pixel(x, mirror_y_axis ? m_height - y - 1 : y, colour);
401 
402 }
.fi
.PP
References m_height, m_width, mirror_y_axis, render_pixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), and put_pixel()\&.
.SS "void GraphicsContext::render_pixel (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 104 of file graphicsContext\&.cpp\&.
.PP
.nf
104                                                                           {
105 
106     // Call the correct put_pixel function based on the color depth
107     switch (m_color_depth) {
108         case 8:
109           render_pixel_8_bit(x, y, colour);
110             break;
111         case 16:
112           render_pixel_16_bit(x, y, colour);
113             break;
114         case 24:
115           render_pixel_24_bit(x, y, colour);
116             break;
117         case 32:
118           render_pixel_32_bit(x, y, colour);
119             break;
120     }
121 
122 
123 }
.fi
.PP
References m_color_depth, render_pixel_16_bit(), render_pixel_24_bit(), render_pixel_32_bit(), render_pixel_8_bit(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by putPixel()\&.
.SS "void GraphicsContext::render_pixel_16_bit (uint32_t x, uint32_t y, uint16_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 143 of file graphicsContext\&.cpp\&.
.PP
.nf
143                                                                       {
144 
145 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_24_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 154 of file graphicsContext\&.cpp\&.
.PP
.nf
154                                                                       {
155 
156 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_32_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 165 of file graphicsContext\&.cpp\&.
.PP
.nf
165                                                                       {
166 
167 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_8_bit (uint32_t x, uint32_t y, uint8_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 132 of file graphicsContext\&.cpp\&.
.PP
.nf
132                                                                     {
133 
134 }
.fi
.PP
Referenced by render_pixel()\&.
.SH "Member Data Documentation"
.PP 
.SS "uint32_t MaxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
Definition at line 26 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), get_rendered_pixel(), int_to_colour(), render_pixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "\fBColour\fP MaxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
Definition at line 28 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), GraphicsContext(), and int_to_colour()\&.
.SS "uint32_t MaxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
Definition at line 25 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_height(), get_pixel(), putPixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "uint32_t MaxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
Definition at line 24 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), get_width(), putPixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "bool MaxOS::common::GraphicsContext::mirror_y_axis { false }\fC [protected]\fP"

.PP
Definition at line 22 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), and putPixel()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

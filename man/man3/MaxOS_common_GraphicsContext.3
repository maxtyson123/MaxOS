.TH "MaxOS::common::GraphicsContext" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.ti -1c
.RI "\fB~GraphicsContext\fP ()"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBcolour_to_int\fP (\fBconst\fP \fBColour\fP &)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (\fBuint32_t\fP)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBwidth\fP () \fBconst\fP"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBheight\fP () \fBconst\fP"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolor_depth\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBuint64_t\fP * \fBframebuffer_address\fP ()"
.br
.RI "Gets the address of the context's framebuffer to draw on\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "\fBvoid\fP \fBputPixel\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvert_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdrawLine\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfillCircle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint8_t\fP \fBget_rendered_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint16_t\fP \fBget_rendered_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBmirror_y_axis\fP { \fBfalse\fP }"
.br
.ti -1c
.RI "\fBint32_t\fP \fBm_width\fP { 0 }"
.br
.ti -1c
.RI "\fBint32_t\fP \fBm_height\fP { 0 }"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBm_color_depth\fP { 0 }"
.br
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.ti -1c
.RI "\fBuint64_t\fP * \fBm_framebuffer_address\fP { \fBnullptr\fP }"
.br
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line \fB19\fP of file \fBgraphicsContext\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Definition at line \fB9\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
9                                  {
10 
11 
12     // VirtualBox VGA palette
13     m_colour_pallet[0x00] = Colour(0x00, 0x00, 0x00);    // Black
14     m_colour_pallet[0x01] = Colour(0x00, 0x00, 0xA8);    // Duke Blue
15     m_colour_pallet[0x02] = Colour(0x00, 0xA8, 0x00);    // Islamic Green
16     m_colour_pallet[0x03] = Colour(0x00, 0xA8, 0xA8);    // Persian Green
17     m_colour_pallet[0x04] = Colour(0xA8, 0x00, 0x00);    // Dark Candy Apple Red
18     m_colour_pallet[0x05] = Colour(0xA8, 0x00, 0xA8);    // Heliotrope Magenta
19 
20     m_colour_pallet[0x06] = Colour(0xA8, 0xA8, 0x00);    // Light Gold
21     m_colour_pallet[0x07] = Colour(0xA8, 0xA8, 0xA8);    // Dark Gray (X11)
22     m_colour_pallet[0x08] = Colour(0x00, 0x00, 0x57);    // Cetacean Blue
23     m_colour_pallet[0x09] = Colour(0x00, 0x00, 0xFF);    // Blue
24     m_colour_pallet[0x0A] = Colour(0x00, 0xA8, 0x57);    // Green (Pigment)
25     m_colour_pallet[0x0B] = Colour(0x00, 0xA8, 0xFF);    // Vivid Cerulean
26     m_colour_pallet[0x0C] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
27     m_colour_pallet[0x0D] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
28     m_colour_pallet[0x0E] = Colour(0xA8, 0xA8, 0x57);    // Olive Green
29     m_colour_pallet[0x0F] = Colour(0xA8, 0xA8, 0xFF);    // Maximum Blue Purple
30 
31     m_colour_pallet[0x10] = Colour(0x00, 0x57, 0x00);    // Dark Green (X11)
32     m_colour_pallet[0x11] = Colour(0x00, 0x57, 0xA8);    // Cobalt Blue
33     m_colour_pallet[0x12] = Colour(0x00, 0xFF, 0x00);    // Electric Green
34     m_colour_pallet[0x13] = Colour(0x00, 0xFF, 0xA8);    // Medium Spring Green
35     m_colour_pallet[0x14] = Colour(0xA8, 0x57, 0x00);    // Windsor Tan
36     m_colour_pallet[0x15] = Colour(0xA8, 0x57, 0xA8);    // Purpureus
37     m_colour_pallet[0x16] = Colour(0xA8, 0xFF, 0x00);    // Spring Bud
38     m_colour_pallet[0x17] = Colour(0xA8, 0xFF, 0xA8);    // Mint Green
39     m_colour_pallet[0x18] = Colour(0x00, 0x57, 0x57);    // Midnight Green (Eagle Green)
40     m_colour_pallet[0x19] = Colour(0x00, 0x57, 0xFF);    // Blue (RYB)
41     m_colour_pallet[0x1A] = Colour(0x00, 0xFF, 0x57);    // Malachite
42     m_colour_pallet[0x1B] = Colour(0x00, 0xFF, 0xFF);    // Aqua
43     m_colour_pallet[0x1C] = Colour(0xA8, 0x57, 0x57);    // Middle Red Purple
44     m_colour_pallet[0x1D] = Colour(0xA8, 0x57, 0xFF);    // Lavender Indigo
45     m_colour_pallet[0x1E] = Colour(0xA8, 0xFF, 0x57);    // Olive Green
46     m_colour_pallet[0x1F] = Colour(0xA8, 0xFF, 0xFF);    // Celeste
47 
48     m_colour_pallet[0x20] = Colour(0x57, 0x00, 0x00);    // Blood Red
49     m_colour_pallet[0x21] = Colour(0x57, 0x00, 0xA8);    // Metallic Violet
50     m_colour_pallet[0x22] = Colour(0x57, 0xA8, 0x00);    // Kelly Green
51     m_colour_pallet[0x23] = Colour(0x57, 0xA8, 0xA8);    // Cadet Blue
52     m_colour_pallet[0x24] = Colour(0xFF, 0x00, 0x00);    // Red
53     m_colour_pallet[0x25] = Colour(0xFF, 0x00, 0xA8);    // Fashion Fuchsia
54     m_colour_pallet[0x26] = Colour(0xFF, 0xA8, 0x00);    // Chrome Yellow
55     m_colour_pallet[0x27] = Colour(0xFF, 0xA8, 0xA8);    // Light Salmon Pink
56     m_colour_pallet[0x28] = Colour(0x57, 0x00, 0x57);    // Imperial Purple
57     m_colour_pallet[0x29] = Colour(0x57, 0x00, 0xFF);    // Electric Indigo
58     m_colour_pallet[0x2A] = Colour(0x57, 0xA8, 0x57);    // Apple
59     m_colour_pallet[0x2B] = Colour(0x57, 0xA8, 0xFF);    // Blue Jeans
60     m_colour_pallet[0x2C] = Colour(0xFF, 0x00, 0x57);    // Folly
61     m_colour_pallet[0x2D] = Colour(0xFF, 0x00, 0xFF);    // Fuchsia
62     m_colour_pallet[0x2E] = Colour(0xFF, 0xA8, 0x57);    // Rajah
63     m_colour_pallet[0x2F] = Colour(0xFF, 0xA8, 0xFF);    // Rich Brilliant Lavender
64 
65     m_colour_pallet[0x30] = Colour(0x57, 0x57, 0x00);    // Dark Bronze (Coin)
66     m_colour_pallet[0x31] = Colour(0x57, 0x57, 0xA8);    // Liberty
67     m_colour_pallet[0x32] = Colour(0x57, 0xFF, 0x00);    // Chlorophyll Green
68     m_colour_pallet[0x33] = Colour(0x57, 0xFF, 0xA8);    // Medium Aquamarine
69     m_colour_pallet[0x34] = Colour(0xFF, 0x57, 0x00);    // Orange (Pantone)
70     m_colour_pallet[0x35] = Colour(0xFF, 0x57, 0xA8);    // Brilliant Rose
71     m_colour_pallet[0x36] = Colour(0xFF, 0xFF, 0x00);    // Yellow
72     m_colour_pallet[0x37] = Colour(0xFF, 0xFF, 0xA8);    // Calamansi
73     m_colour_pallet[0x38] = Colour(0x57, 0x57, 0x57);    // Davy's Grey
74     m_colour_pallet[0x39] = Colour(0x57, 0x57, 0xFF);    // Very Light Blue
75     m_colour_pallet[0x3A] = Colour(0x57, 0xFF, 0x57);    // Screamin' Green
76     m_colour_pallet[0x3B] = Colour(0x57, 0xFF, 0xFF);    // Electric Blue
77     m_colour_pallet[0x3C] = Colour(0xFF, 0x57, 0x57);    // Sunset Orange
78     m_colour_pallet[0x3D] = Colour(0xFF, 0x57, 0xFF);    // Shocking Pink (Crayola)
79     m_colour_pallet[0x3E] = Colour(0xFF, 0xFF, 0x57);    // Shocking Pink (Crayola)
80     m_colour_pallet[0x3F] = Colour(0xFF, 0xFF, 0xFF);    // White
81 
82 
83     // Set the rest of the palette to black
84     for (uint8_t color_code = 255; color_code >= 0x40; \-\-color_code)
85         m_colour_pallet[color_code] = Colour(0, 0, 0);
86 
87 
88 }
.fi

.PP
References \fBm_colour_pallet\fP\&.
.SS "GraphicsContext::~GraphicsContext ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP GraphicsContext::color_depth () const"
@breif Gets the current color depth (bits per pixel) 
.PP
\fBReturns\fP
.RS 4
The color depth 
.RE
.PP

.PP
Definition at line \fB356\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
356                                             {
357     return m_color_depth;
358 }
.fi

.PP
References \fBm_color_depth\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::internal_set_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::colour_to_int (\fBconst\fP \fBColour\fP & colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line \fB237\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
237                                                             {
238 
239     switch (m_color_depth) {
240         case 8: {
241             uint32_t result = 0;
242             int mindistance = 0xfffffff;
243             for (uint32_t i = 0; i <= 255; ++i) {
244                 Colour *c = &m_colour_pallet[i];
245                 int distance =
246                         ((int) colour\&.red \- (int) c\->red) * ((int) colour\&.red \- (int) c\->red)
247                         + ((int) colour\&.green \- (int) c\->green) * ((int) colour\&.green \- (int) c\->green)
248                         + ((int) colour\&.blue \- (int) c\->blue) * ((int) colour\&.blue \- (int) c\->blue);
249                 if (distance < mindistance) {
250                     mindistance = distance;
251                     result = i;
252                 }
253             }
254             return result;
255         }
256         case 16: {
257             // 16\-Bit colours RRRRRGGGGGGBBBBB
258             return ((uint16_t) (colour\&.red & 0xF8)) << 8
259                    | ((uint16_t) (colour\&.green & 0xFC)) << 3
260                    | ((uint16_t) (colour\&.blue & 0xF8) >> 3);
261         }
262         case 24: {
263             return (uint32_t) colour\&.red << 16
264                    | (uint32_t) colour\&.green << 8
265                    | (uint32_t) colour\&.blue;
266         }
267         default:
268         case 32: {
269             uint32_t red_hex = ((uint32_t) colour\&.red & 0xFF) << 16;
270             uint32_t green_hex = ((uint32_t) colour\&.green & 0xFF) << 8;
271             uint32_t blue_hex = (uint32_t) colour\&.blue & 0xFF;
272             uint32_t alpha_hex = ((uint32_t) colour\&.alpha & 0xFF) << 24;
273 
274             uint32_t hexValue = red_hex | green_hex | blue_hex | alpha_hex;
275 
276 
277             return hexValue;
278         }
279     }
280 }
.fi

.PP
References \fBMaxOS::common::Colour::alpha\fP, \fBMaxOS::common::Colour::blue\fP, \fBMaxOS::common::Colour::green\fP, \fBm_color_depth\fP, \fBm_colour_pallet\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBdraw_rectangle()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_rendered_pixel()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB641\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
641                                                                                               {
642     draw_circle(x0, y0, radius, colour_to_int(colour));
643 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_circle()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB653\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
653                                                                                          {
654 
655     // Make sure the circle is with in the width and height of the screen
656     if (x0 < 0) x0 = 0;
657     if (x0 > m_width) x0 = m_width;
658     if (y0 < 0) y0 = 0;
659     if (y0 > m_height) y0 = m_height;
660 
661     // Mirror the Y axis as directly calling put_pixel will not do this
662     if (mirror_y_axis)
663         y0 = m_height \- y0 \- 1;
664 
665 
666     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
667     for (int32_t x = \-radius; x <= radius; ++x) {
668 
669         // Draw a line from the top most point of the circle to the bottom most point of the circle
670         for (int32_t y = \-radius; y <= radius; ++y) {
671 
672             // If the point is within the circle, draw it but make sure it is only part of the outline
673             if (x * x + y * y <= radius * radius && x * x + y * y >= (radius \- 1) * (radius \- 1))
674                 putPixel(x0 + x, y0 + y, colour);
675         }
676     }
677 
678 
679 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_line (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB444\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
444                                                                                                     {
445     drawLine(x0, y0, x1, y1, colour_to_int(colour));
446 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB546\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
546                                                                                                          {
547     draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
548 
549 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_rectangle()\fP\&.
.PP
Referenced by \fBdraw_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB560\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
560                                                                                                     {
561 
562     // Ensure x and y 0 is smaller than x and y 1
563     \-\-y0;
564     \-\-x0;
565 
566     // Draw the rectangle
567     drawLine(x0, y0, x1, y0, colour); // Top
568     drawLine(x0, y1, x1, y1, colour); // Bottom
569     drawLine(x0, y0, x0, y1, colour); // Left
570     drawLine(x1, y0, x1, y1, colour); // Right
571 
572 }
.fi

.PP
References \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::drawLine (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB457\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
457                                                                                               {
458 
459     // Store the minimum and maximum y values
460     bool y_0_is_smaller = y0 < y1;
461     int32_t y_min = y_0_is_smaller ? y0 : y1;
462     int32_t y_max = y_0_is_smaller ? y1 : y0;
463 
464     //Reverse the points to draw from left to right
465     if (x1 < x0) {
466         drawLine(x1, y1, x0, y0, colour);
467         return;
468     }
469 
470     // Vertical line
471     if (x1 == x0) {
472         // Force the line to be within the screen
473         if (y_min < 0) y_min = 0;
474         if (y_max >= m_height)
475             y_max = m_height \- 1;
476 
477         // Mirror the Y axis as directly calling put_pixel will not do this
478         if (mirror_y_axis) {
479             int32_t temp = y_max;
480             y_max = m_height \- y_min \- 1;
481             y_min = m_height \- temp \- 1;
482         }
483 
484         // Check that the line is within the screen
485         if (0 > x0 || (uint32_t) x0 >= m_width) {
486             return;
487         }
488 
489         // Draw the line
490         for (int32_t y = y_min; y <= y_max; ++y)
491             putPixel(x0, y, colour);
492 
493         return;
494     }
495 
496     // Horizontal line
497     if (y1 == y0) {
498         // Ensure the line is within the screen
499         if (x0 < 0) x0 = 0;
500         if (x1 >= m_width) x1 = m_width \- 1;
501 
502         // Mirror the Y axis as directly calling put_pixel will not do this
503         if (mirror_y_axis)
504             y0 = m_height \- y0 \- 1;
505 
506         // Check that the line is within the screen
507         if (0 > y0 || y0 >= m_height)
508             return;
509 
510         // Draw the line
511         for (int32_t x = x0; x <= x1; ++x)
512             putPixel(x, y0, colour);
513     }
514 
515     // If the line is not horizontal or vertical then it must be a diagonal line
516     // Find the slope of the line
517     float slope = ((float) (y1 \- y0)) / (x1 \- x0);
518 
519     // A slope that is more horizontal should be drawn by incrementing x
520     if (\-1 <= slope && slope <= 1) {
521         float y = y0;
522         for (int32_t x = x0; x <= x1; x++, y += slope)
523             putPixel(x, (int32_t) y, colour);
524     }
525 
526         // A slope that is more vertical should be drawn by incrementing y
527     else {
528         // Invert the slope
529         slope = 1\&.0f / slope;
530 
531         float x = x0;
532         for (int32_t y = y_min; y <= y_max; x += slope, y++)
533             putPixel((int32_t) x, y, colour);
534     }
535 }
.fi

.PP
References \fBdrawLine()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBdraw_line()\fP, \fBdraw_rectangle()\fP, and \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB689\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
689                                                                                               {
690     fillCircle(x0, y0, radius, colour_to_int(colour));
691 
692 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfillCircle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB583\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
583                                                                                                          {
584     fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
585 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfill_rectangle()\fP\&.
.PP
Referenced by \fBfill_rectangle()\fP, and \fBfill_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB596\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
596                                                                                                     {
597 
598     // Draw from left to right
599     if (y1 < y0) {
600         fill_rectangle(x1, y1, x0, y0, colour);
601         return;
602     }
603 
604     // Make sure the rectangle is within the height of the screen
605     if (y0 < 0) y0 = 0;
606     if (y1 > m_height) y1 = m_height;
607 
608     // Make sure the rectangle is within the width of the screen
609     bool x_0_is_smaller = x0 < x1;
610     int32_t x_min = x_0_is_smaller ? x0 : x1;
611     int32_t x_max = x_0_is_smaller ? x1 : x0;
612 
613     if (x_min < 0) x_min = 0;
614     if (x_max > m_width)
615         x_max = m_width;
616 
617     // Mirror the Y axis as directly calling put_pixel will not do this
618     if (mirror_y_axis) {
619         int32_t temp = y1;
620         y1 = m_height \- y0 \- 1;
621         y0 = m_height \- temp \- 1;
622     }
623 
624     // Draw the rectangle
625     for (int32_t y = y0; y < y1; ++y) {
626         for (int32_t x = x_min; x < x_max; ++x) {
627             putPixel(x, y, colour);
628         }
629     }
630 
631 }
.fi

.PP
References \fBfill_rectangle()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fillCircle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB702\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
702                                                                                         {
703 
704     // Make sure the circle is with in the width and height of the screen
705     if (x0 < 0) x0 = 0;
706     if (x0 > m_width) x0 = m_width;
707     if (y0 < 0) y0 = 0;
708     if (y0 > m_height) y0 = m_height;
709 
710     // Mirror the Y axis as directly calling put_pixel will not do this
711     if (mirror_y_axis)
712         y0 = m_height \- y0 \- 1;
713 
714     // Draw the circle
715 
716     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
717     for (int32_t x = \-radius; x <= radius; ++x) {
718 
719         // Draw a line from the top most point of the circle to the bottom most point of the circle
720         for (int32_t y = \-radius; y <= radius; ++y) {
721 
722             // Only draw the pixel if it is within the circle
723             if (x * x + y * y <= radius * radius)
724                 putPixel(x0 + x, y0 + y, colour);
725         }
726     }
727 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBfill_circle()\fP\&.
.SS "\fBuint64_t\fP * GraphicsContext::framebuffer_address ()"

.PP
Gets the address of the context's framebuffer to draw on\&. 
.PP
\fBReturns\fP
.RS 4
The framebuffer address 
.RE
.PP

.PP
Definition at line \fB734\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
734                                                {
735     return m_framebuffer_address;
736 }
.fi

.PP
References \fBm_framebuffer_address\fP\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (\fBint32_t\fP x, \fBint32_t\fP y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line \fB403\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
403                                                       {
404 
405     // Check if the pixel is within the bounds of the screen
406     if (0 > x || (uint32_t) x >= m_width || 0 > y || (uint32_t) y >= m_height)
407         return {0, 0, 0};
408 
409     // Get the pixel and convert it to a colour
410     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y);
411     return int_to_colour(translated_color);
412 }
.fi

.PP
References \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBm_height\fP, \fBm_width\fP, and \fBmirror_y_axis\fP\&.
.PP
Referenced by \fBinvert_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line \fB171\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
171                                                                    {
172     // Call the correct get_pixel function based on the color depth
173     switch (m_color_depth) {
174         case 8:
175             return get_rendered_pixel_8_bit(x, y);
176         case 16:
177             return get_rendered_pixel_16_bit(x, y);
178         case 24:
179             return get_rendered_pixel_24_bit(x, y);
180         case 32:
181             return get_rendered_pixel_32_bit(x, y);
182     }
183 
184     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
185 }
.fi

.PP
References \fBcolour_to_int()\fP, \fBget_rendered_pixel_16_bit()\fP, \fBget_rendered_pixel_24_bit()\fP, \fBget_rendered_pixel_32_bit()\fP, \fBget_rendered_pixel_8_bit()\fP, and \fBm_color_depth\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBuint16_t\fP GraphicsContext::get_rendered_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB205\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
205                                                                       {
206     return 0;
207 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB216\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
216                                                                       {
217     return 0;
218 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line \fB227\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
227                                                                       {
228     return 0;
229 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint8_t\fP GraphicsContext::get_rendered_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line \fB194\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
194                                                                     {
195     return 0;
196 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::height () const"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line \fB348\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
348                                        {
349     return m_height;
350 }
.fi

.PP
References \fBm_height\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::internal_set_mode()\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (\fBuint32_t\fP colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line \fB288\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
288                                                      {
289     switch (m_color_depth) {
290 
291         case 8: {
292             // Return the colour from the palette
293             return m_colour_pallet[colour & 0xFF];
294         }
295 
296         case 16: {
297             // 16\-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
298             Colour result;
299 
300             result\&.red = (colour & 0xF800) >> 8;
301             result\&.green = (colour & 0x07E0) >> 3;
302             result\&.blue = (colour & 0x001F) << 3;
303 
304             return result;
305         }
306 
307         case 24: {
308             // 24\-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
309             Colour result;
310 
311             result\&.red = (colour & 0xFF0000) >> 16;
312             result\&.green = (colour & 0x00FF00) >> 8;
313             result\&.blue = (colour & 0x0000FF);
314 
315             return result;
316         }
317 
318         default:
319         case 32: {
320             Colour result;
321 
322             uint32_t hex_value = colour;
323             result\&.red = (hex_value >> 16) & 0xFF;
324             result\&.green = (hex_value >> 8) & 0xFF;
325             result\&.blue = hex_value & 0xFF;
326             result\&.alpha = (hex_value >> 24) & 0xFF;
327 
328             return result;
329 
330         }
331     }
332 }
.fi

.PP
References \fBm_color_depth\fP, and \fBm_colour_pallet\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::invert_pixel (\fBint32_t\fP x, \fBint32_t\fP y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line \fB420\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
420                                                        {
421 
422     // Get the pixel
423     Colour colour = get_pixel(x, y);
424 
425     // Invert the pixel
426     colour\&.red = 255 \- colour\&.red;
427     colour\&.green = 255 \- colour\&.green;
428     colour\&.blue = 255 \- colour\&.blue;
429 
430     // Render the pixel
431     put_pixel(x, y, colour);
432 }
.fi

.PP
References \fBMaxOS::common::Colour::blue\fP, \fBget_pixel()\fP, \fBMaxOS::common::Colour::green\fP, \fBput_pixel()\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBMaxOS::gui::Desktop::invert_mouse_cursor()\fP\&.
.SS "\fBvoid\fP GraphicsContext::put_pixel (\fBint32_t\fP x, \fBint32_t\fP y, \fBconst\fP \fBColour\fP & colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB367\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
367                                                                           {
368 
369     // Convert the colour to an integer and then print it
370     putPixel(x, y, colour_to_int(colour));
371 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBinvert_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::putPixel (\fBint32_t\fP x, \fBint32_t\fP y, \fBuint32_t\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB380\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
380                                                                     {
381 
382     if (0 > x || (uint32_t) x >= m_width) {
383         return;
384     }
385 
386     // Check if the pixel is within the m_height of the screen
387     if (0 > y || (uint32_t) y >= m_height) {
388         return;
389     }
390 
391     // Render the pixel
392     render_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y, colour);
393 
394 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBrender_pixel()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB99\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
99                                                                           {
100 
101     // Call the correct put_pixel function based on the color depth
102     switch (m_color_depth) {
103         case 8:
104             render_pixel_8_bit(x, y, colour);
105             break;
106         case 16:
107             render_pixel_16_bit(x, y, colour);
108             break;
109         case 24:
110             render_pixel_24_bit(x, y, colour);
111             break;
112         case 32:
113             render_pixel_32_bit(x, y, colour);
114             break;
115     }
116 
117 
118 }
.fi

.PP
References \fBm_color_depth\fP, \fBrender_pixel_16_bit()\fP, \fBrender_pixel_24_bit()\fP, \fBrender_pixel_32_bit()\fP, and \fBrender_pixel_8_bit()\fP\&.
.PP
Referenced by \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB138\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
138                                                                       {
139 
140 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB149\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
149                                                                       {
150 
151 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line \fB160\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
160                                                                       {
161 
162 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line \fB127\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
127                                                                     {
128 
129 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::width () const"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line \fB339\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
339                                       {
340     return m_width;
341 }
.fi

.PP
References \fBm_width\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::internal_set_mode()\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBuint32_t\fP MaxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
Definition at line \fB26\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
26 { 0 };
.fi

.PP
Referenced by \fBcolor_depth()\fP, \fBcolour_to_int()\fP, \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBrender_pixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBColour\fP MaxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
Definition at line \fB28\fP of file \fBgraphicsContext\&.h\fP\&.
.PP
Referenced by \fBcolour_to_int()\fP, \fBGraphicsContext()\fP, and \fBint_to_colour()\fP\&.
.SS "\fBuint64_t\fP* MaxOS::common::GraphicsContext::m_framebuffer_address { \fBnullptr\fP }\fC [protected]\fP"

.PP
Definition at line \fB30\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
30 { nullptr };
.fi

.PP
Referenced by \fBframebuffer_address()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::get_rendered_pixel_32_bit()\fP, \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::render_pixel_32_bit()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP\&.
.SS "\fBint32_t\fP MaxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
Definition at line \fB25\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
25 { 0 };
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, \fBheight()\fP, \fBputPixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBint32_t\fP MaxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
Definition at line \fB24\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
24 { 0 };
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, \fBputPixel()\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, and \fBwidth()\fP\&.
.SS "\fBbool\fP MaxOS::common::GraphicsContext::mirror_y_axis { \fBfalse\fP }\fC [protected]\fP"

.PP
Definition at line \fB22\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
22 { false };
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, and \fBputPixel()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

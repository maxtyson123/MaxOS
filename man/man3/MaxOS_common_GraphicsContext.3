.TH "MaxOS::common::GraphicsContext" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBuint32_t\fP \fBcolour_to_int\fP (\fBconst\fP \fBColour\fP &)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (\fBuint32_t\fP)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBwidth\fP () \fBconst\fP"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBheight\fP () \fBconst\fP"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolor_depth\fP () \fBconst\fP"
.br
.RI "Gets the current color depth (bits per pixel) "
.ti -1c
.RI "\fBuint64_t\fP * \fBframebuffer_address\fP ()"
.br
.RI "Gets the address of the context's framebuffer to draw on\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "\fBvoid\fP \fBputPixel\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvert_pixel\fP (\fBint32_t\fP x, \fBint32_t\fP y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdrawLine\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBx1\fP, \fBint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfillCircle\fP (\fBint32_t\fP \fBx0\fP, \fBint32_t\fP \fBy0\fP, \fBint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint8_t\fP \fBget_rendered_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint16_t\fP \fBget_rendered_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBmirror_y_axis\fP { \fBfalse\fP }"
.br
.RI "Should the y axis be mirrored (0,0 is top left if false, bottom left if true) "
.ti -1c
.RI "\fBint32_t\fP \fBm_width\fP { 0 }"
.br
.RI "The width of the screen in pixels\&. "
.ti -1c
.RI "\fBint32_t\fP \fBm_height\fP { 0 }"
.br
.RI "The height of the screen in pixels\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_color_depth\fP { 0 }"
.br
.RI "The color depth of the screen in bits per pixel\&. "
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.RI "The colour pallet for 8 bit color depth\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBm_framebuffer_address\fP { \fBnullptr\fP }"
.br
.RI "The address of the framebuffer\&. "
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line \fB23\fP of file \fBgraphicsContext\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Definition at line \fB13\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
13                                  {
14 
15 
16     // VirtualBox VGA palette
17     m_colour_pallet[0x00] = Colour(0x00, 0x00, 0x00);    // Black
18     m_colour_pallet[0x01] = Colour(0x00, 0x00, 0xA8);    // Duke Blue
19     m_colour_pallet[0x02] = Colour(0x00, 0xA8, 0x00);    // Islamic Green
20     m_colour_pallet[0x03] = Colour(0x00, 0xA8, 0xA8);    // Persian Green
21     m_colour_pallet[0x04] = Colour(0xA8, 0x00, 0x00);    // Dark Candy Apple Red
22     m_colour_pallet[0x05] = Colour(0xA8, 0x00, 0xA8);    // Heliotrope Magenta
23 
24     m_colour_pallet[0x06] = Colour(0xA8, 0xA8, 0x00);    // Light Gold
25     m_colour_pallet[0x07] = Colour(0xA8, 0xA8, 0xA8);    // Dark Gray (X11)
26     m_colour_pallet[0x08] = Colour(0x00, 0x00, 0x57);    // Cetacean Blue
27     m_colour_pallet[0x09] = Colour(0x00, 0x00, 0xFF);    // Blue
28     m_colour_pallet[0x0A] = Colour(0x00, 0xA8, 0x57);    // Green (Pigment)
29     m_colour_pallet[0x0B] = Colour(0x00, 0xA8, 0xFF);    // Vivid Cerulean
30     m_colour_pallet[0x0C] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
31     m_colour_pallet[0x0D] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
32     m_colour_pallet[0x0E] = Colour(0xA8, 0xA8, 0x57);    // Olive Green
33     m_colour_pallet[0x0F] = Colour(0xA8, 0xA8, 0xFF);    // Maximum Blue Purple
34 
35     m_colour_pallet[0x10] = Colour(0x00, 0x57, 0x00);    // Dark Green (X11)
36     m_colour_pallet[0x11] = Colour(0x00, 0x57, 0xA8);    // Cobalt Blue
37     m_colour_pallet[0x12] = Colour(0x00, 0xFF, 0x00);    // Electric Green
38     m_colour_pallet[0x13] = Colour(0x00, 0xFF, 0xA8);    // Medium Spring Green
39     m_colour_pallet[0x14] = Colour(0xA8, 0x57, 0x00);    // Windsor Tan
40     m_colour_pallet[0x15] = Colour(0xA8, 0x57, 0xA8);    // Purpureus
41     m_colour_pallet[0x16] = Colour(0xA8, 0xFF, 0x00);    // Spring Bud
42     m_colour_pallet[0x17] = Colour(0xA8, 0xFF, 0xA8);    // Mint Green
43     m_colour_pallet[0x18] = Colour(0x00, 0x57, 0x57);    // Midnight Green (Eagle Green)
44     m_colour_pallet[0x19] = Colour(0x00, 0x57, 0xFF);    // Blue (RYB)
45     m_colour_pallet[0x1A] = Colour(0x00, 0xFF, 0x57);    // Malachite
46     m_colour_pallet[0x1B] = Colour(0x00, 0xFF, 0xFF);    // Aqua
47     m_colour_pallet[0x1C] = Colour(0xA8, 0x57, 0x57);    // Middle Red Purple
48     m_colour_pallet[0x1D] = Colour(0xA8, 0x57, 0xFF);    // Lavender Indigo
49     m_colour_pallet[0x1E] = Colour(0xA8, 0xFF, 0x57);    // Olive Green
50     m_colour_pallet[0x1F] = Colour(0xA8, 0xFF, 0xFF);    // Celeste
51 
52     m_colour_pallet[0x20] = Colour(0x57, 0x00, 0x00);    // Blood Red
53     m_colour_pallet[0x21] = Colour(0x57, 0x00, 0xA8);    // Metallic Violet
54     m_colour_pallet[0x22] = Colour(0x57, 0xA8, 0x00);    // Kelly Green
55     m_colour_pallet[0x23] = Colour(0x57, 0xA8, 0xA8);    // Cadet Blue
56     m_colour_pallet[0x24] = Colour(0xFF, 0x00, 0x00);    // Red
57     m_colour_pallet[0x25] = Colour(0xFF, 0x00, 0xA8);    // Fashion Fuchsia
58     m_colour_pallet[0x26] = Colour(0xFF, 0xA8, 0x00);    // Chrome Yellow
59     m_colour_pallet[0x27] = Colour(0xFF, 0xA8, 0xA8);    // Light Salmon Pink
60     m_colour_pallet[0x28] = Colour(0x57, 0x00, 0x57);    // Imperial Purple
61     m_colour_pallet[0x29] = Colour(0x57, 0x00, 0xFF);    // Electric Indigo
62     m_colour_pallet[0x2A] = Colour(0x57, 0xA8, 0x57);    // Apple
63     m_colour_pallet[0x2B] = Colour(0x57, 0xA8, 0xFF);    // Blue Jeans
64     m_colour_pallet[0x2C] = Colour(0xFF, 0x00, 0x57);    // Folly
65     m_colour_pallet[0x2D] = Colour(0xFF, 0x00, 0xFF);    // Fuchsia
66     m_colour_pallet[0x2E] = Colour(0xFF, 0xA8, 0x57);    // Rajah
67     m_colour_pallet[0x2F] = Colour(0xFF, 0xA8, 0xFF);    // Rich Brilliant Lavender
68 
69     m_colour_pallet[0x30] = Colour(0x57, 0x57, 0x00);    // Dark Bronze (Coin)
70     m_colour_pallet[0x31] = Colour(0x57, 0x57, 0xA8);    // Liberty
71     m_colour_pallet[0x32] = Colour(0x57, 0xFF, 0x00);    // Chlorophyll Green
72     m_colour_pallet[0x33] = Colour(0x57, 0xFF, 0xA8);    // Medium Aquamarine
73     m_colour_pallet[0x34] = Colour(0xFF, 0x57, 0x00);    // Orange (Pantone)
74     m_colour_pallet[0x35] = Colour(0xFF, 0x57, 0xA8);    // Brilliant Rose
75     m_colour_pallet[0x36] = Colour(0xFF, 0xFF, 0x00);    // Yellow
76     m_colour_pallet[0x37] = Colour(0xFF, 0xFF, 0xA8);    // Calamansi
77     m_colour_pallet[0x38] = Colour(0x57, 0x57, 0x57);    // Davy's Grey
78     m_colour_pallet[0x39] = Colour(0x57, 0x57, 0xFF);    // Very Light Blue
79     m_colour_pallet[0x3A] = Colour(0x57, 0xFF, 0x57);    // Screamin' Green
80     m_colour_pallet[0x3B] = Colour(0x57, 0xFF, 0xFF);    // Electric Blue
81     m_colour_pallet[0x3C] = Colour(0xFF, 0x57, 0x57);    // Sunset Orange
82     m_colour_pallet[0x3D] = Colour(0xFF, 0x57, 0xFF);    // Shocking Pink (Crayola)
83     m_colour_pallet[0x3E] = Colour(0xFF, 0xFF, 0x57);    // Shocking Pink (Crayola)
84     m_colour_pallet[0x3F] = Colour(0xFF, 0xFF, 0xFF);    // White
85 
86 
87     // Set the rest of the palette to black
88     for (uint8_t color_code = 255; color_code >= 0x40; \-\-color_code)
89         m_colour_pallet[color_code] = Colour(0, 0, 0);
90 
91 
92 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP GraphicsContext::color_depth () const"

.PP
Gets the current color depth (bits per pixel) 
.PP
\fBReturns\fP
.RS 4
The color depth 
.RE
.PP

.PP
Definition at line \fB360\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
360                                             {
361     return m_color_depth;
362 }
.fi

.PP
References \fBm_color_depth\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::colour_to_int (\fBconst\fP \fBColour\fP & colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line \fB241\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
241                                                             {
242 
243     switch (m_color_depth) {
244         case 8: {
245             uint32_t result = 0;
246             int mindistance = 0xfffffff;
247             for (uint32_t i = 0; i <= 255; ++i) {
248                 Colour *c = &m_colour_pallet[i];
249                 int distance =
250                         ((int) colour\&.red \- (int) c\->red) * ((int) colour\&.red \- (int) c\->red)
251                         + ((int) colour\&.green \- (int) c\->green) * ((int) colour\&.green \- (int) c\->green)
252                         + ((int) colour\&.blue \- (int) c\->blue) * ((int) colour\&.blue \- (int) c\->blue);
253                 if (distance < mindistance) {
254                     mindistance = distance;
255                     result = i;
256                 }
257             }
258             return result;
259         }
260         case 16: {
261             // 16\-Bit colours RRRRRGGGGGGBBBBB
262             return ((uint16_t) (colour\&.red & 0xF8)) << 8
263                    | ((uint16_t) (colour\&.green & 0xFC)) << 3
264                    | ((uint16_t) (colour\&.blue & 0xF8) >> 3);
265         }
266         case 24: {
267             return (uint32_t) colour\&.red << 16
268                    | (uint32_t) colour\&.green << 8
269                    | (uint32_t) colour\&.blue;
270         }
271         default:
272         case 32: {
273             uint32_t red_hex = ((uint32_t) colour\&.red & 0xFF) << 16;
274             uint32_t green_hex = ((uint32_t) colour\&.green & 0xFF) << 8;
275             uint32_t blue_hex = (uint32_t) colour\&.blue & 0xFF;
276             uint32_t alpha_hex = ((uint32_t) colour\&.alpha & 0xFF) << 24;
277 
278             uint32_t hexValue = red_hex | green_hex | blue_hex | alpha_hex;
279 
280 
281             return hexValue;
282         }
283     }
284 }
.fi

.PP
References \fBMaxOS::common::Colour::alpha\fP, \fBMaxOS::common::Colour::blue\fP, \fBMaxOS::common::Colour::green\fP, \fBm_color_depth\fP, \fBm_colour_pallet\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBdraw_rectangle()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_rendered_pixel()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB645\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
645                                                                                               {
646     draw_circle(x0, y0, radius, colour_to_int(colour));
647 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_circle()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB657\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
657                                                                                          {
658 
659     // Make sure the circle is with in the width and height of the screen
660     if (x0 < 0) x0 = 0;
661     if (x0 > m_width) x0 = m_width;
662     if (y0 < 0) y0 = 0;
663     if (y0 > m_height) y0 = m_height;
664 
665     // Mirror the Y axis as directly calling put_pixel will not do this
666     if (mirror_y_axis)
667         y0 = m_height \- y0 \- 1;
668 
669 
670     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
671     for (int32_t x = \-radius; x <= radius; ++x) {
672 
673         // Draw a line from the top most point of the circle to the bottom most point of the circle
674         for (int32_t y = \-radius; y <= radius; ++y) {
675 
676             // If the point is within the circle, draw it but make sure it is only part of the outline
677             if (x * x + y * y <= radius * radius && x * x + y * y >= (radius \- 1) * (radius \- 1))
678                 putPixel(x0 + x, y0 + y, colour);
679         }
680     }
681 
682 
683 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_line (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB448\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
448                                                                                                     {
449     drawLine(x0, y0, x1, y1, colour_to_int(colour));
450 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB550\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
550                                                                                                          {
551     draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
552 
553 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_rectangle()\fP\&.
.PP
Referenced by \fBdraw_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB564\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
564                                                                                                     {
565 
566     // Ensure x and y 0 is smaller than x and y 1
567     \-\-y0;
568     \-\-x0;
569 
570     // Draw the rectangle
571     drawLine(x0, y0, x1, y0, colour); // Top
572     drawLine(x0, y1, x1, y1, colour); // Bottom
573     drawLine(x0, y0, x0, y1, colour); // Left
574     drawLine(x1, y0, x1, y1, colour); // Right
575 
576 }
.fi

.PP
References \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::drawLine (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB461\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
461                                                                                               {
462 
463     // Store the minimum and maximum y values
464     bool y_0_is_smaller = y0 < y1;
465     int32_t y_min = y_0_is_smaller ? y0 : y1;
466     int32_t y_max = y_0_is_smaller ? y1 : y0;
467 
468     //Reverse the points to draw from left to right
469     if (x1 < x0) {
470         drawLine(x1, y1, x0, y0, colour);
471         return;
472     }
473 
474     // Vertical line
475     if (x1 == x0) {
476         // Force the line to be within the screen
477         if (y_min < 0) y_min = 0;
478         if (y_max >= m_height)
479             y_max = m_height \- 1;
480 
481         // Mirror the Y axis as directly calling put_pixel will not do this
482         if (mirror_y_axis) {
483             int32_t temp = y_max;
484             y_max = m_height \- y_min \- 1;
485             y_min = m_height \- temp \- 1;
486         }
487 
488         // Check that the line is within the screen
489         if (0 > x0 || (uint32_t) x0 >= m_width) {
490             return;
491         }
492 
493         // Draw the line
494         for (int32_t y = y_min; y <= y_max; ++y)
495             putPixel(x0, y, colour);
496 
497         return;
498     }
499 
500     // Horizontal line
501     if (y1 == y0) {
502         // Ensure the line is within the screen
503         if (x0 < 0) x0 = 0;
504         if (x1 >= m_width) x1 = m_width \- 1;
505 
506         // Mirror the Y axis as directly calling put_pixel will not do this
507         if (mirror_y_axis)
508             y0 = m_height \- y0 \- 1;
509 
510         // Check that the line is within the screen
511         if (0 > y0 || y0 >= m_height)
512             return;
513 
514         // Draw the line
515         for (int32_t x = x0; x <= x1; ++x)
516             putPixel(x, y0, colour);
517     }
518 
519     // If the line is not horizontal or vertical then it must be a diagonal line
520     // Find the slope of the line
521     float slope = ((float) (y1 \- y0)) / (x1 \- x0);
522 
523     // A slope that is more horizontal should be drawn by incrementing x
524     if (\-1 <= slope && slope <= 1) {
525         float y = y0;
526         for (int32_t x = x0; x <= x1; x++, y += slope)
527             putPixel(x, (int32_t) y, colour);
528     }
529 
530         // A slope that is more vertical should be drawn by incrementing y
531     else {
532         // Invert the slope
533         slope = 1\&.0f / slope;
534 
535         float x = x0;
536         for (int32_t y = y_min; y <= y_max; x += slope, y++)
537             putPixel((int32_t) x, y, colour);
538     }
539 }
.fi

.PP
References \fBdrawLine()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBdraw_line()\fP, \fBdraw_rectangle()\fP, and \fBdrawLine()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_circle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB693\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
693                                                                                               {
694     fillCircle(x0, y0, radius, colour_to_int(colour));
695 
696 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfillCircle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB587\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
587                                                                                                          {
588     fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
589 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfill_rectangle()\fP\&.
.PP
Referenced by \fBfill_rectangle()\fP, and \fBfill_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP x1, \fBint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB600\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
600                                                                                                     {
601 
602     // Draw from left to right
603     if (y1 < y0) {
604         fill_rectangle(x1, y1, x0, y0, colour);
605         return;
606     }
607 
608     // Make sure the rectangle is within the height of the screen
609     if (y0 < 0) y0 = 0;
610     if (y1 > m_height) y1 = m_height;
611 
612     // Make sure the rectangle is within the width of the screen
613     bool x_0_is_smaller = x0 < x1;
614     int32_t x_min = x_0_is_smaller ? x0 : x1;
615     int32_t x_max = x_0_is_smaller ? x1 : x0;
616 
617     if (x_min < 0) x_min = 0;
618     if (x_max > m_width)
619         x_max = m_width;
620 
621     // Mirror the Y axis as directly calling put_pixel will not do this
622     if (mirror_y_axis) {
623         int32_t temp = y1;
624         y1 = m_height \- y0 \- 1;
625         y0 = m_height \- temp \- 1;
626     }
627 
628     // Draw the rectangle
629     for (int32_t y = y0; y < y1; ++y) {
630         for (int32_t x = x_min; x < x_max; ++x) {
631             putPixel(x, y, colour);
632         }
633     }
634 
635 }
.fi

.PP
References \fBfill_rectangle()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fillCircle (\fBint32_t\fP x0, \fBint32_t\fP y0, \fBint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB706\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
706                                                                                         {
707 
708     // Make sure the circle is with in the width and height of the screen
709     if (x0 < 0) x0 = 0;
710     if (x0 > m_width) x0 = m_width;
711     if (y0 < 0) y0 = 0;
712     if (y0 > m_height) y0 = m_height;
713 
714     // Mirror the Y axis as directly calling put_pixel will not do this
715     if (mirror_y_axis)
716         y0 = m_height \- y0 \- 1;
717 
718     // Draw the circle
719 
720     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
721     for (int32_t x = \-radius; x <= radius; ++x) {
722 
723         // Draw a line from the top most point of the circle to the bottom most point of the circle
724         for (int32_t y = \-radius; y <= radius; ++y) {
725 
726             // Only draw the pixel if it is within the circle
727             if (x * x + y * y <= radius * radius)
728                 putPixel(x0 + x, y0 + y, colour);
729         }
730     }
731 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBfill_circle()\fP\&.
.SS "\fBuint64_t\fP * GraphicsContext::framebuffer_address ()"

.PP
Gets the address of the context's framebuffer to draw on\&. 
.PP
\fBReturns\fP
.RS 4
The framebuffer address 
.RE
.PP

.PP
Definition at line \fB738\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
738                                                {
739     return m_framebuffer_address;
740 }
.fi

.PP
References \fBm_framebuffer_address\fP\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (\fBint32_t\fP x, \fBint32_t\fP y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line \fB407\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
407                                                       {
408 
409     // Check if the pixel is within the bounds of the screen
410     if (0 > x || (uint32_t) x >= m_width || 0 > y || (uint32_t) y >= m_height)
411         return {0, 0, 0};
412 
413     // Get the pixel and convert it to a colour
414     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y);
415     return int_to_colour(translated_color);
416 }
.fi

.PP
References \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBm_height\fP, \fBm_width\fP, and \fBmirror_y_axis\fP\&.
.PP
Referenced by \fBinvert_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line \fB175\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
175                                                                    {
176     // Call the correct get_pixel function based on the color depth
177     switch (m_color_depth) {
178         case 8:
179             return get_rendered_pixel_8_bit(x, y);
180         case 16:
181             return get_rendered_pixel_16_bit(x, y);
182         case 24:
183             return get_rendered_pixel_24_bit(x, y);
184         case 32:
185             return get_rendered_pixel_32_bit(x, y);
186     }
187 
188     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
189 }
.fi

.PP
References \fBcolour_to_int()\fP, \fBget_rendered_pixel_16_bit()\fP, \fBget_rendered_pixel_24_bit()\fP, \fBget_rendered_pixel_32_bit()\fP, \fBget_rendered_pixel_8_bit()\fP, and \fBm_color_depth\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBuint16_t\fP GraphicsContext::get_rendered_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB209\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
209                                                                       {
210     return 0;
211 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB220\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
220                                                                       {
221     return 0;
222 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB231\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
231                                                                       {
232     return 0;
233 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint8_t\fP GraphicsContext::get_rendered_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB198\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
198                                                                     {
199     return 0;
200 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::height () const"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line \fB352\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
352                                        {
353     return m_height;
354 }
.fi

.PP
References \fBm_height\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (\fBuint32_t\fP colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line \fB292\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
292                                                      {
293     switch (m_color_depth) {
294 
295         case 8: {
296             // Return the colour from the palette
297             return m_colour_pallet[colour & 0xFF];
298         }
299 
300         case 16: {
301             // 16\-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
302             Colour result;
303 
304             result\&.red = (colour & 0xF800) >> 8;
305             result\&.green = (colour & 0x07E0) >> 3;
306             result\&.blue = (colour & 0x001F) << 3;
307 
308             return result;
309         }
310 
311         case 24: {
312             // 24\-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
313             Colour result;
314 
315             result\&.red = (colour & 0xFF0000) >> 16;
316             result\&.green = (colour & 0x00FF00) >> 8;
317             result\&.blue = (colour & 0x0000FF);
318 
319             return result;
320         }
321 
322         default:
323         case 32: {
324             Colour result;
325 
326             uint32_t hex_value = colour;
327             result\&.red = (hex_value >> 16) & 0xFF;
328             result\&.green = (hex_value >> 8) & 0xFF;
329             result\&.blue = hex_value & 0xFF;
330             result\&.alpha = (hex_value >> 24) & 0xFF;
331 
332             return result;
333 
334         }
335     }
336 }
.fi

.PP
References \fBm_color_depth\fP, and \fBm_colour_pallet\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::invert_pixel (\fBint32_t\fP x, \fBint32_t\fP y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line \fB424\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
424                                                        {
425 
426     // Get the pixel
427     Colour colour = get_pixel(x, y);
428 
429     // Invert the pixel
430     colour\&.red = 255 \- colour\&.red;
431     colour\&.green = 255 \- colour\&.green;
432     colour\&.blue = 255 \- colour\&.blue;
433 
434     // Render the pixel
435     put_pixel(x, y, colour);
436 }
.fi

.PP
References \fBMaxOS::common::Colour::blue\fP, \fBget_pixel()\fP, \fBMaxOS::common::Colour::green\fP, \fBput_pixel()\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBMaxOS::gui::Desktop::invert_mouse_cursor()\fP\&.
.SS "\fBvoid\fP GraphicsContext::put_pixel (\fBint32_t\fP x, \fBint32_t\fP y, \fBconst\fP \fBColour\fP & colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB371\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
371                                                                           {
372 
373     // Convert the colour to an integer and then print it
374     putPixel(x, y, colour_to_int(colour));
375 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBputPixel()\fP\&.
.PP
Referenced by \fBinvert_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::putPixel (\fBint32_t\fP x, \fBint32_t\fP y, \fBuint32_t\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB384\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
384                                                                     {
385 
386     if (0 > x || (uint32_t) x >= m_width) {
387         return;
388     }
389 
390     // Check if the pixel is within the m_height of the screen
391     if (0 > y || (uint32_t) y >= m_height) {
392         return;
393     }
394 
395     // Render the pixel
396     render_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y, colour);
397 
398 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBrender_pixel()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB103\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
103                                                                           {
104 
105     // Call the correct put_pixel function based on the color depth
106     switch (m_color_depth) {
107         case 8:
108             render_pixel_8_bit(x, y, colour);
109             break;
110         case 16:
111             render_pixel_16_bit(x, y, colour);
112             break;
113         case 24:
114             render_pixel_24_bit(x, y, colour);
115             break;
116         case 32:
117             render_pixel_32_bit(x, y, colour);
118             break;
119     }
120 
121 
122 }
.fi

.PP
References \fBm_color_depth\fP, \fBrender_pixel_16_bit()\fP, \fBrender_pixel_24_bit()\fP, \fBrender_pixel_32_bit()\fP, and \fBrender_pixel_8_bit()\fP\&.
.PP
Referenced by \fBputPixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB142\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
142                                                                       {
143 
144 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB153\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
153                                                                       {
154 
155 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB164\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
164                                                                       {
165 
166 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB131\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
131                                                                     {
132 
133 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::width () const"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line \fB343\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
343                                       {
344     return m_width;
345 }
.fi

.PP
References \fBm_width\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBuint32_t\fP MaxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
The color depth of the screen in bits per pixel\&. 
.PP
Definition at line \fB30\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
30 { 0 };    
.fi

.PP
Referenced by \fBcolor_depth()\fP, \fBcolour_to_int()\fP, \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBrender_pixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBColour\fP MaxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
The colour pallet for 8 bit color depth\&. 
.PP
\fBTodo\fP
.RS 4
make const 
.RE
.PP

.PP
Definition at line \fB32\fP of file \fBgraphicsContext\&.h\fP\&.
.PP
Referenced by \fBcolour_to_int()\fP, and \fBint_to_colour()\fP\&.
.SS "\fBuint64_t\fP* MaxOS::common::GraphicsContext::m_framebuffer_address { \fBnullptr\fP }\fC [protected]\fP"

.PP
The address of the framebuffer\&. 
.PP
Definition at line \fB34\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
34 { nullptr }; 
.fi

.PP
Referenced by \fBframebuffer_address()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP\&.
.SS "\fBint32_t\fP MaxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
The height of the screen in pixels\&. 
.PP
Definition at line \fB29\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
29 { 0 };          
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, \fBheight()\fP, \fBputPixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBint32_t\fP MaxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
The width of the screen in pixels\&. 
.PP
Definition at line \fB28\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
28 { 0 };           
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, \fBputPixel()\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, and \fBwidth()\fP\&.
.SS "\fBbool\fP MaxOS::common::GraphicsContext::mirror_y_axis { \fBfalse\fP }\fC [protected]\fP"

.PP
Should the y axis be mirrored (0,0 is top left if false, bottom left if true) 
.PP
Definition at line \fB26\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
26 { false };    
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdrawLine()\fP, \fBfill_rectangle()\fP, \fBfillCircle()\fP, \fBget_pixel()\fP, and \fBputPixel()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

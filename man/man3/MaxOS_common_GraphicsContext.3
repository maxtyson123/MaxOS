.TH "MaxOS::common::GraphicsContext" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.ti -1c
.RI "\fB~GraphicsContext\fP ()"
.br
.ti -1c
.RI "uint32_t \fBcolour_to_int\fP (\fBColour\fP)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (uint32_t)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "uint32_t \fBget_width\fP ()"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "uint32_t \fBget_height\fP ()"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "uint32_t \fBget_color_depth\fP ()"
.br
.ti -1c
.RI "uint64_t * \fBget_framebuffer_address\fP ()"
.br
.ti -1c
.RI "void \fBput_pixel\fP (int32_t x, int32_t y, \fBColour\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "void \fBputPixel\fP (int32_t x, int32_t y, int32_t colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "void \fBinvert_pixel\fP (int32_t x, int32_t y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "void \fBdraw_line\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdrawLine\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBdraw_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfill_rectangle\fP (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBdraw_circle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "void \fBfill_circle\fP (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "void \fBfillCircle\fP (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBrender_pixel\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_8_bit\fP (uint32_t x, uint32_t y, uint8_t colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_16_bit\fP (uint32_t x, uint32_t y, uint16_t colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_24_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual void \fBrender_pixel_32_bit\fP (uint32_t x, uint32_t y, uint32_t colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "virtual uint8_t \fBget_rendered_pixel_8_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "virtual uint16_t \fBget_rendered_pixel_16_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_24_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "virtual uint32_t \fBget_rendered_pixel_32_bit\fP (uint32_t x, uint32_t y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBmirror_y_axis\fP { false }"
.br
.ti -1c
.RI "uint32_t \fBm_width\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_height\fP { 0 }"
.br
.ti -1c
.RI "uint32_t \fBm_color_depth\fP { 0 }"
.br
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.ti -1c
.RI "uint64_t * \fBm_framebuffer_address\fP { nullptr }"
.br
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line 19 of file graphicsContext\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Definition at line 11 of file graphicsContext\&.cpp\&.
.PP
.nf
12 {
13 
14 
15     // VirtualBox VGA palette
16     m_colour_pallet[0x00] = Colour(0x00,0x00,0x00);    // Black
17     m_colour_pallet[0x01] = Colour(0x00,0x00,0xA8);    // Duke Blue
18     m_colour_pallet[0x02] = Colour(0x00,0xA8,0x00);    // Islamic Green
19     m_colour_pallet[0x03] = Colour(0x00,0xA8,0xA8);    // Persian Green
20     m_colour_pallet[0x04] = Colour(0xA8,0x00,0x00);    // Dark Candy Apple Red
21     m_colour_pallet[0x05] = Colour(0xA8,0x00,0xA8);    // Heliotrope Magenta
22 
23     m_colour_pallet[0x06] = Colour(0xA8,0xA8,0x00);    // Light Gold
24     m_colour_pallet[0x07] = Colour(0xA8,0xA8,0xA8);    // Dark Gray (X11)
25     m_colour_pallet[0x08] = Colour(0x00,0x00,0x57);    // Cetacean Blue
26     m_colour_pallet[0x09] = Colour(0x00,0x00,0xFF);    // Blue
27     m_colour_pallet[0x0A] = Colour(0x00,0xA8,0x57);    // Green (Pigment)
28     m_colour_pallet[0x0B] = Colour(0x00,0xA8,0xFF);    // Vivid Cerulean
29     m_colour_pallet[0x0C] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
30     m_colour_pallet[0x0D] = Colour(0xA8,0x00,0x57);    // Jazzberry Jam
31     m_colour_pallet[0x0E] = Colour(0xA8,0xA8,0x57);    // Olive Green
32     m_colour_pallet[0x0F] = Colour(0xA8,0xA8,0xFF);    // Maximum Blue Purple
33 
34     m_colour_pallet[0x10] = Colour(0x00,0x57,0x00);    // Dark Green (X11)
35     m_colour_pallet[0x11] = Colour(0x00,0x57,0xA8);    // Cobalt Blue
36     m_colour_pallet[0x12] = Colour(0x00,0xFF,0x00);    // Electric Green
37     m_colour_pallet[0x13] = Colour(0x00,0xFF,0xA8);    // Medium Spring Green
38     m_colour_pallet[0x14] = Colour(0xA8,0x57,0x00);    // Windsor Tan
39     m_colour_pallet[0x15] = Colour(0xA8,0x57,0xA8);    // Purpureus
40     m_colour_pallet[0x16] = Colour(0xA8,0xFF,0x00);    // Spring Bud
41     m_colour_pallet[0x17] = Colour(0xA8,0xFF,0xA8);    // Mint Green
42     m_colour_pallet[0x18] = Colour(0x00,0x57,0x57);    // Midnight Green (Eagle Green)
43     m_colour_pallet[0x19] = Colour(0x00,0x57,0xFF);    // Blue (RYB)
44     m_colour_pallet[0x1A] = Colour(0x00,0xFF,0x57);    // Malachite
45     m_colour_pallet[0x1B] = Colour(0x00,0xFF,0xFF);    // Aqua
46     m_colour_pallet[0x1C] = Colour(0xA8,0x57,0x57);    // Middle Red Purple
47     m_colour_pallet[0x1D] = Colour(0xA8,0x57,0xFF);    // Lavender Indigo
48     m_colour_pallet[0x1E] = Colour(0xA8,0xFF,0x57);    // Olive Green
49     m_colour_pallet[0x1F] = Colour(0xA8,0xFF,0xFF);    // Celeste
50 
51     m_colour_pallet[0x20] = Colour(0x57,0x00,0x00);    // Blood Red
52     m_colour_pallet[0x21] = Colour(0x57,0x00,0xA8);    // Metallic Violet
53     m_colour_pallet[0x22] = Colour(0x57,0xA8,0x00);    // Kelly Green
54     m_colour_pallet[0x23] = Colour(0x57,0xA8,0xA8);    // Cadet Blue
55     m_colour_pallet[0x24] = Colour(0xFF,0x00,0x00);    // Red
56     m_colour_pallet[0x25] = Colour(0xFF,0x00,0xA8);    // Fashion Fuchsia
57     m_colour_pallet[0x26] = Colour(0xFF,0xA8,0x00);    // Chrome Yellow
58     m_colour_pallet[0x27] = Colour(0xFF,0xA8,0xA8);    // Light Salmon Pink
59     m_colour_pallet[0x28] = Colour(0x57,0x00,0x57);    // Imperial Purple
60     m_colour_pallet[0x29] = Colour(0x57,0x00,0xFF);    // Electric Indigo
61     m_colour_pallet[0x2A] = Colour(0x57,0xA8,0x57);    // Apple
62     m_colour_pallet[0x2B] = Colour(0x57,0xA8,0xFF);    // Blue Jeans
63     m_colour_pallet[0x2C] = Colour(0xFF,0x00,0x57);    // Folly
64     m_colour_pallet[0x2D] = Colour(0xFF,0x00,0xFF);    // Fuchsia
65     m_colour_pallet[0x2E] = Colour(0xFF,0xA8,0x57);    // Rajah
66     m_colour_pallet[0x2F] = Colour(0xFF,0xA8,0xFF);    // Rich Brilliant Lavender
67 
68     m_colour_pallet[0x30] = Colour(0x57,0x57,0x00);    // Dark Bronze (Coin)
69     m_colour_pallet[0x31] = Colour(0x57,0x57,0xA8);    // Liberty
70     m_colour_pallet[0x32] = Colour(0x57,0xFF,0x00);    // Chlorophyll Green
71     m_colour_pallet[0x33] = Colour(0x57,0xFF,0xA8);    // Medium Aquamarine
72     m_colour_pallet[0x34] = Colour(0xFF,0x57,0x00);    // Orange (Pantone)
73     m_colour_pallet[0x35] = Colour(0xFF,0x57,0xA8);    // Brilliant Rose
74     m_colour_pallet[0x36] = Colour(0xFF,0xFF,0x00);    // Yellow
75     m_colour_pallet[0x37] = Colour(0xFF,0xFF,0xA8);    // Calamansi
76     m_colour_pallet[0x38] = Colour(0x57,0x57,0x57);    // Davy's Grey
77     m_colour_pallet[0x39] = Colour(0x57,0x57,0xFF);    // Very Light Blue
78     m_colour_pallet[0x3A] = Colour(0x57,0xFF,0x57);    // Screamin' Green
79     m_colour_pallet[0x3B] = Colour(0x57,0xFF,0xFF);    // Electric Blue
80     m_colour_pallet[0x3C] = Colour(0xFF,0x57,0x57);    // Sunset Orange
81     m_colour_pallet[0x3D] = Colour(0xFF,0x57,0xFF);    // Shocking Pink (Crayola)
82     m_colour_pallet[0x3E] = Colour(0xFF,0xFF,0x57);    // Shocking Pink (Crayola)
83     m_colour_pallet[0x3F] = Colour(0xFF,0xFF,0xFF);    // White
84 
85 
86     // Set the rest of the palette to black
87     for(uint8_t color_code = 255; color_code >= 0x40; --color_code)
88       m_colour_pallet[color_code] = Colour(0,0,0);
89 
90 
91 }
.fi
.PP
References m_colour_pallet\&.
.SS "GraphicsContext::~GraphicsContext ()"

.PP
Definition at line 93 of file graphicsContext\&.cpp\&.
.PP
.nf
93                                   {
94 
95 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "uint32_t GraphicsContext::colour_to_int (\fBColour\fP colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line 242 of file graphicsContext\&.cpp\&.
.PP
.nf
242                                                      {
243 
244     switch(m_color_depth)
245     {
246         case 8:
247         {
248             uint32_t result = 0;
249             int mindistance = 0xfffffff;
250             for(uint32_t i = 0; i <= 255; ++i)
251             {
252                 Colour* c = &m_colour_pallet[i];
253                 int distance =
254                         ((int)colour\&.red-(int)c->red)*((int)colour\&.red-(int)c->red)
255                         +((int)colour\&.green-(int)c->green)*((int)colour\&.green-(int)c->green)
256                         +((int)colour\&.blue-(int)c->blue)*((int)colour\&.blue-(int)c->blue);
257                 if(distance < mindistance)
258                 {
259                     mindistance = distance;
260                     result = i;
261                 }
262             }
263             return result;
264         }
265         case 16:
266         {
267             // 16-Bit colours RRRRRGGGGGGBBBBB
268             return ((uint16_t)(colour\&.red   & 0xF8)) << 8
269                    | ((uint16_t)(colour\&.green & 0xFC)) << 3
270                    | ((uint16_t)(colour\&.blue  & 0xF8) >> 3);
271         }
272         case 24:
273         {
274             return (uint32_t)colour\&.red   << 16
275                    | (uint32_t)colour\&.green << 8
276                    | (uint32_t)colour\&.blue;
277         }
278         default:
279         case 32:
280         {
281             uint32_t red_hex = ((uint32_t)colour\&.red & 0xFF) << 16;
282             uint32_t green_hex = ((uint32_t)colour\&.green & 0xFF) << 8;
283             uint32_t blue_hex = (uint32_t)colour\&.blue & 0xFF;
284             uint32_t alpha_hex = ((uint32_t)colour\&.alpha & 0xFF) << 24;
285 
286             uint32_t hexValue = red_hex | green_hex | blue_hex | alpha_hex;
287 
288 
289             return hexValue;
290         }
291     }
292 }
.fi
.PP
References MaxOS::common::Colour::alpha, MaxOS::common::Colour::blue, MaxOS::drivers::peripherals::c, MaxOS::common::Colour::green, MaxOS::drivers::peripherals::i, m_color_depth, m_colour_pallet, and MaxOS::common::Colour::red\&.
.PP
Referenced by draw_circle(), draw_line(), draw_rectangle(), MaxOS::gui::Font::draw_text(), fill_circle(), fill_rectangle(), get_rendered_pixel(), put_pixel(), and MaxOS::drivers::console::VESABootConsole::scroll_up()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 673 of file graphicsContext\&.cpp\&.
.PP
.nf
673                                                                                       {
674   draw_circle(x0, y0, radius, colour_to_int(colour));
675 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_circle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 685 of file graphicsContext\&.cpp\&.
.PP
.nf
685                                                                                          {
686 
687     // Make sure the circle is with in the width and height of the screen
688     if(x0 < 0) x0 = 0;
689     if((uint32_t)x0 > m_width) x0 = m_width;
690     if(y0 < 0) y0 = 0;
691     if((uint32_t)y0 > m_height) y0 = m_height;
692 
693     // Mirror the Y axis as directly calling put_pixel will not do this
694     if(mirror_y_axis)
695         y0 = m_height -y0-1;
696 
697 
698     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
699     for(int32_t x = -radius; x <= radius; ++x){
700 
701         // Draw a line from the top most point of the circle to the bottom most point of the circle
702         for(int32_t y = -radius; y <= radius; ++y){
703 
704             // If the point is within the circle, draw it but make sure it is only part of the outline
705             if(x*x + y*y <= radius*radius && x*x + y*y >= (radius-1)*(radius-1))
706                 putPixel(x0+x,y0+y,colour);
707         }
708     }
709 
710 
711 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::draw_line (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 467 of file graphicsContext\&.cpp\&.
.PP
.nf
467                                                                                              {
468     drawLine(x0,y0,x1,y1, colour_to_int(colour));
469 }
.fi
.PP
References colour_to_int(), and drawLine()\&.
.PP
Referenced by MaxOS::gui::widgets::InputBox::draw(), and MaxOS::gui::widgets::Button::draw()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 577 of file graphicsContext\&.cpp\&.
.PP
.nf
577                                                                                                   {
578   draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
579 
580 }
.fi
.PP
References colour_to_int()\&.
.SS "void GraphicsContext::draw_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 591 of file graphicsContext\&.cpp\&.
.PP
.nf
591                                                                                                     {
592 
593     // Ensure x and y 0 is smaller than x and y 1
594     --y0;
595     --x0;
596 
597     // Draw the rectangle
598     drawLine(x0,y0,x1,y0,colour); // Top
599     drawLine(x0,y1,x1,y1,colour); // Bottom
600     drawLine(x0,y0,x0,y1,colour); // Left
601     drawLine(x1,y0,x1,y1,colour); // Right
602 
603 }
.fi
.PP
References drawLine()\&.
.SS "void GraphicsContext::drawLine (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line 480 of file graphicsContext\&.cpp\&.
.PP
.nf
480                                                                                               {
481 
482     // Store the minimum and maximum y values
483     bool y_0_is_smaller = y0 < y1;
484     int32_t y_min = y_0_is_smaller ? y0 : y1;
485     int32_t y_max = y_0_is_smaller ? y1 : y0;
486 
487     //Reverse the points to draw from left to right
488     if(x1 < x0){
489         drawLine(x1,y1,x0,y0,colour);
490         return;
491     }
492 
493     // Vertical line
494     if(x1 == x0)
495     {
496         // Force the line to be within the screen
497         if(y_min < 0) y_min = 0;
498         if((uint32_t)y_max >= m_height)
499           y_max = m_height - 1;
500 
501         // Mirror the Y axis as directly calling put_pixel will not do this
502         if(mirror_y_axis)
503         {
504             int32_t temp = y_max;
505             y_max = m_height - y_min - 1;
506             y_min = m_height - temp - 1;
507         }
508 
509         // Check that the line is within the screen
510         if (0 > x0 || (uint32_t) x0 >= m_width) {
511             return;
512         }
513 
514         // Draw the line
515         for(int32_t y = y_min; y <= y_max; ++y)
516             putPixel(x0, y, colour);
517 
518         return;
519     }
520 
521     // Horizontal line
522     if(y1 == y0)
523     {
524         // Ensure the line is within the screen
525         if(x0 < 0) x0 = 0;
526         if((uint32_t)x1 >= m_width) x1 = m_width -1;
527 
528         // Mirror the Y axis as directly calling put_pixel will not do this
529         if(mirror_y_axis)
530             y0 = m_height -y0-1;
531 
532         // Check that the line is within the screen
533         if (0 > y0 || (uint32_t) y0 >= m_height)
534             return;
535 
536         // Draw the line
537         for(int32_t x = x0; x <= x1; ++x)
538             putPixel(x,y0,colour);
539     }
540 
541     // TODO: Slope once SSE is implemented
542     return;
543 
544     // If the line is not horizontal or vertical then it must be a diagonal line
545     // Find the slope of the line
546     float slope = ((float)(y1-y0))/(x1-x0);
547 
548     // A slope that is more horizontal should be drawn by incrementing x
549     if(-1 <= slope && slope <= 1)
550     {
551         float y = y0;
552         for(int32_t x = x0; x <= x1; x++, y+=slope)
553             putPixel(x, (int32_t)y, colour);
554     }
555 
556     // A slope that is more vertical should be drawn by incrementing y
557     else
558     {
559         // Invert the slope
560         slope = 1\&.0f/slope;
561 
562         float x = x0;
563         for(int32_t y = y_min; y <= y_max; x+=slope, y++)
564             putPixel((int32_t)x, y, colour);
565     }
566 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_line(), and draw_rectangle()\&.
.SS "void GraphicsContext::fill_circle (int32_t x0, int32_t y0, int32_t radius, \fBColour\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 721 of file graphicsContext\&.cpp\&.
.PP
.nf
721                                                                                        {
722     fillCircle(x0,y0,radius, colour_to_int(colour));
723 
724 }
.fi
.PP
References colour_to_int(), and fillCircle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, \fBColour\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 614 of file graphicsContext\&.cpp\&.
.PP
.nf
614                                                                                                   {
615   fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
616 }
.fi
.PP
References colour_to_int()\&.
.PP
Referenced by MaxOS::gui::widgets::Text::draw(), MaxOS::gui::widgets::InputBox::draw(), MaxOS::gui::widgets::Button::draw(), MaxOS::gui::Desktop::draw_self(), MaxOS::gui::Window::draw_self(), and fill_rectangle()\&.
.SS "void GraphicsContext::fill_rectangle (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line 627 of file graphicsContext\&.cpp\&.
.PP
.nf
627                                                                                                     {
628 
629     // Draw from left to right
630     if(y1 < y0){
631         fill_rectangle(x1, y1, x0, y0, colour);
632         return;
633     }
634 
635     // Make sure the rectangle is within the height of the screen
636     if(y0 < 0) y0 = 0;
637     if((uint32_t)y1 > m_height) y1 = m_height;
638 
639     // Make sure the rectangle is within the width of the screen
640     bool x_0_is_smaller = x0 < x1;
641     int32_t x_min = x_0_is_smaller ? x0 : x1;
642     int32_t x_max = x_0_is_smaller ? x1 : x0;
643 
644     if(x_min < 0) x_min = 0;
645     if((uint32_t)x_max > m_width)
646       x_max = m_width;
647 
648     // Mirror the Y axis as directly calling put_pixel will not do this
649     if(mirror_y_axis)
650     {
651         uint32_t temp = y1;
652         y1 = m_height - y0 - 1;
653         y0 = m_height - temp - 1;
654     }
655 
656     // Draw the rectangle
657     for(int32_t y = y0; y < y1; ++y){
658         for (int32_t x = x_min; x < x_max; ++x) {
659             putPixel(x, y, colour);
660         }
661     }
662 
663 }
.fi
.PP
References fill_rectangle(), m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "void GraphicsContext::fillCircle (int32_t x0, int32_t y0, int32_t radius, uint32_t colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line 734 of file graphicsContext\&.cpp\&.
.PP
.nf
734                                                                                         {
735 
736         // Make sure the circle is with in the width and height of the screen
737         if(x0 < 0) x0 = 0;
738         if((uint32_t)x0 > m_width) x0 = m_width;
739         if(y0 < 0) y0 = 0;
740         if((uint32_t)y0 > m_height) y0 = m_height;
741 
742         // Mirror the Y axis as directly calling put_pixel will not do this
743         if(mirror_y_axis)
744             y0 = m_height -y0-1;
745 
746         // Draw the circle
747 
748         // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
749         for(int32_t x = -radius; x <= radius; ++x){
750 
751             // Draw a line from the top most point of the circle to the bottom most point of the circle
752             for(int32_t y = -radius; y <= radius; ++y){
753 
754                 // Only draw the pixel if it is within the circle
755                 if(x*x + y*y <= radius*radius)
756                     putPixel(x0+x,y0+y,colour);
757             }
758         }
759 }
.fi
.PP
References m_height, m_width, mirror_y_axis, putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by fill_circle()\&.
.SS "uint32_t GraphicsContext::get_color_depth ()"
@breif Gets the current color depth (bits per pixel) 
.PP
\fBReturns\fP
.RS 4
The color depth 
.RE
.PP

.PP
Definition at line 372 of file graphicsContext\&.cpp\&.
.PP
.nf
372                                           {
373   return m_color_depth;
374 }
.fi
.PP
References m_color_depth\&.
.PP
Referenced by MaxOS::drivers::console::VESABootConsole::scroll_up()\&.
.SS "uint64_t * GraphicsContext::get_framebuffer_address ()"

.PP
Definition at line 760 of file graphicsContext\&.cpp\&.
.PP
.nf
760                                                    {
761     return m_framebuffer_address;
762 }
.fi
.PP
References m_framebuffer_address\&.
.PP
Referenced by MaxOS::drivers::console::VESABootConsole::scroll_up()\&.
.SS "uint32_t GraphicsContext::get_height ()"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line 364 of file graphicsContext\&.cpp\&.
.PP
.nf
364                                      {
365     return m_height;
366 }
.fi
.PP
References m_height\&.
.PP
Referenced by MaxOS::gui::Desktop::Desktop(), MaxOS::drivers::console::VESABootConsole::height(), and MaxOS::drivers::console::VESABootConsole::scroll_up()\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (int32_t x, int32_t y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line 419 of file graphicsContext\&.cpp\&.
.PP
.nf
419                                                       {
420 
421     // Check if the pixel is within the m_width of the screen
422     if (0 > x || (uint32_t)x >= m_width) {
423         return Colour(0,0,0);
424     }
425 
426     // Check if the pixel is within the m_height of the screen
427     if (0 > y || (uint32_t) y >= m_height) {
428         return Colour(0,0,0);
429     }
430 
431     // Get the pixel and convert it to a colour
432     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height - y - 1 : y);
433     return int_to_colour(translated_color);
434 
435 
436 }
.fi
.PP
References get_rendered_pixel(), int_to_colour(), m_height, m_width, mirror_y_axis, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line 176 of file graphicsContext\&.cpp\&.
.PP
.nf
176                                                                    {
177     // Call the correct get_pixel function based on the color depth
178     switch (m_color_depth) {
179         case 8:
180             return get_rendered_pixel_8_bit(x, y);
181         case 16:
182             return get_rendered_pixel_16_bit(x, y);
183         case 24:
184             return get_rendered_pixel_24_bit(x, y);
185         case 32:
186             return get_rendered_pixel_32_bit(x, y);
187     }
188 
189     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
190 }
.fi
.PP
References colour_to_int(), get_rendered_pixel_16_bit(), get_rendered_pixel_24_bit(), get_rendered_pixel_32_bit(), get_rendered_pixel_8_bit(), m_color_depth, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by get_pixel()\&.
.SS "uint16_t GraphicsContext::get_rendered_pixel_16_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 210 of file graphicsContext\&.cpp\&.
.PP
.nf
210                                                                       {
211     return 0;
212 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_24_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 221 of file graphicsContext\&.cpp\&.
.PP
.nf
221                                                                       {
222     return 0;
223 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_rendered_pixel_32_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 232 of file graphicsContext\&.cpp\&.
.PP
.nf
232                                                                       {
233     return 0;
234 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint8_t GraphicsContext::get_rendered_pixel_8_bit (uint32_t x, uint32_t y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 199 of file graphicsContext\&.cpp\&.
.PP
.nf
199                                                                     {
200     return 0;
201 }
.fi
.PP
Referenced by get_rendered_pixel()\&.
.SS "uint32_t GraphicsContext::get_width ()"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line 355 of file graphicsContext\&.cpp\&.
.PP
.nf
355                                     {
356     return m_width;
357 }
.fi
.PP
References m_width\&.
.PP
Referenced by MaxOS::gui::Desktop::Desktop(), MaxOS::drivers::console::VESABootConsole::scroll_up(), and MaxOS::drivers::console::VESABootConsole::width()\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (uint32_t colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line 300 of file graphicsContext\&.cpp\&.
.PP
.nf
300                                                      {
301     switch (m_color_depth) {
302 
303         case 8:
304         {
305             // Return the colour from the palette
306             return m_colour_pallet[colour & 0xFF];
307         }
308 
309         case 16:
310         {
311             // 16-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
312             Colour result;
313 
314             result\&.red = (colour & 0xF800) >> 8;
315             result\&.green = (colour & 0x07E0) >> 3;
316             result\&.blue = (colour & 0x001F) << 3;
317 
318             return result;
319         }
320 
321         case 24:
322         {
323             // 24-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
324             Colour result;
325 
326             result\&.red = (colour & 0xFF0000) >> 16;
327             result\&.green = (colour & 0x00FF00) >> 8;
328             result\&.blue = (colour & 0x0000FF);
329 
330             return result;
331         }
332 
333         default:
334         case 32:
335         {
336             Colour result;
337 
338             uint32_t hex_value = colour;
339             result\&.red = (hex_value >> 16) & 0xFF;
340             result\&.green = (hex_value >> 8) & 0xFF;
341             result\&.blue = hex_value & 0xFF;
342             result\&.alpha = (hex_value >> 24) & 0xFF;
343 
344             return result;
345 
346         }
347     }
348 }
.fi
.PP
References MaxOS::common::Colour::alpha, MaxOS::common::Colour::blue, MaxOS::common::Colour::green, m_color_depth, m_colour_pallet, and MaxOS::common::Colour::red\&.
.PP
Referenced by get_pixel()\&.
.SS "void GraphicsContext::invert_pixel (int32_t x, int32_t y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line 444 of file graphicsContext\&.cpp\&.
.PP
.nf
444                                                        {
445     // Get the pixel
446     Colour colour = get_pixel(x, y);
447 
448     // Invert the pixel
449     colour\&.red = 255 - colour\&.red;
450     colour\&.green = 255 - colour\&.green;
451     colour\&.blue = 255 - colour\&.blue;
452 
453     // Render the pixel
454     put_pixel(x, y, colour);
455 }
.fi
.PP
References MaxOS::common::Colour::blue, get_pixel(), MaxOS::common::Colour::green, put_pixel(), MaxOS::common::Colour::red, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by MaxOS::gui::Desktop::invert_mouse_cursor()\&.
.SS "void GraphicsContext::put_pixel (int32_t x, int32_t y, \fBColour\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 383 of file graphicsContext\&.cpp\&.
.PP
.nf
383                                                                    {
384 
385     // Convert the colour to an integer and then print it
386     putPixel(x,y, colour_to_int(colour));
387 }
.fi
.PP
References colour_to_int(), putPixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by invert_pixel()\&.
.SS "void GraphicsContext::putPixel (int32_t x, int32_t y, int32_t colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 396 of file graphicsContext\&.cpp\&.
.PP
.nf
396                                                                    {
397 
398     if (0 > x || (uint32_t)x >= m_width) {
399         return;
400     }
401 
402     // Check if the pixel is within the m_height of the screen
403     if (0 > y || (uint32_t) y >= m_height) {
404         return;
405     }
406 
407     // Render the pixel
408     render_pixel(x, mirror_y_axis ? m_height - y - 1 : y, colour);
409 
410 }
.fi
.PP
References m_height, m_width, mirror_y_axis, render_pixel(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), and put_pixel()\&.
.SS "void GraphicsContext::render_pixel (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line 104 of file graphicsContext\&.cpp\&.
.PP
.nf
104                                                                           {
105 
106     // Call the correct put_pixel function based on the color depth
107     switch (m_color_depth) {
108         case 8:
109           render_pixel_8_bit(x, y, colour);
110             break;
111         case 16:
112           render_pixel_16_bit(x, y, colour);
113             break;
114         case 24:
115           render_pixel_24_bit(x, y, colour);
116             break;
117         case 32:
118           render_pixel_32_bit(x, y, colour);
119             break;
120     }
121 
122 
123 }
.fi
.PP
References m_color_depth, render_pixel_16_bit(), render_pixel_24_bit(), render_pixel_32_bit(), render_pixel_8_bit(), MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by putPixel()\&.
.SS "void GraphicsContext::render_pixel_16_bit (uint32_t x, uint32_t y, uint16_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 143 of file graphicsContext\&.cpp\&.
.PP
.nf
143                                                                       {
144 
145 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_24_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line 154 of file graphicsContext\&.cpp\&.
.PP
.nf
154                                                                       {
155 
156 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_32_bit (uint32_t x, uint32_t y, uint32_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation\fP\&.
.PP
Definition at line 165 of file graphicsContext\&.cpp\&.
.PP
.nf
165                                                                       {
166 
167 }
.fi
.PP
Referenced by render_pixel()\&.
.SS "void GraphicsContext::render_pixel_8_bit (uint32_t x, uint32_t y, uint8_t colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Reimplemented in \fBMaxOS::drivers::video::VideoGraphicsArray\fP\&.
.PP
Definition at line 132 of file graphicsContext\&.cpp\&.
.PP
.nf
132                                                                     {
133 
134 }
.fi
.PP
Referenced by render_pixel()\&.
.SH "Member Data Documentation"
.PP 
.SS "uint32_t MaxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
Definition at line 26 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), get_color_depth(), get_rendered_pixel(), int_to_colour(), render_pixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "\fBColour\fP MaxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
Definition at line 28 of file graphicsContext\&.h\&.
.PP
Referenced by colour_to_int(), GraphicsContext(), and int_to_colour()\&.
.SS "uint64_t* MaxOS::common::GraphicsContext::m_framebuffer_address { nullptr }\fC [protected]\fP"

.PP
Definition at line 30 of file graphicsContext\&.h\&.
.PP
Referenced by get_framebuffer_address(), MaxOS::drivers::video::VideoElectronicsStandardsAssociation::get_rendered_pixel_32_bit(), MaxOS::drivers::video::VideoElectronicsStandardsAssociation::render_pixel_32_bit(), and MaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\&.
.SS "uint32_t MaxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
Definition at line 25 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_height(), get_pixel(), putPixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "uint32_t MaxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
Definition at line 24 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), get_width(), putPixel(), and MaxOS::drivers::video::VideoDriver::set_mode()\&.
.SS "bool MaxOS::common::GraphicsContext::mirror_y_axis { false }\fC [protected]\fP"

.PP
Definition at line 22 of file graphicsContext\&.h\&.
.PP
Referenced by draw_circle(), drawLine(), fill_rectangle(), fillCircle(), get_pixel(), and putPixel()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

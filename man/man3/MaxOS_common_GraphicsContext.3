.TH "MaxOS::common::GraphicsContext" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::GraphicsContext \- Draws pixels to the screen, and handles drawing lines, rectangles and circles\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <graphicsContext\&.h>\fP
.PP
Inherited by \fBMaxOS::drivers::video::VideoDriver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGraphicsContext\fP ()"
.br
.RI "Constructs a \fBGraphicsContext\fP object and initializes the color palette\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolour_to_int\fP (\fBconst\fP \fBColour\fP &)"
.br
.RI "Converts a colour to an integer value based on the current color depth\&. "
.ti -1c
.RI "\fBColour\fP \fBint_to_colour\fP (\fBuint32_t\fP)"
.br
.RI "Converts an integer value to a colour based on the current color depth\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBwidth\fP () \fBconst\fP"
.br
.RI "Gets the width of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBheight\fP () \fBconst\fP"
.br
.RI "Gets the height of the screen\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBcolor_depth\fP () \fBconst\fP"
.br
.RI "Gets the current color depth (bits per pixel) "
.ti -1c
.RI "\fBuint64_t\fP * \fBframebuffer_address\fP ()"
.br
.RI "Gets the address of the context's framebuffer to draw on\&. "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer) "
.ti -1c
.RI "\fBvoid\fP \fBput_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. "
.ti -1c
.RI "\fBColour\fP \fBget_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBinvert_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Inverts a pixel\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_line\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a line on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_rectangle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBx1\fP, \fBuint32_t\fP \fBy1\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a rectangle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBdraw_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBconst\fP \fBColour\fP &colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.ti -1c
.RI "\fBvoid\fP \fBfill_circle\fP (\fBuint32_t\fP \fBx0\fP, \fBuint32_t\fP \fBy0\fP, \fBuint32_t\fP \fBradius\fP, \fBuint32_t\fP colour)"
.br
.RI "Draws a circle on the screen, filled with a colour\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen based on the current color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBrender_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"
.br
.RI "Renders a pixel to the screen using the 32 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint8_t\fP \fBget_rendered_pixel_8_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 8 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint16_t\fP \fBget_rendered_pixel_16_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 16 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_24_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 24 bit color depth\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBget_rendered_pixel_32_bit\fP (\fBuint32_t\fP x, \fBuint32_t\fP y)"
.br
.RI "Gets the colour of a pixel on the screen using the 32 bit color depth\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBmirror_y_axis\fP"
.br
.RI "Should the y axis be mirrored (0,0 is top left if false, bottom left if true) "
.ti -1c
.RI "\fBuint32_t\fP \fBm_width\fP { 0 }"
.br
.RI "The width of the screen in pixels\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_height\fP { 0 }"
.br
.RI "The height of the screen in pixels\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_color_depth\fP { 0 }"
.br
.RI "The color depth of the screen in bits per pixel\&. "
.ti -1c
.RI "\fBColour\fP \fBm_colour_pallet\fP [256]"
.br
.RI "The colour pallet for 8 bit color depth\&. "
.ti -1c
.RI "\fBuint64_t\fP * \fBm_framebuffer_address\fP { \fBnullptr\fP }"
.br
.RI "The address of the framebuffer\&. "
.in -1c
.SH "Detailed Description"
.PP 
Draws pixels to the screen, and handles drawing lines, rectangles and circles\&. 
.PP
Definition at line \fB22\fP of file \fBgraphicsContext\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "GraphicsContext::GraphicsContext ()"

.PP
Constructs a \fBGraphicsContext\fP object and initializes the color palette\&. 
.PP
Definition at line \fB17\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
17                                  {
18 
19 
20     // VirtualBox VGA palette
21     m_colour_pallet[0x00] = Colour(0x00, 0x00, 0x00);    // Black
22     m_colour_pallet[0x01] = Colour(0x00, 0x00, 0xA8);    // Duke Blue
23     m_colour_pallet[0x02] = Colour(0x00, 0xA8, 0x00);    // Islamic Green
24     m_colour_pallet[0x03] = Colour(0x00, 0xA8, 0xA8);    // Persian Green
25     m_colour_pallet[0x04] = Colour(0xA8, 0x00, 0x00);    // Dark Candy Apple Red
26     m_colour_pallet[0x05] = Colour(0xA8, 0x00, 0xA8);    // Heliotrope Magenta
27 
28     m_colour_pallet[0x06] = Colour(0xA8, 0xA8, 0x00);    // Light Gold
29     m_colour_pallet[0x07] = Colour(0xA8, 0xA8, 0xA8);    // Dark Gray (X11)
30     m_colour_pallet[0x08] = Colour(0x00, 0x00, 0x57);    // Cetacean Blue
31     m_colour_pallet[0x09] = Colour(0x00, 0x00, 0xFF);    // Blue
32     m_colour_pallet[0x0A] = Colour(0x00, 0xA8, 0x57);    // Green (Pigment)
33     m_colour_pallet[0x0B] = Colour(0x00, 0xA8, 0xFF);    // Vivid Cerulean
34     m_colour_pallet[0x0C] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
35     m_colour_pallet[0x0D] = Colour(0xA8, 0x00, 0x57);    // Jazz berry Jam
36     m_colour_pallet[0x0E] = Colour(0xA8, 0xA8, 0x57);    // Olive Green
37     m_colour_pallet[0x0F] = Colour(0xA8, 0xA8, 0xFF);    // Maximum Blue Purple
38 
39     m_colour_pallet[0x10] = Colour(0x00, 0x57, 0x00);    // Dark Green (X11)
40     m_colour_pallet[0x11] = Colour(0x00, 0x57, 0xA8);    // Cobalt Blue
41     m_colour_pallet[0x12] = Colour(0x00, 0xFF, 0x00);    // Electric Green
42     m_colour_pallet[0x13] = Colour(0x00, 0xFF, 0xA8);    // Medium Spring Green
43     m_colour_pallet[0x14] = Colour(0xA8, 0x57, 0x00);    // Windsor Tan
44     m_colour_pallet[0x15] = Colour(0xA8, 0x57, 0xA8);    // Purpureus
45     m_colour_pallet[0x16] = Colour(0xA8, 0xFF, 0x00);    // Spring Bud
46     m_colour_pallet[0x17] = Colour(0xA8, 0xFF, 0xA8);    // Mint Green
47     m_colour_pallet[0x18] = Colour(0x00, 0x57, 0x57);    // Midnight Green (Eagle Green)
48     m_colour_pallet[0x19] = Colour(0x00, 0x57, 0xFF);    // Blue (RYB)
49     m_colour_pallet[0x1A] = Colour(0x00, 0xFF, 0x57);    // Malachite
50     m_colour_pallet[0x1B] = Colour(0x00, 0xFF, 0xFF);    // Aqua
51     m_colour_pallet[0x1C] = Colour(0xA8, 0x57, 0x57);    // Middle Red Purple
52     m_colour_pallet[0x1D] = Colour(0xA8, 0x57, 0xFF);    // Lavender Indigo
53     m_colour_pallet[0x1E] = Colour(0xA8, 0xFF, 0x57);    // Olive Green
54     m_colour_pallet[0x1F] = Colour(0xA8, 0xFF, 0xFF);    // Celeste
55 
56     m_colour_pallet[0x20] = Colour(0x57, 0x00, 0x00);    // Blood Red
57     m_colour_pallet[0x21] = Colour(0x57, 0x00, 0xA8);    // Metallic Violet
58     m_colour_pallet[0x22] = Colour(0x57, 0xA8, 0x00);    // Kelly Green
59     m_colour_pallet[0x23] = Colour(0x57, 0xA8, 0xA8);    // Cadet Blue
60     m_colour_pallet[0x24] = Colour(0xFF, 0x00, 0x00);    // Red
61     m_colour_pallet[0x25] = Colour(0xFF, 0x00, 0xA8);    // Fashion Fuchsia
62     m_colour_pallet[0x26] = Colour(0xFF, 0xA8, 0x00);    // Chrome Yellow
63     m_colour_pallet[0x27] = Colour(0xFF, 0xA8, 0xA8);    // Light Salmon Pink
64     m_colour_pallet[0x28] = Colour(0x57, 0x00, 0x57);    // Imperial Purple
65     m_colour_pallet[0x29] = Colour(0x57, 0x00, 0xFF);    // Electric Indigo
66     m_colour_pallet[0x2A] = Colour(0x57, 0xA8, 0x57);    // Apple
67     m_colour_pallet[0x2B] = Colour(0x57, 0xA8, 0xFF);    // Blue Jeans
68     m_colour_pallet[0x2C] = Colour(0xFF, 0x00, 0x57);    // Folly
69     m_colour_pallet[0x2D] = Colour(0xFF, 0x00, 0xFF);    // Fuchsia
70     m_colour_pallet[0x2E] = Colour(0xFF, 0xA8, 0x57);    // Rajah
71     m_colour_pallet[0x2F] = Colour(0xFF, 0xA8, 0xFF);    // Rich Brilliant Lavender
72 
73     m_colour_pallet[0x30] = Colour(0x57, 0x57, 0x00);    // Dark Bronze (Coin)
74     m_colour_pallet[0x31] = Colour(0x57, 0x57, 0xA8);    // Liberty
75     m_colour_pallet[0x32] = Colour(0x57, 0xFF, 0x00);    // Chlorophyll Green
76     m_colour_pallet[0x33] = Colour(0x57, 0xFF, 0xA8);    // Medium Aquamarine
77     m_colour_pallet[0x34] = Colour(0xFF, 0x57, 0x00);    // Orange (Pantone)
78     m_colour_pallet[0x35] = Colour(0xFF, 0x57, 0xA8);    // Brilliant Rose
79     m_colour_pallet[0x36] = Colour(0xFF, 0xFF, 0x00);    // Yellow
80     m_colour_pallet[0x37] = Colour(0xFF, 0xFF, 0xA8);    // Calamansi
81     m_colour_pallet[0x38] = Colour(0x57, 0x57, 0x57);    // Davy's Grey
82     m_colour_pallet[0x39] = Colour(0x57, 0x57, 0xFF);    // Very Light Blue
83     m_colour_pallet[0x3A] = Colour(0x57, 0xFF, 0x57);    // Screamin' Green
84     m_colour_pallet[0x3B] = Colour(0x57, 0xFF, 0xFF);    // Electric Blue
85     m_colour_pallet[0x3C] = Colour(0xFF, 0x57, 0x57);    // Sunset Orange
86     m_colour_pallet[0x3D] = Colour(0xFF, 0x57, 0xFF);    // Shocking Pink (Crayola)
87     m_colour_pallet[0x3E] = Colour(0xFF, 0xFF, 0x57);    // Shocking Pink (Crayola)
88     m_colour_pallet[0x3F] = Colour(0xFF, 0xFF, 0xFF);    // White
89 
90 
91     // Set the rest of the palette to black
92     for(uint8_t color_code = 255; color_code >= 0x40; \-\-color_code)
93         m_colour_pallet[color_code] = Colour(0, 0, 0);
94 
95 
96 }
.fi

.PP
References \fBm_colour_pallet\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP GraphicsContext::color_depth () const"

.PP
Gets the current color depth (bits per pixel) 
.PP
\fBReturns\fP
.RS 4
The color depth 
.RE
.PP

.PP
Definition at line \fB364\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
364                                             {
365     return m_color_depth;
366 }
.fi

.PP
References \fBm_color_depth\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::colour_to_int (\fBconst\fP \fBColour\fP & colour)"

.PP
Converts a colour to an integer value based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The colour class to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The integer value of the colour 
.RE
.PP

.PP
Definition at line \fB245\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
245                                                             {
246 
247     switch(m_color_depth) {
248         case 8: {
249             uint32_t result = 0;
250             int mindistance = 0xfffffff;
251             for(uint32_t i = 0; i <= 255; ++i) {
252                 Colour* c = &m_colour_pallet[i];
253                 int distance =
254                         ((int) colour\&.red \- (int) c\->red) * ((int) colour\&.red \- (int) c\->red)
255                         + ((int) colour\&.green \- (int) c\->green) * ((int) colour\&.green \- (int) c\->green)
256                         + ((int) colour\&.blue \- (int) c\->blue) * ((int) colour\&.blue \- (int) c\->blue);
257                 if(distance < mindistance) {
258                     mindistance = distance;
259                     result = i;
260                 }
261             }
262             return result;
263         }
264         case 16: {
265             // 16\-Bit colours RRRRRGGGGGGBBBBB
266             return ((uint16_t) (colour\&.red & 0xF8)) << 8
267                    | ((uint16_t) (colour\&.green & 0xFC)) << 3
268                    | ((uint16_t) (colour\&.blue & 0xF8) >> 3);
269         }
270         case 24: {
271             return (uint32_t) colour\&.red << 16
272                    | (uint32_t) colour\&.green << 8
273                    | (uint32_t) colour\&.blue;
274         }
275         default:
276         case 32: {
277             uint32_t red_hex = ((uint32_t) colour\&.red & 0xFF) << 16;
278             uint32_t green_hex = ((uint32_t) colour\&.green & 0xFF) << 8;
279             uint32_t blue_hex = (uint32_t) colour\&.blue & 0xFF;
280             uint32_t alpha_hex = ((uint32_t) colour\&.alpha & 0xFF) << 24;
281 
282             uint32_t hex_value = red_hex | green_hex | blue_hex | alpha_hex;
283 
284 
285             return hex_value;
286         }
287     }
288 }
.fi

.PP
References \fBMaxOS::common::Colour::alpha\fP, \fBMaxOS::common::Colour::blue\fP, \fBMaxOS::common::Colour::green\fP, \fBm_color_depth\fP, \fBm_colour_pallet\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBdraw_rectangle()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_rendered_pixel()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB647\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
647                                                                                                  {
648     draw_circle(x0, y0, radius, colour_to_int(colour));
649 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_circle()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_circle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB659\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
659                                                                                             {
660 
661     // Make sure the circle is with in the width and height of the screen
662     if(x0 < 0) x0 = 0;
663     if(x0 > m_width) x0 = m_width;
664     if(y0 < 0) y0 = 0;
665     if(y0 > m_height) y0 = m_height;
666 
667     // Mirror the Y axis as directly calling put_pixel will not do this
668     if(mirror_y_axis)
669         y0 = m_height \- y0 \- 1;
670 
671 
672     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
673     for(int32_t x = \-radius; x <= radius; ++x) {
674 
675         // Draw a line from the top most point of the circle to the bottom most point of the circle
676         for(int32_t y = \-radius; y <= radius; ++y) {
677 
678             // If the point is within the circle, draw it but make sure it is only part of the outline
679             if(x * x + y * y <= radius * radius && x * x + y * y >= (radius \- 1) * (radius \- 1))
680                 put_pixel(x0 + x, y0 + y, colour);
681         }
682     }
683 
684 
685 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_line (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB449\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
449                                                                                                         {
450     draw_line(x0, y0, x1, y1, colour_to_int(colour));
451 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_line()\fP\&.
.PP
Referenced by \fBdraw_line()\fP, \fBdraw_line()\fP, and \fBdraw_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_line (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a line on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the m_first_memory_chunk point 
.br
\fIy0\fP The y coordinate of the m_first_memory_chunk point 
.br
\fIx1\fP The x coordinate of the final point 
.br
\fIy1\fP The y coordinate of the final point 
.br
\fIcolour\fP The colour of the line 
.RE
.PP

.PP
Definition at line \fB462\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
462                                                                                                    {
463 
464     // Store the minimum and maximum y values
465     bool y_0_is_smaller = y0 < y1;
466     int32_t y_min = y_0_is_smaller ? y0 : y1;
467     int32_t y_max = y_0_is_smaller ? y1 : y0;
468 
469     //Reverse the points to draw from left to right
470     if(x1 < x0) {
471         draw_line(x1, y1, x0, y0, colour);
472         return;
473     }
474 
475     // Vertical line
476     if(x1 == x0) {
477         // Force the line to be within the screen
478         if(y_min < 0) y_min = 0;
479         if(y_max >= m_height)
480             y_max = m_height \- 1;
481 
482         // Mirror the Y axis as directly calling put_pixel will not do this
483         if(mirror_y_axis) {
484             int32_t temp = y_max;
485             y_max = m_height \- y_min \- 1;
486             y_min = m_height \- temp \- 1;
487         }
488 
489         // Check that the line is within the screen
490         if(0 > x0 || x0 >= m_width) {
491             return;
492         }
493 
494         // Draw the line
495         for(int32_t y = y_min; y <= y_max; ++y)
496             put_pixel(x0, y, colour);
497 
498         return;
499     }
500 
501     // Horizontal line
502     if(y1 == y0) {
503         // Ensure the line is within the screen
504         if(x0 < 0) x0 = 0;
505         if(x1 >= m_width) x1 = m_width \- 1;
506 
507         // Mirror the Y axis as directly calling put_pixel will not do this
508         if(mirror_y_axis)
509             y0 = m_height \- y0 \- 1;
510 
511         // Check that the line is within the screen
512         if(0 > y0 || y0 >= m_height)
513             return;
514 
515         // Draw the line
516         for(int32_t x = x0; x <= x1; ++x)
517             put_pixel(x, y0, colour);
518     }
519 
520     // If the line is not horizontal or vertical then it must be a diagonal line
521     // Find the slope of the line
522 //  float slope = ((float) (y1 \- y0)) / (x1 \- x0);
523     int slope = 1; // replace when in userland
524 
525     // A slope that is more horizontal should be drawn by incrementing x
526     if(\-1 <= slope && slope <= 1) {
527         int y = y0;
528         for(int32_t x = x0; x <= x1; x++, y += slope)
529             put_pixel(x, (int32_t) y, colour);
530     }
531 
532         // A slope that is more vertical should be drawn by incrementing y
533     else {
534         // Invert the slope
535         slope = 1 / slope;
536 
537         int x = x0;
538         for(int32_t y = y_min; y <= y_max; x += slope, y++)
539             put_pixel((int32_t) x, y, colour);
540     }
541 }
.fi

.PP
References \fBdraw_line()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB552\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
552                                                                                                              {
553     draw_rectangle(x0, y0, x1, y1, colour_to_int(colour));
554 
555 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBdraw_rectangle()\fP\&.
.PP
Referenced by \fBdraw_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::draw_rectangle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB566\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
566                                                                                                         {
567 
568     // Ensure x and y 0 is smaller than x and y 1
569     \-\-y0;
570     \-\-x0;
571 
572     // Draw the rectangle
573     draw_line(x0, y0, x1, y0, colour); // Top
574     draw_line(x0, y1, x1, y1, colour); // Bottom
575     draw_line(x0, y0, x0, y1, colour); // Left
576     draw_line(x1, y0, x1, y1, colour); // Right
577 
578 }
.fi

.PP
References \fBdraw_line()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_circle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP radius, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB695\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
695                                                                                                  {
696     fill_circle(x0, y0, radius, colour_to_int(colour));
697 
698 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfill_circle()\fP\&.
.PP
Referenced by \fBfill_circle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_circle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP radius, \fBuint32_t\fP colour)"

.PP
Draws a circle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the centre of the circle 
.br
\fIy0\fP The y coordinate of the centre of the circle 
.br
\fIradius\fP The radius of the circle 
.br
\fIcolour\fP The colour of the circle 
.RE
.PP

.PP
Definition at line \fB708\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
708                                                                                             {
709 
710     // Make sure the circle is with in the width and height of the screen
711     if(x0 < 0) x0 = 0;
712     if(x0 > m_width) x0 = m_width;
713     if(y0 < 0) y0 = 0;
714     if(y0 > m_height) y0 = m_height;
715 
716     // Mirror the Y axis as directly calling put_pixel will not do this
717     if(mirror_y_axis)
718         y0 = m_height \- y0 \- 1;
719 
720     // Draw the circle
721 
722     // Begin drawing at the left most point of the circle and draw a line to the right most point of the circle
723     for(int32_t x = \-radius; x <= radius; ++x) {
724 
725         // Draw a line from the top most point of the circle to the bottom most point of the circle
726         for(int32_t y = \-radius; y <= radius; ++y) {
727 
728             // Only draw the pixel if it is within the circle
729             if(x * x + y * y <= radius * radius)
730                 put_pixel(x0 + x, y0 + y, colour);
731         }
732     }
733 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBconst\fP \fBColour\fP & colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB589\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
589                                                                                                              {
590     fill_rectangle(x0, y0, x1, y1, colour_to_int(colour));
591 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBfill_rectangle()\fP\&.
.PP
Referenced by \fBfill_rectangle()\fP, and \fBfill_rectangle()\fP\&.
.SS "\fBvoid\fP GraphicsContext::fill_rectangle (\fBuint32_t\fP x0, \fBuint32_t\fP y0, \fBuint32_t\fP x1, \fBuint32_t\fP y1, \fBuint32_t\fP colour)"

.PP
Draws a rectangle on the screen, filled with a colour\&. 
.PP
\fBParameters\fP
.RS 4
\fIx0\fP The x coordinate of the top left corner 
.br
\fIy0\fP The y coordinate of the top left corner 
.br
\fIx1\fP The x coordinate of the bottom right corner 
.br
\fIy1\fP The y coordinate of the bottom right corner 
.br
\fIcolour\fP The colour of the rectangle 
.RE
.PP

.PP
Definition at line \fB602\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
602                                                                                                         {
603 
604     // Draw from left to right
605     if(y1 < y0) {
606         fill_rectangle(x1, y1, x0, y0, colour);
607         return;
608     }
609 
610     // Make sure the rectangle is within the height of the screen
611     if(y0 < 0) y0 = 0;
612     if(y1 > m_height) y1 = m_height;
613 
614     // Make sure the rectangle is within the width of the screen
615     bool x_0_is_smaller = x0 < x1;
616     int32_t x_min = x_0_is_smaller ? x0 : x1;
617     int32_t x_max = x_0_is_smaller ? x1 : x0;
618 
619     if(x_min < 0) x_min = 0;
620     if(x_max > m_width)
621         x_max = m_width;
622 
623     // Mirror the Y axis as directly calling put_pixel will not do this
624     if(mirror_y_axis) {
625         int32_t temp = y1;
626         y1 = m_height \- y0 \- 1;
627         y0 = m_height \- temp \- 1;
628     }
629 
630     // Draw the rectangle
631     for(int32_t y = y0; y < y1; ++y) {
632         for(int32_t x = x_min; x < x_max; ++x) {
633             put_pixel(x, y, colour);
634         }
635     }
636 
637 }
.fi

.PP
References \fBfill_rectangle()\fP, \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBput_pixel()\fP\&.
.SS "\fBuint64_t\fP * GraphicsContext::framebuffer_address ()"

.PP
Gets the address of the context's framebuffer to draw on\&. 
.PP
\fBReturns\fP
.RS 4
The framebuffer address 
.RE
.PP

.PP
Definition at line \fB740\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
740                                                {
741     return m_framebuffer_address;
742 }
.fi

.PP
References \fBm_framebuffer_address\fP\&.
.SS "\fBColour\fP GraphicsContext::get_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y)"

.PP
Gets the colour of a pixel, or returns black if the pixel is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or black if the pixel is outside the screen 
.RE
.PP

.PP
Definition at line \fB408\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
408                                                         {
409 
410     // Check bounds
411     if(x >= m_width || y >= m_height)
412         return { 0, 0, 0 };
413 
414     // Get the pixel and convert it to a colour
415     uint32_t translated_color = get_rendered_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y);
416     return int_to_colour(translated_color);
417 }
.fi

.PP
References \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBm_height\fP, \fBm_width\fP, and \fBmirror_y_axis\fP\&.
.PP
Referenced by \fBinvert_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen, automatically uses the correct color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The colour of the pixel or white if the pixel is not supported 
.RE
.PP

.PP
Definition at line \fB179\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
179                                                                    {
180     // Call the correct get_pixel function based on the color depth
181     switch(m_color_depth) {
182         case 8:
183             return get_rendered_pixel_8_bit(x, y);
184         case 16:
185             return get_rendered_pixel_16_bit(x, y);
186         case 24:
187             return get_rendered_pixel_24_bit(x, y);
188         case 32:
189             return get_rendered_pixel_32_bit(x, y);
190     }
191 
192     return colour_to_int(Colour(0xFF, 0xFF, 0xFF));
193 }
.fi

.PP
References \fBcolour_to_int()\fP, \fBget_rendered_pixel_16_bit()\fP, \fBget_rendered_pixel_24_bit()\fP, \fBget_rendered_pixel_32_bit()\fP, \fBget_rendered_pixel_8_bit()\fP, and \fBm_color_depth\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBuint16_t\fP GraphicsContext::get_rendered_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB213\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
213                                                                       {
214     return 0;
215 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB224\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
224                                                                       {
225     return 0;
226 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::get_rendered_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 32Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB235\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
235                                                                       {
236     return 0;
237 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint8_t\fP GraphicsContext::get_rendered_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Gets the colour of a pixel on the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP
\fBReturns\fP
.RS 4
The 8Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB202\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
202                                                                     {
203     return 0;
204 }
.fi

.PP
Referenced by \fBget_rendered_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::height () const"

.PP
Gets the height of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The height of the screen 
.RE
.PP

.PP
Definition at line \fB356\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
356                                        {
357     return m_height;
358 }
.fi

.PP
References \fBm_height\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SS "\fBColour\fP GraphicsContext::int_to_colour (\fBuint32_t\fP colour)"

.PP
Converts an integer value to a colour based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIcolour\fP The integer value to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The colour class of the integer value 
.RE
.PP

.PP
Definition at line \fB296\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
296                                                      {
297     switch(m_color_depth) {
298 
299         case 8: {
300             // Return the colour from the palette
301             return m_colour_pallet[colour & 0xFF];
302         }
303 
304         case 16: {
305             // 16\-Bit Colour: 5 bits for red, 6 bits for green, 5 bits for blue (RRRRR,GGGGGG,BBBBB)
306             Colour result;
307 
308             result\&.red = (colour & 0xF800) >> 8;
309             result\&.green = (colour & 0x07E0) >> 3;
310             result\&.blue = (colour & 0x001F) << 3;
311 
312             return result;
313         }
314 
315         case 24: {
316             // 24\-Bit Colour: 8 bits for red, 8 bits for green, 8 bits for blue (RRRRRRRR,GGGGGGGG,BBBBBBBB)
317             Colour result;
318 
319             result\&.red = (colour & 0xFF0000) >> 16;
320             result\&.green = (colour & 0x00FF00) >> 8;
321             result\&.blue = (colour & 0x0000FF);
322 
323             return result;
324         }
325 
326         default:
327         case 32: {
328             Colour result;
329 
330             uint32_t hex_value = colour;
331             result\&.red = (hex_value >> 16) & 0xFF;
332             result\&.green = (hex_value >> 8) & 0xFF;
333             result\&.blue = hex_value & 0xFF;
334             result\&.alpha = (hex_value >> 24) & 0xFF;
335 
336             return result;
337 
338         }
339     }
340 }
.fi

.PP
References \fBm_color_depth\fP, and \fBm_colour_pallet\fP\&.
.PP
Referenced by \fBget_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::invert_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y)"

.PP
Inverts a pixel\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.RE
.PP

.PP
Definition at line \fB425\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
425                                                          {
426 
427     // Get the pixel
428     Colour colour = get_pixel(x, y);
429 
430     // Invert the pixel
431     colour\&.red = 255 \- colour\&.red;
432     colour\&.green = 255 \- colour\&.green;
433     colour\&.blue = 255 \- colour\&.blue;
434 
435     // Render the pixel
436     put_pixel(x, y, colour);
437 }
.fi

.PP
References \fBMaxOS::common::Colour::blue\fP, \fBget_pixel()\fP, \fBMaxOS::common::Colour::green\fP, \fBput_pixel()\fP, and \fBMaxOS::common::Colour::red\fP\&.
.PP
Referenced by \fBMaxOS::gui::Desktop::invert_mouse_cursor()\fP\&.
.SS "\fBvoid\fP GraphicsContext::put_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBconst\fP \fBColour\fP & colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB375\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
375                                                                             {
376 
377     // Convert the colour to an integer and then print it
378     put_pixel(x, y, colour_to_int(colour));
379 }
.fi

.PP
References \fBcolour_to_int()\fP, and \fBput_pixel()\fP\&.
.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBinvert_pixel()\fP, and \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::put_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)"

.PP
Renders a pixel to the screen (automatically converts the colour to an integer), will not render the pixel if it is outside the screen\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel
.RE
.PP
\fBTodo\fP
.RS 4
make them uint32_t 
.RE
.PP

.PP
Definition at line \fB390\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
390                                                                        {
391 
392     // Check bounds
393     if(x >= m_width || y >= m_height)
394         return;
395 
396     // Render the pixel
397     render_pixel(x, mirror_y_axis ? m_height \- y \- 1 : y, colour);
398 
399 }
.fi

.PP
References \fBm_height\fP, \fBm_width\fP, \fBmirror_y_axis\fP, and \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen based on the current color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The colour of the pixel 
.RE
.PP

.PP
Definition at line \fB107\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
107                                                                           {
108 
109     // Call the correct put_pixel function based on the color depth
110     switch(m_color_depth) {
111         case 8:
112             render_pixel_8_bit(x, y, colour);
113             break;
114         case 16:
115             render_pixel_16_bit(x, y, colour);
116             break;
117         case 24:
118             render_pixel_24_bit(x, y, colour);
119             break;
120         case 32:
121             render_pixel_32_bit(x, y, colour);
122             break;
123     }
124 
125 
126 }
.fi

.PP
References \fBm_color_depth\fP, \fBrender_pixel_16_bit()\fP, \fBrender_pixel_24_bit()\fP, \fBrender_pixel_32_bit()\fP, and \fBrender_pixel_8_bit()\fP\&.
.PP
Referenced by \fBput_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_16_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint16_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 16 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 16Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB146\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
146                                                                       {
147 
148 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_24_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 24 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 24Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB157\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
157                                                                       {
158 
159 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_32_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint32_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 32 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 32Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB168\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
168                                                                       {
169 
170 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBvoid\fP GraphicsContext::render_pixel_8_bit (\fBuint32_t\fP x, \fBuint32_t\fP y, \fBuint8_t\fP colour)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Renders a pixel to the screen using the 8 bit color depth\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the pixel 
.br
\fIy\fP The y coordinate of the pixel 
.br
\fIcolour\fP The 8Bit colour of the pixel 
.RE
.PP

.PP
Definition at line \fB135\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
135                                                                     {
136 
137 }
.fi

.PP
Referenced by \fBrender_pixel()\fP\&.
.SS "\fBuint32_t\fP GraphicsContext::width () const"

.PP
Gets the width of the screen\&. 
.PP
\fBReturns\fP
.RS 4
The width of the screen 
.RE
.PP

.PP
Definition at line \fB347\fP of file \fBgraphicsContext\&.cpp\fP\&..PP
.nf
347                                       {
348     return m_width;
349 }
.fi

.PP
References \fBm_width\fP\&.
.PP
Referenced by \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, \fBMaxOS::drivers::video::VideoGraphicsArray::supports_mode()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::supports_mode()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBuint32_t\fP MaxOS::common::GraphicsContext::m_color_depth { 0 }\fC [protected]\fP"

.PP
The color depth of the screen in bits per pixel\&. 
.PP
Definition at line \fB30\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
30 { 0 };     
.fi

.PP
Referenced by \fBcolor_depth()\fP, \fBcolour_to_int()\fP, \fBget_rendered_pixel()\fP, \fBint_to_colour()\fP, \fBrender_pixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBColour\fP MaxOS::common::GraphicsContext::m_colour_pallet[256]\fC [protected]\fP"

.PP
The colour pallet for 8 bit color depth\&. 
.PP
\fBTodo\fP
.RS 4
make const 
.RE
.PP

.PP
Definition at line \fB32\fP of file \fBgraphicsContext\&.h\fP\&.
.PP
Referenced by \fBcolour_to_int()\fP, \fBGraphicsContext()\fP, and \fBint_to_colour()\fP\&.
.SS "\fBuint64_t\fP* MaxOS::common::GraphicsContext::m_framebuffer_address { \fBnullptr\fP }\fC [protected]\fP"

.PP
The address of the framebuffer\&. 
.PP
Definition at line \fB34\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
34 { nullptr }; 
.fi

.PP
Referenced by \fBframebuffer_address()\fP, and \fBMaxOS::drivers::video::VideoElectronicsStandardsAssociation::VideoElectronicsStandardsAssociation()\fP\&.
.SS "\fBuint32_t\fP MaxOS::common::GraphicsContext::m_height { 0 }\fC [protected]\fP"

.PP
The height of the screen in pixels\&. 
.PP
Definition at line \fB29\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
29 { 0 };          
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_pixel()\fP, \fBheight()\fP, \fBput_pixel()\fP, and \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP\&.
.SS "\fBuint32_t\fP MaxOS::common::GraphicsContext::m_width { 0 }\fC [protected]\fP"

.PP
The width of the screen in pixels\&. 
.PP
Definition at line \fB28\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
28 { 0 };           
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_pixel()\fP, \fBput_pixel()\fP, \fBMaxOS::drivers::video::VideoDriver::set_mode()\fP, and \fBwidth()\fP\&.
.SS "\fBbool\fP MaxOS::common::GraphicsContext::mirror_y_axis\fC [protected]\fP"
\fBInitial value:\fP.PP
.nf
{
                    false }
.fi

.PP
Should the y axis be mirrored (0,0 is top left if false, bottom left if true) 
.PP
Definition at line \fB25\fP of file \fBgraphicsContext\&.h\fP\&..PP
.nf
25                                {
26                     false };    
.fi

.PP
Referenced by \fBdraw_circle()\fP, \fBdraw_line()\fP, \fBfill_circle()\fP, \fBfill_rectangle()\fP, \fBget_pixel()\fP, and \fBput_pixel()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

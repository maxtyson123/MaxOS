.TH "MaxOS::filesystem::VirtualFileSystem" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::VirtualFileSystem \- Combines all the filesystems across the partitions on each disk into a single filesystems and exposes a single API to interact with them\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vfs\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBmount_filesystem\fP (\fBFileSystem\fP *filesystem)"
.br
.RI "Add a filesystem to the virtual file system\&. "
.ti -1c
.RI "\fBvoid\fP \fBmount_filesystem\fP (\fBFileSystem\fP *filesystem, \fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Add a filesystem to the virtual file system at a given mount point\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_filesystem\fP (\fBFileSystem\fP *filesystem)"
.br
.RI "Remove a filesystem from the virtual file system & delete it\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_filesystem\fP (\fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Remove a filesystem from the virtual file system\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_all\fP ()"
.br
.RI "Remove all mounted filesystems\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBroot_directory\fP ()"
.br
.RI "Get the root directory of the virtual file system\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBroot_filesystem\fP ()"
.br
.RI "Get the filesystem mounted at the root\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBget_filesystem\fP (\fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Get a specific filesystem mounted at a given mount point\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBfind_filesystem\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Find the filesystem that is responsible for a given path\&. "
.ti -1c
.RI "\fBstring\fP \fBget_relative_path\fP (\fBFileSystem\fP *filesystem, \fBstring\fP \fBpath\fP)"
.br
.RI "Get the relative path on a filesystem for a given VFS path (ie remove the mount point) "
.ti -1c
.RI "\fBDirectory\fP * \fBopen_directory\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Try to open a directory on the virtual file system and read it's contents\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBcreate_directory\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Attempts to open the parent directory and creates the sub directory at the end of the path\&. "
.ti -1c
.RI "\fBvoid\fP \fBdelete_directory\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Attempts to open the parent directory and deletes the sub directory at the end of the path\&. "
.ti -1c
.RI "\fBFile\fP * \fBcreate_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Attempts to open the parent directory and create the file at the end of the path\&. "
.ti -1c
.RI "\fBFile\fP * \fBopen_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP, \fBsize_t\fP offset=0)"
.br
.RI "Try to open a file on the virtual file system with a given offset\&. "
.ti -1c
.RI "\fBvoid\fP \fBdelete_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Opens a directory on the vfs and deletes the file at the end of the path\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBVirtualFileSystem\fP * \fBcurrent_file_system\fP ()"
.br
.RI "Get the active virtual file system\&. "
.ti -1c
.RI "\fBstatic\fP \fBDirectory\fP * \fBopen_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Opens a subdirectory from a parent directory\&. "
.ti -1c
.RI "\fBstatic\fP \fBDirectory\fP * \fBcreate_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Creates a subdirectory in the specified directory and\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Delete a directory on the virtual file system and it's sub contents\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBDirectory\fP *directory)"
.br
.RI "Delete a directory on the virtual file system and it's sub contents\&. "
.ti -1c
.RI "\fBstatic\fP \fBFile\fP * \fBcreate_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Create a file in a directory\&. "
.ti -1c
.RI "\fBstatic\fP \fBFile\fP * \fBopen_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP, \fBsize_t\fP offset=0)"
.br
.RI "Opens a file in a directory with the given offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &\fBname\fP)"
.br
.RI "Delete a file in the given directory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Combines all the filesystems across the partitions on each disk into a single filesystems and exposes a single API to interact with them\&. 
.PP
Definition at line \fB26\fP of file \fBvfs\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VirtualFileSystem::VirtualFileSystem ()"

.PP
Definition at line \fB16\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
16                                      {
17 
18     // Set the current file system to this instance
19     s_current_file_system = this;
20 
21 }
.fi

.SS "VirtualFileSystem::~VirtualFileSystem ()"

.PP
Definition at line \fB23\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
23                                       {
24 
25     // Remove all mounted filesystems
26     unmount_all();
27 
28     // Set the current file system to null
29     s_current_file_system = nullptr;
30 
31 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBDirectory\fP * VirtualFileSystem::create_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Creates a subdirectory in the specified directory and\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP Where to create the directory 
.br
\fIname\fP The name of the new directory 
.RE
.PP
\fBReturns\fP
.RS 4
The created directory 
.RE
.PP

.PP
Definition at line \fB314\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
314                                                                                     {
315 
316     // Create the directory
317     Directory* directory = parent\->create_subdirectory(name);
318     directory\->read_from_disk();
319 
320     return directory;
321 }
.fi

.PP
References \fBname\fP, and \fBMaxOS::filesystem::Directory::read_from_disk()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::create_directory (\fBstring\fP path)"

.PP
Attempts to open the parent directory and creates the sub directory at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP
\fBReturns\fP
.RS 4
The directory object or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB285\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
285                                                           {
286 
287     // Ensure a valid path is given
288     if (!Path::valid(path))
289         return nullptr;
290 
291     path = path\&.strip('/');
292 
293     // Try to find the filesystem that is responsible for the path
294     FileSystem* fs = find_filesystem(path);
295     if (!fs)
296         return nullptr;
297 
298     // Open the parent directory
299     Directory* parent_directory = open_directory(path);
300     if (!parent_directory)
301         return nullptr;
302 
303     string directory_name = Path::file_name(path);
304     return create_directory(parent_directory, directory_name);
305 }
.fi

.PP
References \fBcreate_directory()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBfind_filesystem()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_directory()\fP, and \fBMaxOS::filesystem::VFSResourceRegistry::create_resource()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::create_file (\fBconst\fP \fBstring\fP & path)"

.PP
Attempts to open the parent directory and create the file at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.RE
.PP
\fBReturns\fP
.RS 4
The file object or null if it could not be created 
.RE
.PP

.PP
Definition at line \fB417\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
417                                                        {
418 
419     // Ensure a valid path is given
420     if (!Path::valid(path))
421         return nullptr;
422 
423     // Open the directory
424     Directory* directory = open_directory(path);
425     if (!directory)
426         return nullptr;
427 
428     // Create the file
429     string file_name = Path::file_name(path);
430     return create_file(directory, file_name);
431 }
.fi

.PP
References \fBcreate_file()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_file()\fP, and \fBMaxOS::filesystem::VFSResourceRegistry::create_resource()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::create_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Create a file in a directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory where the file should be created 
.br
\fIname\fP The name of the file to create 
.RE
.PP

.PP
Definition at line \fB439\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
439                                                                           {
440     return parent\->create_file(name);
441 }
.fi

.PP
References \fBname\fP\&.
.SS "\fBVirtualFileSystem\fP * VirtualFileSystem::current_file_system ()\fC [static]\fP"

.PP
Get the active virtual file system\&. 
.PP
\fBReturns\fP
.RS 4
The current virtual file system or null if none is set 
.RE
.PP

.PP
Definition at line \fB38\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
38                                                           {
39     return s_current_file_system;
40 }
.fi

.PP
Referenced by \fBMaxOS::filesystem::partition::MSDOSPartition::mount_partitions()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Delete a directory on the virtual file system and it's sub contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory that contains the reference to the directory being deleted 
.br
\fIname\fP The name of the directory to delete 
.RE
.PP

.PP
Definition at line \fB353\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
353                                                                               {
354 
355     // Find the directory and delete it
356     for (const auto& directory: parent\->subdirectories())
357         if (directory\->name() == name)
358             delete_directory(parent, directory);
359 
360 }
.fi

.PP
References \fBdelete_directory()\fP, and \fBname\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBDirectory\fP * parent, \fBDirectory\fP * directory)\fC [static]\fP"

.PP
Delete a directory on the virtual file system and it's sub contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory that contains the reference to the directory being deleted 
.br
\fIdirectory\fP The the directory to delete 
.RE
.PP

.PP
Definition at line \fB368\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
368                                                                                 {
369 
370     // Nothing to delete
371     if (!directory)
372         return;
373 
374     // Store a reference to each subdirectory and its parent
375     Map<Directory*, Directory*> stack;
376     Vector<Pair<Directory*, Directory*>> to_delete;
377     stack\&.push_back(parent, directory);
378 
379     while (!stack\&.empty()) {
380 
381         // Save the current
382         auto current = stack\&.pop_back();
383         auto current_directory = current\&.second;
384         current_directory\->read_from_disk();
385         to_delete\&.push_back({current\&.first, current_directory});
386 
387         // Empty the directory
388         for (const auto &file: current_directory\->files())
389             delete_file(current_directory, file\->name());
390 
391         // Process the subdirectories
392         for (const auto &subdir: current_directory\->subdirectories())
393             if (subdir\->name() != "\&." && subdir\->name() != "\&.\&.")
394                 stack\&.push_back(current_directory, subdir);
395 
396     }
397 
398     // Delete the directory from the bottom of the tree
399     for (int i = to_delete\&.size() \- 1; i >= 0; \-\-i) {
400 
401         // Get the parent and child
402         const auto &current = to_delete[i];
403         Directory* owner = current\&.first;
404         Directory* subdirectory = current\&.second;
405 
406         owner\->remove_subdirectory(subdirectory\->name());
407     }
408 }
.fi

.PP
References \fBdelete_file()\fP, and \fBstack\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBstring\fP path)"

.PP
Attempts to open the parent directory and deletes the sub directory at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP

.PP
Definition at line \fB329\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
329                                                     {
330 
331     // Ensure a valid path is given
332     if (!Path::valid(path))
333         return;
334 
335     path = path\&.strip('/');
336 
337     // Open the directory
338     Directory* parent_directory = open_directory(path);
339     if (!parent_directory)
340         return;
341 
342     // Delete the directory
343     string directory_name = Path::file_name(path);
344     delete_directory(parent_directory, directory_name);
345 }
.fi

.PP
References \fBdelete_directory()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBdelete_directory()\fP, and \fBdelete_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_file (\fBconst\fP \fBstring\fP & path)"

.PP
Opens a directory on the vfs and deletes the file at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.RE
.PP

.PP
Definition at line \fB490\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
490                                                       {
491 
492     // Ensure a valid path is given
493     if (!Path::valid(path))
494         return;
495 
496     // Open the directory
497     Directory* directory = open_directory(path);
498     if (!directory)
499         return;
500 
501     // Delete the file
502     string file_name = Path::file_name(path);
503     delete_file(directory, file_name);
504 }
.fi

.PP
References \fBdelete_file()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBdelete_directory()\fP, and \fBdelete_file()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Delete a file in the given directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory containing the file 
.br
\fIname\fP The name of the file 
.RE
.PP

.PP
Definition at line \fB512\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
512                                                                          {
513 
514     // Delete the file
515     parent\->remove_file(name);
516 }
.fi

.PP
References \fBname\fP\&.
.SS "\fBFileSystem\fP * VirtualFileSystem::find_filesystem (\fBstring\fP path)"

.PP
Find the filesystem that is responsible for a given path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to search for 
.RE
.PP
\fBReturns\fP
.RS 4
The filesystem that contains the path or null if none is found 
.RE
.PP

.PP
Definition at line \fB183\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
183                                                           {
184 
185     // Longest matching path will be where the filesystem is mounted
186     string longest_match = "";
187     FileSystem* longest_match_fs = nullptr;
188 
189     // Search through the filesystems
190     for (const auto& filesystem : filesystems) {
191         // Get the filesystem and mount point
192         FileSystem* fs = filesystem\&.first;
193         string mount_point = filesystem\&.second;
194 
195         // Check if the path starts with the mount point
196         if (path\&.starts_with(mount_point) && mount_point\&.length() > longest_match\&.length()) {
197             longest_match = mount_point;
198             longest_match_fs = fs;
199         }
200     }
201 
202     return longest_match_fs;
203 }
.fi

.PP
Referenced by \fBcreate_directory()\fP, and \fBopen_directory()\fP\&.
.SS "\fBFileSystem\fP * VirtualFileSystem::get_filesystem (\fBconst\fP \fBstring\fP & mount_point)"

.PP
Get a specific filesystem mounted at a given mount point\&. 
.PP
\fBParameters\fP
.RS 4
\fImount_point\fP The mount point to search for 
.RE
.PP
\fBReturns\fP
.RS 4
The filesystem mounted at the given mount point or null if none is found 
.RE
.PP

.PP
Definition at line \fB166\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
166                                                                        {
167 
168     // Check if the filesystem is mounted
169     for(const auto& filesystem : filesystems)
170         if (filesystem\&.second == mount_point)
171             return filesystem\&.first;
172 
173     // Filesystem not found
174     return nullptr;
175 }
.fi

.SS "\fBstring\fP VirtualFileSystem::get_relative_path (\fBFileSystem\fP * filesystem, \fBstring\fP path)"

.PP
Get the relative path on a filesystem for a given VFS path (ie remove the mount point) 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to get the path for 
.br
\fIpath\fP The path to get the relative path for 
.RE
.PP
\fBReturns\fP
.RS 4
The relative path on the filesystem or an empty string if none is found 
.RE
.PP

.PP
Definition at line \fB212\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
212                                                                                {
213 
214     // Find the mount point for the filesystem
215     auto fs = filesystems\&.find(filesystem);
216     if (fs == filesystems\&.end())
217         return "";
218 
219     // Get the mount point
220     string mount_point = fs\->second;
221 
222     // Make sure that the path points to the filesystem
223     if (!path\&.starts_with(mount_point))
224         return "";
225 
226     // Get the relative path
227     string relative_path = path\&.substring(mount_point\&.length(), path\&.length() \- mount_point\&.length());
228     return relative_path;
229 }
.fi

.PP
Referenced by \fBopen_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::mount_filesystem (\fBFileSystem\fP * filesystem)"

.PP
Add a filesystem to the virtual file system\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to add 
.RE
.PP

.PP
Definition at line \fB47\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
47                                                                {
48 
49     // Check if the filesystem is already mounted
50     if (filesystems\&.find(filesystem) != filesystems\&.end()) {
51         Logger::WARNING() << "Filesystem already mounted\\n";
52         return;
53     }
54 
55     // Get the mount point for the filesystem
56     string mount_point = "/filesystem_" + filesystems\&.size();
57 
58     // If this is the first filesystem to be mounted, set the root filesystem
59     if (filesystems\&.size() == 0)
60         mount_point = "/";
61 
62     // Add the filesystem to the map
63     filesystems\&.insert(filesystem, mount_point);
64 }
.fi

.PP
References \fBLogger::WARNING()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::mount_filesystem (\fBFileSystem\fP * filesystem, \fBconst\fP \fBstring\fP & mount_point)"

.PP
Add a filesystem to the virtual file system at a given mount point\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to add 
.br
\fImount_point\fP The mount point for the filesystem 
.RE
.PP

.PP
Definition at line \fB72\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
72                                                                                           {
73 
74     // Check if the filesystem is already mounted
75     if (filesystems\&.find(filesystem) != filesystems\&.end()) {
76         Logger::WARNING() << "Filesystem already mounted at " << mount_point << "\\n";
77         return;
78     }
79 
80     // Add the filesystem to the map
81     filesystems\&.insert(filesystem, mount_point);
82 }
.fi

.PP
References \fBLogger::WARNING()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::open_directory (\fBconst\fP \fBstring\fP & path)"

.PP
Try to open a directory on the virtual file system and read it's contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP
\fBReturns\fP
.RS 4
The directory object or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB237\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
237                                                                {
238 
239     // Ensure a valid path is given
240     if (!Path::valid(path))
241         return nullptr;
242 
243     // Try to find the filesystem that is responsible for the path
244     FileSystem* fs = find_filesystem(path);
245     if (!fs)
246         return nullptr;
247 
248     // Get where to open the directory
249     string relative_path = get_relative_path(fs, path);
250     string directory_path = Path::file_path(relative_path);
251 
252     // Open the directory
253     Directory* directory = fs\->get_directory(directory_path);
254     if (!directory)
255         return nullptr;
256     directory\->read_from_disk();
257 
258     return directory;
259 }
.fi

.PP
References \fBMaxOS::filesystem::Path::file_path()\fP, \fBfind_filesystem()\fP, \fBget_relative_path()\fP, \fBMaxOS::filesystem::Directory::read_from_disk()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_directory()\fP, \fBcreate_file()\fP, \fBdelete_directory()\fP, \fBdelete_file()\fP, \fBMaxOS::filesystem::VFSResourceRegistry::get_resource()\fP, and \fBopen_file()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::open_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Opens a subdirectory from a parent directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The parent directory 
.br
\fIname\fP The name of the subdirectory 
.RE
.PP
\fBReturns\fP
.RS 4
The opened subdirectory or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB268\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
268                                                                                   {
269 
270     // Open the file
271     Directory* opened_directory = parent\->open_subdirectory(name);
272     if (!opened_directory)
273         return nullptr;
274 
275     opened_directory\->read_from_disk();
276     return opened_directory;
277 }
.fi

.PP
References \fBname\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::open_file (\fBconst\fP \fBstring\fP & path, \fBsize_t\fP offset = \fC0\fP)"

.PP
Try to open a file on the virtual file system with a given offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.br
\fIoffset\fP The offset to seek to (default = 0) 
.RE
.PP
\fBReturns\fP
.RS 4
The file or null pointer if not found 
.RE
.PP

.PP
Definition at line \fB450\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
450                                                                     {
451 
452     // Ensure a valid path is given
453     if (!Path::valid(path))
454         return nullptr;
455 
456     // Open the directory
457     Directory* directory = open_directory(path);
458     if (!directory)
459         return nullptr;
460 
461     return open_file(directory, Path::file_name(path), offset);
462 }
.fi

.PP
References \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, \fBopen_file()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::VFSResourceRegistry::get_resource()\fP, and \fBopen_file()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::open_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name, \fBsize_t\fP offset = \fC0\fP)\fC [static]\fP"

.PP
Opens a file in a directory with the given offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory containing the file 
.br
\fIname\fP The name of the file to open 
.br
\fIoffset\fP How far in the file to open (default = 0) 
.RE
.PP
\fBReturns\fP
.RS 4
The file or null pointer if not found 
.RE
.PP

.PP
Definition at line \fB472\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
472                                                                                        {
473 
474     // Open the file
475     File* opened_file = parent\->open_file(name);
476     if (!opened_file)
477         return nullptr;
478 
479     // Seek to the offset
480     opened_file\->seek(SeekType::SET, offset);
481 
482     return opened_file;
483 }
.fi

.PP
References \fBname\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::root_directory ()"

.PP
Get the root directory of the virtual file system\&. 
.PP
\fBReturns\fP
.RS 4
The root directory of the virtual file system 
.RE
.PP

.PP
Definition at line \fB134\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
134                                              {
135 
136     // Get the root filesystem
137     FileSystem* fs = root_filesystem();
138     if (!fs)
139         return nullptr;
140 
141     // Get the root directory
142     return fs\->root_directory();
143 }
.fi

.PP
References \fBroot_filesystem()\fP\&.
.SS "\fBFileSystem\fP * VirtualFileSystem::root_filesystem ()"

.PP
Get the filesystem mounted at the root\&. 
.PP
\fBReturns\fP
.RS 4
The file system mounted '/' or null if none is mounted 
.RE
.PP

.PP
Definition at line \fB150\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
150                                                {
151 
152     // Ensure there is at least one filesystem mounted
153     if (filesystems\&.size() == 0)
154         return nullptr;
155 
156     // It is always the first filesystem mounted
157     return filesystems\&.begin()\->first;
158 }
.fi

.PP
Referenced by \fBroot_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_all ()"

.PP
Remove all mounted filesystems\&. 
.PP
Definition at line \fB121\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
121                                     {
122 
123     // Loop through the filesystems and unmount them
124     for(const auto& filesystem : filesystems)
125         unmount_filesystem(filesystem\&.first);
126 
127 }
.fi

.PP
References \fBunmount_filesystem()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_filesystem (\fBconst\fP \fBstring\fP & mount_point)"

.PP
Remove a filesystem from the virtual file system\&. 
.PP
\fBParameters\fP
.RS 4
\fImount_point\fP Where the filesystem is mounted 
.RE
.PP

.PP
Definition at line \fB107\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
107                                                                     {
108 
109     // Remove the filesystem from the map
110     for(const auto& filesystem : filesystems)
111         if (filesystem\&.second == mount_point)
112             return unmount_filesystem(filesystem\&.first);
113 
114     // Filesystem not found
115     Logger::WARNING() << "Filesystem not found at " << mount_point << "\\n";
116 }
.fi

.PP
References \fBunmount_filesystem()\fP, and \fBLogger::WARNING()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_filesystem (\fBFileSystem\fP * filesystem)"

.PP
Remove a filesystem from the virtual file system & delete it\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to remove 
.RE
.PP

.PP
Definition at line \fB89\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
89                                                                  {
90 
91     // Check if the filesystem is mounted
92     if (filesystems\&.find(filesystem) == filesystems\&.end())
93         return;
94 
95     // Remove the filesystem from the map
96     filesystems\&.erase(filesystem);
97 
98     // Delete the filesystem
99     delete filesystem;
100 }
.fi

.PP
Referenced by \fBunmount_all()\fP, and \fBunmount_filesystem()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

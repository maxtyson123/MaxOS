.TH "MaxOS::filesystem::VirtualFileSystem" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::VirtualFileSystem \- Combines all the filesystems across the partitions on each disk into a single filesystems and exposes a single API to interact with them\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vfs\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVirtualFileSystem\fP ()"
.br
.RI "Construct a new Virtual \fBFile\fP System object and set it as the current file system\&. "
.ti -1c
.RI "\fB~VirtualFileSystem\fP ()"
.br
.RI "Destroy the Virtual \fBFile\fP System object and unmount all filesystems\&. "
.ti -1c
.RI "\fBvoid\fP \fBmount_filesystem\fP (\fBFileSystem\fP *filesystem)"
.br
.RI "Add a filesystem to the virtual file system\&. "
.ti -1c
.RI "\fBvoid\fP \fBmount_filesystem\fP (\fBFileSystem\fP *filesystem, \fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Add a filesystem to the virtual file system at a given mount point\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_filesystem\fP (\fBFileSystem\fP *filesystem)"
.br
.RI "Remove a filesystem from the virtual file system & delete it\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_filesystem\fP (\fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Remove a filesystem from the virtual file system\&. "
.ti -1c
.RI "\fBvoid\fP \fBunmount_all\fP ()"
.br
.RI "Remove all mounted filesystems\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBroot_directory\fP ()"
.br
.RI "Get the root directory of the virtual file system\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBroot_filesystem\fP ()"
.br
.RI "Get the filesystem mounted at the root\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBget_filesystem\fP (\fBconst\fP \fBstring\fP &\fBmount_point\fP)"
.br
.RI "Get a specific filesystem mounted at a given mount point\&. "
.ti -1c
.RI "\fBFileSystem\fP * \fBfind_filesystem\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Find the filesystem that is responsible for a given path\&. "
.ti -1c
.RI "\fBstring\fP \fBget_relative_path\fP (\fBFileSystem\fP *filesystem, \fBstring\fP \fBpath\fP)"
.br
.RI "Get the relative path on a filesystem for a given VFS path (ie remove the mount point) "
.ti -1c
.RI "\fBDirectory\fP * \fBopen_directory\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Try to open a directory on the virtual file system and read it's contents\&. "
.ti -1c
.RI "\fBDirectory\fP * \fBcreate_directory\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Attempts to open the parent directory and creates the sub directory at the end of the path\&. "
.ti -1c
.RI "\fBvoid\fP \fBdelete_directory\fP (\fBstring\fP \fBpath\fP)"
.br
.RI "Attempts to open the parent directory and deletes the sub directory at the end of the path\&. "
.ti -1c
.RI "\fBFile\fP * \fBcreate_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Attempts to open the parent directory and create the file at the end of the path\&. "
.ti -1c
.RI "\fBFile\fP * \fBopen_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP, \fBsize_t\fP offset=0)"
.br
.RI "Try to open a file on the virtual file system with a given offset\&. "
.ti -1c
.RI "\fBvoid\fP \fBdelete_file\fP (\fBconst\fP \fBstring\fP &\fBpath\fP)"
.br
.RI "Opens a directory on the vfs and deletes the file at the end of the path\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBVirtualFileSystem\fP * \fBcurrent_file_system\fP ()"
.br
.RI "Get the active virtual file system\&. "
.ti -1c
.RI "\fBstatic\fP \fBDirectory\fP * \fBopen_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name)"
.br
.RI "Opens a subdirectory from a parent directory\&. "
.ti -1c
.RI "\fBstatic\fP \fBDirectory\fP * \fBcreate_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name)"
.br
.RI "Creates a subdirectory in the specified directory and\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name)"
.br
.RI "Delete a directory on the virtual file system and it's sub contents\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_directory\fP (\fBDirectory\fP *\fBparent\fP, \fBDirectory\fP *directory)"
.br
.RI "Delete a directory on the virtual file system and it's sub contents\&. "
.ti -1c
.RI "\fBstatic\fP \fBFile\fP * \fBcreate_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name)"
.br
.RI "Create a file in a directory\&. "
.ti -1c
.RI "\fBstatic\fP \fBFile\fP * \fBopen_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name, \fBsize_t\fP offset=0)"
.br
.RI "Opens a file in a directory with the given offset\&. "
.ti -1c
.RI "\fBstatic\fP \fBvoid\fP \fBdelete_file\fP (\fBDirectory\fP *\fBparent\fP, \fBconst\fP \fBstring\fP &name)"
.br
.RI "Delete a file in the given directory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Combines all the filesystems across the partitions on each disk into a single filesystems and exposes a single API to interact with them\&. 
.PP
Definition at line \fB25\fP of file \fBvfs\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VirtualFileSystem::VirtualFileSystem ()"

.PP
Construct a new Virtual \fBFile\fP System object and set it as the current file system\&. 
.PP
\fBNote\fP
.RS 4
Only call once 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
21                                      {
22 
23     // Set the current file system to this instance
24     s_current_file_system = this;
25 
26 }
.fi

.SS "VirtualFileSystem::~VirtualFileSystem ()"

.PP
Destroy the Virtual \fBFile\fP System object and unmount all filesystems\&. 
.PP
Definition at line \fB31\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
31                                       {
32 
33     // Remove all mounted filesystems
34     unmount_all();
35 
36     // Set the current file system to null
37     s_current_file_system = nullptr;
38 
39 }
.fi

.PP
References \fBunmount_all()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBDirectory\fP * VirtualFileSystem::create_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Creates a subdirectory in the specified directory and\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP Where to create the directory 
.br
\fIname\fP The name of the new directory 
.RE
.PP
\fBReturns\fP
.RS 4
The created directory 
.RE
.PP

.PP
Definition at line \fB322\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
322                                                                                     {
323 
324     // Create the directory
325     Directory* directory = parent\->create_subdirectory(name);
326     directory\->read_from_disk();
327 
328     return directory;
329 }
.fi

.PP
References \fBMaxOS::filesystem::Directory::read_from_disk()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::create_directory (\fBstring\fP path)"

.PP
Attempts to open the parent directory and creates the sub directory at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP
\fBReturns\fP
.RS 4
The directory object or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB293\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
293                                                           {
294 
295     // Ensure a valid path is given
296     if (!Path::valid(path))
297         return nullptr;
298 
299     path = path\&.strip('/');
300 
301     // Try to find the filesystem that is responsible for the path
302     FileSystem* fs = find_filesystem(path);
303     if (!fs)
304         return nullptr;
305 
306     // Open the parent directory
307     Directory* parent_directory = open_directory(path);
308     if (!parent_directory)
309         return nullptr;
310 
311     string directory_name = Path::file_name(path);
312     return create_directory(parent_directory, directory_name);
313 }
.fi

.PP
References \fBcreate_directory()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBfind_filesystem()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_directory()\fP, and \fBMaxOS::filesystem::VFSResourceRegistry::create_resource()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::create_file (\fBconst\fP \fBstring\fP & path)"

.PP
Attempts to open the parent directory and create the file at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.RE
.PP
\fBReturns\fP
.RS 4
The file object or null if it could not be created 
.RE
.PP

.PP
Definition at line \fB425\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
425                                                        {
426 
427     // Ensure a valid path is given
428     if (!Path::valid(path))
429         return nullptr;
430 
431     // Open the directory
432     Directory* directory = open_directory(path);
433     if (!directory)
434         return nullptr;
435 
436     // Create the file
437     string file_name = Path::file_name(path);
438     return create_file(directory, file_name);
439 }
.fi

.PP
References \fBcreate_file()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_file()\fP, and \fBMaxOS::filesystem::VFSResourceRegistry::create_resource()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::create_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Create a file in a directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory where the file should be created 
.br
\fIname\fP The name of the file to create 
.RE
.PP
\fBReturns\fP
.RS 4
The created file or null pointer if it could not be created 
.RE
.PP

.PP
Definition at line \fB448\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
448                                                                           {
449     return parent\->create_file(name);
450 }
.fi

.SS "\fBVirtualFileSystem\fP * VirtualFileSystem::current_file_system ()\fC [static]\fP"

.PP
Get the active virtual file system\&. 
.PP
\fBReturns\fP
.RS 4
The current virtual file system or null if none is set 
.RE
.PP

.PP
Definition at line \fB46\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
46                                                           {
47     return s_current_file_system;
48 }
.fi

.PP
Referenced by \fBMaxOS::filesystem::partition::MSDOSPartition::mount_partitions()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Delete a directory on the virtual file system and it's sub contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory that contains the reference to the directory being deleted 
.br
\fIname\fP The name of the directory to delete 
.RE
.PP

.PP
Definition at line \fB361\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
361                                                                               {
362 
363     // Find the directory and delete it
364     for (const auto& directory: parent\->subdirectories())
365         if (directory\->name() == name)
366             delete_directory(parent, directory);
367 
368 }
.fi

.PP
References \fBdelete_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBDirectory\fP * parent, \fBDirectory\fP * directory)\fC [static]\fP"

.PP
Delete a directory on the virtual file system and it's sub contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory that contains the reference to the directory being deleted 
.br
\fIdirectory\fP The the directory to delete 
.RE
.PP

.PP
Definition at line \fB376\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
376                                                                                 {
377 
378     // Nothing to delete
379     if (!directory)
380         return;
381 
382     // Store a reference to each subdirectory and its parent
383     Map<Directory*, Directory*> stack;
384     Vector<Pair<Directory*, Directory*>> to_delete;
385     stack\&.push_back(parent, directory);
386 
387     while (!stack\&.empty()) {
388 
389         // Save the current
390         auto current = stack\&.pop_back();
391         auto current_directory = current\&.second;
392         current_directory\->read_from_disk();
393         to_delete\&.push_back({current\&.first, current_directory});
394 
395         // Empty the directory
396         for (const auto &file: current_directory\->files())
397             delete_file(current_directory, file\->name());
398 
399         // Process the subdirectories
400         for (const auto &subdir: current_directory\->subdirectories())
401             if (subdir\->name() != "\&." && subdir\->name() != "\&.\&.")
402                 stack\&.push_back(current_directory, subdir);
403 
404     }
405 
406     // Delete the directory from the bottom of the tree
407     for (uint32_t i = to_delete\&.size() \- 1; i >= 0; \-\-i) {
408 
409         // Get the parent and child
410         const auto &current = to_delete[i];
411         Directory* owner = current\&.first;
412         Directory* subdirectory = current\&.second;
413 
414         owner\->remove_subdirectory(subdirectory\->name());
415     }
416 }
.fi

.PP
References \fBdelete_file()\fP, and \fBstack\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_directory (\fBstring\fP path)"

.PP
Attempts to open the parent directory and deletes the sub directory at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP

.PP
Definition at line \fB337\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
337                                                     {
338 
339     // Ensure a valid path is given
340     if (!Path::valid(path))
341         return;
342 
343     path = path\&.strip('/');
344 
345     // Open the directory
346     Directory* parent_directory = open_directory(path);
347     if (!parent_directory)
348         return;
349 
350     // Delete the directory
351     string directory_name = Path::file_name(path);
352     delete_directory(parent_directory, directory_name);
353 }
.fi

.PP
References \fBdelete_directory()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBdelete_directory()\fP, and \fBdelete_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_file (\fBconst\fP \fBstring\fP & path)"

.PP
Opens a directory on the vfs and deletes the file at the end of the path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.RE
.PP

.PP
Definition at line \fB499\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
499                                                       {
500 
501     // Ensure a valid path is given
502     if (!Path::valid(path))
503         return;
504 
505     // Open the directory
506     Directory* directory = open_directory(path);
507     if (!directory)
508         return;
509 
510     // Delete the file
511     string file_name = Path::file_name(path);
512     delete_file(directory, file_name);
513 }
.fi

.PP
References \fBdelete_file()\fP, \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBdelete_directory()\fP, and \fBdelete_file()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::delete_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Delete a file in the given directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory containing the file 
.br
\fIname\fP The name of the file 
.RE
.PP

.PP
Definition at line \fB521\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
521                                                                          {
522 
523     // Delete the file
524     parent\->remove_file(name);
525 }
.fi

.SS "\fBFileSystem\fP * VirtualFileSystem::find_filesystem (\fBstring\fP path)"

.PP
Find the filesystem that is responsible for a given path\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to search for 
.RE
.PP
\fBReturns\fP
.RS 4
The filesystem that contains the path or null if none is found 
.RE
.PP

.PP
Definition at line \fB191\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
191                                                           {
192 
193     // Longest matching path will be where the filesystem is mounted
194     string longest_match = "";
195     FileSystem* longest_match_fs = nullptr;
196 
197     // Search through the filesystems
198     for (const auto& filesystem : filesystems) {
199         // Get the filesystem and mount point
200         FileSystem* fs = filesystem\&.first;
201         string mount_point = filesystem\&.second;
202 
203         // Check if the path starts with the mount point
204         if (path\&.starts_with(mount_point) && mount_point\&.length() > longest_match\&.length()) {
205             longest_match = mount_point;
206             longest_match_fs = fs;
207         }
208     }
209 
210     return longest_match_fs;
211 }
.fi

.PP
Referenced by \fBcreate_directory()\fP, and \fBopen_directory()\fP\&.
.SS "\fBFileSystem\fP * VirtualFileSystem::get_filesystem (\fBconst\fP \fBstring\fP & mount_point)"

.PP
Get a specific filesystem mounted at a given mount point\&. 
.PP
\fBParameters\fP
.RS 4
\fImount_point\fP The mount point to search for 
.RE
.PP
\fBReturns\fP
.RS 4
The filesystem mounted at the given mount point or null if none is found 
.RE
.PP

.PP
Definition at line \fB174\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
174                                                                        {
175 
176     // Check if the filesystem is mounted
177     for(const auto& filesystem : filesystems)
178         if (filesystem\&.second == mount_point)
179             return filesystem\&.first;
180 
181     // Filesystem not found
182     return nullptr;
183 }
.fi

.SS "\fBstring\fP VirtualFileSystem::get_relative_path (\fBFileSystem\fP * filesystem, \fBstring\fP path)"

.PP
Get the relative path on a filesystem for a given VFS path (ie remove the mount point) 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to get the path for 
.br
\fIpath\fP The path to get the relative path for 
.RE
.PP
\fBReturns\fP
.RS 4
The relative path on the filesystem or an empty string if none is found 
.RE
.PP

.PP
Definition at line \fB220\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
220                                                                                {
221 
222     // Find the mount point for the filesystem
223     auto fs = filesystems\&.find(filesystem);
224     if (fs == filesystems\&.end())
225         return "";
226 
227     // Get the mount point
228     string mount_point = fs\->second;
229 
230     // Make sure that the path points to the filesystem
231     if (!path\&.starts_with(mount_point))
232         return "";
233 
234     // Get the relative path
235     string relative_path = path\&.substring(mount_point\&.length(), path\&.length() \- mount_point\&.length());
236     return relative_path;
237 }
.fi

.PP
Referenced by \fBopen_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::mount_filesystem (\fBFileSystem\fP * filesystem)"

.PP
Add a filesystem to the virtual file system\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to add 
.RE
.PP

.PP
Definition at line \fB55\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
55                                                                {
56 
57     // Check if the filesystem is already mounted
58     if (filesystems\&.find(filesystem) != filesystems\&.end()) {
59         Logger::WARNING() << "Filesystem already mounted\\n";
60         return;
61     }
62 
63     // Get the mount point for the filesystem
64     string mount_point = "/filesystem_" + filesystems\&.size();
65 
66     // If this is the first filesystem to be mounted, set the root filesystem
67     if (filesystems\&.size() == 0)
68         mount_point = "/";
69 
70     // Add the filesystem to the map
71     filesystems\&.insert(filesystem, mount_point);
72 }
.fi

.PP
References \fBMaxOS::Logger::WARNING()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::mount_filesystem (\fBFileSystem\fP * filesystem, \fBconst\fP \fBstring\fP & mount_point)"

.PP
Add a filesystem to the virtual file system at a given mount point\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to add 
.br
\fImount_point\fP The mount point for the filesystem 
.RE
.PP

.PP
Definition at line \fB80\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
80                                                                                           {
81 
82     // Check if the filesystem is already mounted
83     if (filesystems\&.find(filesystem) != filesystems\&.end()) {
84         Logger::WARNING() << "Filesystem already mounted at " << mount_point << "\\n";
85         return;
86     }
87 
88     // Add the filesystem to the map
89     filesystems\&.insert(filesystem, mount_point);
90 }
.fi

.PP
References \fBMaxOS::Logger::WARNING()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::open_directory (\fBconst\fP \fBstring\fP & path)"

.PP
Try to open a directory on the virtual file system and read it's contents\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the directory 
.RE
.PP
\fBReturns\fP
.RS 4
The directory object or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB245\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
245                                                                {
246 
247     // Ensure a valid path is given
248     if (!Path::valid(path))
249         return nullptr;
250 
251     // Try to find the filesystem that is responsible for the path
252     FileSystem* fs = find_filesystem(path);
253     if (!fs)
254         return nullptr;
255 
256     // Get where to open the directory
257     string relative_path = get_relative_path(fs, path);
258     string directory_path = Path::file_path(relative_path);
259 
260     // Open the directory
261     Directory* directory = fs\->get_directory(directory_path);
262     if (!directory)
263         return nullptr;
264     directory\->read_from_disk();
265 
266     return directory;
267 }
.fi

.PP
References \fBMaxOS::filesystem::Path::file_path()\fP, \fBfind_filesystem()\fP, \fBget_relative_path()\fP, \fBMaxOS::filesystem::Directory::read_from_disk()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBcreate_directory()\fP, \fBcreate_file()\fP, \fBdelete_directory()\fP, \fBdelete_file()\fP, \fBMaxOS::filesystem::VFSResourceRegistry::get_resource()\fP, and \fBopen_file()\fP\&.
.SS "\fBDirectory\fP * VirtualFileSystem::open_directory (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name)\fC [static]\fP"

.PP
Opens a subdirectory from a parent directory\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The parent directory 
.br
\fIname\fP The name of the subdirectory 
.RE
.PP
\fBReturns\fP
.RS 4
The opened subdirectory or null if it could not be opened 
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
276                                                                                   {
277 
278     // Open the file
279     Directory* opened_directory = parent\->open_subdirectory(name);
280     if (!opened_directory)
281         return nullptr;
282 
283     opened_directory\->read_from_disk();
284     return opened_directory;
285 }
.fi

.SS "\fBFile\fP * VirtualFileSystem::open_file (\fBconst\fP \fBstring\fP & path, \fBsize_t\fP offset = \fC0\fP)"

.PP
Try to open a file on the virtual file system with a given offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The path to the file (including the extension) 
.br
\fIoffset\fP The offset to seek to (default = 0) 
.RE
.PP
\fBReturns\fP
.RS 4
The file or null pointer if not found 
.RE
.PP

.PP
Definition at line \fB459\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
459                                                                     {
460 
461     // Ensure a valid path is given
462     if (!Path::valid(path))
463         return nullptr;
464 
465     // Open the directory
466     Directory* directory = open_directory(path);
467     if (!directory)
468         return nullptr;
469 
470     return open_file(directory, Path::file_name(path), offset);
471 }
.fi

.PP
References \fBMaxOS::filesystem::Path::file_name()\fP, \fBopen_directory()\fP, \fBopen_file()\fP, and \fBMaxOS::filesystem::Path::valid()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::VFSResourceRegistry::get_resource()\fP, and \fBopen_file()\fP\&.
.SS "\fBFile\fP * VirtualFileSystem::open_file (\fBDirectory\fP * parent, \fBconst\fP \fBstring\fP & name, \fBsize_t\fP offset = \fC0\fP)\fC [static]\fP"

.PP
Opens a file in a directory with the given offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP The directory containing the file 
.br
\fIname\fP The name of the file to open 
.br
\fIoffset\fP How far in the file to open (default = 0) 
.RE
.PP
\fBReturns\fP
.RS 4
The file or null pointer if not found 
.RE
.PP

.PP
Definition at line \fB481\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
481                                                                                        {
482 
483     // Open the file
484     File* opened_file = parent\->open_file(name);
485     if (!opened_file)
486         return nullptr;
487 
488     // Seek to the offset
489     opened_file\->seek(SeekType::SET, offset);
490 
491     return opened_file;
492 }
.fi

.SS "\fBDirectory\fP * VirtualFileSystem::root_directory ()"

.PP
Get the root directory of the virtual file system\&. 
.PP
\fBReturns\fP
.RS 4
The root directory of the virtual file system 
.RE
.PP

.PP
Definition at line \fB142\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
142                                              {
143 
144     // Get the root filesystem
145     FileSystem* fs = root_filesystem();
146     if (!fs)
147         return nullptr;
148 
149     // Get the root directory
150     return fs\->root_directory();
151 }
.fi

.PP
References \fBroot_filesystem()\fP\&.
.SS "\fBFileSystem\fP * VirtualFileSystem::root_filesystem ()"

.PP
Get the filesystem mounted at the root\&. 
.PP
\fBReturns\fP
.RS 4
The file system mounted '/' or null if none is mounted 
.RE
.PP

.PP
Definition at line \fB158\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
158                                                {
159 
160     // Ensure there is at least one filesystem mounted
161     if (filesystems\&.size() == 0)
162         return nullptr;
163 
164     // It is always the first filesystem mounted
165     return filesystems\&.begin()\->first;
166 }
.fi

.PP
Referenced by \fBroot_directory()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_all ()"

.PP
Remove all mounted filesystems\&. 
.PP
Definition at line \fB129\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
129                                     {
130 
131     // Loop through the filesystems and unmount them
132     for(const auto& filesystem : filesystems)
133         unmount_filesystem(filesystem\&.first);
134 
135 }
.fi

.PP
References \fBunmount_filesystem()\fP\&.
.PP
Referenced by \fB~VirtualFileSystem()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_filesystem (\fBconst\fP \fBstring\fP & mount_point)"

.PP
Remove a filesystem from the virtual file system\&. 
.PP
\fBParameters\fP
.RS 4
\fImount_point\fP Where the filesystem is mounted 
.RE
.PP

.PP
Definition at line \fB115\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
115                                                                     {
116 
117     // Remove the filesystem from the map
118     for(const auto& filesystem : filesystems)
119         if (filesystem\&.second == mount_point)
120             return unmount_filesystem(filesystem\&.first);
121 
122     // Filesystem not found
123     Logger::WARNING() << "Filesystem not found at " << mount_point << "\\n";
124 }
.fi

.PP
References \fBunmount_filesystem()\fP, and \fBMaxOS::Logger::WARNING()\fP\&.
.SS "\fBvoid\fP VirtualFileSystem::unmount_filesystem (\fBFileSystem\fP * filesystem)"

.PP
Remove a filesystem from the virtual file system & delete it\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilesystem\fP The filesystem to remove 
.RE
.PP

.PP
Definition at line \fB97\fP of file \fBvfs\&.cpp\fP\&..PP
.nf
97                                                                  {
98 
99     // Check if the filesystem is mounted
100     if (filesystems\&.find(filesystem) == filesystems\&.end())
101         return;
102 
103     // Remove the filesystem from the map
104     filesystems\&.erase(filesystem);
105 
106     // Delete the filesystem
107     delete filesystem;
108 }
.fi

.PP
Referenced by \fBunmount_all()\fP, and \fBunmount_filesystem()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

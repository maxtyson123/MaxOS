.TH "MaxOS::processes::Scheduler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Scheduler \- Schedules processes to run on the core via their threads\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <scheduler\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBScheduler\fP ()"
.br
.RI "Constructs a new \fBScheduler\fP object and creates the idle process\&. "
.ti -1c
.RI "system::cpu_status_t * \fBschedule\fP (system::cpu_status_t *cpu_state)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "system::cpu_status_t * \fBschedule_next\fP (system::cpu_status_t *status)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "system::cpu_status_t * \fByield\fP ()"
.br
.RI "Pass execution to the next thread\&. "
.ti -1c
.RI "uint64_t \fBadd_process\fP (\fBProcess\fP *process)"
.br
.RI "Adds a process to the scheduler\&. "
.ti -1c
.RI "uint64_t \fBremove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) "
.ti -1c
.RI "system::cpu_status_t * \fBforce_remove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler and deletes all threads, begins running the next process\&. "
.ti -1c
.RI "uint64_t \fBadd_thread\fP (\fBThread\fP *thread)"
.br
.RI "Adds a thread to the scheduler\&. "
.ti -1c
.RI "\fBProcess\fP * \fBcurrent_process\fP ()"
.br
.RI "Gets the current process\&. "
.ti -1c
.RI "\fBProcess\fP * \fBget_process\fP (uint64_t pid)"
.br
.RI "Gets a process by its PID\&. "
.ti -1c
.RI "uint64_t \fBprocess_amount\fP ()"
.br
.RI "Gets how processes are running on this scheduler\&. "
.ti -1c
.RI "\fBThread\fP * \fBcurrent_thread\fP ()"
.br
.RI "Gets the currently executing thread\&. "
.ti -1c
.RI "\fBThread\fP * \fBget_thread\fP (uint64_t tid)"
.br
.RI "Gets a thread by its TID\&. "
.ti -1c
.RI "uint64_t \fBthread_amount\fP ()"
.br
.RI "Gets how many threads are running on this scheduler\&. "
.ti -1c
.RI "uint64_t \fBticks\fP () const"
.br
.RI "Gets how long the system has been running for\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "Activates the scheduler\&. "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "Deactivates the scheduler\&. "
.in -1c
.SH "Detailed Description"
.PP 
Schedules processes to run on the core via their threads\&. 
.PP
Definition at line \fB85\fP of file \fBscheduler\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Scheduler::Scheduler ()"

.PP
Constructs a new \fBScheduler\fP object and creates the idle process\&. 
.PP
Definition at line \fB362\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
363 : m_next_thread_index(0),
364   m_active(false),
365   m_ticks(0)
366 {
367 
368     // Create this idle process
369     auto* idle = new Process("Idle", nullptr, nullptr, 0, true);
370     idle\->memory_manager = MemoryManager::s_kernel_memory_manager;
371     idle\->set_pid(0);
372     add_process(idle);
373 }
.fi

.PP
References \fBadd_process()\fP, and \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void Scheduler::activate ()"

.PP
Activates the scheduler\&. 
.PP
Definition at line \fB568\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
568                          {
569 
570     m_active = true;
571 }
.fi

.SS "uint64_t Scheduler::add_process (\fBProcess\fP * process)"

.PP
Adds a process to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to add 
.RE
.PP
\fBReturns\fP
.RS 4
The process ID (will be assigned during add) 
.RE
.PP

.PP
Definition at line \fB502\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
502                                                 {
503 
504     // Get the next process ID
505     auto pid = GlobalScheduler::next_pid();
506     process\->set_pid(pid);
507 
508     // Add the process to the list
509     m_processes\&.push_back(process);
510 
511     // Add the threads to the list
512     for(const auto& thread : process\->threads())
513         thread\->tid = add_thread(thread);
514 
515     return pid;
516 }
.fi

.PP
References \fBadd_thread()\fP, \fBMaxOS::processes::GlobalScheduler::next_pid()\fP, \fBMaxOS::processes::Process::set_pid()\fP, \fBMaxOS::processes::Process::threads()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP, and \fBScheduler()\fP\&.
.SS "uint64_t Scheduler::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP
\fBReturns\fP
.RS 4
The thread ID 
.RE
.PP

.PP
Definition at line \fB524\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
524                                              {
525 
526     // Get the next thread ID
527     auto tid = GlobalScheduler::next_tid();
528     thread\->tid = tid;
529 
530     // Add the thread to the list
531     m_threads\&.push_back(thread);
532 
533     // Return the thread ID
534     return tid;
535 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::next_tid()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.PP
Referenced by \fBadd_process()\fP, and \fBMaxOS::processes::GlobalScheduler::add_thread()\fP\&.
.SS "\fBProcess\fP * Scheduler::current_process ()"

.PP
Gets the current process\&. 
.PP
\fBReturns\fP
.RS 4
The current process, or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB642\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
642                                     {
643 
644     Process* current_process = nullptr;
645 
646     // Find the process that has the thread being executed
647     for (auto process: m_processes)
648         if (process\->pid() == current_thread()\->parent_pid) {
649             current_process = process;
650             break;
651         }
652 
653     return current_process;
654 }
.fi

.PP
References \fBcurrent_process()\fP, \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::parent_pid\fP, and \fBMaxOS::processes::Process::pid()\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBcurrent_process()\fP, and \fBschedule_next()\fP\&.
.SS "\fBThread\fP * Scheduler::current_thread ()"

.PP
Gets the currently executing thread\&. 
.PP
\fBReturns\fP
.RS 4
The currently executing thread 
.RE
.PP

.PP
Definition at line \fB686\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
686                                   {
687 
688     return m_threads[m_next_thread_index];
689 }
.fi

.PP
Referenced by \fBcurrent_process()\fP, \fBMaxOS::processes::GlobalScheduler::current_thread()\fP, \fBforce_remove_process()\fP, \fBschedule()\fP, \fBschedule_next()\fP, and \fByield()\fP\&.
.SS "void Scheduler::deactivate ()"

.PP
Deactivates the scheduler\&. 
.PP
Definition at line \fB702\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
702                            {
703 
704     m_active = false;
705 }
.fi

.SS "cpu_status_t * Scheduler::force_remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler and deletes all threads, begins running the next process\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the CPU for the next process to run or nullptr if the process was not found 
.RE
.PP

.PP
Definition at line \fB614\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
614                                                               {
615 
616     // If there is no process, fail
617     if (!process)
618         return nullptr;
619 
620     // Remove all the threads
621     for (auto thread: process\->threads()) {
622 
623         // Remove the thread from the scheduler
624         int index = m_threads\&.find(thread) \- m_threads\&.begin();
625         m_threads\&.erase(m_threads\&.begin() + index);
626 
627         // Delete the thread
628         process\->remove_thread(thread\->tid);
629 
630     }
631 
632     // Process will be dead now so run the next process (don't care about the execution state being outdated as it is being
633     // removed regardless)
634     return schedule_next(&current_thread()\->execution_state);
635 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBMaxOS::processes::Process::remove_thread()\fP, \fBschedule_next()\fP, \fBMaxOS::processes::Process::threads()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.SS "\fBProcess\fP * Scheduler::get_process (uint64_t pid)"

.PP
Gets a process by its PID\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The process ID 
.RE
.PP
\fBReturns\fP
.RS 4
The process or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB662\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
662                                             {
663 
664     // Try to find the process
665     for (auto process: m_processes)
666         if (process\->pid() == pid)
667             return process;
668 
669     // Not found
670     return nullptr;
671 }
.fi

.PP
References \fBMaxOS::processes::Process::pid()\fP\&.
.SS "\fBThread\fP * Scheduler::get_thread (uint64_t tid)"

.PP
Gets a thread by its TID\&. 
.PP
\fBParameters\fP
.RS 4
\fItid\fP The thread ID 
.RE
.PP
\fBReturns\fP
.RS 4
The thread or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB713\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
713                                           {
714 
715     // Try to find the thread
716     for (auto thread: m_threads)
717         if (thread\->tid == tid)
718             return thread;
719 
720     return nullptr;
721 }
.fi

.PP
References \fBMaxOS::processes::Thread::tid\fP\&.
.SS "uint64_t Scheduler::process_amount ()"

.PP
Gets how processes are running on this scheduler\&. 
.PP
\fBReturns\fP
.RS 4
The amount 
.RE
.PP

.PP
Definition at line \fB677\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
677                                    {
678     return m_processes\&.size();
679 }
.fi

.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP\&.
.SS "uint64_t Scheduler::remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.RE
.PP
\fBReturns\fP
.RS 4
-1 if the process has threads, 0 otherwise 
.RE
.PP

.PP
Definition at line \fB579\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
579                                                    {
580 
581     // Check if the process has no threads
582     if (!process\->threads()\&.empty()) {
583 
584         // Set the threads to stopped or remove them if forced
585         for (auto thread: process\->threads())
586             thread\->thread_state = ThreadState::STOPPED;
587 
588         // Need to wait until the threads are stopped before removing the process (this will be called again when all threads are stopped)
589         return \-1;
590 
591     }
592 
593     // Remove the process
594     for (uint32_t i = 0; i < m_processes\&.size(); i++) {
595         if (m_processes[i] == process) {
596             m_processes\&.erase(m_processes\&.begin() + i);
597 
598             // Delete the process mem
599             delete process;
600             return 0;
601         }
602     }
603 
604     // Process not found
605     return \-1;
606 }
.fi

.PP
References \fBMaxOS::processes::Thread::thread_state\fP, and \fBMaxOS::processes::Process::threads()\fP\&.
.PP
Referenced by \fBschedule_next()\fP\&.
.SS "cpu_status_t * Scheduler::schedule (system::cpu_status_t * cpu_state)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIcpu_state\fP The current CPU state 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU state 
.RE
.PP

.PP
Definition at line \fB384\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
384                                                          {
385 
386     // Scheduler cant schedule anything
387     if (m_threads\&.empty() || !m_active)
388         return cpu_state;
389 
390     // Thread that we are dealing with
391     Thread* current_thread = m_threads[m_next_thread_index];
392 
393     // Ticked
394     m_ticks++;
395     current_thread\->ticks++;
396 
397     // Thread hasn't used its time slot yet
398     if(current_thread\->ticks % TICKS_PER_EVENT)
399         return cpu_state;
400 
401     // Schedule the next thread
402     return schedule_next(cpu_state);
403 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBschedule_next()\fP, \fBMaxOS::processes::Thread::ticks\fP, and \fBMaxOS::processes::TICKS_PER_EVENT\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::handle_interrupt()\fP\&.
.SS "cpu_status_t * Scheduler::schedule_next (system::cpu_status_t * status)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current CPU status of the thread 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU status
.RE
.PP
\fBTodo\fP
.RS 4
Remove by reference where possible 
.RE
.PP

.PP
Definition at line \fB413\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
413                                                               {
414 
415     // Get the current state
416     Thread* current_thread = m_threads[m_next_thread_index];
417     Process* owner_process = current_process();
418     auto old_tid = m_next_thread_index;
419 
420     // Save the executing thread state
421     current_thread\->execution_state = *cpu_state;
422     current_thread\->save_sse_state();
423     if (current_thread\->thread_state == ThreadState::RUNNING)
424         current_thread\->thread_state = ThreadState::READY;
425 
426     // Find a free thread to run
427     while ((++m_next_thread_index) != old_tid){
428         m_next_thread_index %= m_threads\&.size();
429 
430         // Get the current thread
431         current_thread = m_threads[m_next_thread_index];
432         owner_process = current_process();
433 
434         // Handle state changes
435         switch (current_thread\->thread_state) {
436 
437             case ThreadState::SLEEPING:
438 
439                 // If the wake\-up time hasn't occurred yet, run the next thread
440                 if (current_thread\->wakeup_time > TICKS_PER_EVENT){
441                     current_thread\->wakeup_time \-= TICKS_PER_EVENT;
442                     continue;
443                 }
444 
445                 break;
446 
447             case ThreadState::STOPPED:
448 
449                 // Find the process that has the thread and remove it
450                 for (auto thread: owner_process\->threads()) {
451                     if (thread == current_thread) {
452                         owner_process\->remove_thread(thread\->tid);
453                         break;
454                     }
455                 }
456 
457                 // Remove the thread
458                 m_threads\&.erase(m_threads\&.begin() + m_next_thread_index);
459                 if(owner_process\->threads()\&.empty())
460                     remove_process(owner_process);
461                 continue;
462 
463             case ThreadState::WAITING:
464                 continue;
465 
466             default:
467                 break;
468         }
469         break;
470     }
471 
472     // Load the thread's state
473     return load_process(owner_process, current_thread);
474 }
.fi

.PP
References \fBcurrent_process()\fP, \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::execution_state\fP, \fBremove_process()\fP, \fBMaxOS::processes::Process::remove_thread()\fP, \fBMaxOS::processes::Thread::save_sse_state()\fP, \fBMaxOS::processes::Thread::thread_state\fP, \fBMaxOS::processes::Process::threads()\fP, \fBMaxOS::processes::TICKS_PER_EVENT\fP, and \fBMaxOS::processes::Thread::wakeup_time\fP\&.
.PP
Referenced by \fBforce_remove_process()\fP, \fBschedule()\fP, and \fByield()\fP\&.
.SS "uint64_t Scheduler::thread_amount ()"

.PP
Gets how many threads are running on this scheduler\&. 
.PP
\fBReturns\fP
.RS 4
The amount 
.RE
.PP

.PP
Definition at line \fB695\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
695                                  {
696     return m_threads\&.size();
697 }
.fi

.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_thread()\fP\&.
.SS "uint64_t Scheduler::ticks () const"

.PP
Gets how long the system has been running for\&. 
.PP
\fBReturns\fP
.RS 4
The number of ticks 
.RE
.PP

.PP
Definition at line \fB542\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
542                                 {
543 
544     return m_ticks;
545 }
.fi

.SS "cpu_status_t * Scheduler::yield ()"

.PP
Pass execution to the next thread\&. 
.PP
Definition at line \fB550\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
550                                {
551 
552     // If this is the only thread, can't yield
553     if (m_threads\&.size() <= 1)
554         return &current_thread()\->execution_state;
555 
556     // Set the current thread to waiting if running
557     auto thread = current_thread();
558     if (thread\->thread_state == ThreadState::RUNNING)
559         thread\->thread_state = ThreadState::READY;
560 
561     // Schedule the next thread
562     return schedule_next(&thread\->execution_state);
563 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::execution_state\fP, \fBschedule_next()\fP, and \fBMaxOS::processes::Thread::thread_state\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::Scheduler" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Scheduler \- Schedules processes to run on the core via their threads\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <scheduler\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBScheduler\fP ()"
.br
.RI "Constructs a new \fBScheduler\fP object and creates the idle process\&. "
.ti -1c
.RI "\fBsystem::cpu_status_t\fP * \fBschedule\fP (\fBsystem::cpu_status_t\fP *cpu_state)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "\fBsystem::cpu_status_t\fP * \fBschedule_next\fP (\fBsystem::cpu_status_t\fP *status)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "\fBsystem::cpu_status_t\fP * \fByield\fP ()"
.br
.RI "Pass execution to the next thread\&. "
.ti -1c
.RI "uint64_t \fBadd_process\fP (\fBProcess\fP *process)"
.br
.RI "Adds a process to the scheduler\&. "
.ti -1c
.RI "uint64_t \fBremove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) "
.ti -1c
.RI "\fBsystem::cpu_status_t\fP * \fBforce_remove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler and deletes all threads, begins running the next process\&. "
.ti -1c
.RI "uint64_t \fBadd_thread\fP (\fBThread\fP *thread)"
.br
.RI "Adds a thread to the scheduler\&. "
.ti -1c
.RI "\fBProcess\fP * \fBcurrent_process\fP ()"
.br
.RI "Gets the current process\&. "
.ti -1c
.RI "\fBProcess\fP * \fBget_process\fP (uint64_t pid)"
.br
.RI "Gets a process by its PID\&. "
.ti -1c
.RI "uint64_t \fBprocess_amount\fP ()"
.br
.RI "Gets how processes are running on this scheduler\&. "
.ti -1c
.RI "\fBThread\fP * \fBcurrent_thread\fP ()"
.br
.RI "Gets the currently executing thread\&. "
.ti -1c
.RI "\fBThread\fP * \fBget_thread\fP (uint64_t tid)"
.br
.RI "Gets a thread by its TID\&. "
.ti -1c
.RI "uint64_t \fBthread_amount\fP ()"
.br
.RI "Gets how many threads are running on this scheduler\&. "
.ti -1c
.RI "uint64_t \fBticks\fP () const"
.br
.RI "Gets how long the system has been running for\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "Activates the scheduler\&. "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "Deactivates the scheduler\&. "
.in -1c
.SH "Detailed Description"
.PP 
Schedules processes to run on the core via their threads\&. 
.PP
Definition at line \fB85\fP of file \fBscheduler\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Scheduler::Scheduler ()"

.PP
Constructs a new \fBScheduler\fP object and creates the idle process\&. 
.PP
Definition at line \fB365\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
366 : m_next_thread_index(0),
367   m_active(false),
368   m_ticks(0)
369 {
370 
371     // Create this idle process
372     auto* idle = new Process("Idle", nullptr, nullptr, 0, true);
373     idle\->memory_manager = MemoryManager::s_kernel_memory_manager;
374     idle\->set_pid(0);
375     add_process(idle);
376 }
.fi

.PP
References \fBadd_process()\fP, and \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void Scheduler::activate ()"

.PP
Activates the scheduler\&. 
.PP
Definition at line \fB573\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
573                          {
574 
575     m_active = true;
576 }
.fi

.SS "uint64_t Scheduler::add_process (\fBProcess\fP * process)"

.PP
Adds a process to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to add 
.RE
.PP
\fBReturns\fP
.RS 4
The process ID (will be assigned during add) 
.RE
.PP

.PP
Definition at line \fB505\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
505                                                 {
506 
507     // Get the next process ID
508     auto pid = GlobalScheduler::next_pid();
509     process\->set_pid(pid);
510 
511     // Add the process to the list
512     m_processes\&.push_back(process);
513 
514     // Add the threads to the list
515     for(const auto& thread : process\->threads())
516         thread\->tid = add_thread(thread);
517 
518     return pid;
519 }
.fi

.PP
References \fBadd_thread()\fP, \fBMaxOS::processes::GlobalScheduler::next_pid()\fP, \fBMaxOS::processes::Process::set_pid()\fP, \fBMaxOS::processes::Process::threads()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP, and \fBScheduler()\fP\&.
.SS "uint64_t Scheduler::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP
\fBReturns\fP
.RS 4
The thread ID 
.RE
.PP

.PP
Definition at line \fB527\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
527                                              {
528 
529     // Get the next thread ID
530     auto tid = GlobalScheduler::next_tid();
531     thread\->tid = tid;
532 
533     // Add the thread to the list
534     m_threads\&.push_back(thread);
535 
536     // Return the thread ID
537     return tid;
538 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::next_tid()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.PP
Referenced by \fBadd_process()\fP, and \fBMaxOS::processes::GlobalScheduler::add_thread()\fP\&.
.SS "\fBProcess\fP * Scheduler::current_process ()"

.PP
Gets the current process\&. 
.PP
\fBReturns\fP
.RS 4
The current process, or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB647\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
647                                     {
648 
649     Process* current_process = nullptr;
650 
651     // Find the process that has the thread being executed
652     for (auto process: m_processes)
653         if (process\->pid() == current_thread()\->parent_pid) {
654             current_process = process;
655             break;
656         }
657 
658     return current_process;
659 }
.fi

.PP
References \fBcurrent_process()\fP, \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::parent_pid\fP, and \fBMaxOS::processes::Process::pid()\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBcurrent_process()\fP, and \fBschedule_next()\fP\&.
.SS "\fBThread\fP * Scheduler::current_thread ()"

.PP
Gets the currently executing thread\&. 
.PP
\fBReturns\fP
.RS 4
The currently executing thread 
.RE
.PP

.PP
Definition at line \fB691\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
691                                   {
692 
693     return m_threads[m_next_thread_index];
694 }
.fi

.PP
Referenced by \fBcurrent_process()\fP, \fBMaxOS::processes::GlobalScheduler::current_thread()\fP, \fBforce_remove_process()\fP, \fBschedule()\fP, \fBschedule_next()\fP, and \fByield()\fP\&.
.SS "void Scheduler::deactivate ()"

.PP
Deactivates the scheduler\&. 
.PP
Definition at line \fB707\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
707                            {
708 
709     m_active = false;
710 }
.fi

.SS "\fBcpu_status_t\fP * Scheduler::force_remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler and deletes all threads, begins running the next process\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the CPU for the next process to run or nullptr if the process was not found 
.RE
.PP

.PP
Definition at line \fB619\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
619                                                               {
620 
621     // If there is no process, fail
622     if (!process)
623         return nullptr;
624 
625     // Remove all the threads
626     for (auto thread: process\->threads()) {
627 
628         // Remove the thread from the scheduler
629         size_t index = m_threads\&.find(thread) \- m_threads\&.begin();
630         m_threads\&.erase(m_threads\&.begin() + index);
631 
632         // Delete the thread
633         process\->remove_thread(thread\->tid);
634 
635     }
636 
637     // Process will be dead now so run the next process (don't care about the execution state being outdated as it is being
638     // removed regardless)
639     return schedule_next(&current_thread()\->execution_state);
640 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBMaxOS::processes::Process::remove_thread()\fP, \fBschedule_next()\fP, \fBMaxOS::processes::Process::threads()\fP, and \fBMaxOS::processes::Thread::tid\fP\&.
.SS "\fBProcess\fP * Scheduler::get_process (uint64_t pid)"

.PP
Gets a process by its PID\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The process ID 
.RE
.PP
\fBReturns\fP
.RS 4
The process or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB667\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
667                                             {
668 
669     // Try to find the process
670     for (auto process: m_processes)
671         if (process\->pid() == pid)
672             return process;
673 
674     // Not found
675     return nullptr;
676 }
.fi

.PP
References \fBMaxOS::processes::Process::pid()\fP\&.
.SS "\fBThread\fP * Scheduler::get_thread (uint64_t tid)"

.PP
Gets a thread by its TID\&. 
.PP
\fBParameters\fP
.RS 4
\fItid\fP The thread ID 
.RE
.PP
\fBReturns\fP
.RS 4
The thread or nullptr if not found 
.RE
.PP

.PP
Definition at line \fB718\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
718                                           {
719 
720     // Try to find the thread
721     for (auto thread: m_threads)
722         if (thread\->tid == tid)
723             return thread;
724 
725     return nullptr;
726 }
.fi

.PP
References \fBMaxOS::processes::Thread::tid\fP\&.
.SS "uint64_t Scheduler::process_amount ()"

.PP
Gets how processes are running on this scheduler\&. 
.PP
\fBReturns\fP
.RS 4
The amount 
.RE
.PP

.PP
Definition at line \fB682\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
682                                    {
683     return m_processes\&.size();
684 }
.fi

.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP\&.
.SS "uint64_t Scheduler::remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.RE
.PP
\fBReturns\fP
.RS 4
-1 if the process has threads, 0 otherwise 
.RE
.PP

.PP
Definition at line \fB584\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
584                                                    {
585 
586     // Check if the process has no threads
587     if (!process\->threads()\&.empty()) {
588 
589         // Set the threads to stopped or remove them if forced
590         for (auto thread: process\->threads())
591             thread\->thread_state = ThreadState::STOPPED;
592 
593         // Need to wait until the threads are stopped before removing the process (this will be called again when all threads are stopped)
594         return \-1;
595 
596     }
597 
598     // Remove the process
599     for (uint32_t i = 0; i < m_processes\&.size(); i++) {
600         if (m_processes[i] == process) {
601             m_processes\&.erase(m_processes\&.begin() + i);
602 
603             // Delete the process mem
604             delete process;
605             return 0;
606         }
607     }
608 
609     // Process not found
610     return \-1;
611 }
.fi

.PP
References \fBMaxOS::processes::Thread::thread_state\fP, and \fBMaxOS::processes::Process::threads()\fP\&.
.PP
Referenced by \fBschedule_next()\fP\&.
.SS "\fBcpu_status_t\fP * Scheduler::schedule (\fBsystem::cpu_status_t\fP * cpu_state)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIcpu_state\fP The current CPU state 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU state 
.RE
.PP

.PP
Definition at line \fB387\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
387                                                          {
388 
389     // Scheduler cant schedule anything
390     if (m_threads\&.empty() || !m_active)
391         return cpu_state;
392 
393     // Thread that we are dealing with
394     Thread* current_thread = m_threads[m_next_thread_index];
395 
396     // Ticked
397     m_ticks++;
398     current_thread\->ticks++;
399 
400     // Thread hasn't used its time slot yet
401     if(current_thread\->ticks % TICKS_PER_EVENT)
402         return cpu_state;
403 
404     // Schedule the next thread
405     return schedule_next(cpu_state);
406 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBschedule_next()\fP, \fBMaxOS::processes::Thread::ticks\fP, and \fBMaxOS::processes::TICKS_PER_EVENT\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::handle_interrupt()\fP\&.
.SS "\fBcpu_status_t\fP * Scheduler::schedule_next (\fBsystem::cpu_status_t\fP * status)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current CPU status of the thread 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU status
.RE
.PP
\fBTodo\fP
.RS 4
Remove by reference where possible 
.RE
.PP

.PP
Definition at line \fB416\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
416                                                               {
417 
418     // Get the current state
419     Thread* current_thread = m_threads[m_next_thread_index];
420     Process* owner_process = current_process();
421     auto old_tid = m_next_thread_index;
422 
423     // Save the executing thread state
424     current_thread\->execution_state = *cpu_state;
425     current_thread\->save_sse_state();
426     if (current_thread\->thread_state == ThreadState::RUNNING)
427         current_thread\->thread_state = ThreadState::READY;
428 
429     // Find a free thread to run
430     while ((++m_next_thread_index) != old_tid){
431         m_next_thread_index %= m_threads\&.size();
432 
433         // Get the current thread
434         current_thread = m_threads[m_next_thread_index];
435         owner_process = current_process();
436 
437         // Handle state changes
438         switch (current_thread\->thread_state) {
439 
440             case ThreadState::SLEEPING:
441 
442                 // If the wake\-up time hasn't occurred yet, run the next thread
443                 if (current_thread\->wakeup_time > TICKS_PER_EVENT){
444                     current_thread\->wakeup_time \-= TICKS_PER_EVENT;
445                     continue;
446                 }
447 
448                 break;
449 
450             case ThreadState::STOPPED:
451 
452                 // Find the process that has the thread and remove it
453                 for (auto thread: owner_process\->threads()) {
454                     if (thread == current_thread) {
455                         owner_process\->remove_thread(thread\->tid);
456                         break;
457                     }
458                 }
459 
460                 // Remove the thread
461                 m_threads\&.erase(m_threads\&.begin() + m_next_thread_index);
462                 if(owner_process\->threads()\&.empty())
463                     remove_process(owner_process);
464                 continue;
465 
466             case ThreadState::WAITING:
467                 continue;
468 
469             default:
470                 break;
471         }
472         break;
473     }
474 
475     // Load the thread's state
476     return load_process(owner_process, current_thread);
477 }
.fi

.PP
References \fBcurrent_process()\fP, \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::execution_state\fP, \fBremove_process()\fP, \fBMaxOS::processes::Process::remove_thread()\fP, \fBMaxOS::processes::Thread::save_sse_state()\fP, \fBMaxOS::processes::Thread::thread_state\fP, \fBMaxOS::processes::Process::threads()\fP, \fBMaxOS::processes::TICKS_PER_EVENT\fP, and \fBMaxOS::processes::Thread::wakeup_time\fP\&.
.PP
Referenced by \fBforce_remove_process()\fP, \fBschedule()\fP, and \fByield()\fP\&.
.SS "uint64_t Scheduler::thread_amount ()"

.PP
Gets how many threads are running on this scheduler\&. 
.PP
\fBReturns\fP
.RS 4
The amount 
.RE
.PP

.PP
Definition at line \fB700\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
700                                  {
701     return m_threads\&.size();
702 }
.fi

.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_thread()\fP\&.
.SS "uint64_t Scheduler::ticks () const"

.PP
Gets how long the system has been running for\&. 
.PP
\fBReturns\fP
.RS 4
The number of ticks 
.RE
.PP

.PP
Definition at line \fB545\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
545                                 {
546 
547     return m_ticks;
548 }
.fi

.SS "\fBcpu_status_t\fP * Scheduler::yield ()"

.PP
Pass execution to the next thread\&. 
.PP
\fBReturns\fP
.RS 4
The cpu state of the next thread to run 
.RE
.PP

.PP
Definition at line \fB555\fP of file \fBscheduler\&.cpp\fP\&..PP
.nf
555                                {
556 
557     // If this is the only thread, can't yield
558     if (m_threads\&.size() <= 1)
559         return &current_thread()\->execution_state;
560 
561     // Set the current thread to waiting if running
562     auto thread = current_thread();
563     if (thread\->thread_state == ThreadState::RUNNING)
564         thread\->thread_state = ThreadState::READY;
565 
566     // Schedule the next thread
567     return schedule_next(&thread\->execution_state);
568 }
.fi

.PP
References \fBcurrent_thread()\fP, \fBMaxOS::processes::Thread::execution_state\fP, \fBschedule_next()\fP, and \fBMaxOS::processes::Thread::thread_state\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::Scheduler" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Scheduler \- Schedules processes to run on the CPU\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <scheduler\&.h>\fP
.PP
Inherits \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBScheduler\fP (\fBhardwarecommunication::InterruptManager\fP *interrupt_manager)"
.br
.ti -1c
.RI "\fB~Scheduler\fP ()"
.br
.ti -1c
.RI "system::cpu_status_t * \fBhandle_interrupt\fP (system::cpu_status_t *\fBstatus\fP) final"
.br
.RI "Handles the interrupt 0x20\&. "
.ti -1c
.RI "system::cpu_status_t * \fBschedule\fP (system::cpu_status_t *\fBstatus\fP)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "system::cpu_status_t * \fBschedule_next\fP (system::cpu_status_t *\fBstatus\fP)"
.br
.RI "Schedules the next thread to run\&. "
.ti -1c
.RI "system::cpu_status_t * \fByield\fP ()"
.br
.RI "Yield the current thread\&. "
.ti -1c
.RI "uint64_t \fBadd_process\fP (\fBProcess\fP *process)"
.br
.RI "Adds a process to the scheduler\&. "
.ti -1c
.RI "uint64_t \fBremove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) "
.ti -1c
.RI "system::cpu_status_t * \fBforce_remove_process\fP (\fBProcess\fP *process)"
.br
.RI "Removes a process from the scheduler and deletes all threads, begins running the next process\&. "
.ti -1c
.RI "uint64_t \fBadd_thread\fP (\fBThread\fP *thread)"
.br
.RI "Adds a thread to the scheduler\&. "
.ti -1c
.RI "uint64_t \fBget_ticks\fP ()"
.br
.RI "Gets how long the system has been running for\&. "
.ti -1c
.RI "void \fBload_multiboot_elfs\fP (\fBsystem::Multiboot\fP *multiboot)"
.br
.RI "Loads any valid ELF files from the multiboot structure\&. "
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.RI "Activates the scheduler\&. "
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.RI "Deactivates the scheduler\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBScheduler\fP * \fBget_system_scheduler\fP ()"
.br
.RI "Gets the system scheduler\&. "
.ti -1c
.RI "static \fBProcess\fP * \fBget_current_process\fP ()"
.br
.RI "Gets the current process\&. "
.ti -1c
.RI "static \fBProcess\fP * \fBget_process\fP (uint64_t pid)"
.br
.RI "Gets a process by its PID\&. "
.ti -1c
.RI "static \fBThread\fP * \fBget_current_thread\fP ()"
.br
.RI "Gets the currently executing thread\&. "
.ti -1c
.RI "static \fBThread\fP * \fBget_thread\fP (uint64_t tid)"
.br
.RI "Gets a thread by its TID\&. "
.ti -1c
.RI "static \fBIPC\fP * \fBget_ipc\fP ()"
.br
.RI "Gets the \fBIPC\fP handler\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Schedules processes to run on the CPU\&. 
.PP
Definition at line 23 of file scheduler\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Scheduler::Scheduler (\fBhardwarecommunication::InterruptManager\fP * interrupt_manager)"

.PP
Definition at line 17 of file scheduler\&.cpp\&.
.PP
.nf
18 : InterruptHandler(0x20, interrupt_manager),
19   m_current_thread_index(0),
20   m_active(false),
21   m_ticks(0),
22   m_next_pid(-1),
23   m_next_tid(-1)
24 
25 {
26   s_instance = this;
27 
28   // Create the IPC handler
29   m_ipc = new IPC();
30 }
.fi
.SS "Scheduler::~Scheduler ()"

.PP
Definition at line 32 of file scheduler\&.cpp\&.
.PP
.nf
32                       {
33   s_instance = nullptr;
34   m_active = false;
35 
36   // Delete the IPC handler
37   delete m_ipc;
38 
39 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Scheduler::activate ()"

.PP
Activates the scheduler\&. 
.PP
Definition at line 237 of file scheduler\&.cpp\&.
.PP
.nf
237                          {
238     m_active = true;
239 }
.fi
.PP
Referenced by kernelMain()\&.
.SS "uint64_t Scheduler::add_process (\fBProcess\fP * process)"

.PP
Adds a process to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to add 
.RE
.PP
\fBReturns\fP
.RS 4
The process ID 
.RE
.PP

.PP
Definition at line 161 of file scheduler\&.cpp\&.
.PP
.nf
161                                                 {
162 
163   // Get the next process ID
164   m_next_pid++;
165 
166   // Add the process to the list
167   m_processes\&.push_back(process);
168   _kprintf("Adding process %d: %s\n", m_next_pid, process->name\&.c_str());
169 
170   // Return the process ID
171   return m_next_pid;
172 
173 }
.fi
.PP
References _kprintf, MaxOS::String::c_str(), and MaxOS::processes::Process::name\&.
.PP
Referenced by kernelMain(), and MaxOS::processes::Process::set_up()\&.
.SS "uint64_t Scheduler::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the scheduler\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP
\fBReturns\fP
.RS 4
The thread ID 
.RE
.PP

.PP
Definition at line 180 of file scheduler\&.cpp\&.
.PP
.nf
180                                              {
181 
182     // Get the next thread ID
183     m_next_tid++;
184 
185     // Add the thread to the list
186     m_threads\&.push_back(thread);
187     _kprintf("Adding thread %d to process %d\n", m_next_tid, thread->parent_pid);
188 
189     // Return the thread ID
190     return m_next_tid;
191 
192 }
.fi
.PP
References _kprintf, and MaxOS::processes::Thread::parent_pid\&.
.SS "void Scheduler::deactivate ()"

.PP
Deactivates the scheduler\&. 
.PP
Definition at line 354 of file scheduler\&.cpp\&.
.PP
.nf
354                            {
355     m_active = false;
356 
357 }
.fi
.SS "cpu_status_t * Scheduler::force_remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler and deletes all threads, begins running the next process\&. 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.RE
.PP
\fBReturns\fP
.RS 4
The status of the CPU for the next process to run or nullptr if the process was not found 
.RE
.PP

.PP
Definition at line 283 of file scheduler\&.cpp\&.
.PP
.nf
283                                                               {
284 
285   // If there is no process, fail
286   if (!process)
287       return nullptr;
288 
289   // Remove all the threads
290   for (auto thread : process->get_threads()){
291 
292     // Remove the thread from the scheduler
293     int index = m_threads\&.find(thread) - m_threads\&.begin();
294     m_threads\&.erase(m_threads\&.begin() + index);
295 
296     // Delete the thread
297     process->remove_thread(thread->tid);
298 
299   }
300 
301 
302   // Process will be dead now so run the next process (don't care about the execution state being outdated as we are removing it anyway)
303   return schedule_next(get_current_thread()->execution_state);
304 }
.fi
.PP
References get_current_thread(), MaxOS::processes::Process::get_threads(), MaxOS::processes::Process::remove_thread(), and schedule_next()\&.
.SS "\fBProcess\fP * Scheduler::get_current_process ()\fC [static]\fP"

.PP
Gets the current process\&. 
.PP
\fBReturns\fP
.RS 4
The current process, or nullptr if not found 
.RE
.PP

.PP
Definition at line 310 of file scheduler\&.cpp\&.
.PP
.nf
310                                         {
311 
312   Process* current_process = nullptr;
313 
314   // Find the process that has the thread being executed
315   for (auto process : s_instance -> m_processes)
316     if (process->get_pid() == get_current_thread() -> parent_pid) {
317       current_process = process;
318       break;
319     }
320 
321   return current_process;
322 }
.fi
.PP
References get_current_thread()\&.
.PP
Referenced by MaxOS::processes::IPC::alloc_shared_memory(), MaxOS::processes::IPC::create_message_endpoint(), MaxOS::processes::IPC::free_message_endpoint(), schedule_next(), and MaxOS::processes::IPC::send_message()\&.
.SS "\fBThread\fP * Scheduler::get_current_thread ()\fC [static]\fP"

.PP
Gets the currently executing thread\&. 
.PP
\fBReturns\fP
.RS 4
The currently executing thread 
.RE
.PP

.PP
Definition at line 345 of file scheduler\&.cpp\&.
.PP
.nf
345                                       {
346 
347   return s_instance -> m_threads[s_instance -> m_current_thread_index];
348 
349 }
.fi
.PP
Referenced by force_remove_process(), get_current_process(), and yield()\&.
.SS "\fBIPC\fP * Scheduler::get_ipc ()\fC [static]\fP"

.PP
Gets the \fBIPC\fP handler\&. 
.PP
\fBReturns\fP
.RS 4
The \fBIPC\fP handler or nullptr if not found 
.RE
.PP

.PP
Definition at line 395 of file scheduler\&.cpp\&.
.PP
.nf
395                         {
396 
397   return s_instance -> m_ipc;
398 
399 }
.fi
.SS "\fBProcess\fP * Scheduler::get_process (uint64_t pid)\fC [static]\fP"

.PP
Gets a process by its PID\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The process ID 
.RE
.PP
\fBReturns\fP
.RS 4
The process or nullptr if not found 
.RE
.PP

.PP
Definition at line 329 of file scheduler\&.cpp\&.
.PP
.nf
329                                             {
330 
331   // Try to find the process
332   for (auto process : s_instance->m_processes)
333     if (process->get_pid() == pid)
334       return process;
335 
336   // Not found
337   return nullptr;
338 }
.fi
.PP
Referenced by MaxOS::processes::IPC::send_message()\&.
.SS "\fBScheduler\fP * Scheduler::get_system_scheduler ()\fC [static]\fP"

.PP
Gets the system scheduler\&. 
.PP
\fBReturns\fP
.RS 4
The system scheduler or nullptr if not found 
.RE
.PP

.PP
Definition at line 198 of file scheduler\&.cpp\&.
.PP
.nf
198                                            {
199 
200   if(s_instance)
201     return s_instance;
202 
203   return nullptr;
204 }
.fi
.PP
Referenced by MaxOS::processes::Process::remove_thread(), and MaxOS::processes::Process::set_up()\&.
.SS "\fBThread\fP * Scheduler::get_thread (uint64_t tid)\fC [static]\fP"

.PP
Gets a thread by its TID\&. 
.PP
\fBParameters\fP
.RS 4
\fItid\fP The thread ID 
.RE
.PP
\fBReturns\fP
.RS 4
The thread or nullptr if not found 
.RE
.PP

.PP
Definition at line 407 of file scheduler\&.cpp\&.
.PP
.nf
407                                           {
408 
409   // Try to find the thread
410   for (auto thread : s_instance -> m_threads)
411     if (thread -> tid == tid)
412       return thread;
413 
414   return nullptr;
415 }
.fi
.SS "uint64_t Scheduler::get_ticks ()"

.PP
Gets how long the system has been running for\&. 
.PP
\fBReturns\fP
.RS 4
The number of ticks 
.RE
.PP

.PP
Definition at line 210 of file scheduler\&.cpp\&.
.PP
.nf
210                               {
211     return m_ticks;
212 }
.fi
.SS "cpu_status_t * Scheduler::handle_interrupt (system::cpu_status_t * status)\fC [final]\fP, \fC [virtual]\fP"

.PP
Handles the interrupt 0x20\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current CPU status 
.RE
.PP
\fBReturns\fP
.RS 4
The new CPU status 
.RE
.PP
Note: Could have set scheduler to just be the handle interrupt function, / but in the future there may be a need to schedule at other times
.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line 46 of file scheduler\&.cpp\&.
.PP
.nf
46                                                               {
47 
48     // Schedule the next thread
49     return schedule(status);
50 
53 }
.fi
.PP
References schedule(), and status\&.
.SS "void Scheduler::load_multiboot_elfs (\fBsystem::Multiboot\fP * multiboot)"

.PP
Loads any valid ELF files from the multiboot structure\&. 
.PP
\fBParameters\fP
.RS 4
\fImultiboot\fP The multiboot structure 
.RE
.PP

.PP
Definition at line 364 of file scheduler\&.cpp\&.
.PP
.nf
364                                                               {
365 
366   for(multiboot_tag* tag = multiboot -> get_start_tag(); tag->type != MULTIBOOT_TAG_TYPE_END; tag = (struct multiboot_tag *) ((multiboot_uint8_t *) tag + ((tag->size + 7) & ~7))) {
367     if(tag -> type != MULTIBOOT_TAG_TYPE_MODULE)
368       continue;
369 
370     // Get the module tag
371     struct multiboot_tag_module* module = (struct multiboot_tag_module*)tag;
372 
373     // Create the elf
374     Elf64* elf = new Elf64((uintptr_t)MemoryManager::to_dm_region((uintptr_t )module->mod_start));
375     if(!elf->is_valid())
376       continue;
377 
378     _kprintf("Creating process from multiboot module for %s (at 0x%x)\n", module->cmdline, module->mod_start);
379 
380     // Create an array of args for the process
381     char* args[1] = {module->cmdline};
382 
383     // Create the process
384     Process* process = new Process(module->cmdline, args, 1, elf);
385 
386     _kprintf("Elf loaded to pid %d\n", process->get_pid());
387   }
388 
389 }
.fi
.PP
References _kprintf, multiboot_tag_module::cmdline, MaxOS::processes::Process::get_pid(), MaxOS::processes::Elf64::is_valid(), multiboot_tag_module::mod_start, MULTIBOOT_TAG_TYPE_END, MULTIBOOT_TAG_TYPE_MODULE, and type\&.
.PP
Referenced by kernelMain()\&.
.SS "uint64_t Scheduler::remove_process (\fBProcess\fP * process)"

.PP
Removes a process from the scheduler if the process has no threads, if it does then the threads are stopped but the process is not removed (this will be done automatically when all threads are stopped) 
.PP
\fBParameters\fP
.RS 4
\fIprocess\fP The process to remove 
.br
\fIforce\fP If true, the process will be removed and so will all threads 
.RE
.PP
\fBReturns\fP
.RS 4
-1 if the process has threads, 0 otherwise 
.RE
.PP

.PP
Definition at line 247 of file scheduler\&.cpp\&.
.PP
.nf
247                                                    {
248 
249   // Check if the process has no threads
250   if (!process->get_threads()\&.empty()) {
251 
252     // Set the threads to stopped or remove them if forced
253     for (auto thread : process->get_threads())
254         thread->thread_state = ThreadState::STOPPED;
255 
256     // Need to wait until the threads are stopped before removing the process (this will be called again when all threads are stopped)
257     return -1;
258 
259   }
260 
261   // Remove the process
262   for (uint16_t i = 0; i < m_processes\&.size(); i++) {
263     if (m_processes[i] == process) {
264         m_processes\&.erase(m_processes\&.begin() + i);
265 
266         // Delete the process mem
267         delete process;
268         return 0;
269     }
270   }
271 
272   // Process not found
273   return -1;
274 
275 }
.fi
.PP
References MaxOS::processes::Process::get_threads(), MaxOS::drivers::peripherals::i, and MaxOS::processes::STOPPED\&.
.SS "cpu_status_t * Scheduler::schedule (system::cpu_status_t * status)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIcpu_state\fP The current CPU state 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU state 
.RE
.PP

.PP
Definition at line 61 of file scheduler\&.cpp\&.
.PP
.nf
61                                                          {
62 
63   // If there are no threads to schedule or not active, return the current state
64   if (m_threads\&.empty() || !m_active)
65       return cpu_state;
66 
67 
68   // Thread that we are dealing with
69   Thread* current_thread = m_threads[m_current_thread_index];
70 
71   // Ticked
72   m_ticks++;
73   current_thread->ticks++;
74 
75    // Wait for a bit so that the scheduler doesn't run too fast
76    if (m_ticks % s_ticks_per_event != 0) return cpu_state;
77 
78    // Schedule the next thread
79    return schedule_next(cpu_state);
80 
81 }
.fi
.PP
References schedule_next(), and MaxOS::processes::Thread::ticks\&.
.PP
Referenced by handle_interrupt()\&.
.SS "system::cpu_status_t * Scheduler::schedule_next (system::cpu_status_t * cpu_state)"

.PP
Schedules the next thread to run\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The current CPU status of the thread 
.RE
.PP
\fBReturns\fP
.RS 4
The next CPU status 
.RE
.PP

.PP
Definition at line 88 of file scheduler\&.cpp\&.
.PP
.nf
88                                                                           {
89 
90   // Get the current thread
91   Thread* current_thread = m_threads[m_current_thread_index];
92 
93   // Save the current state
94   current_thread->execution_state = cpu_state;
95   if(current_thread->thread_state == ThreadState::RUNNING)
96     current_thread->thread_state = ThreadState::WAITING;
97 
98   // Switch to the next thread
99   m_current_thread_index++;
100   m_current_thread_index %= m_threads\&.size();
101 
102   current_thread = m_threads[m_current_thread_index];
103 
104   // If the current thread is in the process then we can get the process
105   Process* current_process = get_current_process();
106 
107   // Handle state changes
108   switch (current_thread->thread_state) {
109 
110     case ThreadState::NEW:
111       current_thread->thread_state = ThreadState::RUNNING;
112       break;
113 
114     case ThreadState::SLEEPING:
115 
116       // If the wake-up time hasn't occurred yet, run the next thread
117       if (current_thread->wakeup_time > m_ticks)
118         return schedule_next(current_thread->execution_state);
119 
120       break;
121 
122     case ThreadState::STOPPED:
123 
124       // Find the process that has the thread and remove it
125       for (auto thread : current_process->get_threads()) {
126         if (thread == current_thread) {
127           current_process->remove_thread(m_current_thread_index);
128           break;
129         }
130       }
131 
132       // Remove the thread
133       m_threads\&.erase(m_threads\&.begin() + m_current_thread_index);
134 
135       // Run the next thread
136       return schedule_next(cpu_state);
137 
138     default:
139       break;
140   }
141 
142   // Prepare the next thread to run
143   current_thread -> thread_state = ThreadState::RUNNING;
144 
145   // Load the threads memory manager
146   MemoryManager::switch_active_memory_manager(current_process->memory_manager);
147 
148   // Load the TSS for the thread
149   system::CPU::get_instance() -> tss\&.rsp0 = current_thread->get_tss_pointer();
150 
151   // Return the next thread's state
152   return current_thread->execution_state;
153 }
.fi
.PP
References MaxOS::processes::Thread::execution_state, get_current_process(), MaxOS::system::CPU::get_instance(), MaxOS::processes::Process::get_threads(), MaxOS::processes::Thread::get_tss_pointer(), MaxOS::processes::Process::memory_manager, MaxOS::processes::NEW, MaxOS::processes::Process::remove_thread(), MaxOS::system::tss::rsp0, MaxOS::processes::RUNNING, MaxOS::processes::SLEEPING, MaxOS::processes::STOPPED, MaxOS::processes::Thread::thread_state, MaxOS::processes::WAITING, and MaxOS::processes::Thread::wakeup_time\&.
.PP
Referenced by force_remove_process(), schedule(), and yield()\&.
.SS "cpu_status_t * Scheduler::yield ()"

.PP
Yield the current thread\&. 
.PP
Definition at line 217 of file scheduler\&.cpp\&.
.PP
.nf
217                                {
218 
219   // If this is the only thread, can't yield
220   if (m_threads\&.size() <= 1)
221       return get_current_thread()->execution_state;
222 
223   // Set the current thread to waiting if running
224   if (m_threads[m_current_thread_index]->thread_state == ThreadState::RUNNING)
225       m_threads[m_current_thread_index]->thread_state = ThreadState::WAITING;
226 
227   _kprintf("Yielding thread %d\n", m_current_thread_index);
228 
229   // Schedule the next thread
230   return schedule_next(get_current_thread()->execution_state);
231 
232 }
.fi
.PP
References _kprintf, MaxOS::processes::Thread::execution_state, get_current_thread(), MaxOS::processes::RUNNING, schedule_next(), and MaxOS::processes::WAITING\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::drivers::disk::AdvancedTechnologyAttachment" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::disk::AdvancedTechnologyAttachment \- \fBDriver\fP for the ATA controller, handles the reading and writing of data to the hard drive\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ata\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::disk::Disk\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAdvancedTechnologyAttachment\fP (\fBuint16_t\fP port_base, \fBbool\fP \fBmaster\fP)"
.br
.ti -1c
.RI "\fB~AdvancedTechnologyAttachment\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBidentify\fP ()"
.br
.RI "Identify the ATA device\&. "
.ti -1c
.RI "\fBvoid\fP \fBread\fP (\fBuint32_t\fP \fBsector\fP, \fBcommon::buffer_t\fP *\fBdata_buffer\fP, \fBsize_t\fP \fBamount\fP) \fBfinal\fP"
.br
.RI "Read a sector from the ATA device\&. "
.ti -1c
.RI "\fBvoid\fP \fBwrite\fP (\fBuint32_t\fP \fBsector\fP, \fBconst\fP \fBcommon::buffer_t\fP *\fBdata\fP, \fBsize_t\fP \fBcount\fP) \fBfinal\fP"
.br
.RI "write to a sector on the ATA device "
.ti -1c
.RI "\fBvoid\fP \fBflush\fP () \fBfinal\fP"
.br
.RI "Flush the cache of the ATA device\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBfinal\fP"
.br
.RI "Get the device name\&. "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBfinal\fP"
.br
.RI "Get the vendor name\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::disk::Disk\fP
.in +1c
.ti -1c
.RI "\fBDisk\fP ()"
.br
.ti -1c
.RI "\fB~Disk\fP ()"
.br
.ti -1c
.RI "\fBvoid\fP \fBread\fP (\fBuint32_t\fP \fBsector\fP, \fBcommon::buffer_t\fP *\fBdata_buffer\fP)"
.br
.RI "Read data from the disk into a buffer (max capacity 512 bytes) "
.ti -1c
.RI "\fBvoid\fP \fBwrite\fP (\fBuint32_t\fP \fBsector\fP, \fBconst\fP \fBcommon::buffer_t\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP () \fBoverride\fP"
.br
.RI "Activate the disk driver\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBoverride\fP"
.br
.RI "Get the device name\&. "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBoverride\fP"
.br
.RI "Get the vendor name\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBDriver\fP ()"
.br
.ti -1c
.RI "\fB~Driver\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdeactivate\fP ()"
.br
.RI "deactivate the driver "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.ti -1c
.RI "\fBvirtual\fP \fBuint32_t\fP \fBreset\fP ()"
.br
.RI "Reset the driver\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBhardwarecommunication::Port16Bit\fP \fBm_data_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_error_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_sector_count_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_low_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_mid_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_high_Port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_device_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_command_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_control_port\fP"
.br
.ti -1c
.RI "bool \fBm_is_master\fP"
.br
.ti -1c
.RI "uint16_t \fBm_bytes_per_sector\fP { 512 }"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the ATA controller, handles the reading and writing of data to the hard drive\&. 
.PP
Definition at line \fB25\fP of file \fBata\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AdvancedTechnologyAttachment::AdvancedTechnologyAttachment (\fBuint16_t\fP port_base, \fBbool\fP master)"

.PP
Definition at line \fB13\fP of file \fBata\&.cpp\fP\&..PP
.nf
14 : m_data_port(port_base),
15   m_error_port(port_base + 1),
16   m_sector_count_port(port_base + 2),
17   m_LBA_low_port(port_base + 3),
18   m_LBA_mid_port(port_base + 4),
19   m_LBA_high_Port(port_base + 5),
20   m_device_port(port_base + 6),
21   m_command_port(port_base + 7),
22   m_control_port(port_base + 0x206),
23   m_is_master(master)
24 {
25 
26 }
.fi

.SS "AdvancedTechnologyAttachment::~AdvancedTechnologyAttachment ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBstring\fP AdvancedTechnologyAttachment::device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the device name\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB236\fP of file \fBata\&.cpp\fP\&..PP
.nf
236                                                  {
237     return "Advanced Technology Attachment";
238 }
.fi

.SS "\fBvoid\fP AdvancedTechnologyAttachment::flush ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Flush the cache of the ATA device\&. 
.PP
Reimplemented from \fBMaxOS::drivers::disk::Disk\fP\&.
.PP
Definition at line \fB207\fP of file \fBata\&.cpp\fP\&..PP
.nf
207                                          {
208 
209     // Select the device (master or slave)
210     m_device_port\&.write(m_is_master ? 0xE0 : 0xF0);
211 
212     // Send the flush command
213     m_command_port\&.write(0xE7);
214 
215     // Make sure the device is there
216     uint8_t status = m_command_port\&.read();
217     if (status == 0x00)
218         return;
219 
220     // Wait for the device to be ready or for an error to occur
221     while (((status & 0x80) == 0x80) && ((status & 0x01) != 0x01))
222         status = m_command_port\&.read();
223 
224     // Check for an error
225     if (status & 0x01)
226         return;
227 
228     // \&.\&.\&.
229 }
.fi

.PP
References \fBm_command_port\fP, \fBm_device_port\fP, \fBm_is_master\fP, \fBMaxOS::hardwarecommunication::Port8Bit::read()\fP, \fBstatus\fP, and \fBMaxOS::hardwarecommunication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBwrite()\fP\&.
.SS "\fBbool\fP AdvancedTechnologyAttachment::identify ()"

.PP
Identify the ATA device\&. 
.PP
\fBReturns\fP
.RS 4
True if the device is present, false otherwise 
.RE
.PP

.PP
Definition at line \fB35\fP of file \fBata\&.cpp\fP\&..PP
.nf
35                                             {
36 
37     // Select the device (master or slave)
38     m_device_port\&.write(m_is_master ? 0xA0 : 0xB0);
39 
40     // Reset the High Order Byte
41     m_control_port\&.write(0);
42 
43     // Check if the master is present
44     m_device_port\&.write(0xA0);
45     uint8_t status = m_command_port\&.read();
46     if (status == 0xFF) {
47         Logger::WARNING() << "ATA Device: Invalid status";
48         return false;
49     }
50 
51     // Select the device (master or slave)
52     m_device_port\&.write(m_is_master ? 0xA0 : 0xB0);
53 
54     // Clear the ports
55     m_sector_count_port\&.write(0);
56     m_LBA_low_port\&.write(0);
57     m_LBA_mid_port\&.write(0);
58     m_LBA_high_Port\&.write(0);
59 
60     // Check if the device is present
61     m_command_port\&.write(0x0EC);
62     status = m_command_port\&.read();
63     if (status == 0x00)
64         return false;
65 
66     // Wait for the device to be ready or for an error to occur
67     while (((status & 0x80) == 0x80) && ((status & 0x01) != 0x01))
68         status = m_command_port\&.read();
69 
70     //Check for any errors
71     if (status & 0x01) {
72         Logger::WARNING() << "ATA Device: Error reading status\\n";
73         return false;
74     }
75 
76     // Read the rest of the data as a whole sector needs to be read
77     for (uint16_t i = 0; i < 256; ++i)
78         uint16_t data = m_data_port\&.read();
79 
80     // Device is present and ready
81     return true;
82 }
.fi

.PP
References \fBdata\fP, \fBm_command_port\fP, \fBm_control_port\fP, \fBm_data_port\fP, \fBm_device_port\fP, \fBm_is_master\fP, \fBm_LBA_high_Port\fP, \fBm_LBA_low_port\fP, \fBm_LBA_mid_port\fP, \fBm_sector_count_port\fP, \fBMaxOS::hardwarecommunication::Port8Bit::read()\fP, \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, \fBstatus\fP, \fBLogger::WARNING()\fP, and \fBMaxOS::hardwarecommunication::Port8Bit::write()\fP\&.
.SS "\fBvoid\fP AdvancedTechnologyAttachment::read (\fBuint32_t\fP sector, \fBcommon::buffer_t\fP * data_buffer, \fBsize_t\fP amount)\fC [final]\fP, \fC [virtual]\fP"

.PP
Read a sector from the ATA device\&. 
.PP
\fBParameters\fP
.RS 4
\fIsector\fP The sector to read 
.br
\fIdata_buffer\fP The data to read into 
.br
\fIamount\fP The amount of bytes to read from that sector 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::disk::Disk\fP\&.
.PP
Definition at line \fB91\fP of file \fBata\&.cpp\fP\&..PP
.nf
91                                                                                              {
92 
93     // Don't allow reading more than a sector
94     if (sector & 0xF0000000 || amount > m_bytes_per_sector)
95         return;
96 
97     // Select the device (master or slave)
98     m_device_port\&.write((m_is_master ? 0xE0 : 0xF0) | ((sector & 0x0F000000) >> 24));
99 
100     // Device is busy (TODO: YIELD)
101     while ((m_command_port\&.read() & 0x80) != 0);
102 
103     // Reset the device
104     m_error_port\&.write(0);
105     m_sector_count_port\&.write(1);
106 
107     // Split the sector into the ports
108     m_LBA_low_port\&.write(sector & 0x000000FF);
109     m_LBA_mid_port\&.write((sector & 0x0000FF00) >> 8);
110     m_LBA_high_Port\&.write((sector & 0x00FF0000) >> 16);
111 
112     // Tell the device to prepare for reading
113     m_command_port\&.write(0x20);
114 
115     // Make sure the device is there
116     uint8_t status = m_command_port\&.read();
117     if (status == 0x00)
118         return;
119 
120     // Wait for the device to be ready or for an error to occur TODO: Userspace block here
121     while (((status & 0x80) == 0x80) && ((status & 0x01) != 0x01))
122         status = m_command_port\&.read();
123 
124     //Check for any errors
125     if (status & 0x01)
126         return;
127 
128     for (size_t i = 0; i < amount; i += 2) {
129 
130         // Read from the disk (2 bytes) and store the first byte
131         uint16_t read_data = m_data_port\&.read();
132         data_buffer\->write(read_data & 0x00FF);
133 
134         // Place the second byte in the array if there is one
135         if (i + 1 < amount)
136             data_buffer\->write((read_data >> 8) & 0x00FF);
137     }
138 
139     // Read the remaining bytes as a full sector has to be read
140     for (uint16_t i = amount + (amount % 2); i < m_bytes_per_sector; i += 2)
141         m_data_port\&.read();
142 }
.fi

.PP
References \fBm_bytes_per_sector\fP, \fBm_command_port\fP, \fBm_data_port\fP, \fBm_device_port\fP, \fBm_error_port\fP, \fBm_is_master\fP, \fBm_LBA_high_Port\fP, \fBm_LBA_low_port\fP, \fBm_LBA_mid_port\fP, \fBm_sector_count_port\fP, \fBMaxOS::hardwarecommunication::Port8Bit::read()\fP, \fBMaxOS::hardwarecommunication::Port16Bit::read()\fP, \fBstatus\fP, and \fBMaxOS::hardwarecommunication::Port8Bit::write()\fP\&.
.SS "\fBstring\fP AdvancedTechnologyAttachment::vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the vendor name\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB245\fP of file \fBata\&.cpp\fP\&..PP
.nf
245                                                  {
246     return "IDE";
247 }
.fi

.SS "\fBvoid\fP AdvancedTechnologyAttachment::write (\fBuint32_t\fP sector, \fBconst\fP \fBcommon::buffer_t\fP * data, \fBsize_t\fP count)\fC [final]\fP, \fC [virtual]\fP"

.PP
write to a sector on the ATA device 
.PP
\fBParameters\fP
.RS 4
\fIsector\fP The sector to write to 
.br
\fIdata\fP The data to write 
.br
\fIcount\fP The amount of data to write to that sector 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::disk::Disk\fP\&.
.PP
Definition at line \fB151\fP of file \fBata\&.cpp\fP\&..PP
.nf
151                                                                                             {
152 
153     // Don't allow writing more than a sector
154     if (sector > 0x0FFFFFFF || count > m_bytes_per_sector)
155         return;
156 
157     // Select the device (master or slave)
158     m_device_port\&.write(m_is_master ? 0xE0 : 0xF0 | ((sector & 0x0F000000) >> 24));
159 
160     // Device is busy (TODO: YIELD)
161     while ((m_command_port\&.read() & 0x80) != 0);
162 
163     // Reset the device
164     m_error_port\&.write(0);
165     m_sector_count_port\&.write(1);
166 
167     // Split the sector into the ports
168     m_LBA_low_port\&.write(sector & 0x000000FF);
169     m_LBA_mid_port\&.write((sector & 0x0000FF00) >> 8);
170     m_LBA_high_Port\&.write((sector & 0x00FF0000) >> 16);
171 
172     // Send the write command
173     m_command_port\&.write(0x30);
174 
175     // Wait for the device be ready writing (TODO: YIELD)
176     uint8_t status = m_command_port\&.read();
177     while ((status & 0x80) != 0 || (status & 0x08) == 0)
178         status = m_command_port\&.read();
179 
180     // Write the data to the device
181     for (uint16_t i = 0; i < m_bytes_per_sector; i += 2) {
182 
183         uint16_t writeData = data\->read();
184 
185         // Place the next byte in the array if there is one
186         if (i + 1 < count)
187             writeData |= (uint16_t) (data\->read()) << 8;
188 
189         m_data_port\&.write(writeData);
190     }
191 
192     // Write the remaining bytes as a full sector has to be written
193     for (int i = count + (count % 2); i < m_bytes_per_sector; i += 2)
194         m_data_port\&.write(0x0000);
195 
196     // Wait for the device to finish writing (TODO: YIELD)
197     status = m_command_port\&.read();
198     while ((status & 0x80) != 0 || (status & 0x08) != 0)
199         status = m_command_port\&.read();
200 
201     flush();
202 }
.fi

.PP
References \fBdata\fP, \fBflush()\fP, \fBm_bytes_per_sector\fP, \fBm_command_port\fP, \fBm_data_port\fP, \fBm_device_port\fP, \fBm_error_port\fP, \fBm_is_master\fP, \fBm_LBA_high_Port\fP, \fBm_LBA_low_port\fP, \fBm_LBA_mid_port\fP, \fBm_sector_count_port\fP, \fBMaxOS::hardwarecommunication::Port8Bit::read()\fP, \fBstatus\fP, \fBMaxOS::hardwarecommunication::Port16Bit::write()\fP, and \fBMaxOS::hardwarecommunication::Port8Bit::write()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "uint16_t MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_bytes_per_sector { 512 }\fC [protected]\fP"

.PP
Definition at line \fB38\fP of file \fBata\&.h\fP\&..PP
.nf
38 { 512 };
.fi

.PP
Referenced by \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_command_port\fC [protected]\fP"

.PP
Definition at line \fB35\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBflush()\fP, \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_control_port\fC [protected]\fP"

.PP
Definition at line \fB36\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP\&.
.SS "\fBhardwarecommunication::Port16Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_data_port\fC [protected]\fP"

.PP
Definition at line \fB28\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_device_port\fC [protected]\fP"

.PP
Definition at line \fB34\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBflush()\fP, \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_error_port\fC [protected]\fP"

.PP
Definition at line \fB29\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBread()\fP, and \fBwrite()\fP\&.
.SS "bool MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_is_master\fC [protected]\fP"

.PP
Definition at line \fB37\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBflush()\fP, \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_high_Port\fC [protected]\fP"

.PP
Definition at line \fB33\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_low_port\fC [protected]\fP"

.PP
Definition at line \fB31\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_mid_port\fC [protected]\fP"

.PP
Definition at line \fB32\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.
.SS "\fBhardwarecommunication::Port8Bit\fP MaxOS::drivers::disk::AdvancedTechnologyAttachment::m_sector_count_port\fC [protected]\fP"

.PP
Definition at line \fB30\fP of file \fBata\&.h\fP\&.
.PP
Referenced by \fBidentify()\fP, \fBread()\fP, and \fBwrite()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

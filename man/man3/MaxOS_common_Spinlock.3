.TH "MaxOS::common::Spinlock" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::Spinlock \- Enables a resource to be used by only one instance at a time through locking and unlocking\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <spinlock\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBlock\fP ()"
.br
.RI "Lock the spinlock once it is available\&. "
.ti -1c
.RI "\fBvoid\fP \fBunlock\fP ()"
.br
.RI "Unlock the spinlock\&. "
.ti -1c
.RI "\fBbool\fP \fBis_locked\fP () \fBconst\fP"
.br
.RI "Check if the spinlock is locked\&. "
.ti -1c
.RI "\fBvoid\fP \fBacquire\fP ()"
.br
.RI "Acquire the spinlock: wait until the lock is available, spinning until that happens\&. "
.ti -1c
.RI "\fBvoid\fP \fBrelease\fP ()"
.br
.RI "Release the spinlock\&. "
.in -1c
.SH "Detailed Description"
.PP 
Enables a resource to be used by only one instance at a time through locking and unlocking\&. 
.PP
Definition at line \fB22\fP of file \fBspinlock\&.h\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Spinlock::acquire ()"

.PP
Acquire the spinlock: wait until the lock is available, spinning until that happens\&. 
.PP
Definition at line \fB51\fP of file \fBspinlock\&.cpp\fP\&..PP
.nf
51                        {
52     while (__atomic_test_and_set(&m_locked, __ATOMIC_ACQUIRE))
53         asm("nop");
54 }
.fi

.PP
Referenced by \fBlock()\fP\&.
.SS "\fBbool\fP Spinlock::is_locked () const"

.PP
Check if the spinlock is locked\&. 
.PP
\fBReturns\fP
.RS 4
True if the spinlock is locked, false otherwise 
.RE
.PP

.PP
Definition at line \fB43\fP of file \fBspinlock\&.cpp\fP\&..PP
.nf
43                                {
44     return m_locked;
45 }
.fi

.SS "\fBvoid\fP Spinlock::lock ()"

.PP
Lock the spinlock once it is available\&. 
.PP
Definition at line \fB24\fP of file \fBspinlock\&.cpp\fP\&..PP
.nf
24                     {
25     acquire();
26     m_locked = true;
27 }
.fi

.PP
References \fBacquire()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Process::add_thread()\fP, \fBMaxOS::memory::PhysicalMemoryManager::allocate_area()\fP, \fBMaxOS::memory::PhysicalMemoryManager::allocate_frame()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Volume::create_inode()\fP, \fBMaxOS::filesystem::format::ext2::InodeHandler::free()\fP, \fBMaxOS::memory::PhysicalMemoryManager::free_area()\fP, \fBMaxOS::memory::PhysicalMemoryManager::free_frame()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::read()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, \fBMaxOS::memory::PhysicalMemoryManager::reserve()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP, and \fBMaxOS::processes::SharedMessageEndpoint::write()\fP\&.
.SS "\fBvoid\fP Spinlock::release ()"

.PP
Release the spinlock\&. 
.PP
Definition at line \fB59\fP of file \fBspinlock\&.cpp\fP\&..PP
.nf
59                        {
60     __atomic_clear(&m_locked, __ATOMIC_RELEASE);
61 }
.fi

.PP
Referenced by \fBunlock()\fP\&.
.SS "\fBvoid\fP Spinlock::unlock ()"

.PP
Unlock the spinlock\&. 
.PP
Definition at line \fB32\fP of file \fBspinlock\&.cpp\fP\&..PP
.nf
32                       {
33 
34     m_locked = false;
35     release();
36 }
.fi

.PP
References \fBrelease()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Process::add_thread()\fP, \fBMaxOS::memory::PhysicalMemoryManager::allocate_area()\fP, \fBMaxOS::memory::PhysicalMemoryManager::allocate_frame()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Volume::create_inode()\fP, \fBMaxOS::filesystem::format::ext2::InodeHandler::free()\fP, \fBMaxOS::memory::PhysicalMemoryManager::free_area()\fP, \fBMaxOS::memory::PhysicalMemoryManager::free_frame()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::read()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, \fBMaxOS::memory::PhysicalMemoryManager::reserve()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP, and \fBMaxOS::processes::SharedMessageEndpoint::write()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

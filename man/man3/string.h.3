.TH "/home/runner/work/MaxOS/MaxOS/kernel/include/common/string.h" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/include/common/string.h \- Defines a String class for dynamically sized strings with various operations\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <cstdint>\fP
.br
\fC#include <common/vector\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBMaxOS::String\fP"
.br
.RI "Dynamically sized string with various operations\&. "
.ti -1c
.RI "class \fBMaxOS::StringBuilder\fP"
.br
.RI "Creates a string using a using a combination of parts with the '<<' operator\&. Simmilar to the logger\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef class \fBMaxOS::String\fP \fBMaxOS::string\fP"
.br
.RI "Typedef for \fBString\fP\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBstrlen\fP (const char *str)"
.br
.RI "Gets the length of a string\&. "
.ti -1c
.RI "char * \fBitoa\fP (int base, int64_t number)"
.br
.RI "Converts integer to string\&. "
.ti -1c
.RI "char * \fBhtoa\fP (uint64_t number)"
.br
.RI "Converts hex to string\&. "
.ti -1c
.RI "bool \fBstrcmp\fP (char const *str1, char const *str2)"
.br
.RI "Checks if one string pointer is equal to another string pointer\&. "
.ti -1c
.RI "bool \fBstrcmp\fP (char const *str1, \fBMaxOS::String\fP const &str2)"
.br
.RI "Checks if one string pointer is equal to a String\&. "
.ti -1c
.RI "bool \fBstrcmp\fP (\fBMaxOS::String\fP const &str1, char const *str2)"
.br
.RI "Checks if one String is equal to a string pointer\&. "
.ti -1c
.RI "bool \fBstrcmp\fP (\fBMaxOS::String\fP const &str1, \fBMaxOS::String\fP const &str2)"
.br
.RI "Checks if one String is equal to another String (better use is of '==') "
.ti -1c
.RI "bool \fBstrncmp\fP (char const *str1, char const *str2, int length)"
.br
.RI "Checks if one string pointer is equal to another string pointer up to a specified length (each must be >= this length) "
.ti -1c
.RI "bool \fBstrncmp\fP (char const *str1, \fBMaxOS::String\fP const &str2, int length)"
.br
.RI "Checks if one string pointer is equal to another String up to a specified length (each must be >= this length) "
.ti -1c
.RI "bool \fBstrncmp\fP (\fBMaxOS::String\fP const &str1, char const *str2, int length)"
.br
.RI "Checks if one String is equal to another string pointer up to a specified length (each must be >= this length) "
.ti -1c
.RI "bool \fBstrncmp\fP (\fBMaxOS::String\fP const &str1, \fBMaxOS::String\fP const &str2, int length)"
.br
.RI "Checks if one String is equal to another String up to a specified length (each must be >= this length) "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr int \fBMaxOS::MAX_STRING_SMALL_STORAGE\fP = 0x99"
.br
.RI "How many characters can be stored in the small string optimization array\&. "
.in -1c
.SH "Detailed Description"
.PP 
Defines a String class for dynamically sized strings with various operations\&. 


.PP
\fBDate\fP
.RS 4
12th April 2023 
.RE
.PP
\fBAuthor\fP
.RS 4
Max Tyson 
.RE
.PP

.PP
Definition in file \fBstring\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "char * htoa (uint64_t number)"

.PP
Converts hex to string\&. 
.PP
\fBParameters\fP
.RS 4
\fInumber\fP The number to convert 
.RE
.PP
\fBReturns\fP
.RS 4
The converted string 
.RE
.PP

.PP
Definition at line \fB738\fP of file \fBstring\&.cpp\fP\&..PP
.nf
738                             {
739     // If there is no buffer use a default buffer
740     static char buffer[50] = { 0 };
741     int i = 49;
742 
743     // Null terminate the string
744     buffer[i] = '\\0';
745     \-\-i;
746 
747     if (number == 0) {
748         buffer[i] = '0';
749         return &buffer[i];
750     }
751 
752     for (; number && i; \-\-i, number /= 16)
753         buffer[i] = "0123456789ABCDEF"[number % 16];
754 
755     return &buffer[i + 1];
756 }
.fi

.PP
Referenced by \fBMaxOS::String::String()\fP, and \fBMaxOS::common::OutputStream::write_hex()\fP\&.
.SS "char * itoa (int base, int64_t number)"

.PP
Converts integer to string\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP The base of the number (10 for decimal, 16 for hex) 
.br
\fInumber\fP The number to convert
.RE
.PP
\fBReturns\fP
.RS 4
The converted string 
.RE
.PP

.PP
Definition at line \fB703\fP of file \fBstring\&.cpp\fP\&..PP
.nf
703                                      {
704 
705     // If there is no buffer use a default buffer
706     static char buffer[50] = { 0 };
707 
708     int i = 49;
709     bool is_negative = number < 0;
710 
711     // Null terminate the string
712     buffer[i] = '\\0';
713     \-\-i;
714 
715     if (number == 0) {
716         buffer[i] = '0';
717         return &buffer[i];
718     }
719 
720 
721     for (; number && i; \-\-i, number /= base)
722         buffer[i] = "0123456789ABCDEF"[number % base];
723 
724     if (is_negative) {
725         buffer[i] = '\-';
726         return &buffer[i];
727     }
728 
729     return &buffer[i + 1];
730 }
.fi

.PP
Referenced by \fBMaxOS::String::String()\fP, and \fBMaxOS::common::OutputStream::write_int()\fP\&.
.SS "bool strcmp (char const * str1, char const * str2)"

.PP
Checks if one string pointer is equal to another string pointer\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB765\fP of file \fBstring\&.cpp\fP\&..PP
.nf
765                                                 {
766 
767     // Check if the strings are equal
768     for (int i = 0; str1[i] != '\\0' || str2[i] != '\\0'; i++)
769         if (str1[i] != str2[i])
770             return false;
771 
772     // The strings are equal
773     return true;
774 
775 }
.fi

.PP
Referenced by \fBMaxOS::drivers::console::VESABootConsole::put_character()\fP, \fBstrcmp()\fP, \fBstrcmp()\fP, and \fBstrcmp()\fP\&.
.SS "bool strcmp (char const * str1, \fBString\fP const & str2)"

.PP
Checks if one string pointer is equal to a String\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB784\fP of file \fBstring\&.cpp\fP\&..PP
.nf
784                                                   {
785 
786     // Use the other strcmp function
787     return strcmp(str1, str2\&.c_str());
788 
789 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrcmp()\fP\&.
.SS "bool strcmp (\fBString\fP const & str1, char const * str2)"

.PP
Checks if one String is equal to a string pointer\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB798\fP of file \fBstring\&.cpp\fP\&..PP
.nf
798                                                   {
799 
800     // Use the other strcmp function
801     return strcmp(str1\&.c_str(), str2);
802 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrcmp()\fP\&.
.SS "bool strcmp (\fBString\fP const & str1, \fBString\fP const & str2)"

.PP
Checks if one String is equal to another String (better use is of '==') 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB811\fP of file \fBstring\&.cpp\fP\&..PP
.nf
811                                                     {
812 
813     // Use the other strcmp function
814     return strcmp(str1\&.c_str(), str2\&.c_str());
815 
816 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrcmp()\fP\&.
.SS "int strlen (const char * str)"

.PP
Gets the length of a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to get the length of 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line \fB689\fP of file \fBstring\&.cpp\fP\&..PP
.nf
689                             {
690     int len = 0;
691     for (; str[len] != '\\0'; len++);
692     return len;
693 }
.fi

.PP
Referenced by \fBMaxOS::String::String()\fP, and \fBMaxOS::String::String()\fP\&.
.SS "bool strncmp (char const * str1, char const * str2, int length)"

.PP
Checks if one string pointer is equal to another string pointer up to a specified length (each must be >= this length) 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.br
\fIlength\fP The length of the string to compare 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB826\fP of file \fBstring\&.cpp\fP\&..PP
.nf
826                                                              {
827 
828     // Check if the strings are equal
829     for (int i = 0; i < length; i++)
830         if (str1[i] != str2[i])
831             return false;
832 
833     // Strings are equal
834     return true;
835 
836 }
.fi

.PP
Referenced by \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find()\fP, \fBstrncmp()\fP, \fBstrncmp()\fP, and \fBstrncmp()\fP\&.
.SS "bool strncmp (char const * str1, \fBString\fP const & str2, int length)"

.PP
Checks if one string pointer is equal to another String up to a specified length (each must be >= this length) 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.br
\fIlength\fP The length of the string to compare 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB846\fP of file \fBstring\&.cpp\fP\&..PP
.nf
846                                                                {
847 
848     // Use the other strncmp function
849     return strncmp(str1, str2\&.c_str(), length);
850 
851 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrncmp()\fP\&.
.SS "bool strncmp (\fBString\fP const & str1, char const * str2, int length)"

.PP
Checks if one String is equal to another string pointer up to a specified length (each must be >= this length) 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.br
\fIlength\fP The length of the string to compare 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB861\fP of file \fBstring\&.cpp\fP\&..PP
.nf
861                                                                {
862 
863     // Use the other strncmp function
864     return strncmp(str1\&.c_str(), str2, length);
865 
866 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrncmp()\fP\&.
.SS "bool strncmp (\fBString\fP const & str1, \fBString\fP const & str2, int length)"

.PP
Checks if one String is equal to another String up to a specified length (each must be >= this length) 
.PP
\fBParameters\fP
.RS 4
\fIstr1\fP The first string 
.br
\fIstr2\fP The second string 
.br
\fIlength\fP The length of the string to compare 
.RE
.PP
\fBReturns\fP
.RS 4
True if the strings are equal, false otherwise 
.RE
.PP

.PP
Definition at line \fB876\fP of file \fBstring\&.cpp\fP\&..PP
.nf
876                                                                  {
877 
878     // Use the other strncmp function
879     return strncmp(str1\&.c_str(), str2\&.c_str(), length);
880 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, and \fBstrncmp()\fP\&.
.SH "Variable Documentation"
.PP 
.SS "constexpr int MaxOS::MAX_STRING_SMALL_STORAGE = 0x99\fC [constexpr]\fP"

.PP
How many characters can be stored in the small string optimization array\&. 
.PP
Definition at line \fB20\fP of file \fBstring\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

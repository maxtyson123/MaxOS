.TH "MaxOS::common::Vector< Type >" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::Vector< Type > \- Dynamically stores an array of elements\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "\fBtypedef\fP \fBType\fP * \fBiterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector\fP ()"
.br
.RI "______________________________________Implementation__________________________________________________ "
.ti -1c
.RI "\fBVector\fP (\fBint\fP \fBSize\fP, \fBType\fP \fBelement\fP)"
.br
.RI "Constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fBVector\fP (\fBconst\fP \fBVector\fP< \fBType\fP > &\fBother\fP)"
.br
.RI "Copy constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fBVector\fP (\fBVector\fP< \fBType\fP > &&\fBother\fP)"
.br
.RI "Move constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fB~Vector\fP ()"
.br
.ti -1c
.RI "\fBType\fP & \fBoperator[]\fP (\fBuint32_t\fP index) \fBconst\fP"
.br
.RI "Overloads the [] operator to return the element at the index\&. "
.ti -1c
.RI "\fBVector\fP< \fBType\fP > & \fBoperator=\fP (\fBconst\fP \fBVector\fP< \fBType\fP > &\fBother\fP)"
.br
.RI "Assignment by copy, data is copied into a new buffer stored in this vector\&. "
.ti -1c
.RI "\fBVector\fP< \fBType\fP > & \fBoperator=\fP (\fBVector\fP< \fBType\fP > &&\fBother\fP)"
.br
.RI "Assignment by move, data is moved into the buffer stored in this vector and the other vector is cleared\&. "
.ti -1c
.RI "\fBbool\fP \fBempty\fP () \fBconst\fP"
.br
.RI "Checks if the \fBVector\fP is empty\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBsize\fP () \fBconst\fP"
.br
.RI "Returns the number of elements in the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () \fBconst\fP"
.br
.RI "Returns the first element of the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBend\fP () \fBconst\fP"
.br
.RI "Returns the last element of the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (\fBType\fP) \fBconst\fP"
.br
.RI "Finds an element in the \fBVector\fP and returns the iterator of the element\&. "
.ti -1c
.RI "\fBiterator\fP \fBpush_back\fP (\fBType\fP)"
.br
.RI "Adds an element to the end of the vector and returns the iterator of the element\&. "
.ti -1c
.RI "\fBType\fP \fBpop_back\fP ()"
.br
.RI "Removes the last element from the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBpush_front\fP (\fBType\fP)"
.br
.RI "Adds an element to the front of the \fBVector\fP and returns the iterator of the element\&. "
.ti -1c
.RI "\fBType\fP \fBpop_front\fP ()"
.br
.RI "Removes the m_first_memory_chunk element from the \fBVector\fP\&. "
.ti -1c
.RI "\fBvoid\fP \fBerase\fP (\fBType\fP)"
.br
.RI "Removes all elements from the \fBVector\fP that are equal to the element\&. "
.ti -1c
.RI "\fBvoid\fP \fBerase\fP (\fBiterator\fP position)"
.br
.ti -1c
.RI "\fBvoid\fP \fBclear\fP ()"
.br
.RI "Removes all elements from the \fBVector\fP\&. "
.ti -1c
.RI "\fBvoid\fP \fBiterate\fP (\fBVectorIterationHandler\fP< \fBType\fP > *)"
.br
.RI "Iterates over the \fBVector\fP and calls the OnRead function of the handler for each element\&. "
.ti -1c
.RI "\fBvoid\fP \fBIterate\fP (\fBvoid\fP \fBcallback\fP(\fBType\fP &))"
.br
.RI "Iterates over the \fBVector\fP and calls the callback function for each element\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBincrease_size\fP ()"
.br
.RI "Increases the size of the \fBVector\fP by doubling the capacity\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBType\fP * \fBm_elements\fP"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBm_size\fP { 0 }"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBm_capacity\fP { 1 }"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<\fBclass\fP \fBType\fP>
.br
class MaxOS::common::Vector< Type >"Dynamically stores an array of elements\&. 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB36\fP of file \fBvector\&.h\fP\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBtypedef\fP \fBType\fP* \fBMaxOS::common::Vector\fP< \fBType\fP >::iterator"

.PP
Definition at line \fB46\fP of file \fBvector\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector ()"

.PP
______________________________________Implementation__________________________________________________ Constructor for \fBVector\fP
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB85\fP of file \fBvector\&.h\fP\&..PP
.nf
85                                                   {
86 
87             // Allocate space for the array
88             m_elements = new Type[m_capacity];
89 
90         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBint\fP size, \fBType\fP element)"

.PP
Constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIsize\fP Size of the \fBVector\fP 
.br
\fIelement\fP Element to fill the \fBVector\fP with 
.RE
.PP

.PP
Definition at line \fB99\fP of file \fBvector\&.h\fP\&..PP
.nf
99                                                                         {
100 
101             // Allocate space for the array
102             m_elements = new Type[size];
103             m_capacity = size > 0 ? size : 1;
104             m_size     = 0;
105 
106             // Push all the elements to the Vector
107             for (int i = 0; i < size; ++i)
108                     push_back(element);
109         }
.fi

.PP
References \fBsize\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBconst\fP \fBVector\fP< \fBType\fP > & other)"

.PP
Copy constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP The type of data to be stored 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP

.PP
Definition at line \fB117\fP of file \fBvector\&.h\fP\&..PP
.nf
118         : m_size(other\&.m_size),
119           m_capacity(other\&.m_capacity)
120         {
121             // Copy each element into a new array
122             m_elements = new Type[m_capacity];
123             for (uint32_t i = 0; i < m_size; ++i)
124                 m_elements[i] = other\&.m_elements[i];
125         }
.fi

.PP
References \fBMaxOS::common::Vector< Type >::m_capacity\fP, \fBMaxOS::common::Vector< Type >::m_elements\fP, and \fBMaxOS::common::Vector< Type >::m_size\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBVector\fP< \fBType\fP > && other)"

.PP
Move constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP The type of data to be stored 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP

.PP
Definition at line \fB133\fP of file \fBvector\&.h\fP\&..PP
.nf
134         : m_elements(other\&.m_elements),
135           m_size(other\&.m_size),
136           m_capacity(other\&.m_capacity)
137         {
138 
139             // Clear the other Vector
140             other\&.m_elements = nullptr;
141             other\&.m_size = 0;
142             other\&.m_capacity = 0;
143 
144         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::~\fBVector\fP ()"

.PP
Definition at line \fB146\fP of file \fBvector\&.h\fP\&..PP
.nf
146                                                    {
147 
148             // De\-allocate the array
149             delete[] m_elements;
150 
151         }
.fi

.SH "Member Function Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::begin () const"

.PP
Returns the first element of the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The first element of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB266\fP of file \fBvector\&.h\fP\&..PP
.nf
266                                                                                     {
267             return &m_elements[0];
268         }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::begin()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::clear ()"

.PP
Removes all elements from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB445\fP of file \fBvector\&.h\fP\&..PP
.nf
445                                                       {
446           m_size = 0;
447         }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::clear()\fP, and \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBbool\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::empty () const"

.PP
Checks if the \fBVector\fP is empty\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
True if the \fBVector\fP is empty, false otherwise 
.RE
.PP

.PP
Definition at line \fB304\fP of file \fBvector\&.h\fP\&..PP
.nf
304                                                            {
305             return begin() == end();
306         }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::empty()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::end () const"

.PP
Returns the last element of the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The last element of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBvector\&.h\fP\&..PP
.nf
276                                                                                    {
277             return &m_elements[0] + m_size;
278          }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::end()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::erase (\fBiterator\fP position)"

.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::erase (\fBType\fP element)"

.PP
Removes all elements from the \fBVector\fP that are equal to the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to remove 
.RE
.PP

.PP
Definition at line \fB396\fP of file \fBvector\&.h\fP\&..PP
.nf
396                                                                   {
397 
398             // Search for the element
399             int hits = 0;
400             for (iterator i = begin(); i != end(); ++i)
401             {
402                 // If it is the element we are looking for
403                 if (*i == element)
404                 {
405                     ++hits;
406                 } else {
407 
408                     // If there are hits move the element to the left
409                     if (hits > 0)
410                         *(i \- hits) = *i;
411                 }
412 
413             }
414 
415             // Decrease the size of the Vector
416             m_size \-= hits;
417         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::erase()\fP, and \fBMaxOS::common::Map< Key, Value >::erase()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::find (\fBType\fP element) const"

.PP
Finds an element in the \fBVector\fP and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to find 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element or the end of the \fBVector\fP if the element is not found 
.RE
.PP

.PP
Definition at line \fB287\fP of file \fBvector\&.h\fP\&..PP
.nf
287                                                                                                {
288 
289             // Find the element
290             for (iterator i = begin(); i != end(); ++i)
291               if (*i == element)
292                       return i;
293 
294             // The element must not be in the Vector
295             return end();
296         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::increase_size ()\fC [protected]\fP"

.PP
Increases the size of the \fBVector\fP by doubling the capacity\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB158\fP of file \fBvector\&.h\fP\&..PP
.nf
158                                                                {
159 
160 
161             // Allocate more space for the array
162             Type* new_elements = new Type[m_capacity * 2];
163 
164             // Copy the elements to the new array
165             for (uint32_t i = 0; i < m_size; ++i)
166               new_elements[i] = m_elements[i];
167 
168             // De\-allocate the old array
169             delete[] m_elements;
170 
171             // Set the new array
172             m_elements = new_elements;
173 
174             // Increase the capacity of the Vector
175             m_capacity *= 2;
176 
177         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::iterate (\fBVectorIterationHandler\fP< \fBType\fP > * vector_iteration_handler)"

.PP
Iterates over the \fBVector\fP and calls the OnRead function of the handler for each element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIvector_iteration_handler\fP The handler 
.RE
.PP

.PP
Definition at line \fB455\fP of file \fBvector\&.h\fP\&..PP
.nf
455                                                                                                               {
456 
457           // Call the OnRead function of the handler for each element
458           for(auto& element : m_elements)
459             vector_iteration_handler\->on_read(element);
460 
461           // Call the OnEndOfStream function of the handler
462           vector_iteration_handler\->on_end_of_stream();
463         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::Iterate (\fBvoid\fP  callbackType &)"

.PP
Iterates over the \fBVector\fP and calls the callback function for each element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIcallback\fP The callback function 
.RE
.PP

.PP
Definition at line \fB472\fP of file \fBvector\&.h\fP\&..PP
.nf
472                                                                              {
473 
474            // Call the callback function for each element
475            for(auto& element : m_elements)
476               callback(element);
477         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP > & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator= (\fBconst\fP \fBVector\fP< \fBType\fP > & other)"

.PP
Assignment by copy, data is copied into a new buffer stored in this vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP
\fBReturns\fP
.RS 4
This vector, with the copied elements 
.RE
.PP

.PP
Definition at line \fB204\fP of file \fBvector\&.h\fP\&..PP
.nf
204                                                                                             {
205 
206             // Setting to itself?
207             if (this == &other)
208                 return *this;
209 
210             // Create a new buffer to store the elements
211             delete[] m_elements;
212             m_elements = new Type[other\&.m_capacity];
213 
214             // Copy data
215             m_size = other\&.m_size;
216             m_capacity = other\&.m_capacity;
217             for (uint32_t i = 0; i < m_size; ++i)
218                 m_elements[i] = other\&.m_elements[i];
219 
220             return *this;
221         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP > & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator= (\fBVector\fP< \fBType\fP > && other)\fC [noexcept]\fP"

.PP
Assignment by move, data is moved into the buffer stored in this vector and the other vector is cleared\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP
\fBReturns\fP
.RS 4
This vector, with the copied elements 
.RE
.PP

.PP
Definition at line \fB230\fP of file \fBvector\&.h\fP\&..PP
.nf
230                                                                                                 {
231 
232             // Moving to itself?
233             if (this == &other)
234                 return *this;
235 
236             // Move into this vector
237             delete[] m_elements;
238             m_elements = other\&.m_elements;
239             m_size = other\&.m_size;
240             m_capacity = other\&.m_capacity;
241 
242             // Remove from other vector
243             other\&.m_elements = nullptr;
244             other\&.m_size = 0;
245             other\&.m_capacity = 0;
246 
247             return *this;
248         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBType\fP & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator[] (\fBuint32_t\fP index) const"

.PP
Overloads the [] operator to return the element at the index\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the element 
.RE
.PP
\fBReturns\fP
.RS 4
the element at the index or the end of the \fBVector\fP if the index is out of bounds 
.RE
.PP

.PP
Definition at line \fB186\fP of file \fBvector\&.h\fP\&..PP
.nf
186                                                                                {
187 
188             // If the index is in the Vector
189             if (index < m_size)
190                 return m_elements[index];
191 
192             // Return the last element of the Vector
193             return m_elements[m_size \- 1];
194 
195         }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBType\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::pop_back ()"

.PP
Removes the last element from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB331\fP of file \fBvector\&.h\fP\&..PP
.nf
331                                                          {
332 
333             // Remove the last element from the Vector
334             if (m_size > 0)
335                     \-\-m_size;
336 
337             return m_elements[m_size];
338         }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::pop_back()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBType\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::pop_front ()"

.PP
Removes the m_first_memory_chunk element from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The element that was removed, or a default constructed element if the \fBVector\fP is empty 
.RE
.PP

.PP
Definition at line \fB371\fP of file \fBvector\&.h\fP\&..PP
.nf
371                                                           {
372 
373             // Make sure the Vector is not empty
374             if (m_size == 0)
375               return Type();
376 
377             // Store the element to return
378 
379             Type element = m_elements[0];
380 
381             // Move all elements one index to the left
382             for (uint32_t i = 0; i < m_size \- 1; ++i)
383                 m_elements[i] = m_elements[i + 1];
384 
385             // Decrease the size of the Vector
386             \-\-m_size;
387             return element;
388         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::pop_front()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::push_back (\fBType\fP element)"

.PP
Adds an element to the end of the vector and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to add 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element, if the \fBVector\fP is full it returns the end of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB316\fP of file \fBvector\&.h\fP\&..PP
.nf
316                                                                                                {
317 
318             // Check if we need to allocate more space for the array
319             if(m_size == m_capacity)
320                 increase_size();
321 
322             // Add the element to the Vector and return the iterator of the element
323             m_elements[m_size++] = element;
324             return end() \- 1;
325         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::ext2::InodeHandler::InodeHandler()\fP, \fBMaxOS::common::Map< Key, Value >::insert()\fP, \fBMaxOS::common::Map< Key, Value >::push_back()\fP, and \fBMaxOS::common::EventManager< EventType >::raise_event()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::push_front (\fBType\fP element)"

.PP
Adds an element to the front of the \fBVector\fP and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to add 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element, if the \fBVector\fP is full it returns the end of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB347\fP of file \fBvector\&.h\fP\&..PP
.nf
347                                                                                                 {
348 
349             // Check if we need to allocate more space for the array
350             if(m_size == m_capacity)
351                     increase_size();
352 
353             // Move all elements one index to the right
354             for (iterator i = end(); i > begin(); \-\-i)
355                 *i = *(i \- 1);
356 
357             // Add the element to the front of the Vector
358             m_elements[0] = element;
359             ++m_size;
360 
361             // Return the iterator of the element
362             return begin();
363         }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::push_front()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::size () const"

.PP
Returns the number of elements in the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The size of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB256\fP of file \fBvector\&.h\fP\&..PP
.nf
256                                                               {
257             return m_size;
258         }
.fi

.PP
Referenced by \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, and \fBMaxOS::common::Map< Key, Value >::size()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::m_capacity { 1 }\fC [protected]\fP"

.PP
Definition at line \fB41\fP of file \fBvector\&.h\fP\&..PP
.nf
41 { 1 };
.fi

.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBType\fP* \fBMaxOS::common::Vector\fP< \fBType\fP >::m_elements\fC [protected]\fP"

.PP
Definition at line \fB39\fP of file \fBvector\&.h\fP\&.
.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::m_size { 0 }\fC [protected]\fP"

.PP
Definition at line \fB40\fP of file \fBvector\&.h\fP\&..PP
.nf
40 { 0 };
.fi

.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

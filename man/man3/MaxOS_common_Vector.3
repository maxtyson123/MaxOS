.TH "MaxOS::common::Vector< Type >" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::common::Vector< Type > \- Dynamically stores an array of elements\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "\fBtypedef\fP \fBType\fP * \fBiterator\fP"
.br
.RI "The iterator type for the \fBVector\fP\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector\fP ()"
.br
.RI "______________________________________Implementation__________________________________________________ "
.ti -1c
.RI "\fBVector\fP (\fBint\fP \fBsize\fP, \fBType\fP \fBelement\fP)"
.br
.RI "Constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fBVector\fP (\fBconst\fP \fBVector\fP< \fBType\fP > &\fBother\fP)"
.br
.RI "Copy constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fBVector\fP (\fBVector\fP< \fBType\fP > &&\fBother\fP)"
.br
.RI "Move constructor for \fBVector\fP\&. "
.ti -1c
.RI "\fB~Vector\fP ()"
.br
.RI "Destructor for \fBVector\fP, de-allocates the array\&. "
.ti -1c
.RI "\fBType\fP & \fBoperator[]\fP (\fBuint32_t\fP index) \fBconst\fP"
.br
.RI "Overloads the [] operator to return the element at the index\&. "
.ti -1c
.RI "\fBVector\fP< \fBType\fP > & \fBoperator=\fP (\fBconst\fP \fBVector\fP< \fBType\fP > &\fBother\fP)"
.br
.RI "Assignment by copy, data is copied into a new buffer stored in this vector\&. "
.ti -1c
.RI "\fBVector\fP< \fBType\fP > & \fBoperator=\fP (\fBVector\fP< \fBType\fP > &&\fBother\fP)"
.br
.RI "Assignment by move, data is moved into the buffer stored in this vector and the other vector is cleared\&. "
.ti -1c
.RI "\fBbool\fP \fBempty\fP () \fBconst\fP"
.br
.RI "Checks if the \fBVector\fP is empty\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBsize\fP () \fBconst\fP"
.br
.RI "Returns the number of elements in the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () \fBconst\fP"
.br
.RI "Returns the first element of the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBend\fP () \fBconst\fP"
.br
.RI "Returns the last element of the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (\fBType\fP) \fBconst\fP"
.br
.RI "Finds an element in the \fBVector\fP and returns the iterator of the element\&. "
.ti -1c
.RI "\fBiterator\fP \fBpush_back\fP (\fBType\fP)"
.br
.RI "Adds an element to the end of the vector and returns the iterator of the element\&. "
.ti -1c
.RI "\fBType\fP \fBpop_back\fP ()"
.br
.RI "Removes the last element from the \fBVector\fP\&. "
.ti -1c
.RI "\fBiterator\fP \fBpush_front\fP (\fBType\fP)"
.br
.RI "Adds an element to the front of the \fBVector\fP and returns the iterator of the element\&. "
.ti -1c
.RI "\fBType\fP \fBpop_front\fP ()"
.br
.RI "Removes the m_first_memory_chunk element from the \fBVector\fP\&. "
.ti -1c
.RI "\fBvoid\fP \fBerase\fP (\fBType\fP)"
.br
.RI "Removes all elements from the \fBVector\fP that are equal to the element\&. "
.ti -1c
.RI "\fBvoid\fP \fBerase\fP (\fBtypename\fP \fBVector\fP< \fBType\fP >\fB::iterator\fP position)"
.br
.RI "Removes the element at the m_position\&. "
.ti -1c
.RI "\fBvoid\fP \fBclear\fP ()"
.br
.RI "Removes all elements from the \fBVector\fP\&. "
.ti -1c
.RI "\fBvoid\fP \fBreserve\fP (\fBsize_t\fP \fBamount\fP)"
.br
.RI "Reserves space in the \fBVector\fP for a certain amount of elements\&. "
.ti -1c
.RI "\fBvoid\fP \fBincrease_size\fP ()"
.br
.RI "Increases the size of the \fBVector\fP by doubling the capacity\&. "
.ti -1c
.RI "\fBvoid\fP \fBiterate\fP (\fBVectorIterationHandler\fP< \fBType\fP > *)"
.br
.RI "Iterates over the \fBVector\fP and calls the OnRead function of the handler for each element\&. "
.ti -1c
.RI "\fBvoid\fP \fBiterate\fP (\fBvoid\fP \fBcallback\fP(\fBType\fP &))"
.br
.RI "Iterates over the \fBVector\fP and calls the callback function for each element\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBType\fP * \fBm_elements\fP"
.br
.RI "The array of elements\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_size\fP { 0 }"
.br
.RI "How many elements are currently stored\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBm_capacity\fP { 1 }"
.br
.RI "How many elements can be stored without resizing\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<\fBclass\fP \fBType\fP>
.br
class MaxOS::common::Vector< Type >"Dynamically stores an array of elements\&. 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB39\fP of file \fBvector\&.h\fP\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBtypedef\fP \fBType\fP* \fBMaxOS::common::Vector\fP< \fBType\fP >::iterator"

.PP
The iterator type for the \fBVector\fP\&. 
.PP
Definition at line \fB46\fP of file \fBvector\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector ()"

.PP
______________________________________Implementation__________________________________________________ Constructor for \fBVector\fP
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB88\fP of file \fBvector\&.h\fP\&..PP
.nf
88                                               {
89 
90         // Allocate space for the array
91         m_elements = new Type[m_capacity];
92 
93     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBint\fP size, \fBType\fP element)"

.PP
Constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIsize\fP Size of the \fBVector\fP 
.br
\fIelement\fP Element to fill the \fBVector\fP with 
.RE
.PP

.PP
Definition at line \fB102\fP of file \fBvector\&.h\fP\&..PP
.nf
102                                                                     {
103 
104         // Allocate space for the array
105         m_elements = new Type[size];
106         m_capacity = size > 0 ? size : 1;
107         m_size = 0;
108 
109         // Push all the elements to the Vector
110         for(int i = 0; i < size; ++i)
111             push_back(element);
112     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBconst\fP \fBVector\fP< \fBType\fP > & other)"

.PP
Copy constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP The type of data to be stored 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP

.PP
Definition at line \fB120\fP of file \fBvector\&.h\fP\&..PP
.nf
121             : m_size(other\&.m_size),
122             m_capacity(other\&.m_capacity) {
123         // Copy each element into a new array
124         m_elements = new Type[m_capacity];
125         for(uint32_t i = 0; i < m_size; ++i)
126             m_elements[i] = other\&.m_elements[i];
127     }
.fi

.PP
References \fBMaxOS::common::Vector< Type >::m_capacity\fP, \fBMaxOS::common::Vector< Type >::m_elements\fP, and \fBMaxOS::common::Vector< Type >::m_size\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::Vector (\fBVector\fP< \fBType\fP > && other)"

.PP
Move constructor for \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP The type of data to be stored 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP

.PP
Definition at line \fB135\fP of file \fBvector\&.h\fP\&..PP
.nf
136             : m_elements(other\&.m_elements),
137             m_size(other\&.m_size),
138             m_capacity(other\&.m_capacity) {
139 
140         // Clear the other Vector
141         other\&.m_elements = nullptr;
142         other\&.m_size = 0;
143         other\&.m_capacity = 0;
144 
145     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBMaxOS::common::Vector\fP< \fBType\fP >::~\fBVector\fP ()"

.PP
Destructor for \fBVector\fP, de-allocates the array\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type data stored in the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB152\fP of file \fBvector\&.h\fP\&..PP
.nf
152                                                {
153 
154         // De\-allocate the array
155         delete[] m_elements;
156 
157     }
.fi

.SH "Member Function Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::begin () const"

.PP
Returns the first element of the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The first element of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB283\fP of file \fBvector\&.h\fP\&..PP
.nf
283                                                                                  {
284         return &m_elements[0];
285     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::begin()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::clear ()"

.PP
Removes all elements from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB461\fP of file \fBvector\&.h\fP\&..PP
.nf
461                                                   {
462         m_size = 0;
463     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::clear()\fP, and \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBbool\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::empty () const"

.PP
Checks if the \fBVector\fP is empty\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
True if the \fBVector\fP is empty, false otherwise 
.RE
.PP

.PP
Definition at line \fB321\fP of file \fBvector\&.h\fP\&..PP
.nf
321                                                         {
322         return begin() == end();
323     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::empty()\fP, and \fBMaxOS::common::BlockingLock::release()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::end () const"

.PP
Returns the last element of the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The last element of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB293\fP of file \fBvector\&.h\fP\&..PP
.nf
293                                                                                {
294         return &m_elements[0] + m_size;
295     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::end()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::erase (\fBType\fP element)"

.PP
Removes all elements from the \fBVector\fP that are equal to the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to remove 
.RE
.PP

.PP
Definition at line \fB415\fP of file \fBvector\&.h\fP\&..PP
.nf
415                                                               {
416 
417         // Search for the element
418         int hits = 0;
419         for(iterator i = begin(); i != end(); ++i) {
420             // If it is the element we are looking for
421             if(*i == element) {
422                 ++hits;
423             } else {
424 
425                 // If there are hits move the element to the left
426                 if(hits > 0)
427                     *(i \- hits) = *i;
428             }
429 
430         }
431 
432         // Decrease the size of the Vector
433         m_size \-= hits;
434     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::erase()\fP, and \fBMaxOS::common::Map< Key, Value >::erase()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::erase (\fBtypename\fP \fBVector\fP< \fBType\fP >\fB::iterator\fP position)"

.PP
Removes the element at the m_position\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP The type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIposition\fP The m_position of the element to remove 
.RE
.PP

.PP
Definition at line \fB442\fP of file \fBvector\&.h\fP\&..PP
.nf
442                                                                                         {
443 
444         // If the m_position is not in the Vector
445         if(position < begin() || position >= end())
446             return;
447 
448         // Move all elements one index to the left
449         for(++position; position != end(); ++position)
450             *(position \- 1) = *position;
451 
452         // Decrease the size of the Vector
453         \-\-m_size;
454     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::find (\fBType\fP element) const"

.PP
Finds an element in the \fBVector\fP and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to find 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element or the end of the \fBVector\fP if the element is not found 
.RE
.PP

.PP
Definition at line \fB304\fP of file \fBvector\&.h\fP\&..PP
.nf
304                                                                                             {
305 
306         // Find the element
307         for(iterator i = begin(); i != end(); ++i)
308             if(*i == element)
309                 return i;
310 
311         // The element must not be in the Vector
312         return end();
313     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::increase_size ()"

.PP
Increases the size of the \fBVector\fP by doubling the capacity\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB164\fP of file \fBvector\&.h\fP\&..PP
.nf
164                                                           {
165         reserve(m_capacity * 2);
166     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::increase_size()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::iterate (\fBVectorIterationHandler\fP< \fBType\fP > * vector_iteration_handler)"

.PP
Iterates over the \fBVector\fP and calls the OnRead function of the handler for each element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIvector_iteration_handler\fP The handler 
.RE
.PP

.PP
Definition at line \fB471\fP of file \fBvector\&.h\fP\&..PP
.nf
471                                                                                                           {
472 
473         // Call the OnRead function of the handler for each element
474         for(auto& element : m_elements)
475             vector_iteration_handler\->on_read(element);
476 
477         // Call the OnEndOfStream function of the handler
478         vector_iteration_handler\->on_end_of_stream();
479     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::iterate (\fBvoid\fP  callbackType &)"

.PP
Iterates over the \fBVector\fP and calls the callback function for each element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIcallback\fP The callback function 
.RE
.PP

.PP
Definition at line \fB488\fP of file \fBvector\&.h\fP\&..PP
.nf
488                                                                         {
489 
490         // Call the callback function for each element
491         for(auto& element : m_elements)
492             callback(element);
493     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP > & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator= (\fBconst\fP \fBVector\fP< \fBType\fP > & other)"

.PP
Assignment by copy, data is copied into a new buffer stored in this vector\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP
\fBReturns\fP
.RS 4
This vector, with the copied elements 
.RE
.PP

.PP
Definition at line \fB221\fP of file \fBvector\&.h\fP\&..PP
.nf
221                                                                                          {
222 
223         // Setting to itself?
224         if(this == &other)
225             return *this;
226 
227         // Create a new buffer to store the elements
228         delete[] m_elements;
229         m_elements = new Type[other\&.m_capacity];
230 
231         // Copy data
232         m_size = other\&.m_size;
233         m_capacity = other\&.m_capacity;
234         for(uint32_t i = 0; i < m_size; ++i)
235             m_elements[i] = other\&.m_elements[i];
236 
237         return *this;
238     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP > & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator= (\fBVector\fP< \fBType\fP > && other)"

.PP
Assignment by move, data is moved into the buffer stored in this vector and the other vector is cleared\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIother\fP The vector to copy from 
.RE
.PP
\fBReturns\fP
.RS 4
This vector, with the copied elements 
.RE
.PP

.PP
Definition at line \fB247\fP of file \fBvector\&.h\fP\&..PP
.nf
247                                                                                     {
248 
249         // Moving to itself?
250         if(this == &other)
251             return *this;
252 
253         // Move into this vector
254         delete[] m_elements;
255         m_elements = other\&.m_elements;
256         m_size = other\&.m_size;
257         m_capacity = other\&.m_capacity;
258 
259         // Remove from other vector
260         other\&.m_elements = nullptr;
261         other\&.m_size = 0;
262         other\&.m_capacity = 0;
263 
264         return *this;
265     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBType\fP & \fBMaxOS::common::Vector\fP< \fBType\fP >::operator[] (\fBuint32_t\fP index) const"

.PP
Overloads the [] operator to return the element at the index\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the element 
.RE
.PP
\fBReturns\fP
.RS 4
the element at the index or the end of the \fBVector\fP if the index is out of bounds 
.RE
.PP

.PP
Definition at line \fB203\fP of file \fBvector\&.h\fP\&..PP
.nf
203                                                                              {
204 
205         // If the index is in the Vector
206         if(index < m_size)
207             return m_elements[index];
208 
209         // Return the last element of the Vector
210         return m_elements[m_size \- 1];
211 
212     }
.fi

.SS "template<\fBclass\fP \fBType\fP > \fBType\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::pop_back ()"

.PP
Removes the last element from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP
.RE
.PP
\fBReturns\fP
.RS 4
The element that was removed 
.RE
.PP

.PP
Definition at line \fB350\fP of file \fBvector\&.h\fP\&..PP
.nf
350                                                      {
351 
352         // Remove the last element from the Vector
353         if(m_size > 0)
354             \-\-m_size;
355 
356         return m_elements[m_size];
357     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::pop_back()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBType\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::pop_front ()"

.PP
Removes the m_first_memory_chunk element from the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The element that was removed, or a default constructed element if the \fBVector\fP is empty 
.RE
.PP

.PP
Definition at line \fB390\fP of file \fBvector\&.h\fP\&..PP
.nf
390                                                       {
391 
392         // Make sure the Vector is not empty
393         if(m_size == 0)
394             return Type();
395 
396         // Store the element to return
397 
398         Type element = m_elements[0];
399 
400         // Move all elements one index to the left
401         for(uint32_t i = 0; i < m_size \- 1; ++i)
402             m_elements[i] = m_elements[i + 1];
403 
404         // Decrease the size of the Vector
405         \-\-m_size;
406         return element;
407     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::pop_front()\fP, and \fBMaxOS::common::BlockingLock::release()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::push_back (\fBType\fP element)"

.PP
Adds an element to the end of the vector and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to add 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element, if the \fBVector\fP is full it returns the end of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB333\fP of file \fBvector\&.h\fP\&..PP
.nf
333                                                                                            {
334 
335         // Check if we need to allocate more space for the array
336         if(m_size == m_capacity)
337             increase_size();
338 
339         // Add the element to the Vector and return the iterator of the element
340         m_elements[m_size++] = element;
341         return end() \- 1;
342     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::BlockingLock::acquire()\fP, \fBMaxOS::filesystem::format::ext2::InodeHandler::InodeHandler()\fP, \fBMaxOS::common::Map< Key, Value >::insert()\fP, \fBMaxOS::common::Map< Key, Value >::push_back()\fP, and \fBMaxOS::common::EventManager< EventType >::raise_event()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBVector\fP< \fBType\fP >\fB::iterator\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::push_front (\fBType\fP element)"

.PP
Adds an element to the front of the \fBVector\fP and returns the iterator of the element\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIelement\fP The element to add 
.RE
.PP
\fBReturns\fP
.RS 4
The iterator of the element, if the \fBVector\fP is full it returns the end of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB366\fP of file \fBvector\&.h\fP\&..PP
.nf
366                                                                                             {
367 
368         // Check if we need to allocate more space for the array
369         if(m_size == m_capacity)
370             increase_size();
371 
372         // Move all elements one index to the right
373         for(iterator i = end(); i > begin(); \-\-i)
374             *i = *(i \- 1);
375 
376         // Add the element to the front of the Vector
377         m_elements[0] = element;
378         ++m_size;
379 
380         // Return the iterator of the element
381         return begin();
382     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::push_front()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBvoid\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::reserve (\fBsize_t\fP amount)"

.PP
Reserves space in the \fBVector\fP for a certain amount of elements\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIamount\fP The amount of elements to reserve space for 
.RE
.PP

.PP
Definition at line \fB174\fP of file \fBvector\&.h\fP\&..PP
.nf
174                                                                  {
175 
176 
177         // Increase the capacity of the Vector
178         if(m_capacity < amount)
179             m_capacity = amount;
180 
181         // Allocate more space for the array
182         Type* new_elements = new Type[amount];
183 
184         // Copy the elements to the new array
185         for(uint32_t i = 0; i < m_size; ++i)
186             new_elements[i] = m_elements[i];
187 
188         // De\-allocate the old array
189         delete[] m_elements;
190 
191         // Set the new array
192         m_elements = new_elements;
193     }
.fi

.PP
References \fBMaxOS::common::Rectangle< Type >::Rectangle()\fP\&.
.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::reserve()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::size () const"

.PP
Returns the number of elements in the \fBVector\fP\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIType\fP Type of the \fBVector\fP 
.RE
.PP
\fBReturns\fP
.RS 4
The size of the \fBVector\fP 
.RE
.PP

.PP
Definition at line \fB273\fP of file \fBvector\&.h\fP\&..PP
.nf
273                                                            {
274         return m_size;
275     }
.fi

.PP
Referenced by \fBMaxOS::common::Map< Key, Value >::size()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::m_capacity { 1 }\fC [protected]\fP"

.PP
How many elements can be stored without resizing\&. 
.PP
Definition at line \fB43\fP of file \fBvector\&.h\fP\&..PP
.nf
43 { 1 };          
.fi

.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBType\fP* \fBMaxOS::common::Vector\fP< \fBType\fP >::m_elements\fC [protected]\fP"

.PP
The array of elements\&. 
.PP
Definition at line \fB41\fP of file \fBvector\&.h\fP\&.
.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.
.SS "template<\fBclass\fP \fBType\fP > \fBuint32_t\fP \fBMaxOS::common::Vector\fP< \fBType\fP >::m_size { 0 }\fC [protected]\fP"

.PP
How many elements are currently stored\&. 
.PP
Definition at line \fB42\fP of file \fBvector\&.h\fP\&..PP
.nf
42 { 0 };              
.fi

.PP
Referenced by \fBMaxOS::common::Vector< Type >::Vector()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::Elf64" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Elf64 \- Handles the loading and parsing of 64-bit ELF files\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <elf\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBElf64\fP (uintptr_t elf_header_address)"
.br
.RI "Constructor for the \fBElf64\fP class\&. "
.ti -1c
.RI "\fB~Elf64\fP ()"
.br
.RI "Destructor for the \fBElf64\fP class\&. "
.ti -1c
.RI "void \fBload\fP ()"
.br
.RI "Loads the elf program into memory if a valid elf file\&. "
.ti -1c
.RI "bool \fBis_valid\fP () const"
.br
.RI "Checks if the elf file is valid for \fBMaxOS\fP runtime\&. "
.ti -1c
.RI "\fBelf_64_header_t\fP * \fBheader\fP () const"
.br
.RI "Gets the header of the elf file\&. "
.ti -1c
.RI "\fBelf_64_program_header_t\fP * \fBget_program_header\fP (size_t index) const"
.br
.RI "Gets a program header from the elf file\&. "
.ti -1c
.RI "\fBelf_64_section_header_t\fP * \fBget_section_header\fP (size_t index) const"
.br
.RI "Gets a section header from the elf file\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static uint64_t \fBto_vmm_flags\fP (uint32_t \fBtype\fP)"
.br
.RI "Converts elf flags to vmm flags\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the loading and parsing of 64-bit ELF files\&. 
.PP
Definition at line \fB154\fP of file \fBelf\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Elf64::Elf64 (uintptr_t elf_header_address)"

.PP
Constructor for the \fBElf64\fP class\&. 
.PP
\fBParameters\fP
.RS 4
\fIelf_header_address\fP The address of the elf header, this must be mapped to memory before uses 
.RE
.PP

.PP
Definition at line \fB19\fP of file \fBelf\&.cpp\fP\&..PP
.nf
20 : m_elf_header_address(elf_header_address)
21 {
22 }
.fi

.SS "Elf64::~Elf64 ()\fC [default]\fP"

.PP
Destructor for the \fBElf64\fP class\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBelf_64_program_header_t\fP * Elf64::get_program_header (size_t index) const"

.PP
Gets a program header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The program header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line \fB58\fP of file \fBelf\&.cpp\fP\&..PP
.nf
58                                                                      {
59 
60     // Check bounds
61     if (index >= header()\->program_header_count)
62         return nullptr;
63 
64     // Find the program headers and return the item
65     auto* program_headers = (elf_64_program_header_t*) (m_elf_header_address + header()\->program_header_offset);
66     return &program_headers[index];
67 
68 }
.fi

.PP
References \fBheader()\fP, and \fBMaxOS::processes::elf_64_header_t::program_header_offset\fP\&.
.SS "\fBelf_64_section_header_t\fP * Elf64::get_section_header (size_t index) const"

.PP
Gets a section header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the section header 
.RE
.PP
\fBReturns\fP
.RS 4
The section header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line \fB76\fP of file \fBelf\&.cpp\fP\&..PP
.nf
76                                                                      {
77 
78     // Check bound
79     if (index >= header()\->section_header_count)
80         return nullptr;
81 
82     // Find the section headers and return the item
83     auto* section_headers = (elf_64_section_header_t*) (m_elf_header_address + header()\->section_header_offset);
84     return &section_headers[index];
85 
86 }
.fi

.PP
References \fBheader()\fP, and \fBMaxOS::processes::elf_64_header_t::section_header_offset\fP\&.
.SS "\fBelf_64_header_t\fP * Elf64::header () const"

.PP
Gets the header of the elf file\&. 
.PP
\fBReturns\fP
.RS 4
The header of the elf file 
.RE
.PP

.PP
Definition at line \fB47\fP of file \fBelf\&.cpp\fP\&..PP
.nf
47                                      {
48 
49     return (elf_64_header_t*) m_elf_header_address;
50 }
.fi

.PP
Referenced by \fBget_program_header()\fP, \fBget_section_header()\fP, and \fBis_valid()\fP\&.
.SS "bool Elf64::is_valid () const"

.PP
Checks if the elf file is valid for \fBMaxOS\fP runtime\&. 
.PP
Definition at line \fB91\fP of file \fBelf\&.cpp\fP\&..PP
.nf
91                            {
92 
93     // Validate the magic number
94     for (size_t i = 0; i < 4; i++)
95         if (header()\->identification[i] != elf_magic[i])
96             return false;
97 
98     // Check if the elf is 64 bit
99     if (header()\->identification[(int) ElfIdentification::Class] != (int) ElfClass::Bits64)
100         return false;
101 
102     // Check if the elf is little endian
103     if (header()\->identification[(int) ElfIdentification::Data] != (int) ElfData::LittleEndian)
104         return false;
105 
106     // Check if the elf is version 1
107     if (header()\->identification[(int) ElfIdentification::Version] != (int) ElfVersion::Current)
108         return false;
109 
110     // Check if the elf is for the MaxOS platform
111     //  if(header() \-> identification[OSABI] != MaxOSABI)
112     //      return false; TODO: Would be nice to have an OS ABI
113 
114     // Check if the elf is executable
115     if (header()\->type != (int) ElfType::Executable)
116         return false;
117 
118     // Check if the elf is for the x86_64 platform
119     if (header()\->machine != (int) ElfMachine::x86_64)
120         return false;
121 
122     // LGTM
123     return true;
124 
125 }
.fi

.PP
References \fBMaxOS::processes::Bits64\fP, \fBMaxOS::processes::Class\fP, \fBMaxOS::processes::Current\fP, \fBMaxOS::processes::Data\fP, \fBMaxOS::processes::Executable\fP, \fBheader()\fP, \fBMaxOS::processes::LittleEndian\fP, \fBtype\fP, \fBMaxOS::processes::Version\fP, and \fBMaxOS::processes::x86_64\fP\&.
.PP
Referenced by \fBload()\fP\&.
.SS "void Elf64::load ()"

.PP
Loads the elf program into memory if a valid elf file\&. 
.PP
Definition at line \fB32\fP of file \fBelf\&.cpp\fP\&..PP
.nf
32                  {
33 
34     //TODO: error handling when the syscall for this is implemented
35     if (!is_valid())
36         return;
37 
38     load_program_headers();
39 
40 }
.fi

.PP
References \fBis_valid()\fP\&.
.SS "uint64_t Elf64::to_vmm_flags (uint32_t type)\fC [static]\fP"

.PP
Converts elf flags to vmm flags\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The elf flags of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The vmm flags 
.RE
.PP

.PP
Definition at line \fB164\fP of file \fBelf\&.cpp\fP\&..PP
.nf
164                                           {
165 
166     // Conversion
167     // ELF   |   VMM
168     // 0x0   |   Executable
169     // 0x1   |   Write
170     // 0x2   |   Read
171 
172     uint64_t flags = Present | User | NoExecute;
173 
174     // Enable write
175     if (type & ElfWrite)
176         flags |= Write;
177 
178     // Disable no execute
179     if (type & ElfExecute)
180         flags &= ~NoExecute;
181 
182     return flags;
183 }
.fi

.PP
References \fBMaxOS::processes::ElfExecute\fP, \fBMaxOS::processes::ElfWrite\fP, \fBflags\fP, \fBMaxOS::memory::NoExecute\fP, \fBMaxOS::memory::Present\fP, \fBtype\fP, \fBMaxOS::memory::User\fP, and \fBMaxOS::memory::Write\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

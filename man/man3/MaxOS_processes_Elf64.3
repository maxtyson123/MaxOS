.TH "MaxOS::processes::Elf64" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Elf64
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <elf\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBElf64\fP (uintptr_t elf_header_address)"
.br
.RI "Constructor for the \fBElf64\fP class\&. "
.ti -1c
.RI "\fB~Elf64\fP ()"
.br
.RI "Destructor for the \fBElf64\fP class\&. "
.ti -1c
.RI "void \fBload\fP ()"
.br
.RI "Loads the elf program into memory if a valid elf file\&. "
.ti -1c
.RI "bool \fBis_valid\fP ()"
.br
.RI "Checks if the elf file is valid for \fBMaxOS\fP runtime\&. "
.ti -1c
.RI "\fBelf_64_header_t\fP * \fBget_header\fP ()"
.br
.RI "Gets the header of the elf file\&. "
.ti -1c
.RI "\fBelf_64_program_header_t\fP * \fBget_program_header\fP (size_t index)"
.br
.RI "Gets a program header from the elf file\&. "
.ti -1c
.RI "\fBelf_64_section_header_t\fP * \fBget_section_header\fP (size_t index)"
.br
.RI "Gets a section header from the elf file\&. "
.ti -1c
.RI "uint64_t \fBto_vmm_flags\fP (uint32_t \fBtype\fP)"
.br
.RI "Converts elf flags to vmm flags\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 149 of file elf\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Elf64::Elf64 (uintptr_t elf_header_address)"

.PP
Constructor for the \fBElf64\fP class\&. 
.PP
\fBParameters\fP
.RS 4
\fIelf_header_address\fP The address of the elf header, this must be mapped to memory before uses 
.RE
.PP

.PP
Definition at line 19 of file elf\&.cpp\&.
.PP
.nf
20 : m_elf_header_address(elf_header_address)
21 {
22 }
.fi
.SS "Elf64::~Elf64 ()"

.PP
Destructor for the \fBElf64\fP class\&. 
.PP
Definition at line 27 of file elf\&.cpp\&.
.PP
.nf
28 {
29 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBelf_64_header_t\fP * Elf64::get_header ()"

.PP
Gets the header of the elf file\&. 
.PP
\fBReturns\fP
.RS 4
The header of the elf file 
.RE
.PP

.PP
Definition at line 49 of file elf\&.cpp\&.
.PP
.nf
49                                    {
50 
51   // Return the header
52   return (elf_64_header_t*)m_elf_header_address;
53 }
.fi
.PP
Referenced by get_program_header(), get_section_header(), and is_valid()\&.
.SS "\fBelf_64_program_header_t\fP * Elf64::get_program_header (size_t index)"

.PP
Gets a program header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The program header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line 61 of file elf\&.cpp\&.
.PP
.nf
61                                                                {
62 
63   // Check if within bounds
64   if(index >= get_header() -> program_header_count) return nullptr;
65 
66   // Get the address of the program headers
67   elf_64_program_header_t* program_headers = (elf_64_program_header_t*)(m_elf_header_address + get_header() -> program_header_offset);
68 
69   // Return the requested program header
70   return &program_headers[index];
71 
72 }
.fi
.PP
References get_header()\&.
.SS "\fBelf_64_section_header_t\fP * Elf64::get_section_header (size_t index)"

.PP
Gets a section header from the elf file\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the section header 
.RE
.PP
\fBReturns\fP
.RS 4
The section header at that index or nullptr if out of bounds 
.RE
.PP

.PP
Definition at line 80 of file elf\&.cpp\&.
.PP
.nf
80                                                                {
81 
82   // Check if within bounds
83   if(index >= get_header() -> section_header_count) return nullptr;
84 
85   // Get the address of the section headers
86   elf_64_section_header_t* section_headers = (elf_64_section_header_t*)(m_elf_header_address + get_header() -> section_header_offset);
87 
88   // Return the requested section header
89   return &section_headers[index];
90 
91 }
.fi
.PP
References get_header()\&.
.SS "bool Elf64::is_valid ()"

.PP
Checks if the elf file is valid for \fBMaxOS\fP runtime\&. 
.PP
Definition at line 96 of file elf\&.cpp\&.
.PP
.nf
96                      {
97 
98   // Validate the magic number
99   for (size_t i = 0; i < 4; i++)
100     if (get_header() -> identification[i] != elf_magic[i])
101       return false;
102 
103   // Check if the elf is 64 bit
104   if(get_header() -> identification[Class] != Class64)
105     return false;
106 
107   // Check if the elf is little endian
108   if(get_header() -> identification[Data] != LittleEndian)
109     return false;
110 
111   // Check if the elf is version 1
112   if(get_header() -> identification[Version] != Current)
113     return false;
114 
115   // Check if the elf is for the MaxOS platform
116   //  if(get_header() -> identification[OSABI] != MaxOSABI)
117   //      return false; TODO: Would be nice to have an OSABI
118 
119   // Check if the elf is executable
120   if(get_header() -> type != Executable)
121     return false;
122 
123   // Check if the elf is for the x86_64 platform
124   if(get_header() -> machine != x86_64)
125     return false;
126 
127   // LGTM
128   return true;
129 
130 }
.fi
.PP
References MaxOS::processes::Class, MaxOS::processes::Class64, MaxOS::processes::Current, MaxOS::processes::Data, MaxOS::processes::Executable, get_header(), MaxOS::drivers::peripherals::i, MaxOS::processes::LittleEndian, type, MaxOS::processes::Version, and MaxOS::processes::x86_64\&.
.PP
Referenced by load(), and MaxOS::processes::Scheduler::load_multiboot_elfs()\&.
.SS "void Elf64::load ()"

.PP
Loads the elf program into memory if a valid elf file\&. 
.PP
Definition at line 34 of file elf\&.cpp\&.
.PP
.nf
34                  {
35 
36   // Check if valid
37   if(!is_valid()) return; //TODO: error handling
38 
39   // Load the program headers
40   load_program_headers();
41 
42 }
.fi
.PP
References is_valid()\&.
.SS "uint64_t Elf64::to_vmm_flags (uint32_t type)"

.PP
Converts elf flags to vmm flags\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The elf flags of the program header 
.RE
.PP
\fBReturns\fP
.RS 4
The vmm flags 
.RE
.PP

.PP
Definition at line 175 of file elf\&.cpp\&.
.PP
.nf
175                                           {
176 
177   // Conversion
178   // ELF   |   VMM
179   // 0x0   |   Executable (not used)
180   // 0x1   |   Write
181   // 0x2   |   Read
182 
183   uint64_t flags = 0;
184 
185   if(type & ElfWrite)
186       flags |= Write;
187 
188 //  if(type & ElfProgramFlags::Execute)
189 //      flags |= PageFlags::Execute;
190 
191 
192   return flags;
193 
194 }
.fi
.PP
References MaxOS::processes::ElfWrite, flags, type, and MaxOS::memory::Write\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

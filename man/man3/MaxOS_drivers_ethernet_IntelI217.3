.TH "MaxOS::drivers::ethernet::IntelI217" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::drivers::ethernet::IntelI217 \- \fBDriver\fP for the Intel I217 Ethernet Controller\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <intel_i217\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriver\fP, and \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIntelI217\fP (\fBhardwarecommunication::PCIDeviceDescriptor\fP *\fBdevice_descriptor\fP)"
.br
.RI "Constructs a new Intel I217 Ethernet driver\&. Gets the MAC address and clears the receive descriptor array\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBreset\fP () \fBfinal\fP"
.br
.RI "Reset the driver\&. "
.ti -1c
.RI "\fBvoid\fP \fBactivate\fP () \fBfinal\fP"
.br
.RI "Activate the driver\&. "
.ti -1c
.RI "\fBvoid\fP \fBdeactivate\fP () \fBfinal\fP"
.br
.RI "Deactivate the driver\&. "
.ti -1c
.RI "\fBvoid\fP \fBhandle_interrupt\fP () \fBfinal\fP"
.br
.RI "Handles an interrupt\&. "
.ti -1c
.RI "\fBstring\fP \fBvendor_name\fP () \fBfinal\fP"
.br
.RI "Get who created the device\&. "
.ti -1c
.RI "\fBstring\fP \fBdevice_name\fP () \fBfinal\fP"
.br
.RI "Get the device name of the driver\&. "
.ti -1c
.RI "\fBvoid\fP \fBdo_send\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size) \fBfinal\fP"
.br
.RI "(Device Side) send the data "
.ti -1c
.RI "\fBuint64_t\fP \fBget_media_access_control_address\fP () \fBfinal\fP"
.br
.RI "Get the MAC address\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBsend\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size)"
.br
.RI "send data to the network via the driver backend "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::Driver\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBinitialise\fP ()"
.br
.RI "Initialise the driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventManager< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBconnect_event_handler\fP (\fBEventHandler\fP< EthernetDriverEvents > *\fBhandler\fP)"
.br
.RI "connect an event handler to the event manager if it is not already connected "
.ti -1c
.RI "\fBvoid\fP \fBdisconnect_event_handler\fP (\fBEventHandler\fP< EthernetDriverEvents > *\fBhandler\fP)"
.br
.RI "disconnect an event handler from the event manager if it is connected "
.ti -1c
.RI "\fBVector\fP< \fBEvent\fP< EthernetDriverEvents > * > \fBraise_event\fP (\fBEvent\fP< EthernetDriverEvents > *\fBevent\fP)"
.br
.RI "Calls the on_event function of all the event m_handlers connected to the event manager and returns a list of the results\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBsystem::cpu_status_t\fP * \fBhandle_interrupt\fP (\fBsystem::cpu_status_t\fP *status)"
.br
.RI "Handles an interrupt and returns the status\&. "
.in -1c
.SS "Additional Inherited Members"


Static Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBstatic\fP \fBMediaAccessControlAddress\fP \fBcreate_media_access_control_address\fP (\fBuint8_t\fP \fBdigit1\fP, \fBuint8_t\fP \fBdigit2\fP, \fBuint8_t\fP \fBdigit3\fP, \fBuint8_t\fP \fBdigit4\fP, \fBuint8_t\fP \fBdigit5\fP, \fBuint8_t\fP \fBdigit6\fP)"
.br
.RI "Create a Media Access Control Address\&. "
.in -1c

Protected Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriver\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBfire_data_received\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size)"
.br
.RI "Handle the recieved data\&. "
.ti -1c
.RI "\fBvoid\fP \fBfire_data_sent\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size)"
.br
.RI "send data "
.in -1c

Protected Member Functions inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP (\fBuint8_t\fP interrupt_number, \fBint64_t\fP \fBredirect\fP=\-1, \fBuint64_t\fP \fBredirect_index\fP=0)"
.br
.RI "Creates a new interrupt handler and registers it with the interrupt manager\&. "
.ti -1c
.RI "\fB~InterruptHandler\fP ()"
.br
.RI "Destroys the interrupt handler and unregisters it from the interrupt manager\&. "
.in -1c

Protected Attributes inherited from \fBMaxOS::common::EventManager< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBVector\fP< \fBEventHandler\fP< EthernetDriverEvents > * > \fBm_handlers\fP"
.br
.in -1c

Protected Attributes inherited from \fBMaxOS::hardwarecommunication::InterruptHandler\fP
.in +1c
.ti -1c
.RI "uint8_t \fBm_interrupt_number\fP"
.br
.RI "The interrupt number this handler handles\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBDriver\fP for the Intel I217 Ethernet Controller\&. 
.PP
Definition at line \fB64\fP of file \fBintel_i217\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IntelI217::IntelI217 (\fBhardwarecommunication::PCIDeviceDescriptor\fP * device_descriptor)\fC [explicit]\fP"

.PP
Constructs a new Intel I217 Ethernet driver\&. Gets the MAC address and clears the receive descriptor array\&. 
.PP
\fBParameters\fP
.RS 4
\fIdevice_descriptor\fP The PCI device descriptor for this device 
.RE
.PP

.PP
Definition at line \fB33\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
34         : InterruptHandler(0x20 + device_descriptor\->interrupt) {
35 
36     //Set the registers
37     control_register = 0x0000;
38     status_register = 0x0008;
39     eprom_register = 0x0014;
40     control_ext_register = 0x0018;
41     interrupt_mask_register = 0x00D0;
42 
43     receive_control_register = 0x0100;
44     receive_descriptor_low_register = 0x2800;
45     receive_descriptor_high_register = 0x2804;
46     receive_descriptor_length_register = 0x2808;
47     receive_descriptor_head_register = 0x2810;
48     receive_descriptor_tail_register = 0x2818;
49 
50     send_control_register = 0x0400;
51     send_descriptor_low_register = 0x3800;
52     send_descriptor_high_register = 0x3804;
53     send_descriptor_length_register = 0x3808;
54     send_descriptor_head_register = 0x3810;
55     send_descriptor_tail_register = 0x3818;
56 
57     // Get BAR0 type, io_base address and MMIO base address
58     bar_type = 1; // deviceDescriptor \-> has_memory_base ? 0 : 1;  @todo Fix memory mapping from PCI as it is unable to get MAC from memory
59     port_base = device_descriptor\->port_base;
60     //TODO: memBase = deviceDescriptor \-> memory_base;
61 
62     init_done = false;
63     active = false;
64 
65     // Clear eprom
66     eprom_present = detect_ee_prom();
67 
68 
69     if (read_mac_address()) {
70         own_mac = create_media_access_control_address(mac_address[0], mac_address[1], mac_address[2], mac_address[3],
71                                                       mac_address[4], mac_address[5]);
72 
73     } else {
74         ASSERT(false, "ERROR, INIT FAILED, MAC ADDRESS NOT FOUND");
75     }
76 
77     for (int i = 0; i < 0x80; i++)               //Loop through all the registers
78         write(0x5200 + i * 4, 0);     //Clear the receive descriptor array
79 
80 
81 
82 
83 }
.fi

.PP
References \fBASSERT\fP, and \fBMaxOS::drivers::ethernet::EthernetDriver::create_media_access_control_address()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP IntelI217::activate ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Activate the driver\&. 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB298\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
298                          {
299 
300 
301     //Enable interrupts
302     write(interrupt_mask_register, 0x1F6DC);                     //Enable all interrupts
303     write(interrupt_mask_register, 0xff & ~4);                   //Enable all interrupts except link status change
304     read(0xc0);                                                     //Clear all interrupts
305 
306     //while (!initDone);                                           //Wait for the init to be done
307 
308     //Initialise the send and receive descriptors
309     receive_init();
310     send_init();
311 
312     active = true;                                               // Set active to true
313 
314 }
.fi

.SS "\fBvoid\fP IntelI217::deactivate ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Deactivate the driver\&. 
.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB391\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
391                            {
392     Driver::deactivate();
393 }
.fi

.PP
References \fBMaxOS::drivers::Driver::deactivate()\fP\&.
.SS "\fBstring\fP IntelI217::device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the device name of the driver\&. 
.PP
\fBReturns\fP
.RS 4
The device name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB399\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
399                               {
400     return "E1000 (i217)";
401 }
.fi

.SS "\fBvoid\fP IntelI217::do_send (\fBuint8_t\fP * buffer, \fBuint32_t\fP size)\fC [final]\fP, \fC [virtual]\fP"

.PP
(Device Side) send the data 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to handle 
.br
\fIsize\fP The size of the buffer 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line \fB356\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
356                                                       {
357 
358     while (!active);
359 
360     //Put params into send buffer
361     send_dsrctrs[current_send_buffer]\->buffer_address = (uint64_t) buffer;
362     send_dsrctrs[current_send_buffer]\->length = size;
363 
364     //Set the commands
365     send_dsrctrs[current_send_buffer]\->cmd = (1 << 0)    // End of Packet
366                                           | (1 << 1)    // Insert FCS
367                                           | (1 << 3)    // Report Status
368             ;
369 
370     send_dsrctrs[current_send_buffer]\->status = 0;
371 
372     uint8_t old_cur = current_send_buffer;                                    //Save the current send buffer
373     current_send_buffer = (current_send_buffer + 1) % 8;                        //Increment the current send buffer
374     write(send_descriptor_tail_register, current_send_buffer);       //write the current send buffer to the tail register
375 
376     //Wait for the packet to be sent
377     while (!(send_dsrctrs[old_cur]\->status & 0xff));
378 
379 }
.fi

.SS "\fBuint64_t\fP IntelI217::get_media_access_control_address ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the MAC address\&. 
.PP
\fBReturns\fP
.RS 4
the MAC address 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriver\fP\&.
.PP
Definition at line \fB381\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
381                                                      {
382     while (own_mac == 0);
383     return own_mac;
384 
385 }
.fi

.SS "\fBvoid\fP IntelI217::handle_interrupt ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Handles an interrupt\&. 
.PP
Reimplemented from \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.PP
Definition at line \fB316\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
316                                  {
317 
318     write(interrupt_mask_register, 0x1);      //Clear the interrupt or it will hang
319     uint32_t temp = read(0xc0);                //read the interrupt status register
320 
321     // if(temp & 0x04)
322     //   m_driver_message_stream\-> write("INTEL i217 START LINK");//initDone = true;
323     //
324     // if(temp & 0x10)
325     //   m_driver_message_stream\-> write("INTEL i217 GOOD THRESHOLD");
326 
327     if (temp & 0x80) fetch_data_received();
328 }
.fi

.SS "\fBuint32_t\fP IntelI217::reset ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Reset the driver\&. 
.PP
\fBReturns\fP
.RS 4
How long in milliseconds it took to reset the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB387\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
387                           {
388     return Driver::reset();
389 }
.fi

.PP
References \fBMaxOS::drivers::Driver::reset()\fP\&.
.SS "\fBstring\fP IntelI217::vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get who created the device\&. 
.PP
\fBReturns\fP
.RS 4
The vendor name of the driver 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::Driver\fP\&.
.PP
Definition at line \fB395\fP of file \fBintel_i217\&.cpp\fP\&..PP
.nf
395                               {
396     return "Intel";
397 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

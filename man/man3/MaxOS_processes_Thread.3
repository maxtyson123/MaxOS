.TH "MaxOS::processes::Thread" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Thread \- The execution context of a sub-process thread\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <process\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBThread\fP (\fBvoid\fP(*\fB_entry_point\fP)(\fBvoid\fP *), \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBProcess\fP *\fBparent\fP)"
.br
.RI "Constructor for the \fBThread\fP class\&. "
.ti -1c
.RI "\fB~Thread\fP ()"
.br
.RI "Destructor for the \fBThread\fP class\&. "
.ti -1c
.RI "\fBvoid\fP \fBsleep\fP (\fBsize_t\fP \fBmilliseconds\fP)"
.br
.RI "Sleeps the thread for a certain amount of time\&. "
.ti -1c
.RI "uintptr_t \fBtss_pointer\fP () const"
.br
.RI "Gets the stack pointer to use for the TSS when switching to this thread\&. "
.ti -1c
.RI "\fBvoid\fP \fBsave_sse_state\fP ()"
.br
.RI "Saves the SSE, x87 FPU, and MMX states from memory to the thread\&. "
.ti -1c
.RI "\fBvoid\fP \fBrestore_sse_state\fP ()"
.br
.RI "Restores the SSE, x87 FPU, and MMX states from the thread to memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBsave_cpu_state\fP ()"
.br
.RI "Saves the CPU state into the thread's execution_state structure\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "uint64_t \fBtid\fP"
.br
.RI "The thread ID\&. "
.ti -1c
.RI "uint64_t \fBparent_pid\fP"
.br
.RI "The parent process ID\&. "
.ti -1c
.RI "\fBsystem::cpu_status_t\fP \fBexecution_state\fP"
.br
.RI "The CPU state of the thread\&. "
.ti -1c
.RI "\fBthread_state_t\fP \fBthread_state\fP"
.br
.RI "The current state of the thread\&. "
.ti -1c
.RI "size_t \fBticks\fP"
.br
.RI "The number of ticks the thread has run for\&. "
.ti -1c
.RI "size_t \fBwakeup_time\fP"
.br
.RI "The time at which the thread should wake up (if sleeping) "
.in -1c
.SH "Detailed Description"
.PP 
The execution context of a sub-process thread\&. 
.PP
Definition at line \fB49\fP of file \fBprocess\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Thread::Thread (\fBvoid\fP(*)(\fBvoid\fP *) _entry_point, \fBvoid\fP * args, \fBint\fP arg_amount, \fBProcess\fP * parent)"

.PP
Constructor for the \fBThread\fP class\&. 
.PP
\fBParameters\fP
.RS 4
\fI_entry_point\fP The address of the function to start executing 
.br
\fIargs\fP The arguments to pass to the function 
.br
\fIarg_amount\fP The number of arguments 
.br
\fIparent\fP The proccess that owns this thread (started it) 
.RE
.PP

.PP
Definition at line \fB26\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
26                                                                                         {
27 
28     // Basic setup
29     thread_state = ThreadState::NEW;
30     wakeup_time = 0;
31     ticks = 0;
32 
33     // Create the stack
34     m_stack_pointer = (uintptr_t) MemoryManager::malloc(STACK_SIZE);
35 
36     // Create the TSS stack
37     if (parent\->is_kernel) {
38 
39         // Use the kernel stack
40         m_tss_stack_pointer = CPU::executing_core() \-> tss\&.rsp0;
41 
42     } else {
43         m_tss_stack_pointer = (uintptr_t) MemoryManager::kmalloc(STACK_SIZE) + STACK_SIZE;
44     }
45 
46     // Mak sure there is a stack
47     ASSERT(m_stack_pointer != 0 && m_tss_stack_pointer != 0, "Failed to allocate stack for thread");
48 
49     // Set up the execution state
50     execution_state = {};
51     execution_state\&.rip = (uint64_t) _entry_point;
52     execution_state\&.ss = parent\->is_kernel ? 0x10 : 0x23;
53     execution_state\&.cs = parent\->is_kernel ? 0x8 : 0x1B;
54     execution_state\&.rflags = 0x202;
55     execution_state\&.interrupt_number = 0;
56     execution_state\&.error_code = 0;
57     execution_state\&.rsp = m_stack_pointer;
58     execution_state\&.rbp = 0;
59 
60     // Copy the args into userspace
61     uint64_t argc = arg_amount;
62     void* argv = MemoryManager::malloc(arg_amount * sizeof(void*));
63     memcpy(argv, args, arg_amount * sizeof(void*));
64 
65     execution_state\&.rdi = argc;
66     execution_state\&.rsi = (uint64_t) argv;
67     //execution_state\->rdx = (uint64_t)env_args;
68 
69     parent_pid = parent\->pid();
70 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::system::CPU::executing_core()\fP, \fBexecution_state\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::memory::MemoryManager::malloc()\fP, \fBmemcpy()\fP, \fBparent_pid\fP, \fBMaxOS::processes::STACK_SIZE\fP, \fBthread_state\fP, \fBticks\fP, and \fBwakeup_time\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Thread::restore_sse_state ()"

.PP
Restores the SSE, x87 FPU, and MMX states from the thread to memory\&. 
.PP
Definition at line \fB105\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
105                                {
106 
107     // Ensure the state saving is enabled
108     if (!CPU::executing_core()\->xsave_enabled)
109         return;
110 
111     // Restore the state
112     asm volatile("fxrstor %0" : : "m" (m_sse_save_region));
113 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP\&.
.SS "\fBvoid\fP Thread::save_cpu_state ()"

.PP
Saves the CPU state into the thread's execution_state structure\&. 
.PP
Definition at line \fB118\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
118                             {
119     asm volatile(
120             // Store return address before stack is modified
121             "movq (%%rsp), %%rax\\n"
122 
123             // Store RDI before stack is modified
124             "pushq %%rdi\\n"
125             "movq %0, %%rdi\\n"
126 
127             // Store general purpose
128             "movq %%r15, 0x00(%%rdi)\\n"
129             "movq %%r14, 0x08(%%rdi)\\n"
130             "movq %%r13, 0x10(%%rdi)\\n"
131             "movq %%r12, 0x18(%%rdi)\\n"
132             "movq %%r11, 0x20(%%rdi)\\n"
133             "movq %%r10, 0x28(%%rdi)\\n"
134             "movq %%r9,  0x30(%%rdi)\\n"
135             "movq %%r8,  0x38(%%rdi)\\n"
136             "movq %%rdi, 0x40(%%rdi)\\n"
137             "movq %%rsi, 0x48(%%rdi)\\n"
138             "movq %%rbp, 0x50(%%rdi)\\n"
139             "movq %%rdx, 0x58(%%rdi)\\n"
140             "movq %%rcx, 0x60(%%rdi)\\n"
141             "movq %%rbx, 0x68(%%rdi)\\n"
142             "movq %%rax, 0x70(%%rdi)\\n"
143 
144             // Reserved
145             "movq $0,    0x78(%%rdi)\\n"
146             "movq $0,    0x80(%%rdi)\\n"
147 
148             // RIP from earlier
149             "movq %%rax, 0x88(%%rdi)\\n"
150 
151             // Get cs
152             "xorq %%rax, %%rax\\n"
153             "movw %%cs, %%ax\\n"
154             "movq %%rax, 0x90(%%rdi)\\n"
155 
156             // Store flags
157             "pushfq\\n"
158             "popq %%rax\\n"
159             "movq %%rax, 0x98(%%rdi)\\n"
160 
161             // Get RSP and SS
162             "movq %%rsp, 0xA0(%%rdi)\\n"
163             "xorq %%rax, %%rax\\n"
164             "movw %%ss, %%ax\\n"
165             "movq %%rax, 0xA8(%%rdi)\\n"
166 
167             // Restore RDI
168             "popq %%rdi\\n"
169             :
170             : "r" (&execution_state)
171             : "rax", "cc", "memory"
172             );
173 }
.fi

.PP
References \fBexecution_state\fP\&.
.SS "\fBvoid\fP Thread::save_sse_state ()"

.PP
Saves the SSE, x87 FPU, and MMX states from memory to the thread\&. 
.PP
Definition at line \fB92\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
92                             {
93 
94     // Ensure the state saving is enabled
95     if (!CPU::executing_core()\->xsave_enabled)
96         return;
97 
98     // Save the state
99     asm volatile("fxsave %0" : "=m" (m_sse_save_region));
100 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBvoid\fP Thread::sleep (\fBsize_t\fP milliseconds)"

.PP
Sleeps the thread for a certain amount of time\&. 
.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP The amount of time to sleep for 
.RE
.PP

.PP
Definition at line \fB82\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
82                                       {
83 
84     // Update the state
85     thread_state = ThreadState::SLEEPING;
86     wakeup_time  = milliseconds;
87 }
.fi

.PP
References \fBthread_state\fP, and \fBwakeup_time\fP\&.
.SS "uintptr_t MaxOS::processes::Thread::tss_pointer () const\fC [inline]\fP"

.PP
Gets the stack pointer to use for the TSS when switching to this thread\&. 
.PP
\fBReturns\fP
.RS 4
tss 
.RE
.PP

.PP
Definition at line \fB73\fP of file \fBprocess\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBsystem::cpu_status_t\fP MaxOS::processes::Thread::execution_state"

.PP
The CPU state of the thread\&. 
.PP
Definition at line \fB67\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBsave_cpu_state()\fP, \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBThread()\fP, \fBMaxOS::processes::Scheduler::yield()\fP, and \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.
.SS "uint64_t MaxOS::processes::Thread::parent_pid"

.PP
The parent process ID\&. 
.PP
Definition at line \fB65\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::current_process()\fP, and \fBThread()\fP\&.
.SS "\fBthread_state_t\fP MaxOS::processes::Thread::thread_state"

.PP
The current state of the thread\&. 
.PP
Definition at line \fB68\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::remove_process()\fP, \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBsleep()\fP, \fBThread()\fP, and \fBMaxOS::processes::Scheduler::yield()\fP\&.
.SS "size_t MaxOS::processes::Thread::ticks"

.PP
The number of ticks the thread has run for\&. 
.PP
Definition at line \fB70\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule()\fP, and \fBThread()\fP\&.
.SS "uint64_t MaxOS::processes::Thread::tid"

.PP
The thread ID\&. 
.PP
Definition at line \fB64\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP, \fBMaxOS::processes::Scheduler::add_thread()\fP, \fBMaxOS::processes::Scheduler::force_remove_process()\fP, and \fBMaxOS::processes::Scheduler::get_thread()\fP\&.
.SS "size_t MaxOS::processes::Thread::wakeup_time"

.PP
The time at which the thread should wake up (if sleeping) 
.PP
Definition at line \fB71\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBsleep()\fP, and \fBThread()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

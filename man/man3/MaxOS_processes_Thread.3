.TH "MaxOS::processes::Thread" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Thread \- The execution context of a sub-process thread\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <process\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBThread\fP (\fBvoid\fP(*\fB_entry_point\fP)(\fBvoid\fP *), \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBProcess\fP *\fBparent\fP)"
.br
.RI "Constructor for the \fBThread\fP class\&. "
.ti -1c
.RI "\fB~Thread\fP ()"
.br
.RI "Destructor for the \fBThread\fP class\&. "
.ti -1c
.RI "\fBvoid\fP \fBsleep\fP (\fBsize_t\fP \fBmilliseconds\fP)"
.br
.RI "Sleeps the thread for a certain amount of time\&. "
.ti -1c
.RI "uintptr_t \fBtss_pointer\fP () const"
.br
.RI "Gets the stack pointer to use for the TSS when switching to this thread\&. "
.ti -1c
.RI "\fBvoid\fP \fBsave_sse_state\fP ()"
.br
.RI "Saves the SSE, x87 FPU, and MMX states from memory to the thread\&. "
.ti -1c
.RI "\fBvoid\fP \fBrestore_sse_state\fP ()"
.br
.RI "Restores the SSE, x87 FPU, and MMX states from the thread to memory\&. "
.ti -1c
.RI "\fBvoid\fP \fBsave_cpu_state\fP ()"
.br
.RI "Saves the CPU state into the thread's execution_state structure\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "uint64_t \fBtid\fP"
.br
.RI "The thread ID\&. "
.ti -1c
.RI "uint64_t \fBparent_pid\fP"
.br
.RI "The parent process ID\&. "
.ti -1c
.RI "system::cpu_status_t \fBexecution_state\fP"
.br
.RI "The CPU state of the thread\&. "
.ti -1c
.RI "thread_state_t \fBthread_state\fP"
.br
.RI "The current state of the thread\&. "
.ti -1c
.RI "size_t \fBticks\fP"
.br
.RI "The number of ticks the thread has run for\&. "
.ti -1c
.RI "size_t \fBwakeup_time\fP"
.br
.RI "The time at which the thread should wake up (if sleeping) "
.in -1c
.SH "Detailed Description"
.PP 
The execution context of a sub-process thread\&. 
.PP
Definition at line \fB47\fP of file \fBprocess\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Thread::Thread (\fBvoid\fP(*)(\fBvoid\fP *) _entry_point, \fBvoid\fP * args, \fBint\fP arg_amount, \fBProcess\fP * parent)"

.PP
Constructor for the \fBThread\fP class\&. 
.PP
Definition at line \fB21\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
21                                                                                         {
22 
23     // Basic setup
24     thread_state = ThreadState::NEW;
25     wakeup_time = 0;
26     ticks = 0;
27 
28     // Create the stack
29     m_stack_pointer = (uintptr_t) MemoryManager::malloc(STACK_SIZE);
30 
31     // Create the TSS stack
32     if (parent\->is_kernel) {
33 
34         // Use the kernel stack
35         m_tss_stack_pointer = CPU::executing_core() \-> tss\&.rsp0;
36 
37     } else {
38         m_tss_stack_pointer = (uintptr_t) MemoryManager::kmalloc(STACK_SIZE) + STACK_SIZE;
39     }
40 
41     // Mak sure there is a stack
42     ASSERT(m_stack_pointer != 0 && m_tss_stack_pointer != 0, "Failed to allocate stack for thread");
43 
44     // Set up the execution state
45     execution_state = {};
46     execution_state\&.rip = (uint64_t) _entry_point;
47     execution_state\&.ss = parent\->is_kernel ? 0x10 : 0x23;
48     execution_state\&.cs = parent\->is_kernel ? 0x8 : 0x1B;
49     execution_state\&.rflags = 0x202;
50     execution_state\&.interrupt_number = 0;
51     execution_state\&.error_code = 0;
52     execution_state\&.rsp = m_stack_pointer;
53     execution_state\&.rbp = 0;
54 
55     // Copy the args into userspace
56     uint64_t argc = arg_amount;
57     void* argv = MemoryManager::malloc(arg_amount * sizeof(void*));
58     memcpy(argv, args, arg_amount * sizeof(void*));
59 
60     execution_state\&.rdi = argc;
61     execution_state\&.rsi = (uint64_t) argv;
62     //execution_state\->rdx = (uint64_t)env_args;
63 
64     parent_pid = parent\->pid();
65 }
.fi

.PP
References \fBASSERT\fP, \fBMaxOS::system::CPU::executing_core()\fP, \fBexecution_state\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::memory::MemoryManager::malloc()\fP, \fBmemcpy()\fP, \fBparent_pid\fP, \fBthread_state\fP, \fBticks\fP, and \fBwakeup_time\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Thread::restore_sse_state ()"

.PP
Restores the SSE, x87 FPU, and MMX states from the thread to memory\&. 
.PP
Definition at line \fB100\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
100                                {
101 
102     // Ensure the state saving is enabled
103     if (!CPU::executing_core()\->xsave_enabled)
104         return;
105 
106     // Restore the state
107     asm volatile("fxrstor %0" : : "m" (m_sse_save_region));
108 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP\&.
.SS "\fBvoid\fP Thread::save_cpu_state ()"

.PP
Saves the CPU state into the thread's execution_state structure\&. 
.PP
Definition at line \fB113\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
113                             {
114     asm volatile(
115             // Store return address before stack is modified
116             "movq (%%rsp), %%rax\\n"
117 
118             // Store RDI before stack is modified
119             "pushq %%rdi\\n"
120             "movq %0, %%rdi\\n"
121 
122             // Store general purpose
123             "movq %%r15, 0x00(%%rdi)\\n"
124             "movq %%r14, 0x08(%%rdi)\\n"
125             "movq %%r13, 0x10(%%rdi)\\n"
126             "movq %%r12, 0x18(%%rdi)\\n"
127             "movq %%r11, 0x20(%%rdi)\\n"
128             "movq %%r10, 0x28(%%rdi)\\n"
129             "movq %%r9,  0x30(%%rdi)\\n"
130             "movq %%r8,  0x38(%%rdi)\\n"
131             "movq %%rdi, 0x40(%%rdi)\\n"
132             "movq %%rsi, 0x48(%%rdi)\\n"
133             "movq %%rbp, 0x50(%%rdi)\\n"
134             "movq %%rdx, 0x58(%%rdi)\\n"
135             "movq %%rcx, 0x60(%%rdi)\\n"
136             "movq %%rbx, 0x68(%%rdi)\\n"
137             "movq %%rax, 0x70(%%rdi)\\n"
138 
139             // Reserved
140             "movq $0,    0x78(%%rdi)\\n"
141             "movq $0,    0x80(%%rdi)\\n"
142 
143             // RIP from earlier
144             "movq %%rax, 0x88(%%rdi)\\n"
145 
146             // Get cs
147             "xorq %%rax, %%rax\\n"
148             "movw %%cs, %%ax\\n"
149             "movq %%rax, 0x90(%%rdi)\\n"
150 
151             // Store flags
152             "pushfq\\n"
153             "popq %%rax\\n"
154             "movq %%rax, 0x98(%%rdi)\\n"
155 
156             // Get RSP and SS
157             "movq %%rsp, 0xA0(%%rdi)\\n"
158             "xorq %%rax, %%rax\\n"
159             "movw %%ss, %%ax\\n"
160             "movq %%rax, 0xA8(%%rdi)\\n"
161 
162             // Restore RDI
163             "popq %%rdi\\n"
164             :
165             : "r" (&execution_state)
166             : "rax", "cc", "memory"
167             );
168 }
.fi

.PP
References \fBexecution_state\fP\&.
.SS "\fBvoid\fP Thread::save_sse_state ()"

.PP
Saves the SSE, x87 FPU, and MMX states from memory to the thread\&. 
.PP
Definition at line \fB87\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
87                             {
88 
89     // Ensure the state saving is enabled
90     if (!CPU::executing_core()\->xsave_enabled)
91         return;
92 
93     // Save the state
94     asm volatile("fxsave %0" : "=m" (m_sse_save_region));
95 }
.fi

.PP
References \fBMaxOS::system::CPU::executing_core()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBvoid\fP Thread::sleep (\fBsize_t\fP milliseconds)"

.PP
Sleeps the thread for a certain amount of time\&. 
.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP The amount of time to sleep for 
.RE
.PP

.PP
Definition at line \fB77\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
77                                       {
78 
79     // Update the state
80     thread_state = ThreadState::SLEEPING;
81     wakeup_time  = milliseconds;
82 }
.fi

.PP
References \fBthread_state\fP, and \fBwakeup_time\fP\&.
.SS "uintptr_t MaxOS::processes::Thread::tss_pointer () const\fC [inline]\fP"

.PP
Gets the stack pointer to use for the TSS when switching to this thread\&. 
.PP
Definition at line \fB71\fP of file \fBprocess\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "system::cpu_status_t MaxOS::processes::Thread::execution_state"

.PP
The CPU state of the thread\&. 
.PP
Definition at line \fB65\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBsave_cpu_state()\fP, \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBThread()\fP, \fBMaxOS::processes::Scheduler::yield()\fP, and \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.
.SS "uint64_t MaxOS::processes::Thread::parent_pid"

.PP
The parent process ID\&. 
.PP
Definition at line \fB63\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::current_process()\fP, and \fBThread()\fP\&.
.SS "thread_state_t MaxOS::processes::Thread::thread_state"

.PP
The current state of the thread\&. 
.PP
Definition at line \fB66\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::remove_process()\fP, \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBsleep()\fP, \fBThread()\fP, and \fBMaxOS::processes::Scheduler::yield()\fP\&.
.SS "size_t MaxOS::processes::Thread::ticks"

.PP
The number of ticks the thread has run for\&. 
.PP
Definition at line \fB68\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule()\fP, and \fBThread()\fP\&.
.SS "uint64_t MaxOS::processes::Thread::tid"

.PP
The thread ID\&. 
.PP
Definition at line \fB62\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP, \fBMaxOS::processes::Scheduler::add_thread()\fP, \fBMaxOS::processes::Scheduler::force_remove_process()\fP, and \fBMaxOS::processes::Scheduler::get_thread()\fP\&.
.SS "size_t MaxOS::processes::Thread::wakeup_time"

.PP
The time at which the thread should wake up (if sleeping) 
.PP
Definition at line \fB69\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::schedule_next()\fP, \fBsleep()\fP, and \fBThread()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

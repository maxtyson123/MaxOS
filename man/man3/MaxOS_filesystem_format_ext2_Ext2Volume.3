.TH "MaxOS::filesystem::format::ext2::Ext2Volume" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::filesystem::format::ext2::Ext2Volume \- Common operations for an ext2 volume that are used by both files & directories (like block & inode allocation)  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ext2\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBExt2Volume\fP (\fBdrivers::disk::Disk\fP *\fBdisk\fP, \fBlba_t\fP \fBpartition_offset\fP)"
.br
.RI "Construct a new Ext2 Volume object, reads the superblock and block group descriptors\&. "
.ti -1c
.RI "\fBvoid\fP \fBwrite_block\fP (\fBuint32_t\fP \fBblock_num\fP, \fBcommon::buffer_t\fP *buffer) \fBconst\fP"
.br
.RI "write a single block from a buffer into onto the disk "
.ti -1c
.RI "\fBvoid\fP \fBwrite_inode\fP (\fBuint32_t\fP \fBinode_num\fP, \fBinode_t\fP *inode) \fBconst\fP"
.br
.RI "write an inode to the filesystem "
.ti -1c
.RI "\fBuint32_t\fP \fBcreate_inode\fP (\fBbool\fP \fBis_directory\fP)"
.br
.RI "Allocates a new inode and sets the base metadata\&. Also allocates block 0 of the inode\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_inode\fP (\fBuint32_t\fP inode)"
.br
.RI "Mark an inode as free\&. Note: does NOT unallocated the inodes blocks, use free_group_blocks()\&. "
.ti -1c
.RI "\fBvoid\fP \fBread_block\fP (\fBuint32_t\fP \fBblock_num\fP, \fBcommon::buffer_t\fP *buffer) \fBconst\fP"
.br
.RI "Reads a single block from the disk into a buffer\&. "
.ti -1c
.RI "\fBinode_t\fP \fBread_inode\fP (\fBuint32_t\fP \fBinode_num\fP) \fBconst\fP"
.br
.RI "read an inode from the filesystem "
.ti -1c
.RI "\fBuint32_t\fP \fBallocate_block\fP ()"
.br
.RI "Allocates a single block to be used by an inode\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBuint32_t\fP > \fBallocate_blocks\fP (\fBuint32_t\fP \fBamount\fP)"
.br
.RI "Allocates a set of blocks to be used by an inode\&. "
.ti -1c
.RI "\fBuint32_t\fP \fBbytes_to_blocks\fP (\fBsize_t\fP \fBbytes\fP) \fBconst\fP"
.br
.RI "How many blocks are needed to contain a set amount of bytes\&. "
.ti -1c
.RI "\fBvoid\fP \fBfree_blocks\fP (\fBconst\fP \fBcommon::Vector\fP< \fBuint32_t\fP > &\fBblocks\fP)"
.br
.RI "Frees a group of blocks\&. Preferably with adjacent blocks apearing next to each other but not enforced\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBdrivers::disk::Disk\fP * \fBdisk\fP"
.br
.RI "The disk that this volume is on\&. "
.ti -1c
.RI "\fBlba_t\fP \fBpartition_offset\fP"
.br
.RI "How far into the disk this partition starts\&. "
.ti -1c
.RI "\fBsuperblock_t\fP \fBsuperblock\fP"
.br
.RI "The superblock of the ext2 filesystem\&. "
.ti -1c
.RI "\fBblock_group_descriptor_t\fP ** \fBblock_groups\fP"
.br
.RI "The block group descriptors\&. "
.ti -1c
.RI "size_t \fBblock_size\fP"
.br
.RI "How large each block is (in bytes) "
.ti -1c
.RI "uint32_t \fBblock_group_descriptor_table_block\fP"
.br
.RI "Where the block group descriptor table starts\&. "
.ti -1c
.RI "uint32_t \fBblock_group_descriptor_table_size\fP"
.br
.RI "How many block groups are in the block group descriptor table\&. "
.ti -1c
.RI "uint32_t \fBtotal_block_groups\fP"
.br
.RI "How many block groups are in the filesystem\&. "
.ti -1c
.RI "size_t \fBpointers_per_block\fP"
.br
.RI "How many block pointers fit in a block\&. "
.ti -1c
.RI "uint32_t \fBinodes_per_block\fP"
.br
.RI "How many inodes fit in a block\&. "
.ti -1c
.RI "uint32_t \fBsectors_per_block\fP"
.br
.RI "How many sectors does a block take\&. "
.ti -1c
.RI "\fBcommon::Spinlock\fP \fBext2_lock\fP"
.br
.RI "Lock for synchronised access to the volume (\&. "
.in -1c
.SH "Detailed Description"
.PP 
Common operations for an ext2 volume that are used by both files & directories (like block & inode allocation) 


.PP
\fBTodo\fP
.RS 4
Free blocks 
.RE
.PP

.PP
Definition at line \fB322\fP of file \fBext2\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Ext2Volume::Ext2Volume (\fBdrivers::disk::Disk\fP * disk, \fBlba_t\fP partition_offset)"

.PP
Construct a new Ext2 Volume object, reads the superblock and block group descriptors\&. 
.PP
\fBParameters\fP
.RS 4
\fIdisk\fP The disk to read from 
.br
\fIpartition_offset\fP The offset of the partition on the disk in sectors
.RE
.PP
\fBTodo\fP
.RS 4
Should lock per file and not expose volume lock 
.RE
.PP

.PP
Definition at line \fB27\fP of file \fBext2\&.cpp\fP\&..PP
.nf
28 : disk(disk),
29   partition_offset(partition_offset),
30   superblock({})
31 {
32 
33     // Read superblock
34     buffer_t superblock_buffer(&superblock, 1024);
35     disk\->read(partition_offset + 2, &superblock_buffer, 512);
36     disk\->read(partition_offset + 3, &superblock_buffer, 512);
37 
38     // Validate signature
39     ASSERT(superblock\&.signature == 0xEF53, "Ext2 Filesystem doesnt have a valid signature\\n");
40 
41     // Version 0 has constant inode info
42     if(superblock\&.version_major < 1) {
43         superblock\&.first_inode = 11;
44         superblock\&.inode_size = 128;
45     }
46 
47     // Parse the superblock
48     block_size = 1024 << superblock\&.block_size;
49     total_block_groups = (superblock\&.total_blocks + superblock\&.blocks_per_group \- 1) / superblock\&.blocks_per_group;
50     block_group_descriptor_table_block = superblock\&.starting_block + 1;
51     block_group_descriptor_table_size = total_block_groups * sizeof(block_group_descriptor_t);
52     pointers_per_block = block_size / sizeof(uint32_t);
53     inodes_per_block = block_size / superblock\&.inode_size;
54     sectors_per_block = block_size / 512;
55 
56     // Read the block groups
57     block_groups = new block_group_descriptor_t* [total_block_groups] { nullptr };
58     uint32_t bgdt_lba = partition_offset + block_group_descriptor_table_block * sectors_per_block;
59     uint32_t sectors_to_read = (block_group_descriptor_table_size + block_size \- 1) / block_size * sectors_per_block;
60     buffer_t bg_buffer(sectors_to_read * 512);
61     for(uint32_t i = 0; i < sectors_to_read; ++i)
62         disk\->read(bgdt_lba + i, &bg_buffer, 512);
63 
64     // Store the block groups
65     for(uint32_t i = 0; i < total_block_groups; ++i) {
66         block_groups[i] = new block_group_descriptor_t;
67         memcpy(block_groups[i], bg_buffer\&.raw() + i * sizeof(block_group_descriptor_t),
68                sizeof(block_group_descriptor_t));
69     }
70 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP Ext2Volume::allocate_block ()"

.PP
Allocates a single block to be used by an inode\&. 
.PP
\fBReturns\fP
.RS 4
The new block number or 0 if the allocation failed 
.RE
.PP

.PP
Definition at line \fB177\fP of file \fBext2\&.cpp\fP\&..PP
.nf
177                                     {
178 
179     return allocate_blocks(1)[0];
180 }
.fi

.PP
References \fBallocate_blocks()\fP\&.
.PP
Referenced by \fBcreate_inode()\fP\&.
.SS "\fBVector\fP< \fBuint32_t\fP > Ext2Volume::allocate_blocks (\fBuint32_t\fP amount)"

.PP
Allocates a set of blocks to be used by an inode\&. 
.PP
\fBParameters\fP
.RS 4
\fIamount\fP The amount of blocks to allocate 
.RE
.PP
\fBReturns\fP
.RS 4
A list of the allocated blocks or [0] if the allocation failed 
.RE
.PP

.PP
Definition at line \fB188\fP of file \fBext2\&.cpp\fP\&..PP
.nf
188                                                             {
189 
190     // No blocks to allocate
191     if(!amount)
192         return { 1, 0 };
193 
194     // Find the block group with enough free blocks
195     block_group_descriptor_t* block_group = block_groups[0];
196     for(uint32_t bg_index = 0; bg_index < total_block_groups; block_group = block_groups[++bg_index])
197         if(block_group\->free_blocks >= amount)
198             return allocate_group_blocks(bg_index, amount);
199 
200     // No block group can contain the block so split across multiple
201     Vector<uint32_t> result { };
202     while(amount > 0) {
203 
204         // Find the block group with most free blocks
205         block_group = block_groups[0];
206         uint32_t bg_index = 0;
207         for(; bg_index < total_block_groups; ++bg_index)
208             if(block_groups[bg_index]\->free_blocks > block_group\->free_blocks)
209                 block_group = block_groups[bg_index];
210 
211         // No space
212         if(block_group\->free_blocks == 0)
213             return { 1, 0 };
214 
215         // Allocate the remaining blocks
216         auto allocated = allocate_group_blocks(bg_index, 1);
217         amount \-= allocated\&.size();
218         for(auto block : allocated)
219             result\&.push_back(block);
220     }
221 
222     return result;
223 }
.fi

.PP
References \fBblock_groups\fP, \fBfree_blocks()\fP, and \fBtotal_block_groups\fP\&.
.PP
Referenced by \fBallocate_block()\fP, and \fBMaxOS::filesystem::format::ext2::InodeHandler::grow()\fP\&.
.SS "\fBuint32_t\fP Ext2Volume::bytes_to_blocks (\fBsize_t\fP bytes) const"

.PP
How many blocks are needed to contain a set amount of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIbytes\fP Bytes needed 
.RE
.PP
\fBReturns\fP
.RS 4
The blocks required 
.RE
.PP

.PP
Definition at line \fB360\fP of file \fBext2\&.cpp\fP\&..PP
.nf
360                                                        {
361     return (bytes + block_size \- 1) / block_size;
362 }
.fi

.PP
References \fBblock_size\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::ext2::InodeHandler::grow()\fP\&.
.SS "\fBuint32_t\fP Ext2Volume::create_inode (\fBbool\fP is_directory)"

.PP
Allocates a new inode and sets the base metadata\&. Also allocates block 0 of the inode\&. 
.PP
\fBParameters\fP
.RS 4
\fIis_directory\fP is the inode to be used for a directory 
.RE
.PP
\fBReturns\fP
.RS 4
The new inode 
.RE
.PP

.PP
Definition at line \fB370\fP of file \fBext2\&.cpp\fP\&..PP
.nf
370                                                    {
371 
372     ext2_lock\&.lock();
373 
374     // Find the block group with enough free inodes
375     block_group_descriptor_t* block_group = block_groups[0];
376     uint32_t bg_index = 0;
377     for(; bg_index < total_block_groups; block_group = block_groups[++bg_index])
378         if(block_group\->free_inodes >= 1)
379             break;
380 
381     // Read bitmap
382     buffer_t bitmap(block_size);
383     read_block(block_group\->block_inode_bitmap, &bitmap);
384 
385     // First group contains reserved inodes
386     uint32_t inode_index = 0;
387     if(bg_index == 0 && superblock\&.first_inode > 1)
388         inode_index = superblock\&.first_inode \- 1;
389 
390     // Find a free inode
391     for(; inode_index < superblock\&.inodes_per_group; ++inode_index) {
392 
393         // Block is already used
394         if((bitmap\&.raw()[inode_index / 8] & (1u << (inode_index % 8))) != 0)
395             continue;
396 
397         // Mark as used
398         block_group\->free_inodes\-\-;
399         superblock\&.unallocated_inodes\-\-;
400         bitmap\&.raw()[inode_index / 8] |= (uint8_t) (1u << (inode_index % 8));
401 
402         break;
403     }
404 
405     // Convert into the 1\-based inode index in the group
406     inode_index += bg_index * superblock\&.inodes_per_group + 1;
407 
408     // Save the changed metadata
409     write_block(block_group\->block_inode_bitmap, &bitmap);
410     write_back_block_groups();
411     write_back_superblock();
412 
413     // Create the inode
414     inode_t inode { };
415     inode\&.creation_time = time_to_epoch(Clock::active_clock()\->get_time());
416     inode\&.last_modification_time = time_to_epoch(Clock::active_clock()\->get_time());
417     inode\&.block_pointers[0] = allocate_block();
418     inode\&.hard_links = is_directory ? 2 : 1;
419     inode\&.type = ((uint16_t) (is_directory ? InodeType::DIRECTORY : InodeType::FILE) >> 12) & 0xF;
420     inode\&.permissions =
421             (uint16_t) (is_directory ? InodePermissionsDefaults::DIRECTORY : InodePermissionsDefaults::FILE) & 0x0FFF;
422     write_inode(inode_index, &inode);
423 
424     ext2_lock\&.unlock();
425     return inode_index;
426 }
.fi

.PP
References \fBMaxOS::drivers::clock::Clock::active_clock()\fP, \fBallocate_block()\fP, \fBblock_groups\fP, \fBblock_size\fP, \fBext2_lock\fP, \fBMaxOS::common::Spinlock::lock()\fP, \fBread_block()\fP, \fBsuperblock\fP, \fBtotal_block_groups\fP, \fBMaxOS::common::Spinlock::unlock()\fP, \fBwrite_block()\fP, and \fBwrite_inode()\fP\&.
.SS "\fBvoid\fP Ext2Volume::free_blocks (\fBconst\fP \fBcommon::Vector\fP< \fBuint32_t\fP > & blocks)"

.PP
Frees a group of blocks\&. Preferably with adjacent blocks apearing next to each other but not enforced\&. 
.PP
\fBParameters\fP
.RS 4
\fIblocks\fP The blocks to free 
.RE
.PP

.PP
Definition at line \fB464\fP of file \fBext2\&.cpp\fP\&..PP
.nf
464                                                                  {
465 
466     // No blocks to free
467     if(blocks\&.empty())
468         return;
469 
470     uint32_t start = blocks[0];
471     uint32_t previous = start;
472     uint32_t amount = 1;
473 
474     // Free each adjacent set of blocks
475     for(auto& block : blocks) {
476 
477         // First is already accounted for
478         if(block == start)
479             continue;
480 
481         // Is this block adjacent
482         if((previous + 1) == block) {
483             previous = block;
484             amount += 1;
485             continue;
486         }
487 
488         // Adjacent set has ended
489         uint32_t group = (start \- superblock\&.starting_block) / superblock\&.blocks_per_group;
490         free_group_blocks(group, amount, start);
491 
492         // Reset
493         start = block;
494         previous = start;
495         amount = 1;
496     }
497 
498     // Account for the last set of blocks in the loop
499     uint32_t group = (start \- superblock\&.starting_block) / superblock\&.blocks_per_group;
500     free_group_blocks(group, amount, start);
501 }
.fi

.PP
References \fBsuperblock\fP\&.
.PP
Referenced by \fBallocate_blocks()\fP, and \fBMaxOS::filesystem::format::ext2::InodeHandler::free()\fP\&.
.SS "\fBvoid\fP Ext2Volume::free_inode (\fBuint32_t\fP inode)"

.PP
Mark an inode as free\&. Note: does NOT unallocated the inodes blocks, use free_group_blocks()\&. 
.PP
\fBSee also\fP
.RS 4
free_group_blocks
.RE
.PP
\fBParameters\fP
.RS 4
\fIinode\fP The inode number to mark as free 
.RE
.PP

.PP
Definition at line \fB434\fP of file \fBext2\&.cpp\fP\&..PP
.nf
434                                           {
435 
436     // Find the block group containing the inode
437     uint32_t bg_index = (inode \- 1) / superblock\&.inodes_per_group;
438     block_group_descriptor_t* block_group = block_groups[bg_index];
439 
440     // Read bitmap
441     buffer_t bitmap(block_size);
442     read_block(block_group\->block_inode_bitmap, &bitmap);
443 
444     // First group contains reserved inodes
445     uint32_t inode_index = (inode \- 1) % superblock\&.inodes_per_group;
446     if(bg_index == 0 && (inode_index < (superblock\&.first_inode \- 1)))
447         return;
448 
449     // Mark as used
450     block_group\->free_inodes++;
451     superblock\&.unallocated_inodes++;
452     bitmap\&.raw()[inode_index / 8] &= (uint8_t) ~(1u << (inode_index % 8));
453 
454     // Save the changed metadata
455     write_block(block_group\->block_inode_bitmap, &bitmap);
456     write_back_block_groups();
457     write_back_superblock();
458 }
.fi

.PP
References \fBblock_groups\fP, \fBblock_size\fP, \fBread_block()\fP, \fBsuperblock\fP, and \fBwrite_block()\fP\&.
.PP
Referenced by \fBMaxOS::filesystem::format::ext2::InodeHandler::free()\fP\&.
.SS "\fBvoid\fP Ext2Volume::read_block (\fBuint32_t\fP block_num, \fBcommon::buffer_t\fP * buffer) const"

.PP
Reads a single block from the disk into a buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIblock_num\fP The block to read 
.br
\fIbuffer\fP The buffer to read into 
.RE
.PP

.PP
Definition at line \fB129\fP of file \fBext2\&.cpp\fP\&..PP
.nf
129                                                                       {
130 
131     // Ensure the buffer is in the right format
132     buffer\->set_offset(0);
133 
134     // Read each sector of the block
135     for(size_t i = 0; i < sectors_per_block; ++i)
136         disk\->read(partition_offset + block_num * sectors_per_block + i, buffer, 512);
137 
138     // Reset buffer
139     buffer\->set_offset(0);
140 
141 }
.fi

.PP
References \fBdisk\fP, \fBpartition_offset\fP, \fBMaxOS::drivers::disk::Disk::read()\fP, \fBsectors_per_block\fP, and \fBMaxOS::common::Buffer::set_offset()\fP\&.
.PP
Referenced by \fBcreate_inode()\fP, \fBfree_inode()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::read()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, \fBread_inode()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP, and \fBwrite_inode()\fP\&.
.SS "\fBinode_t\fP Ext2Volume::read_inode (\fBuint32_t\fP inode_num) const"

.PP
read an inode from the filesystem 
.PP
\fBParameters\fP
.RS 4
\fIinode_num\fP The inode index 
.RE
.PP
\fBReturns\fP
.RS 4
The inode read 
.RE
.PP

.PP
Definition at line \fB149\fP of file \fBext2\&.cpp\fP\&..PP
.nf
149                                                        {
150 
151     inode_t inode;
152 
153     // Locate the inode
154     uint32_t group = (inode_num \- 1) / superblock\&.inodes_per_group;
155     uint32_t index = (inode_num \- 1) % superblock\&.inodes_per_group;
156 
157     // Locate the block
158     uint32_t inode_table = block_groups[group]\->inode_table_address;
159     uint32_t offset = index * superblock\&.inode_size;
160     uint32_t block = offset / block_size;
161     uint32_t in_block_offset = offset % block_size;
162 
163     // Read the block
164     buffer_t buffer(block_size);
165     read_block(inode_table + block, &buffer);
166 
167     // Read the inode from the block
168     buffer\&.copy_to(&inode, sizeof(inode_t), in_block_offset);
169     return inode;
170 }
.fi

.PP
References \fBblock_groups\fP, \fBblock_size\fP, \fBMaxOS::common::Buffer::copy_to()\fP, \fBread_block()\fP, and \fBsuperblock\fP\&.
.SS "\fBvoid\fP Ext2Volume::write_block (\fBuint32_t\fP block_num, \fBcommon::buffer_t\fP * buffer) const"

.PP
write a single block from a buffer into onto the disk 
.PP
\fBParameters\fP
.RS 4
\fIblock_num\fP The block to update 
.br
\fIbuffer\fP The buffer to read from 
.RE
.PP

.PP
Definition at line \fB80\fP of file \fBext2\&.cpp\fP\&..PP
.nf
80                                                                        {
81 
82     // Ensure the buffer is in the right format
83     buffer\->set_offset(0);
84     bool old = buffer\->update_offset;
85     buffer\->update_offset = true;
86 
87     // Read each sector of the block
88     for(size_t i = 0; i < sectors_per_block; ++i)
89         disk\->write(partition_offset + block_num * sectors_per_block + i, buffer, 512);
90 
91     // Reset buffer
92     buffer\->set_offset(0);
93     buffer\->update_offset = old;
94 }
.fi

.PP
References \fBdisk\fP, \fBpartition_offset\fP, \fBsectors_per_block\fP, \fBMaxOS::common::Buffer::set_offset()\fP, \fBMaxOS::common::Buffer::update_offset\fP, and \fBMaxOS::drivers::disk::Disk::write()\fP\&.
.PP
Referenced by \fBcreate_inode()\fP, \fBfree_inode()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP, and \fBwrite_inode()\fP\&.
.SS "\fBvoid\fP Ext2Volume::write_inode (\fBuint32_t\fP inode_num, \fBinode_t\fP * inode) const"

.PP
write an inode to the filesystem 
.PP
\fBParameters\fP
.RS 4
\fIinode_num\fP The inode index 
.br
\fIinode\fP The inode to read from 
.RE
.PP

.PP
Definition at line \fB102\fP of file \fBext2\&.cpp\fP\&..PP
.nf
102                                                                      {
103 
104     // Locate the inode
105     uint32_t group = (inode_num \- 1) / superblock\&.inodes_per_group;
106     uint32_t index = (inode_num \- 1) % superblock\&.inodes_per_group;
107 
108     // Locate the block
109     uint32_t inode_table = block_groups[group]\->inode_table_address;
110     uint32_t offset = index * superblock\&.inode_size;
111     uint32_t block = offset / block_size;
112     uint32_t in_block_offset = offset % block_size;
113 
114     // Read the inode
115     buffer_t buffer(block_size);
116     read_block(inode_table + block, &buffer);
117     buffer\&.copy_from(inode, sizeof(inode_t), in_block_offset);
118 
119     // Modify the block
120     write_block(inode_table + block, &buffer);
121 }
.fi

.PP
References \fBblock_groups\fP, \fBblock_size\fP, \fBMaxOS::common::Buffer::copy_from()\fP, \fBread_block()\fP, \fBsuperblock\fP, and \fBwrite_block()\fP\&.
.PP
Referenced by \fBcreate_inode()\fP, and \fBMaxOS::filesystem::format::ext2::InodeHandler::save()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "uint32_t MaxOS::filesystem::format::ext2::Ext2Volume::block_group_descriptor_table_block"

.PP
Where the block group descriptor table starts\&. 
.PP
Definition at line \fB343\fP of file \fBext2\&.h\fP\&.
.SS "uint32_t MaxOS::filesystem::format::ext2::Ext2Volume::block_group_descriptor_table_size"

.PP
How many block groups are in the block group descriptor table\&. 
.PP
Definition at line \fB344\fP of file \fBext2\&.h\fP\&.
.SS "\fBblock_group_descriptor_t\fP** MaxOS::filesystem::format::ext2::Ext2Volume::block_groups"

.PP
The block group descriptors\&. 
.PP
Definition at line \fB340\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBallocate_blocks()\fP, \fBcreate_inode()\fP, \fBfree_inode()\fP, \fBread_inode()\fP, and \fBwrite_inode()\fP\&.
.SS "size_t MaxOS::filesystem::format::ext2::Ext2Volume::block_size"

.PP
How large each block is (in bytes) 
.PP
Definition at line \fB342\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBbytes_to_blocks()\fP, \fBcreate_inode()\fP, \fBfree_inode()\fP, \fBMaxOS::filesystem::format::ext2::InodeHandler::InodeHandler()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::read()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, \fBread_inode()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP, and \fBwrite_inode()\fP\&.
.SS "\fBdrivers::disk::Disk\fP* MaxOS::filesystem::format::ext2::Ext2Volume::disk"

.PP
The disk that this volume is on\&. 
.PP
Definition at line \fB336\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBread_block()\fP, and \fBwrite_block()\fP\&.
.SS "\fBcommon::Spinlock\fP MaxOS::filesystem::format::ext2::Ext2Volume::ext2_lock"

.PP
Lock for synchronised access to the volume (\&. 
.PP
\fBTodo\fP
.RS 4
: remove public?) 
.RE
.PP

.PP
Definition at line \fB350\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBcreate_inode()\fP, \fBMaxOS::filesystem::format::ext2::InodeHandler::free()\fP, \fBMaxOS::filesystem::format::ext2::Ext2File::read()\fP, \fBMaxOS::filesystem::format::ext2::Ext2Directory::read_from_disk()\fP, and \fBMaxOS::filesystem::format::ext2::Ext2File::write()\fP\&.
.SS "uint32_t MaxOS::filesystem::format::ext2::Ext2Volume::inodes_per_block"

.PP
How many inodes fit in a block\&. 
.PP
Definition at line \fB347\fP of file \fBext2\&.h\fP\&.
.SS "\fBlba_t\fP MaxOS::filesystem::format::ext2::Ext2Volume::partition_offset"

.PP
How far into the disk this partition starts\&. 
.PP
Definition at line \fB337\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBread_block()\fP, and \fBwrite_block()\fP\&.
.SS "size_t MaxOS::filesystem::format::ext2::Ext2Volume::pointers_per_block"

.PP
How many block pointers fit in a block\&. 
.PP
Definition at line \fB346\fP of file \fBext2\&.h\fP\&.
.SS "uint32_t MaxOS::filesystem::format::ext2::Ext2Volume::sectors_per_block"

.PP
How many sectors does a block take\&. 
.PP
Definition at line \fB348\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBread_block()\fP, and \fBwrite_block()\fP\&.
.SS "\fBsuperblock_t\fP MaxOS::filesystem::format::ext2::Ext2Volume::superblock"

.PP
The superblock of the ext2 filesystem\&. 
.PP
Definition at line \fB339\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBcreate_inode()\fP, \fBfree_blocks()\fP, \fBfree_inode()\fP, \fBread_inode()\fP, and \fBwrite_inode()\fP\&.
.SS "uint32_t MaxOS::filesystem::format::ext2::Ext2Volume::total_block_groups"

.PP
How many block groups are in the filesystem\&. 
.PP
Definition at line \fB345\fP of file \fBext2\&.h\fP\&.
.PP
Referenced by \fBallocate_blocks()\fP, and \fBcreate_inode()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

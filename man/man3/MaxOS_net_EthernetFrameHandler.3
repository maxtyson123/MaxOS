.TH "MaxOS::net::EthernetFrameHandler" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::EthernetFrameHandler \- Handles incoming Ethernet Frames and routes them to the appropriate payload handlers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ethernetframe\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP (\fBdrivers::ethernet::EthernetDriver\fP *\fBdriver\fP, \fBcommon::OutputStream\fP *\fBerror_messages\fP)"
.br
.RI "Construct a new Ether Frame Handler object\&. "
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBget_mac\fP ()"
.br
.RI "Get the MAC address of this device\&. "
.ti -1c
.RI "\fBbool\fP \fBdata_received\fP (\fBuint8_t\fP *data, \fBuint32_t\fP size) \fBoverride\fP"
.br
.RI "Handle the received packet\&. "
.ti -1c
.RI "\fBvoid\fP \fBconnect_handler\fP (\fBEthernetFramePayloadHandler\fP *\fBhandler\fP)"
.br
.RI "connect a handler to the frame handler "
.ti -1c
.RI "\fBvoid\fP \fBsend_ethernet_frame\fP (\fBuint64_t\fP destination_mac, \fBuint16_t\fP \fBframe_type\fP, \fBuint8_t\fP *data, \fBuint32_t\fP size)"
.br
.RI "send an packet via the backend driver "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetDriverEventHandler\fP ()"
.br
.RI "__EVENT HANDLER___ "
.ti -1c
.RI "\fBcommon::Event\fP< \fBEthernetDriverEvents\fP > * \fBon_event\fP (\fBcommon::Event\fP< \fBEthernetDriverEvents\fP > *\fBevent\fP) \fBoverride\fP"
.br
.RI "Handle an event\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBbefore_send\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size)"
.br
.RI "Handle before send event\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdata_sent\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP size)"
.br
.RI "Handle data sent event\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventHandler< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBvirtual\fP \fBEvent\fP< EthernetDriverEvents > * \fBon_event\fP (\fBEvent\fP< EthernetDriverEvents > *\fBevent\fP)"
.br
.RI "This function is called when an event is raised\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint16_t, \fBEthernetFramePayloadHandler\fP * > \fBframe_handlers\fP"
.br
.RI "The map of frame handlers by type\&. "
.ti -1c
.RI "\fBdrivers::ethernet::EthernetDriver\fP * \fBethernet_driver\fP"
.br
.RI "The driver this frame handler is using\&. "
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerror_messages\fP"
.br
.RI "The output stream for error messages\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles incoming Ethernet Frames and routes them to the appropriate payload handlers\&. 
.PP
Definition at line \fB76\fP of file \fBethernetframe\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "EthernetFrameHandler::EthernetFrameHandler (\fBdrivers::ethernet::EthernetDriver\fP * driver, \fBcommon::OutputStream\fP * error_messages)"

.PP
Construct a new Ether Frame Handler object\&. 
.PP
\fBParameters\fP
.RS 4
\fIdriver\fP The backend ethernet driver 
.br
\fIerror_messages\fP The output stream for error messages 
.RE
.PP

.PP
Definition at line \fB73\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
74         : EthernetDriverEventHandler() {
75 
76     this\->ethernet_driver = driver;
77     this\->error_messages = error_messages;
78 
79     driver\->connect_event_handler(this);
80 
81 }
.fi

.PP
References \fBerror_messages\fP, and \fBethernet_driver\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP EthernetFrameHandler::connect_handler (\fBEthernetFramePayloadHandler\fP * handler)"

.PP
connect a handler to the frame handler 
.PP
\fBParameters\fP
.RS 4
\fIhandler\fP The handler to connect 
.RE
.PP

.PP
Definition at line \fB164\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
164                                                                                {
165 
166     // Convert the protocol type to big endian
167     uint16_t frame_type_be = ((handler\->handled_type >> 8) & 0xFF) | ((handler\->handled_type << 8) & 0xFF00);
168 
169     // Add the handler to the list
170     frame_handlers\&.insert(frame_type_be, handler);
171 
172 }
.fi

.PP
References \fBframe_handlers\fP\&.
.PP
Referenced by \fBMaxOS::net::EthernetFramePayloadHandler::EthernetFramePayloadHandler()\fP\&.
.SS "\fBbool\fP EthernetFrameHandler::data_received (\fBuint8_t\fP * buffer, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle the received packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP the buffer with the received data 
.br
\fIsize\fP the size of the received data 
.RE
.PP
\fBReturns\fP
.RS 4
True if the data is to be sent back, false otherwise
.RE
.PP
\fBTodo\fP
.RS 4
Future debugging me: the override is not being called in derived classes 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP\&.
.PP
Definition at line \fB104\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
104                                                                        {
105 
106     error_messages\->write("EFH: Data received\\n");
107 
108 
109     //Check if the size is big enough to contain an ethernet frame
110     if(size < sizeof(EthernetFrameHeader))
111         return false;
112 
113     //Convert to struct for easier use
114     auto* frame = (EthernetFrameHeader*) buffer;
115     bool send_back = false;
116 
117     //Only handle if it is for this device
118     if(frame\->destination_mac == 0xFFFFFFFFFFFF                                          //If it is a broadcast
119        || frame\->destination_mac == ethernet_driver\->get_media_access_control_address())      //If it is for this device
120     {
121 
122         // Find the handler for the protocol
123         Map<uint16_t, EthernetFramePayloadHandler*>::iterator handler_iterator = frame_handlers\&.find(frame\->type);
124 
125         // If the handler is found
126         if(handler_iterator != frame_handlers\&.end()) {
127 
128             //Handle the data
129             error_messages\->write("EFH: Handling ethernet frame payload\\n");
130             send_back = handler_iterator\->second\->handle_ethernetframe_payload(buffer + sizeof(EthernetFrameHeader),
131                                                                                size \- sizeof(EthernetFrameHeader));
132             error_messages\->write("\&.\&.DONE\\n");
133 
134         } else {
135 
136             //If the handler is not found, print an error message
137             error_messages\->write("EFH: Unhandled ethernet frame type 0x");
138             error_messages\->write_hex(frame\->type);
139             error_messages\->write("\\n");
140 
141         }
142     }
143 
144     //If the data is to be sent back again
145     if(send_back) {
146 
147         error_messages\->write("EFH: Sending back\\n");
148 
149         frame\->destination_mac = frame\->source_mac;                             //Set the new destination to be the device the data was received from
150         frame\->source_mac = ethernet_driver\->get_media_access_control_address();      //Set the new source to be this device's MAC address
151 
152     }
153 
154     //Return if the data is to be sent back
155     return send_back;
156 
157 }
.fi

.PP
References \fBerror_messages\fP, \fBethernet_driver\fP, \fBframe_handlers\fP, \fBMaxOS::drivers::ethernet::EthernetDriver::get_media_access_control_address()\fP, \fBMaxOS::common::OutputStream::write()\fP, and \fBMaxOS::common::OutputStream::write_hex()\fP\&.
.SS "\fBdrivers::ethernet::MediaAccessControlAddress\fP EthernetFrameHandler::get_mac ()"

.PP
Get the MAC address of this device\&. 
.PP
\fBReturns\fP
.RS 4
MediaAccessControlAddress The MAC address 
.RE
.PP

.PP
Definition at line \fB90\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
90                                                                        {
91     return ethernet_driver\->get_media_access_control_address();
92 }
.fi

.PP
References \fBethernet_driver\fP, and \fBMaxOS::drivers::ethernet::EthernetDriver::get_media_access_control_address()\fP\&.
.PP
Referenced by \fBMaxOS::net::InternetProtocolHandler::get_media_access_control_address()\fP, and \fBMaxOS::net::AddressResolutionProtocol::request_mac_address()\fP\&.
.SS "\fBvoid\fP EthernetFrameHandler::send_ethernet_frame (\fBuint64_t\fP destination_mac, \fBuint16_t\fP frame_type, \fBuint8_t\fP * data, \fBuint32_t\fP size)"

.PP
send an packet via the backend driver 
.PP
\fBParameters\fP
.RS 4
\fIdestination_mac\fP the destination MAC address 
.br
\fIframe_type\fP the type of the protocol 
.br
\fIdata\fP the data to send 
.br
\fIsize\fP the size of the payload 
.RE
.PP

.PP
Definition at line \fB182\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
182                                                                                                                           {
183 
184     error_messages\->write("EFH: Sending frame\&.\&.\&.");
185 
186     //Allocate memory for the buffer
187     auto* buffer = (uint8_t*) MemoryManager::kmalloc(size + sizeof(EthernetFrameHeader));
188     auto* frame = (EthernetFrameHeader*) buffer;
189 
190     //Put data in the header
191     frame\->destination_mac = destination_mac;
192     frame\->source_mac = ethernet_driver\->get_media_access_control_address();
193     frame\->type = (frame_type >> 8) | (frame_type << 8);                        //Convert to big endian
194 
195     //Copy the data
196     for(uint8_t* src = data + size \- 1, * dst = buffer + sizeof(EthernetFrameHeader) + size \- 1; src >= data; \-\-src, \-\-dst)
197         *dst = *src;
198 
199     //Send the data
200     ethernet_driver\->send(buffer, size + sizeof(EthernetFrameHeader));
201 
202     error_messages\->write("Done\\n");
203 
204 
205     //Free the buffer
206     MemoryManager::kfree(buffer);
207 }
.fi

.PP
References \fBerror_messages\fP, \fBethernet_driver\fP, \fBMaxOS::drivers::ethernet::EthernetDriver::get_media_access_control_address()\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::drivers::ethernet::EthernetDriver::send()\fP, and \fBMaxOS::common::OutputStream::write()\fP\&.
.PP
Referenced by \fBMaxOS::net::EthernetFramePayloadHandler::send()\fP, and \fBMaxOS::net::InternetProtocolHandler::send_internet_protocol_packet()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* MaxOS::net::EthernetFrameHandler::error_messages\fC [protected]\fP"

.PP
The output stream for error messages\&. 
.PP
Definition at line \fB82\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBdata_received()\fP, \fBEthernetFrameHandler()\fP, and \fBsend_ethernet_frame()\fP\&.
.SS "\fBdrivers::ethernet::EthernetDriver\fP* MaxOS::net::EthernetFrameHandler::ethernet_driver\fC [protected]\fP"

.PP
The driver this frame handler is using\&. 
.PP
Definition at line \fB81\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBdata_received()\fP, \fBEthernetFrameHandler()\fP, \fBget_mac()\fP, and \fBsend_ethernet_frame()\fP\&.
.SS "\fBcommon::Map\fP<uint16_t, \fBEthernetFramePayloadHandler\fP*> MaxOS::net::EthernetFrameHandler::frame_handlers\fC [protected]\fP"

.PP
The map of frame handlers by type\&. 
.PP
Definition at line \fB79\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBconnect_handler()\fP, and \fBdata_received()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::net::EthernetFrameHandler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::EthernetFrameHandler
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ethernetframe\&.h>\fP
.PP
Inherits \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEthernetFrameHandler\fP (\fBdrivers::ethernet::EthernetDriver\fP *\fBethernetDriver\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.ti -1c
.RI "\fB~EthernetFrameHandler\fP ()"
.br
.ti -1c
.RI "\fBdrivers::ethernet::MediaAccessControlAddress\fP \fBgetMAC\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBDataReceived\fP (\fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP) \fBoverride\fP"
.br
.RI "Handle the received packet\&. "
.ti -1c
.RI "\fBvoid\fP \fBconnectHandler\fP (\fBEthernetFramePayloadHandler\fP *\fBhandler\fP)"
.br
.ti -1c
.RI "\fBvoid\fP \fBsendEthernetFrame\fP (\fBuint64_t\fP \fBdestinationMAC\fP, \fBuint16_t\fP \fBframeType\fP, \fBuint8_t\fP *\fBdata\fP, \fBuint32_t\fP \fBsize\fP)"
.br
.RI "Send an packet via the backend driver\&. "
.in -1c

Public Member Functions inherited from \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP
.in +1c
.ti -1c
.RI "\fBEthernetDriverEventHandler\fP ()"
.br
.RI "__EVENT HANDLER___ "
.ti -1c
.RI "\fB~EthernetDriverEventHandler\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBcommon::Event\fP< \fBEthernetDriverEvents\fP > * \fBon_event\fP (\fBcommon::Event\fP< \fBEthernetDriverEvents\fP > *\fBevent\fP) \fBoverride\fP"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBBeforeSend\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBDataSent\fP (\fBuint8_t\fP *buffer, \fBuint32_t\fP \fBsize\fP)"
.br
.in -1c

Public Member Functions inherited from \fBMaxOS::common::EventHandler< EthernetDriverEvents >\fP
.in +1c
.ti -1c
.RI "\fBEventHandler\fP ()"
.br
.ti -1c
.RI "\fB~EventHandler\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBEvent\fP< EthernetDriverEvents > * \fBon_event\fP (\fBEvent\fP< EthernetDriverEvents > *\fBevent\fP)"
.br
.RI "This function is called when an event is raised\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::Map\fP< uint16_t, \fBEthernetFramePayloadHandler\fP * > \fBframeHandlers\fP"
.br
.ti -1c
.RI "\fBdrivers::ethernet::EthernetDriver\fP * \fBethernetDriver\fP"
.br
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB50\fP of file \fBethernetframe\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "EthernetFrameHandler::EthernetFrameHandler (\fBdrivers::ethernet::EthernetDriver\fP * ethernetDriver, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line \fB54\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
55 : EthernetDriverEventHandler()
56 {
57 
58     this \-> ethernetDriver = driver;
59     this \-> errorMessages = errorMessages;
60 
61     driver\->connect_event_handler(this);
62 
63 }
.fi

.PP
References \fBerrorMessages\fP, and \fBethernetDriver\fP\&.
.SS "EthernetFrameHandler::~EthernetFrameHandler ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP EthernetFrameHandler::connectHandler (\fBEthernetFramePayloadHandler\fP * handler)"

.PP
Definition at line \fB135\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
135                                                                               {
136 
137     // Convert the protocol type to big endian
138     uint16_t frameType_BE = ((handler\->handledType >> 8) & 0xFF) | ((handler\->handledType << 8) & 0xFF00);
139 
140     // Add the handler to the list
141     frameHandlers\&.insert(frameType_BE, handler);
142 
143 }
.fi

.PP
References \fBframeHandlers\fP\&.
.PP
Referenced by \fBMaxOS::net::EthernetFramePayloadHandler::EthernetFramePayloadHandler()\fP\&.
.SS "\fBbool\fP EthernetFrameHandler::DataReceived (\fBuint8_t\fP * buffer, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle the received packet\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP the buffer with the received data 
.br
\fIsize\fP the size of the received data 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::drivers::ethernet::EthernetDriverEventHandler\fP\&.
.PP
Definition at line \fB78\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
78                                                                       {
79 
80     errorMessages \-> write("EFH: Data received\\n");
81 
82 
83     //Check if the size is big enough to contain an ethernet frame
84     if(size < sizeof(EthernetFrameHeader))
85         return false;
86 
87     //Convert to struct for easier use
88     auto* frame = (EthernetFrameHeader*)buffer;
89     bool sendBack = false;
90 
91     //Only handle if it is for this device
92     if(frame\->destinationMAC == 0xFFFFFFFFFFFF                                          //If it is a broadcast
93     || frame\->destinationMAC == ethernetDriver \-> GetMediaAccessControlAddress())      //If it is for this device
94     {
95 
96         // Find the handler for the protocol
97         Map<uint16_t , EthernetFramePayloadHandler*>::iterator handlerIterator = frameHandlers\&.find(frame\->type);
98 
99         // If the handler is found
100         if(handlerIterator != frameHandlers\&.end()) {
101 
102 
103             //TODO: The override is not being called (IDK WHY)
104 
105             //Handle the data
106             errorMessages \-> write("EFH: Handling ethernet frame payload\\n");
107             sendBack = handlerIterator\->second\->handleEthernetframePayload(buffer + sizeof(EthernetFrameHeader), size \- sizeof(EthernetFrameHeader));
108             errorMessages \-> write("\&.\&.DONE\\n");
109 
110         } else {
111 
112             //If the handler is not found, print an error message
113             errorMessages \-> write("EFH: Unhandled ethernet frame type 0x");
114             errorMessages\->write_hex(frame\->type);
115             errorMessages \-> write("\\n");
116 
117         }
118     }
119 
120     //If the data is to be sent back again
121     if(sendBack){
122 
123         errorMessages \-> write("EFH: Sending back\\n");
124 
125         frame \-> destinationMAC = frame \-> sourceMAC;                             //Set the new destination to be the device the data was received from
126         frame \-> sourceMAC = ethernetDriver\->GetMediaAccessControlAddress();      //Set the new source to be this device's MAC address
127 
128     }
129 
130     //Return if the data is to be sent back
131     return sendBack;
132 
133 }
.fi

.PP
References \fBdestinationMAC\fP, \fBerrorMessages\fP, \fBethernetDriver\fP, \fBframeHandlers\fP, \fBMaxOS::drivers::ethernet::EthernetDriver::GetMediaAccessControlAddress()\fP, \fBsize\fP, \fBsourceMAC\fP, \fBwrite\fP, and \fBMaxOS::common::OutputStream::write_hex()\fP\&.
.SS "\fBdrivers::ethernet::MediaAccessControlAddress\fP EthernetFrameHandler::getMAC ()"

.PP
Definition at line \fB67\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
67                                                                       {
68     return ethernetDriver \-> GetMediaAccessControlAddress();
69 }
.fi

.PP
References \fBethernetDriver\fP\&.
.SS "\fBvoid\fP EthernetFrameHandler::sendEthernetFrame (\fBuint64_t\fP destinationMAC, \fBuint16_t\fP frameType, \fBuint8_t\fP * data, \fBuint32_t\fP size)"

.PP
Send an packet via the backend driver\&. 
.PP
\fBParameters\fP
.RS 4
\fIdstMAC_BE\fP the destination MAC address 
.br
\fIetherType_BE\fP the type of the protocol 
.br
\fIbuffer\fP the data to send 
.br
\fIsize\fP the size of the payload 
.RE
.PP

.PP
Definition at line \fB153\fP of file \fBethernetframe\&.cpp\fP\&..PP
.nf
153                                                                                                                       {
154 
155     errorMessages\->write("EFH: Sending frame\&.\&.\&.");
156 
157     //Allocate memory for the buffer
158     auto* buffer = (uint8_t*)MemoryManager::kmalloc(size + sizeof(EthernetFrameHeader));
159     auto* frame = (EthernetFrameHeader*)buffer;
160 
161     //Put data in the header
162     frame \-> destinationMAC = destinationMAC;
163     frame \-> sourceMAC = ethernetDriver \-> GetMediaAccessControlAddress();
164     frame \-> type = (frameType >> 8) | (frameType << 8);                        //Convert to big endian
165 
166     //Copy the data
167     for(uint8_t *src = data + size \- 1, *dst = buffer+sizeof(EthernetFrameHeader)+size\-1; src >= data; \-\-src, \-\-dst)
168         *dst = *src;
169 
170     //Send the data
171     ethernetDriver \-> Send(buffer, size + sizeof(EthernetFrameHeader));
172 
173     errorMessages\->write("Done\\n");
174 
175 
176     //Free the buffer
177     MemoryManager::kfree(buffer);
178 }
.fi

.PP
References \fBdata\fP, \fBdestinationMAC\fP, \fBerrorMessages\fP, \fBethernetDriver\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBsize\fP, \fBsourceMAC\fP, \fBtype\fP, and \fBMaxOS::common::OutputStream::write()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* MaxOS::net::EthernetFrameHandler::errorMessages\fC [protected]\fP"

.PP
Definition at line \fB57\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBDataReceived()\fP, \fBEthernetFrameHandler()\fP, and \fBsendEthernetFrame()\fP\&.
.SS "\fBdrivers::ethernet::EthernetDriver\fP* MaxOS::net::EthernetFrameHandler::ethernetDriver\fC [protected]\fP"

.PP
Definition at line \fB56\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBDataReceived()\fP, \fBEthernetFrameHandler()\fP, \fBgetMAC()\fP, and \fBsendEthernetFrame()\fP\&.
.SS "\fBcommon::Map\fP<uint16_t , \fBEthernetFramePayloadHandler\fP*> MaxOS::net::EthernetFrameHandler::frameHandlers\fC [protected]\fP"

.PP
Definition at line \fB54\fP of file \fBethernetframe\&.h\fP\&.
.PP
Referenced by \fBconnectHandler()\fP, and \fBDataReceived()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

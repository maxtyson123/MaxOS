.TH "maxOS::net::TransmissionControlProtocolHandler" 3 "Sat Jan 6 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::net::TransmissionControlProtocolHandler
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tcp\&.h>\fP
.PP
Inherits \fBmaxOS::net::InternetProtocolPayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTransmissionControlProtocolHandler\fP (\fBInternetProtocolHandler\fP *\fBinternetProtocolHandler\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.ti -1c
.RI "\fB~TransmissionControlProtocolHandler\fP ()"
.br
.ti -1c
.RI "bool \fBhandleInternetProtocolPayload\fP (\fBInternetProtocolAddress\fP \fBsourceIP\fP, \fBInternetProtocolAddress\fP \fBdestinationIP\fP, uint8_t *payloadData, uint32_t \fBsize\fP)"
.br
.RI "Handle the TCP message (provider end) "
.ti -1c
.RI "\fBTransmissionControlProtocolSocket\fP * \fBConnect\fP (\fBInternetProtocolAddress\fP ip, \fBTransmissionControlProtocolPort\fP port)"
.br
.RI "Connect to a remote host through the TCP protocol\&. "
.ti -1c
.RI "\fBTransmissionControlProtocolSocket\fP * \fBConnect\fP (\fBstring\fP internetProtocolAddressAndPort)"
.br
.ti -1c
.RI "void \fBDisconnect\fP (\fBTransmissionControlProtocolSocket\fP *socket)"
.br
.RI "Begin the disconnect process\&. "
.ti -1c
.RI "virtual \fBTransmissionControlProtocolSocket\fP * \fBListen\fP (uint16_t port)"
.br
.RI "Begin listening on a port\&. "
.ti -1c
.RI "virtual void \fBBind\fP (\fBTransmissionControlProtocolSocket\fP *socket, \fBTransmissionControlProtocolPayloadHandler\fP *handler)"
.br
.RI "Bind a data handler to this socket\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBsendTransmissionControlProtocolPacket\fP (\fBTransmissionControlProtocolSocket\fP *socket, uint8_t *\fBdata\fP, uint16_t \fBsize\fP, uint16_t \fBflags\fP=0)"
.br
.RI "Send a packet (Throught the provider) "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.ti -1c
.RI "\fBcommon::Vector\fP< \fBTransmissionControlProtocolSocket\fP * > \fBsockets\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBTransmissionControlProtocolPort\fP \fBfreePorts\fP = 0x8000"
.br
.RI "\fBHandler\fP/// "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBTransmissionControlProtocolSocket\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 158 of file tcp\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TransmissionControlProtocolHandler::TransmissionControlProtocolHandler (\fBInternetProtocolHandler\fP * internetProtocolHandler, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line 126 of file tcp\&.cpp\&.
.PP
.nf
128 : InternetProtocolPayloadHandler(internetProtocolHandler, 0x06)
129 {
130     this -> errorMessages = errorMessages;
131     
132 }
.fi
.PP
References errorMessages\&.
.SS "TransmissionControlProtocolHandler::~TransmissionControlProtocolHandler ()"

.PP
Definition at line 134 of file tcp\&.cpp\&.
.PP
.nf
135 {
136 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void TransmissionControlProtocolHandler::Bind (\fBTransmissionControlProtocolSocket\fP * socket, \fBTransmissionControlProtocolPayloadHandler\fP * handler)\fC [virtual]\fP"

.PP
Bind a data handler to this socket\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to bind the handler to 
.br
\fItransmissionControlProtocolHandler\fP The handler to bind 
.RE
.PP

.PP
Definition at line 568 of file tcp\&.cpp\&.
.PP
.nf
569 {
570   socket->connect_event_handler(handler);
571 }
.fi
.PP
References maxOS::common::EventManager< EventType >::connect_event_handler()\&.
.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Connect (\fBInternetProtocolAddress\fP ip, \fBTransmissionControlProtocolPort\fP port)"

.PP
Connect to a remote host through the TCP protocol\&. 
.PP
\fBParameters\fP
.RS 4
\fIip\fP The IP of the remote host 
.br
\fIport\fP The port of the remote host 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that is connected to the remote host, 0 if it failed 
.RE
.PP

.PP
Definition at line 449 of file tcp\&.cpp\&.
.PP
.nf
450 {
451     //Create a new socket
452     TransmissionControlProtocolSocket* socket = (TransmissionControlProtocolSocket*)MemoryManager::s_active_memory_manager-> malloc(sizeof(TransmissionControlProtocolSocket));
453 
454     //If there is space for the socket
455     if(socket != 0)
456     {
457         //Set the socket
458         new (socket) TransmissionControlProtocolSocket(this);
459 
460         //Set local and remote addresses
461         socket -> remotePort = port;
462         socket -> remoteIP = ip;
463         socket -> localPort = freePorts++;
464         socket -> localIP = internetProtocolHandler -> GetInternetProtocolAddress();
465 
466         //Convert into big endian
467         socket -> remotePort = ((socket -> remotePort & 0xFF00)>>8) | ((socket -> remotePort & 0x00FF) << 8);
468         socket -> localPort = ((socket -> localPort & 0xFF00)>>8) | ((socket -> localPort & 0x00FF) << 8);
469 
470         //Set the socket into the socket array and then set its state
471         sockets\&.push_back(socket);
472         socket -> state = SYN_SENT;
473 
474         //Dummy sequence number
475         socket -> sequenceNumber = 0xbeefcafe;
476 
477         //Send a sync packet
478         sendTransmissionControlProtocolPacket(socket, 0,0, SYN);
479     }
480 
481     return socket;
482 }
.fi
.PP
References freePorts, maxOS::net::InternetProtocolPayloadHandler::internetProtocolHandler, sendTransmissionControlProtocolPacket(), sequenceNumber, sockets, maxOS::net::SYN, maxOS::net::SYN_SENT, and TransmissionControlProtocolSocket\&.
.PP
Referenced by Connect()\&.
.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Connect (\fBstring\fP internetProtocolAddressAndPort)"

.PP
Definition at line 485 of file tcp\&.cpp\&.
.PP
.nf
485                                                                                                                     {
486     // Find the colon (:) character in the input string
487     string colonPosition = (string)internetProtocolAddressAndPort;
488     for (; *colonPosition != '\0'; colonPosition++) {
489         if (*colonPosition == ':') {
490             // Break the loop if a colon is found
491             break;
492         }
493     }
494 
495     // If no colon is found, return 0
496     if (*colonPosition != ':') {
497         return 0;
498     }
499 
500     // Parse the InternetProtocolAddress from the input string
501     InternetProtocolAddress remoteAddress = InternetProtocolHandler::Parse(internetProtocolAddressAndPort);
502 
503     // Initialize the TransmissionControlProtocolPort to 0
504     TransmissionControlProtocolPort port = 0;
505 
506     // Iterate through the string after the colon to extract the port number
507     for (colonPosition++; *colonPosition != '\0'; colonPosition++) {
508         if ('0' <= *colonPosition && *colonPosition <= '9') {
509             // Calculate the port number by converting characters to integers
510             port = port * 10 + (*colonPosition - '0');
511         }
512     }
513 
514     // Connect to the remote address and port
515     return Connect(remoteAddress, port);
516 }
.fi
.PP
References Connect(), maxOS::net::InternetProtocolHandler::Parse(), and maxOS::string\&.
.SS "void TransmissionControlProtocolHandler::Disconnect (\fBTransmissionControlProtocolSocket\fP * socket)"

.PP
Begin the disconnect process\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to disconnect 
.RE
.PP

.PP
Definition at line 523 of file tcp\&.cpp\&.
.PP
.nf
524 {
525 
526     socket -> state = FIN_WAIT1;                            //Begin fin wait sequence
527     sendTransmissionControlProtocolPacket(socket, 0,0, FIN + ACK);            //Send FIN|ACK packet
528     socket -> sequenceNumber++;                             //Increase the sequence number
529 }
.fi
.PP
References maxOS::net::ACK, maxOS::net::FIN, maxOS::net::FIN_WAIT1, sendTransmissionControlProtocolPacket(), and sequenceNumber\&.
.SS "bool TransmissionControlProtocolHandler::handleInternetProtocolPayload (\fBInternetProtocolAddress\fP sourceIP, \fBInternetProtocolAddress\fP destinationIP, uint8_t * payloadData, uint32_t size)\fC [virtual]\fP"

.PP
Handle the TCP message (provider end) 
.PP
\fBParameters\fP
.RS 4
\fIsrcIP_BE\fP The source IP address 
.br
\fIdstIP_BE\fP The destination IP address 
.br
\fIinternetprotocolPayload\fP The payload 
.br
\fIsize\fP The size of the payload 
.RE
.PP
\fBReturns\fP
.RS 4
True if data is to be sent back or false if not 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::net::InternetProtocolPayloadHandler\fP\&.
.PP
Definition at line 162 of file tcp\&.cpp\&.
.PP
.nf
163 {
164 
165     errorMessages -> write("TCP: Handling TCP message\n");
166 
167     //Check if the size is too small
168     if(size < 13)
169     {
170         return false;
171     }
172 
173     // If it's smaller than the header, return
174     if(size < 4*payloadData[12]/16)             // The lower 4 bits of the 13th byte is the header length
175     {
176         return false;
177     }
178 
179     //Get the header
180     TransmissionControlProtocolHeader* msg = (TransmissionControlProtocolHeader*)payloadData;
181 
182     //Get the connection values (convert to host endian)
183     uint16_t localPort = bigEndian16(msg -> dstPort);
184     uint16_t remotePort = bigEndian16(msg -> srcPort);
185 
186     //Create the socket
187     TransmissionControlProtocolSocket* socket = 0;
188 
189     for(Vector<TransmissionControlProtocolSocket*>::iterator currentSocket = sockets\&.begin(); currentSocket != sockets\&.end(); currentSocket++)
190     {
191         if( (*currentSocket) -> localPort == localPort                               //Check if the local port is the same as the destination port
192         &&  (*currentSocket) -> localIP == destinationIP                                  //Check if the local IP is the same as the destination IP
193         &&  (*currentSocket) -> state == LISTEN                                           //Check if the socket is in the LISTEN state
194         && (((msg -> flags) & (SYN | ACK)) == SYN))                                       //Check if the SYN flag is set (allow for acknoweldgement)
195         {
196             socket = *currentSocket;
197         }
198         else if( (*currentSocket) -> localPort == localPort                          //Check if the local port is the same as the destination port
199              &&  (*currentSocket) -> localIP == destinationIP                             //Check if the local IP is the same as the destination IP
200              &&  (*currentSocket) -> remotePort == remotePort                         //Check if the remote port is the same as the source port
201              &&  (*currentSocket) -> remoteIP == destinationIP)                           //Check if the remote IP is the same as the source IP
202         {
203             socket = *currentSocket;
204         }
205     }
206 
207 
208     bool reset = false;
209 
210     //Check if the socket is found and if the socket wants to reset
211     if(socket != 0 && msg -> flags & RST)
212     {
213         socket -> state = CLOSED;
214         socket -> Disconnected();
215     }
216 
217     //Check if the socket is found and if the socket is not closed
218     if(socket != 0 && socket -> state != CLOSED)
219     {
220         switch((msg -> flags) & (SYN | ACK | FIN))
221         {
222             /*
223              * Example for explanation:
224              * socket -> state = SYN_RECEIVED;                                                  //The state of the socket, e\&.g\&. recieved, or established\&. This is used to know how to handle the socket
225              * socket -> remotePort = msg -> srcPort;                                           //The remote port, e\&.g\&. the port of the server
226              * socket -> remoteIP = srcIP_BE;                                                   //The remote IP, e\&.g\&. the IP of the server
227              * socket -> acknowledgementNumber = bigEndian32( msg -> sequenceNumber ) + 1;      //The acknowledgement number, the number used to keep track of what has been received, this is just incremented by 1 each time
228              * socket -> sequenceNumber = 0xbeefcafe;                                           //The sequence number, the number of the next set that is to be sent but in this case sequence isnt enabled so just set it to anything
229              * Send(socket, 0,0, SYN|ACK);                                                      //The response command, genneraly has to have the acknoledgement flag set
230              * socket -> sequenceNumber++;                                                      //Increment the sequence number
231              *
232              */
233 
234             case SYN:
235                 if(socket -> state == LISTEN)
236                 {
237                     socket -> state = SYN_RECEIVED;
238                     socket -> remotePort = msg -> srcPort;
239                     socket -> remoteIP = sourceIP;
240                     socket -> acknowledgementNumber = bigEndian32( msg -> sequenceNumber ) + 1;
241                     socket -> sequenceNumber = 0xbeefcafe;
242                     sendTransmissionControlProtocolPacket(socket, 0,0, SYN|ACK);
243                     socket -> sequenceNumber++;
244                 }
245                 else
246                     reset = true;
247                 break;
248 
249 
250             case SYN | ACK:
251                 if(socket -> state == SYN_SENT)
252                 {
253                     socket -> state = ESTABLISHED;
254                     socket -> acknowledgementNumber = bigEndian32( msg -> sequenceNumber ) + 1;
255                     socket -> sequenceNumber++;
256                     sendTransmissionControlProtocolPacket(socket, 0,0, ACK);
257                 }
258                 else
259                     reset = true;
260                 break;
261 
262 
263             case SYN | FIN:
264             case SYN | FIN | ACK:
265                 reset = true;
266                 break;
267 
268 
269             case FIN:
270             case FIN|ACK:
271                 if(socket -> state == ESTABLISHED)
272                 {
273                     socket -> state = CLOSE_WAIT;
274                     socket -> acknowledgementNumber++;
275                     sendTransmissionControlProtocolPacket(socket, 0,0, ACK);
276                     sendTransmissionControlProtocolPacket(socket, 0,0, FIN|ACK);
277                     socket -> Disconnected();
278                 }
279                 else if(socket -> state == CLOSE_WAIT)
280                 {
281                     socket -> state = CLOSED;
282                 }
283                 else if(socket -> state == FIN_WAIT1 || socket -> state == FIN_WAIT2)
284                 {
285                     socket -> state = CLOSED;
286                     socket -> acknowledgementNumber++;
287                     sendTransmissionControlProtocolPacket(socket, 0,0, ACK);
288                     socket -> Disconnected();
289                 }
290                 else
291                     reset = true;
292                 break;
293 
294 
295             case ACK:
296                 if(socket -> state == SYN_RECEIVED)
297                 {
298                     socket -> state = ESTABLISHED;
299                     socket -> Connected();
300                     return false;
301                 }
302                 else if(socket -> state == FIN_WAIT1)
303                 {
304                     socket -> state = FIN_WAIT2;
305                     return false;
306                 }
307                 else if(socket -> state == CLOSE_WAIT)
308                 {
309                     socket -> state = CLOSED;
310                     break;
311                 }
312 
313                 if(msg -> flags == ACK)
314                     break;
315 
316                 // no break, because of piggybacking
317 
318             default:
319 
320                 //By default handle the data
321 
322                 if(bigEndian32(msg -> sequenceNumber) == socket -> acknowledgementNumber)
323                 {
324 
325                     reset = !(socket -> handleTransmissionControlProtocolPayload(payloadData + msg -> headerSize32*4,size - msg -> headerSize32*4));
326                     if(!reset)
327                     {
328                         int x = 0;                                                                      //The number of bytes to send back
329                         for(int i = msg -> headerSize32*4; i < size; i++)                               //Loop through the data
330                             if(payloadData[i] != 0)                                                     //Check if the data is not 0
331                                 x = i;                                                                  //Set the number of bytes to send back to the current index
332                         socket -> acknowledgementNumber += x - msg -> headerSize32*4 + 1;               //Increment the acknowledgement number by the number of bytes to send back
333                         sendTransmissionControlProtocolPacket(socket, 0,0, ACK);                                          //Send the acknowledgement
334                     }
335                 }
336                 else
337                 {
338                     // data in wrong order
339                     reset = true;
340                 }
341 
342         }
343     }
344 
345 
346 
347     if(reset)                                                                       //If the socket is to be reset
348     {
349         if(socket != 0)                                                             //If the socket exists then send a reset flag
350         {
351             sendTransmissionControlProtocolPacket(socket, 0,0, RST);
352         }
353         else                                                                        //If it doesnt exist then create a new socket and send a reset flag
354         {
355             TransmissionControlProtocolSocket socket(this);                     //Create a new socket
356             socket\&.remotePort = msg -> srcPort;                                         //Set the remote port
357             socket\&.remoteIP = sourceIP;                                                 //Set the remote IP
358             socket\&.localPort = msg -> dstPort;                                                  //Set the local port
359             socket\&.localIP = destinationIP;                                                     //Set the local IP
360             socket\&.sequenceNumber = bigEndian32(msg -> acknowledgementNumber);              //Set the sequence number
361             socket\&.acknowledgementNumber = bigEndian32(msg -> sequenceNumber) + 1;          //Set the acknowledgement number
362             sendTransmissionControlProtocolPacket(&socket, 0,0, RST);          //Send the reset flag
363         }
364     }
365 
366 
367     errorMessages ->write("TCP: Handled packet\n");
368 
369     if(socket != 0 && socket -> state == CLOSED)                                        //If the socket is closed then remove it from the list
370     {
371         sockets\&.erase(socket);
372         return true;
373     }
374 
375 
376 
377     return false;
378 }
.fi
.PP
References maxOS::net::ACK, acknowledgementNumber, maxOS::net::TransmissionControlProtocolSocket::acknowledgementNumber, bigEndian16(), bigEndian32(), maxOS::net::CLOSE_WAIT, maxOS::net::CLOSED, destinationIP, dstPort, errorMessages, maxOS::net::ESTABLISHED, maxOS::net::FIN, maxOS::net::FIN_WAIT1, maxOS::net::FIN_WAIT2, flags, headerSize32, maxOS::drivers::peripherals::i, maxOS::net::LISTEN, maxOS::net::TransmissionControlProtocolSocket::localIP, maxOS::net::TransmissionControlProtocolSocket::localPort, maxOS::net::TransmissionControlProtocolSocket::remoteIP, maxOS::net::TransmissionControlProtocolSocket::remotePort, maxOS::net::RST, sendTransmissionControlProtocolPacket(), sequenceNumber, maxOS::net::TransmissionControlProtocolSocket::sequenceNumber, size, sockets, sourceIP, srcPort, maxOS::net::SYN, maxOS::net::SYN_RECEIVED, maxOS::net::SYN_SENT, maxOS::common::OutputStream::write(), and maxOS::drivers::peripherals::x\&.
.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Listen (uint16_t port)\fC [virtual]\fP"

.PP
Begin listening on a port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP The port to listen on 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that will handle the connection 
.RE
.PP

.PP
Definition at line 537 of file tcp\&.cpp\&.
.PP
.nf
538 {
539     //Create a new socket
540     TransmissionControlProtocolSocket* socket = (TransmissionControlProtocolSocket*)MemoryManager::s_active_memory_manager-> malloc(sizeof(TransmissionControlProtocolSocket));
541 
542     //If there is space for the socket
543     if(socket != 0)
544     {
545         //Set the socket
546         new (socket) TransmissionControlProtocolSocket(this);
547 
548         //Configure the socket
549         socket -> state = LISTEN;
550         socket -> localIP = internetProtocolHandler -> GetInternetProtocolAddress();
551         socket -> localPort = ((port & 0xFF00)>>8) | ((port & 0x00FF) << 8);
552 
553         //Add the socket to the socket array
554         sockets\&.push_back(socket);
555     }
556 
557     //Return the socket
558     return socket;
559 }
.fi
.PP
References maxOS::net::InternetProtocolPayloadHandler::internetProtocolHandler, maxOS::net::LISTEN, sockets, and TransmissionControlProtocolSocket\&.
.SS "void TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket (\fBTransmissionControlProtocolSocket\fP * socket, uint8_t * data, uint16_t size, uint16_t flags = \fC0\fP)\fC [protected]\fP"

.PP
Send a packet (Throught the provider) 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to send the packet from 
.br
\fIdata\fP The data to send 
.br
\fIsize\fP The size of the data 
.br
\fIflags\fP The flags to send 
.RE
.PP

.PP
Definition at line 388 of file tcp\&.cpp\&.
.PP
.nf
389 {
390     //Get the total size of the packet and the packet with the pseudo header
391     uint16_t totalLength = size + sizeof(TransmissionControlProtocolHeader);
392     uint16_t lengthInclPHdr = totalLength + sizeof(TransmissionControlProtocolPseudoHeader);
393 
394     //Create a buffer for the packet
395     uint8_t* buffer = (uint8_t*)MemoryManager::s_active_memory_manager-> malloc(lengthInclPHdr);
396     uint8_t* buffer2 = buffer + sizeof(TransmissionControlProtocolHeader) + sizeof(TransmissionControlProtocolPseudoHeader);
397 
398     //Create the headers
399     TransmissionControlProtocolPseudoHeader* phdr = (TransmissionControlProtocolPseudoHeader*)buffer;
400     TransmissionControlProtocolHeader* msg = (TransmissionControlProtocolHeader*)(buffer + sizeof(TransmissionControlProtocolPseudoHeader));
401 
402     //Size is translated into 32bit
403     msg -> headerSize32 = sizeof(TransmissionControlProtocolHeader)/4;
404 
405     //Set the ports
406     msg -> srcPort = bigEndian16(socket -> localPort);
407     msg -> dstPort = bigEndian16(socket -> remotePort);
408 
409     //Set TCP related data
410     msg -> acknowledgementNumber = bigEndian32( socket -> acknowledgementNumber );
411     msg -> sequenceNumber = bigEndian32( socket -> sequenceNumber );
412     msg -> reserved = 0;
413     msg -> flags = flags;
414     msg -> windowSize = 0xFFFF;
415     msg -> urgentPtr = 0;
416 
417     //Through the options allow for the MSS to be set
418     msg -> options = ((flags & SYN) != 0) ? 0xB4050402 : 0;
419 
420     //Increase the sequence number
421     socket -> sequenceNumber += size;
422 
423     //Copy the data into the buffer
424     for(int i = 0; i < size; i++)
425         buffer2[i] = data[i];
426 
427     //Set the pseudo header
428     phdr -> srcIP = socket -> localIP;
429     phdr -> dstIP = socket -> remoteIP;
430     phdr -> protocol = 0x0600;
431     phdr -> totalLength = ((totalLength & 0x00FF) << 8) | ((totalLength & 0xFF00) >> 8);
432 
433     //Calculate the checksum
434     msg -> checksum = 0;
435     msg -> checksum = InternetProtocolHandler::Checksum((uint16_t*)buffer, lengthInclPHdr);
436 
437 
438     //Send and then free the data
439     Send(socket -> remoteIP, (uint8_t*)msg, totalLength);
440     MemoryManager::s_active_memory_manager-> free(buffer);
441 }
.fi
.PP
References acknowledgementNumber, bigEndian16(), bigEndian32(), checksum, maxOS::net::InternetProtocolHandler::Checksum(), data, dstIP, dstPort, flags, headerSize32, maxOS::drivers::peripherals::i, options, protocol, reserved, maxOS::net::InternetProtocolPayloadHandler::Send(), sequenceNumber, size, srcIP, srcPort, maxOS::net::SYN, totalLength, urgentPtr, and windowSize\&.
.PP
Referenced by Connect(), Disconnect(), and handleInternetProtocolPayload()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBTransmissionControlProtocolSocket\fP\fC [friend]\fP"

.PP
Definition at line 160 of file tcp\&.h\&.
.PP
Referenced by Connect(), and Listen()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* maxOS::net::TransmissionControlProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Definition at line 162 of file tcp\&.h\&.
.PP
Referenced by handleInternetProtocolPayload(), and TransmissionControlProtocolHandler()\&.
.SS "\fBTransmissionControlProtocolPort\fP TransmissionControlProtocolHandler::freePorts = 0x8000\fC [static]\fP, \fC [protected]\fP"

.PP
\fBHandler\fP/// 
.PP
Definition at line 165 of file tcp\&.h\&.
.PP
Referenced by Connect()\&.
.SS "\fBcommon::Vector\fP<\fBTransmissionControlProtocolSocket\fP*> maxOS::net::TransmissionControlProtocolHandler::sockets\fC [protected]\fP"

.PP
Definition at line 163 of file tcp\&.h\&.
.PP
Referenced by Connect(), handleInternetProtocolPayload(), and Listen()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::Process" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Process \- A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <process\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Base Constructor for the \fBProcess\fP\&. "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP(*\fB_entry_point\fP)(\fBvoid\fP *), \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from a function) "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBElf64\fP *\fBelf\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) "
.ti -1c
.RI "\fB~Process\fP ()"
.br
.RI "Destructor for the \fBProcess\fP class\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBThread\fP * > \fBthreads\fP ()"
.br
.RI "Gets the threads of the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBadd_thread\fP (\fBThread\fP *\fBthread\fP)"
.br
.RI "Adds a thread to the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_thread\fP (\fBuint64_t\fP tid)"
.br
.RI "Finds a thread by its tid\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_pid\fP (\fBuint64_t\fP \fBpid\fP)"
.br
.RI "Sets the pid of the process once added to the queue\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBpid\fP () \fBconst\fP"
.br
.RI "Gets the pid of the process\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBtotal_ticks\fP ()"
.br
.RI "Gets the total ticks of the threads in the process (not this does not include any past killed threads) "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBis_kernel\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBname\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBworking_directory\fP = '/'"
.br
.ti -1c
.RI "\fBmemory::MemoryManager\fP * \fBmemory_manager\fP = nullptr"
.br
.ti -1c
.RI "\fBResourceManager\fP \fBresource_manager\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&. 
.PP
Definition at line \fB78\fP of file \fBprocess\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Base Constructor for the \fBProcess\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB119\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
120 : is_kernel(is_kernel),
121   name(p_name)
122 {
123 
124     // Pause interrupts while creating the process
125     asm("cli");
126 
127     // Basic setup
128     m_pid = Scheduler::system_scheduler()\->add_process(this);
129 
130     // If it is a kernel process then don't need a new memory manager
131     memory_manager = is_kernel ? MemoryManager::s_kernel_memory_manager : new MemoryManager();
132 
133     // Resuming interrupts are done when adding a thread
134 }
.fi

.PP
References \fBis_kernel\fP, \fBmemory_manager\fP, \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP, and \fBMaxOS::processes::Scheduler::system_scheduler()\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP(*)(\fBvoid\fP *) _entry_point, \fBvoid\fP * args, \fBint\fP arg_amount, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from a function) 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fI_entry_point\fP The entry point of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB145\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
146 : Process(p_name, is_kernel)
147 {
148 
149     // Create the main thread
150     auto* main_thread = new Thread(_entry_point, args, arg_amount, this);
151 
152     // Add the thread
153     add_thread(main_thread);
154 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP * args, \fBint\fP arg_amount, \fBElf64\fP * elf, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) 
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIelf\fP The elf file to load the process from 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB165\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
166 : Process(p_name, is_kernel)
167 {
168 
169     // Get the entry point
170     elf\->load();
171     auto* entry_point = (void (*)(void*)) elf\->header()\->entry;
172 
173     // Create the main thread
174     auto* main_thread = new Thread(entry_point, args, arg_amount, this);
175     add_thread(main_thread);
176 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::~Process ()"

.PP
Destructor for the \fBProcess\fP class\&. 
.PP
Definition at line \fB182\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
182                   {
183 
184     uint64_t pages = PhysicalMemoryManager::s_current_manager\->memory_used();
185 
186     // Free the threads
187     for (auto thread: m_threads)
188         delete thread;
189 
190     // Free the memory manager (only if it was created)
191     if (!is_kernel)
192         delete memory_manager;
193 
194     // Log the cleanup
195     Logger::DEBUG() << "Process " << name\&.c_str() << " cleaned up, memory before: " << pages << " bytes, after cleanup: " << PhysicalMemoryManager::s_current_manager\->memory_used() << " bytes\\n";
196 }
.fi

.PP
References \fBMaxOS::String::c_str()\fP, \fBLogger::DEBUG()\fP, \fBis_kernel\fP, \fBmemory_manager\fP, \fBname\fP, and \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Process::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the process\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP

.PP
Definition at line \fB203\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
203                                        {
204 
205     // Pause interrupts while adding the thread
206     asm("cli");
207 
208     // Store the thread
209     m_threads\&.push_back(thread);
210     thread\->parent_pid = m_pid;
211 
212     // Can now resume interrupts
213     asm("sti");
214 }
.fi

.PP
Referenced by \fBProcess()\fP, and \fBProcess()\fP\&.
.SS "\fBuint64_t\fP Process::pid () const"

.PP
Gets the pid of the process\&. 
.PP
\fBReturns\fP
.RS 4
The pid of the process 
.RE
.PP

.PP
Definition at line \fB278\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
278                             {
279 
280     return m_pid;
281 }
.fi

.PP
Referenced by \fBset_pid()\fP\&.
.SS "\fBvoid\fP Process::remove_thread (\fBuint64_t\fP tid)"

.PP
Finds a thread by its tid\&. 
.PP
\fBParameters\fP
.RS 4
\fItid\fP 
.RE
.PP

.PP
Definition at line \fB221\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
221                                         {
222 
223     // Find the thread
224     for (uint32_t i = 0; i < m_threads\&.size(); i++) {
225 
226         // Thread is not what is being removed
227         if (m_threads[i]\->tid != tid)
228             continue;
229 
230         // Delete the thread
231         Thread* thread = m_threads[i];
232         delete thread;
233 
234         // Remove the thread from the list
235         m_threads\&.erase(m_threads\&.begin() + i);
236 
237         // If there are no more threads then delete the process from the scheduler
238         if (m_threads\&.empty())
239             Scheduler::system_scheduler()\->remove_process(this);
240 
241         return;
242     }
243 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::system_scheduler()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::force_remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBvoid\fP Process::set_pid (\fBuint64_t\fP pid)"

.PP
Sets the pid of the process once added to the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP 
.RE
.PP

.PP
Definition at line \fB250\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
250                                   {
251 
252     // Check if the pid is already set
253     if (m_pid != 0)
254         return;
255 
256     // Set the pid
257     m_pid = pid;
258 
259     // Assign the pid to the threads
260     for (auto thread: m_threads)
261         thread\->parent_pid = pid;
262 
263 }
.fi

.PP
References \fBpid()\fP\&.
.SS "\fBVector\fP< \fBThread\fP * > Process::threads ()"

.PP
Gets the threads of the process\&. 
.PP
Definition at line \fB268\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
268                                  {
269 
270     return m_threads;
271 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::force_remove_process()\fP, \fBMaxOS::processes::Scheduler::remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBuint64_t\fP Process::total_ticks ()"

.PP
Gets the total ticks of the threads in the process (not this does not include any past killed threads) 
.PP
\fBReturns\fP
.RS 4
The total ticks of the threads in the process 
.RE
.PP

.PP
Definition at line \fB288\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
288                               {
289 
290     uint64_t total_ticks = 0;
291     for (auto thread: m_threads)
292         total_ticks += thread\->ticks;
293 
294     return total_ticks;
295 }
.fi

.PP
References \fBtotal_ticks()\fP\&.
.PP
Referenced by \fBMaxOS::system::CPU::PANIC()\fP, and \fBtotal_ticks()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool MaxOS::processes::Process::is_kernel"

.PP
Definition at line \fB100\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fB~Process()\fP\&.
.SS "\fBmemory::MemoryManager\fP* MaxOS::processes::Process::memory_manager = nullptr"

.PP
Definition at line \fB105\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, \fBMaxOS::processes::Scheduler::schedule_next()\fP, and \fB~Process()\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::name"

.PP
Definition at line \fB102\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP, \fBMaxOS::system::CPU::PANIC()\fP, \fBMaxOS::system::CPU::prepare_for_panic()\fP, and \fB~Process()\fP\&.
.SS "\fBResourceManager\fP MaxOS::processes::Process::resource_manager"

.PP
Definition at line \fB106\fP of file \fBprocess\&.h\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::working_directory = '/'"

.PP
Definition at line \fB103\fP of file \fBprocess\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::processes::Process" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Process \- A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <process\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Base Constructor for the \fBProcess\fP\&. "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP(*\fB_entry_point\fP)(\fBvoid\fP *), \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from a function) "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBELF64\fP *\fBelf\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) "
.ti -1c
.RI "\fB~Process\fP ()"
.br
.RI "Destructor for the \fBProcess\fP class\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBThread\fP * > \fBthreads\fP ()"
.br
.RI "Gets the threads of the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBadd_thread\fP (\fBThread\fP *\fBthread\fP)"
.br
.RI "Adds a thread to the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_thread\fP (\fBuint64_t\fP tid)"
.br
.RI "Remove a thread by its tid (NOTE: this will not remove it from the scheduler) "
.ti -1c
.RI "\fBvoid\fP \fBset_pid\fP (\fBuint64_t\fP \fBpid\fP)"
.br
.RI "Sets the pid of the process once added to the queue\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBpid\fP () \fBconst\fP"
.br
.RI "Gets the pid of the process\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBtotal_ticks\fP ()"
.br
.RI "Gets the total ticks of the threads in the process (not this does not include any past killed threads) "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBis_kernel\fP"
.br
.RI "Whether this process is a kernel process\&. "
.ti -1c
.RI "\fBstring\fP \fBname\fP"
.br
.RI "The name of the process\&. "
.ti -1c
.RI "\fBstring\fP \fBworking_directory\fP = '/'"
.br
.RI "The working directory of the process\&. "
.ti -1c
.RI "\fBmemory::MemoryManager\fP * \fBmemory_manager\fP = nullptr"
.br
.RI "The manager for memory used by this process\&. "
.ti -1c
.RI "\fBResourceManager\fP \fBresource_manager\fP"
.br
.RI "The manger for resources used by this process\&. "
.in -1c
.SH "Detailed Description"
.PP 
A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&. 
.PP
Definition at line \fB85\fP of file \fBprocess\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)\fC [explicit]\fP"

.PP
Base Constructor for the \fBProcess\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB181\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
182 : is_kernel(is_kernel),
183   name(p_name)
184 {
185     // If it is a kernel process then don't need a new memory manager
186     memory_manager = is_kernel ? MemoryManager::s_kernel_memory_manager : new MemoryManager();
187 }
.fi

.PP
References \fBis_kernel\fP, \fBmemory_manager\fP, and \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP(*)(\fBvoid\fP *) _entry_point, \fBvoid\fP * args, \fBint\fP arg_amount, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from a function) 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fI_entry_point\fP The entry point of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB198\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
199 : Process(p_name, is_kernel)
200 {
201 
202     // Create the main thread
203     auto* main_thread = new Thread(_entry_point, args, arg_amount, this);
204 
205     // Add the thread
206     add_thread(main_thread);
207 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP * args, \fBint\fP arg_amount, \fBELF64\fP * elf, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIelf\fP The elf file to load the process from 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB218\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
219 : Process(p_name, is_kernel)
220 {
221 
222     // Get the entry point
223     elf\->load();
224     auto* entry_point = (void (*)(void*)) elf\->header()\->entry;
225 
226     // Create the main thread
227     auto* main_thread = new Thread(entry_point, args, arg_amount, this);
228     add_thread(main_thread);
229 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::~Process ()"

.PP
Destructor for the \fBProcess\fP class\&. 
.PP
Definition at line \fB235\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
235                   {
236 
237     uint64_t pages = PhysicalMemoryManager::s_current_manager\->memory_used();
238 
239     // Free the threads
240     for (auto thread: m_threads)
241         delete thread;
242 
243     // Free the memory manager (only if it was created)
244     if (!is_kernel)
245         delete memory_manager;
246 
247     // Log the cleanup
248     Logger::DEBUG() << "Process " << name\&.c_str() << " cleaned up, memory before: " << pages << " bytes, after cleanup: " << PhysicalMemoryManager::s_current_manager\->memory_used() << " bytes\\n";
249 }
.fi

.PP
References \fBMaxOS::Logger::DEBUG()\fP, \fBis_kernel\fP, \fBmemory_manager\fP, \fBname\fP, and \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Process::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the process\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP

.PP
Definition at line \fB256\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
256                                        {
257 
258     m_lock\&.lock();
259 
260     // Store the thread
261     m_threads\&.push_back(thread);
262     thread\->parent_pid = m_pid;
263 
264     m_lock\&.unlock();
265 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fBProcess()\fP\&.
.SS "\fBuint64_t\fP Process::pid () const"

.PP
Gets the pid of the process\&. 
.PP
\fBReturns\fP
.RS 4
The pid of the process 
.RE
.PP

.PP
Definition at line \fB326\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
326                             {
327 
328     return m_pid;
329 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::current_process()\fP, \fBMaxOS::processes::GlobalScheduler::force_remove_process()\fP, \fBMaxOS::processes::Scheduler::get_process()\fP, \fBMaxOS::processes::GlobalScheduler::remove_process()\fP, and \fBset_pid()\fP\&.
.SS "\fBvoid\fP Process::remove_thread (\fBuint64_t\fP tid)"

.PP
Remove a thread by its tid (NOTE: this will not remove it from the scheduler) 
.PP
\fBParameters\fP
.RS 4
\fItid\fP 
.RE
.PP

.PP
Definition at line \fB272\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
272                                         {
273 
274     // Find the thread
275     for (uint32_t i = 0; i < m_threads\&.size(); i++) {
276 
277         // Thread is not what is being removed
278         if (m_threads[i]\->tid != tid)
279             continue;
280 
281         // Delete the thread
282         Thread* thread = m_threads[i];
283         delete thread;
284 
285         // Remove the thread from the list
286         m_threads\&.erase(m_threads\&.begin() + i);
287         return;
288     }
289 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::force_remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBvoid\fP Process::set_pid (\fBuint64_t\fP pid)"

.PP
Sets the pid of the process once added to the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP 
.RE
.PP

.PP
Definition at line \fB296\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
296                                   {
297 
298     // Check if the pid is already set
299     if (m_pid != 0)
300         return;
301 
302     // Set the pid
303     m_pid = pid;
304 
305     // Assign the pid to the threads
306     for (auto thread: m_threads)
307         thread\->parent_pid = pid;
308 
309 }
.fi

.PP
References \fBpid()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP\&.
.SS "\fBVector\fP< \fBThread\fP * > Process::threads ()"

.PP
Gets the threads of the process\&. 
.PP
\fBReturns\fP
.RS 4
The threads of the process 
.RE
.PP

.PP
Definition at line \fB316\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
316                                  {
317 
318     return m_threads;
319 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP, \fBMaxOS::processes::Scheduler::force_remove_process()\fP, \fBMaxOS::processes::Scheduler::remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBuint64_t\fP Process::total_ticks ()"

.PP
Gets the total ticks of the threads in the process (not this does not include any past killed threads) 
.PP
\fBReturns\fP
.RS 4
The total ticks of the threads in the process 
.RE
.PP

.PP
Definition at line \fB336\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
336                               {
337 
338     uint64_t total_ticks = 0;
339     for (auto thread: m_threads)
340         total_ticks += thread\->ticks;
341 
342     return total_ticks;
343 }
.fi

.PP
References \fBtotal_ticks()\fP\&.
.PP
Referenced by \fBtotal_ticks()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool MaxOS::processes::Process::is_kernel"

.PP
Whether this process is a kernel process\&. 
.PP
Definition at line \fB107\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fB~Process()\fP\&.
.SS "\fBmemory::MemoryManager\fP* MaxOS::processes::Process::memory_manager = nullptr"

.PP
The manager for memory used by this process\&. 
.PP
Definition at line \fB112\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fB~Process()\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::name"

.PP
The name of the process\&. 
.PP
Definition at line \fB109\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP, and \fB~Process()\fP\&.
.SS "\fBResourceManager\fP MaxOS::processes::Process::resource_manager"

.PP
The manger for resources used by this process\&. 
.PP
Definition at line \fB113\fP of file \fBprocess\&.h\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::working_directory = '/'"

.PP
The working directory of the process\&. 
.PP
Definition at line \fB110\fP of file \fBprocess\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

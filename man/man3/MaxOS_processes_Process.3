.TH "MaxOS::processes::Process" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::processes::Process \- A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <process\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Base Constructor for the \fBProcess\fP\&. "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP(*\fB_entry_point\fP)(\fBvoid\fP *), \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from a function) "
.ti -1c
.RI "\fBProcess\fP (\fBconst\fP \fBstring\fP &\fBname\fP, \fBvoid\fP *\fBargs\fP, \fBint\fP \fBarg_amount\fP, \fBELF64\fP *\fBelf\fP, \fBbool\fP \fBis_kernel\fP=\fBfalse\fP)"
.br
.RI "Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) "
.ti -1c
.RI "\fB~Process\fP ()"
.br
.RI "Destructor for the \fBProcess\fP class\&. "
.ti -1c
.RI "\fBcommon::Vector\fP< \fBThread\fP * > \fBthreads\fP ()"
.br
.RI "Gets the threads of the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBadd_thread\fP (\fBThread\fP *\fBthread\fP)"
.br
.RI "Adds a thread to the process\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_thread\fP (\fBuint64_t\fP tid)"
.br
.RI "Remove a thread by its tid (NOTE: this will not remove it from the scheduler) "
.ti -1c
.RI "\fBvoid\fP \fBset_pid\fP (\fBuint64_t\fP \fBpid\fP)"
.br
.RI "Sets the pid of the process once added to the queue\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBpid\fP () \fBconst\fP"
.br
.RI "Gets the pid of the process\&. "
.ti -1c
.RI "\fBuint64_t\fP \fBtotal_ticks\fP ()"
.br
.RI "Gets the total ticks of the threads in the process (not this does not include any past killed threads) "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBis_kernel\fP"
.br
.RI "Whether this process is a kernel process\&. "
.ti -1c
.RI "\fBstring\fP \fBname\fP"
.br
.RI "The name of the process\&. "
.ti -1c
.RI "\fBstring\fP \fBworking_directory\fP = '/'"
.br
.RI "The working directory of the process\&. "
.ti -1c
.RI "\fBmemory::MemoryManager\fP * \fBmemory_manager\fP = nullptr"
.br
.RI "The manager for memory used by this process\&. "
.ti -1c
.RI "\fBResourceManager\fP \fBresource_manager\fP"
.br
.RI "The manger for resources used by this process\&. "
.in -1c
.SH "Detailed Description"
.PP 
A process that can be scheduled by the \fBScheduler\fP, wraps & manages threads as well as its own address space and resources\&. 
.PP
Definition at line \fB83\fP of file \fBprocess\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Base Constructor for the \fBProcess\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB176\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
177 : is_kernel(is_kernel),
178   name(p_name)
179 {
180     // If it is a kernel process then don't need a new memory manager
181     memory_manager = is_kernel ? MemoryManager::s_kernel_memory_manager : new MemoryManager();
182 }
.fi

.PP
References \fBis_kernel\fP, \fBmemory_manager\fP, and \fBMaxOS::memory::MemoryManager::s_kernel_memory_manager\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP(*)(\fBvoid\fP *) _entry_point, \fBvoid\fP * args, \fBint\fP arg_amount, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from a function) 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fI_entry_point\fP The entry point of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB193\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
194 : Process(p_name, is_kernel)
195 {
196 
197     // Create the main thread
198     auto* main_thread = new Thread(_entry_point, args, arg_amount, this);
199 
200     // Add the thread
201     add_thread(main_thread);
202 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::Process (\fBconst\fP \fBstring\fP & p_name, \fBvoid\fP * args, \fBint\fP arg_amount, \fBELF64\fP * elf, \fBbool\fP is_kernel = \fC\fBfalse\fP\fP)"

.PP
Constructor for the \fBProcess\fP class (from an elf, will free the elf memory after loading) 
.PP
\fBParameters\fP
.RS 4
\fIp_name\fP The name of the process 
.br
\fIargs\fP The arguments to pass to the process 
.br
\fIarg_amount\fP The amount of arguments 
.br
\fIelf\fP The elf file to load the process from 
.br
\fIis_kernel\fP If the process is a kernel process 
.RE
.PP

.PP
Definition at line \fB213\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
214 : Process(p_name, is_kernel)
215 {
216 
217     // Get the entry point
218     elf\->load();
219     auto* entry_point = (void (*)(void*)) elf\->header()\->entry;
220 
221     // Create the main thread
222     auto* main_thread = new Thread(entry_point, args, arg_amount, this);
223     add_thread(main_thread);
224 }
.fi

.PP
References \fBadd_thread()\fP\&.
.SS "Process::~Process ()"

.PP
Destructor for the \fBProcess\fP class\&. 
.PP
Definition at line \fB230\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
230                   {
231 
232     uint64_t pages = PhysicalMemoryManager::s_current_manager\->memory_used();
233 
234     // Free the threads
235     for (auto thread: m_threads)
236         delete thread;
237 
238     // Free the memory manager (only if it was created)
239     if (!is_kernel)
240         delete memory_manager;
241 
242     // Log the cleanup
243     Logger::DEBUG() << "Process " << name\&.c_str() << " cleaned up, memory before: " << pages << " bytes, after cleanup: " << PhysicalMemoryManager::s_current_manager\->memory_used() << " bytes\\n";
244 }
.fi

.PP
References \fBLogger::DEBUG()\fP, \fBis_kernel\fP, \fBmemory_manager\fP, \fBname\fP, and \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Process::add_thread (\fBThread\fP * thread)"

.PP
Adds a thread to the process\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to add 
.RE
.PP

.PP
Definition at line \fB251\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
251                                        {
252 
253     m_lock\&.lock();
254 
255     // Store the thread
256     m_threads\&.push_back(thread);
257     thread\->parent_pid = m_pid;
258 
259     m_lock\&.unlock();
260 }
.fi

.PP
References \fBMaxOS::common::Spinlock::lock()\fP, and \fBMaxOS::common::Spinlock::unlock()\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fBProcess()\fP\&.
.SS "\fBuint64_t\fP Process::pid () const"

.PP
Gets the pid of the process\&. 
.PP
\fBReturns\fP
.RS 4
The pid of the process 
.RE
.PP

.PP
Definition at line \fB319\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
319                             {
320 
321     return m_pid;
322 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::current_process()\fP, \fBMaxOS::processes::GlobalScheduler::force_remove_process()\fP, \fBMaxOS::processes::Scheduler::get_process()\fP, \fBMaxOS::processes::GlobalScheduler::remove_process()\fP, and \fBset_pid()\fP\&.
.SS "\fBvoid\fP Process::remove_thread (\fBuint64_t\fP tid)"

.PP
Remove a thread by its tid (NOTE: this will not remove it from the scheduler) 
.PP
\fBParameters\fP
.RS 4
\fItid\fP 
.RE
.PP

.PP
Definition at line \fB267\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
267                                         {
268 
269     // Find the thread
270     for (uint32_t i = 0; i < m_threads\&.size(); i++) {
271 
272         // Thread is not what is being removed
273         if (m_threads[i]\->tid != tid)
274             continue;
275 
276         // Delete the thread
277         Thread* thread = m_threads[i];
278         delete thread;
279 
280         // Remove the thread from the list
281         m_threads\&.erase(m_threads\&.begin() + i);
282         return;
283     }
284 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::force_remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBvoid\fP Process::set_pid (\fBuint64_t\fP pid)"

.PP
Sets the pid of the process once added to the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP 
.RE
.PP

.PP
Definition at line \fB291\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
291                                   {
292 
293     // Check if the pid is already set
294     if (m_pid != 0)
295         return;
296 
297     // Set the pid
298     m_pid = pid;
299 
300     // Assign the pid to the threads
301     for (auto thread: m_threads)
302         thread\->parent_pid = pid;
303 
304 }
.fi

.PP
References \fBpid()\fP\&.
.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP\&.
.SS "\fBVector\fP< \fBThread\fP * > Process::threads ()"

.PP
Gets the threads of the process\&. 
.PP
Definition at line \fB309\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
309                                  {
310 
311     return m_threads;
312 }
.fi

.PP
Referenced by \fBMaxOS::processes::Scheduler::add_process()\fP, \fBMaxOS::processes::Scheduler::force_remove_process()\fP, \fBMaxOS::processes::Scheduler::remove_process()\fP, and \fBMaxOS::processes::Scheduler::schedule_next()\fP\&.
.SS "\fBuint64_t\fP Process::total_ticks ()"

.PP
Gets the total ticks of the threads in the process (not this does not include any past killed threads) 
.PP
\fBReturns\fP
.RS 4
The total ticks of the threads in the process 
.RE
.PP

.PP
Definition at line \fB329\fP of file \fBprocess\&.cpp\fP\&..PP
.nf
329                               {
330 
331     uint64_t total_ticks = 0;
332     for (auto thread: m_threads)
333         total_ticks += thread\->ticks;
334 
335     return total_ticks;
336 }
.fi

.PP
References \fBtotal_ticks()\fP\&.
.PP
Referenced by \fBtotal_ticks()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool MaxOS::processes::Process::is_kernel"

.PP
Whether this process is a kernel process\&. 
.PP
Definition at line \fB106\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fB~Process()\fP\&.
.SS "\fBmemory::MemoryManager\fP* MaxOS::processes::Process::memory_manager = nullptr"

.PP
The manager for memory used by this process\&. 
.PP
Definition at line \fB111\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBProcess()\fP, and \fB~Process()\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::name"

.PP
The name of the process\&. 
.PP
Definition at line \fB108\fP of file \fBprocess\&.h\fP\&.
.PP
Referenced by \fBMaxOS::processes::GlobalScheduler::add_process()\fP, and \fB~Process()\fP\&.
.SS "\fBResourceManager\fP MaxOS::processes::Process::resource_manager"

.PP
The manger for resources used by this process\&. 
.PP
Definition at line \fB112\fP of file \fBprocess\&.h\fP\&.
.SS "\fBstring\fP MaxOS::processes::Process::working_directory = '/'"

.PP
The working directory of the process\&. 
.PP
Definition at line \fB109\fP of file \fBprocess\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "maxOS::memory::MemoryManager" 3 "Mon Jan 8 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::memory::MemoryManager \- Handles memory allocation and deallocation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <memorymanagement\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMemoryManager\fP (\fBsystem::multiboot_info_t\fP *boot_info)"
.br
.ti -1c
.RI "\fB~MemoryManager\fP ()"
.br
.ti -1c
.RI "void * \fBmalloc\fP (size_t \fBsize\fP)"
.br
.RI "Allocates a block of memory\&. "
.ti -1c
.RI "void \fBfree\fP (void *pointer)"
.br
.RI "Frees a block of memory\&. "
.ti -1c
.RI "int \fBmemory_used\fP ()"
.br
.RI "Returns the amount of memory used\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBMemoryManager\fP * \fBs_active_memory_manager\fP = 0"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBMemoryChunk\fP * \fBm_first_memory_chunk\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handles memory allocation and deallocation\&. 
.PP
Definition at line 34 of file memorymanagement\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MemoryManager::MemoryManager (\fBsystem::multiboot_info_t\fP * boot_info)"

.PP
Definition at line 12 of file memorymanagement\&.cpp\&.
.PP
.nf
13 {
14 
15 
16     size_t  heap = 10*1024*1024;
17     size_t  size = boot_info->mem_upper*1024 - heap - 10*1024;
18 
19     s_active_memory_manager = this;
20 
21     //Prevent wiring outside the area that is allowed to write
22     if(size < sizeof(MemoryChunk)){
23 
24         this ->m_first_memory_chunk = 0;
25 
26     }else{
27 
28         this ->m_first_memory_chunk = (MemoryChunk*)heap;
29         m_first_memory_chunk-> allocated = false;
30         m_first_memory_chunk-> prev = 0;
31         m_first_memory_chunk-> next = 0;
32         m_first_memory_chunk-> size = size - sizeof(MemoryChunk);
33     }
34 }
.fi
.PP
References m_first_memory_chunk, maxOS::system::multiboot_info::mem_upper, s_active_memory_manager, and size\&.
.SS "MemoryManager::~MemoryManager ()"

.PP
Definition at line 36 of file memorymanagement\&.cpp\&.
.PP
.nf
36                               {
37     if(s_active_memory_manager == this)
38       s_active_memory_manager = 0;
39 }
.fi
.PP
References s_active_memory_manager\&.
.SH "Member Function Documentation"
.PP 
.SS "void MemoryManager::free (void * pointer)"

.PP
Frees a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP A pointer to the block 
.RE
.PP

.PP
Definition at line 95 of file memorymanagement\&.cpp\&.
.PP
.nf
95                                       {
96 
97 
98     // Create a new free chunk
99     MemoryChunk* chunk = (MemoryChunk*)((size_t)pointer - sizeof(MemoryChunk));
100     chunk -> allocated = false;
101 
102     // If there is a free chunk before this chunk then merge them
103     if(chunk -> prev != 0 && !chunk -> prev -> allocated){
104 
105         // Increase the previous chunk's size and remove the current chunk from the linked list
106         chunk->prev->size += chunk->size + sizeof(MemoryChunk);
107         chunk -> prev -> next = chunk -> next;
108 
109         // If there is a next chunk then ensure this chunk is removed from its linked list
110         if(chunk -> next != 0)
111             chunk -> next -> prev = chunk->prev;
112 
113         // Chunk is now the previous chunk
114         chunk = chunk -> prev;
115 
116     }
117 
118     // If there is a free chunk after this chunk then merge them
119     if(chunk -> next != 0 && !chunk -> next -> allocated){
120 
121         // Increase the current chunk's size and remove the next chunk from the linked list
122         chunk -> size += chunk -> next -> size + sizeof(MemoryChunk);
123         chunk -> next = chunk -> next -> next;
124 
125         // Remove the just merged chunk from the linked list
126         if(chunk -> next != 0)
127             chunk -> next -> prev = chunk;
128 
129     }
130 }
.fi
.PP
References maxOS::memory::MemoryChunk::prev, size, and maxOS::memory::MemoryChunk::size\&.
.SS "void * MemoryManager::malloc (size_t size)"

.PP
Allocates a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP size of the block 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the block, 0 if no block is available 
.RE
.PP

.PP
Definition at line 47 of file memorymanagement\&.cpp\&.
.PP
.nf
47                                        {
48 
49     MemoryChunk* result = 0;
50 
51     // Find the next free chunk that is big enough
52     for (MemoryChunk* chunk = m_first_memory_chunk; chunk != 0 && result == 0; chunk = chunk->next) {
53         if(chunk -> size > size && !chunk -> allocated)
54             result = chunk;
55     }
56 
57     // If there is no free chunk then return 0
58     if(result == 0)
59         return 0;
60 
61     // If there is space to split the chunk
62     if(result -> size < size + sizeof(MemoryChunk) + 1) {
63         result->allocated = true;
64         return (void *)(((size_t)result) + sizeof(MemoryChunk));
65     }
66 
67 
68     // Create a new chunk after the current one
69     MemoryChunk* temp = (MemoryChunk*)((size_t)result + sizeof(MemoryChunk) + size);
70 
71     // Set the new chunk's properties and insert it into the linked list
72     temp -> allocated = false;
73     temp -> size =  result->size - size - sizeof(MemoryChunk);
74     temp -> prev = result;
75     temp -> next = result -> next;
76 
77     // If there is a chunk after the current one then set its previous to the new chunk
78     if(temp -> next != 0)
79        temp -> next -> prev = temp;
80 
81     // Current chunk is now allocated and is pointing to the new chunk
82     result->size = size;
83     result -> allocated = true;
84     result->next = temp;
85 
86     return (void*)(((size_t)result) + sizeof(MemoryChunk));
87 }
.fi
.PP
References maxOS::memory::MemoryChunk::allocated, m_first_memory_chunk, maxOS::memory::MemoryChunk::next, size, and maxOS::memory::MemoryChunk::size\&.
.SS "int MemoryManager::memory_used ()"

.PP
Returns the amount of memory used\&. 
.PP
\fBReturns\fP
.RS 4
The amount of memory used 
.RE
.PP

.PP
Definition at line 136 of file memorymanagement\&.cpp\&.
.PP
.nf
136                                {
137 
138         int result = 0;
139 
140         // Loop through all the chunks and add up the size of the allocated chunks
141         for (MemoryChunk* chunk = m_first_memory_chunk; chunk != 0; chunk = chunk->next)
142             if(chunk -> allocated)
143                 result += chunk -> size;
144 
145         return result;
146 }
.fi
.PP
References m_first_memory_chunk, maxOS::memory::MemoryChunk::next, and size\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBMemoryChunk\fP* maxOS::memory::MemoryManager::m_first_memory_chunk\fC [protected]\fP"

.PP
Definition at line 37 of file memorymanagement\&.h\&.
.PP
Referenced by malloc(), memory_used(), and MemoryManager()\&.
.SS "\fBMemoryManager\fP * MemoryManager::s_active_memory_manager = 0\fC [static]\fP"

.PP
Definition at line 40 of file memorymanagement\&.h\&.
.PP
Referenced by MemoryManager(), operator delete(), operator delete[](), operator new(), operator new[](), and ~MemoryManager()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

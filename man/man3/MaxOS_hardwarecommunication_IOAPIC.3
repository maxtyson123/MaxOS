.TH "MaxOS::hardwarecommunication::IOAPIC" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::IOAPIC
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIOAPIC\fP (\fBAdvancedConfigurationAndPowerInterface\fP *acpi)"
.br
.ti -1c
.RI "\fB~IOAPIC\fP ()"
.br
.ti -1c
.RI "uint32_t \fBread\fP (uint32_t reg) const"
.br
.RI "Read a value from a IO Apic register\&. "
.ti -1c
.RI "void \fBwrite\fP (uint32_t reg, uint32_t value) const"
.br
.RI "Write a value to an IO Apic register\&. "
.ti -1c
.RI "void \fBset_redirect\fP (\fBinterrupt_redirect_t\fP *redirect)"
.br
.RI "Redirect a system interrupt to a different IRQ\&. "
.ti -1c
.RI "void \fBset_redirect_mask\fP (uint8_t index, bool \fBmask\fP)"
.br
.RI "Enables/Disables an interrupt redirect by masking it\&. "
.ti -1c
.RI "void \fBinit\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB90\fP of file \fBapic\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IOAPIC::IOAPIC (\fBAdvancedConfigurationAndPowerInterface\fP * acpi)"

.PP
Definition at line \fB119\fP of file \fBapic\&.cpp\fP\&..PP
.nf
120 : m_acpi(acpi)
121 {
122 
123     // Get the information about the IO APIC
124     m_madt = (MADT*) m_acpi\->find("APIC");
125     MADT_Item* io_apic_item = get_madt_item(1, 0);
126 
127     // Get the IO APIC
128     auto* io_apic = (MADT_IOAPIC*) PhysicalMemoryManager::to_io_region((uint64_t) io_apic_item + sizeof(MADT_Item));
129     PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) io_apic_item, (virtual_address_t*) (io_apic \- sizeof(MADT_Item)), Present | Write);
130 
131     // Map the IO APIC address to the higher half
132     m_address = io_apic\->io_apic_address;
133     m_address_high = (uint64_t) PhysicalMemoryManager::to_io_region(m_address);
134     PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) m_address, (virtual_address_t*) m_address_high, Present | Write);
135     Logger::DEBUG() << "IO APIC Address: phy=0x" << m_address << ", virt=0x" << m_address_high << "\\n";
136 
137     // Get the IO APIC version and max redirection entry
138     m_version = read(0x1);
139     m_max_redirect_entry = (uint8_t) (m_version >> 16);
140 
141     // Log the IO APIC information
142     Logger::DEBUG() << "IO APIC Version: 0x" << (uint64_t) (m_version & 0xFF) << "\\n";
143     Logger::DEBUG() << "IO APIC Max Redirection Entry: 0x" << (uint64_t) m_max_redirect_entry << "\\n";
144 
145     // Get the source override item
146     MADT_Item* source_override_item = get_madt_item(2, m_override_array_size);
147     uint32_t total_length = sizeof(MADT);
148     while (total_length < m_madt\->header\&.length && m_override_array_size < 0x10) { // 0x10 is the max items
149 
150         total_length += source_override_item\->length;
151 
152         // If there is an override, populate the array
153         if (source_override_item != nullptr && source_override_item\->type == 2) {
154 
155             // Get the override and populate the array
156             auto* override = (Override*) (source_override_item + 1);
157             m_override_array[m_override_array_size]\&.bus = override\->bus;
158             m_override_array[m_override_array_size]\&.source = override\->source;
159             m_override_array[m_override_array_size]\&.global_system_interrupt = override\->global_system_interrupt;
160             m_override_array[m_override_array_size]\&.flags = override\->flags;
161             m_override_array_size++;
162         }
163 
164         // Get the next item
165         source_override_item = get_madt_item(2, m_override_array_size);
166         if (source_override_item == nullptr)
167             break;
168     }
169 
170     Logger::DEBUG() << "IO APIC Source Overrides: 0x" << m_override_array_size << "\\n";
171 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::Override::bus\fP, \fBLogger::DEBUG()\fP, \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find()\fP, \fBMaxOS::hardwarecommunication::Override::flags\fP, \fBMaxOS::hardwarecommunication::Override::global_system_interrupt\fP, \fBheader\fP, \fBMaxOS::hardwarecommunication::ACPISDTHeader::length\fP, \fBMaxOS::hardwarecommunication::MADT_Item::length\fP, \fBMaxOS::memory::PhysicalMemoryManager::map()\fP, \fBMaxOS::memory::Present\fP, \fBread()\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::hardwarecommunication::Override::source\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_io_region()\fP, \fBMaxOS::hardwarecommunication::MADT_Item::type\fP, and \fBMaxOS::memory::Write\fP\&.
.SS "IOAPIC::~IOAPIC ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void MaxOS::hardwarecommunication::IOAPIC::init ()"

.SS "uint32_t IOAPIC::read (uint32_t reg) const"

.PP
Read a value from a IO Apic register\&. 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to read from 
.RE
.PP
\fBReturns\fP
.RS 4
The value at the register 
.RE
.PP

.PP
Definition at line \fB218\fP of file \fBapic\&.cpp\fP\&..PP
.nf
218                                         {
219 
220     // Tell the APIC what register to read from
221     *(volatile uint32_t*) (m_address_high + 0x00) = reg;
222 
223     // Read the value
224     return *(volatile uint32_t*) (m_address_high + 0x10);
225 }
.fi

.PP
Referenced by \fBIOAPIC()\fP\&.
.SS "void IOAPIC::set_redirect (\fBinterrupt_redirect_t\fP * redirect)"

.PP
Redirect a system interrupt to a different IRQ\&. 
.PP
\fBParameters\fP
.RS 4
\fIredirect\fP The redirection entry 
.RE
.PP

.PP
Definition at line \fB287\fP of file \fBapic\&.cpp\fP\&..PP
.nf
287                                                         {
288 
289     // Create the redirection entry
290     RedirectionEntry entry = {};
291     entry\&.raw = redirect\->flags | (redirect\->interrupt & 0xFF);
292     entry\&.destination = redirect\->destination;
293     entry\&.mask = redirect\->mask;
294 
295     // Check if a global system interrupt is used
296     for (uint8_t i = 0; i < m_override_array_size; i++) {
297 
298         if (m_override_array[i]\&.source != redirect\->type)
299             continue;
300 
301         // Set the lower 4 bits of the pin
302         entry\&.pin_polarity = ((m_override_array[i]\&.flags & 0b11) == 2) ? 0b1 : 0b0;
303         entry\&.pin_polarity = (((m_override_array[i]\&.flags >> 2) & 0b11) == 2) ? 0b1 : 0b0;
304 
305         // Set the trigger mode
306         entry\&.trigger_mode = (((m_override_array[i]\&.flags >> 2) & 0b11) == 2);
307         break;
308 
309     }
310 
311     // Write the redirect
312     write_redirect(redirect\->index, &entry);
313 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::RedirectionEntry::destination\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::destination\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::flags\fP, \fBMaxOS::hardwarecommunication::Override::flags\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::index\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::interrupt\fP, \fBMaxOS::hardwarecommunication::RedirectionEntry::mask\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::mask\fP, \fBMaxOS::hardwarecommunication::RedirectionEntry::pin_polarity\fP, \fBMaxOS::hardwarecommunication::RedirectionEntry::raw\fP, \fBsource\fP, \fBMaxOS::hardwarecommunication::RedirectionEntry::trigger_mode\fP, and \fBMaxOS::hardwarecommunication::InterruptRedirect::type\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\fP, and \fBMaxOS::drivers::clock::PIT::ticks_per_ms()\fP\&.
.SS "void IOAPIC::set_redirect_mask (uint8_t index, bool mask)"

.PP
Enables/Disables an interrupt redirect by masking it\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the redirect mask 
.br
\fImask\fP True = masked = disabled, False = unmasked = enabled 
.RE
.PP

.PP
Definition at line \fB321\fP of file \fBapic\&.cpp\fP\&..PP
.nf
321                                                        {
322 
323     // Read the current entry
324     RedirectionEntry entry = {};
325     read_redirect(index, &entry);
326 
327     // Set the mask
328     entry\&.mask = mask;
329     write_redirect(index, &entry);
330 }
.fi

.PP
References \fBmask\fP, and \fBMaxOS::hardwarecommunication::RedirectionEntry::mask\fP\&.
.PP
Referenced by \fBMaxOS::drivers::clock::PIT::ticks_per_ms()\fP\&.
.SS "void IOAPIC::write (uint32_t reg, uint32_t value) const"

.PP
Write a value to an IO Apic register\&. 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to write to 
.br
\fIvalue\fP The value to set the register to 
.RE
.PP
\fBReturns\fP
.RS 4
The value at the register 
.RE
.PP

.PP
Definition at line \fB234\fP of file \fBapic\&.cpp\fP\&..PP
.nf
234                                                      {
235 
236     // Write the register
237     *(volatile uint32_t*) (m_address_high + 0x00) = reg;
238 
239     // Write the value
240     *(volatile uint32_t*) (m_address_high + 0x10) = value;
241 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

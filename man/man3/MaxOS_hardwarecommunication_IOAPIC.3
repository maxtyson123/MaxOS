.TH "MaxOS::hardwarecommunication::IOAPIC" 3 "Sun Oct 13 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::IOAPIC
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIOAPIC\fP (\fBAdvancedConfigurationAndPowerInterface\fP *acpi)"
.br
.ti -1c
.RI "\fB~IOAPIC\fP ()"
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 80 of file apic\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IOAPIC::IOAPIC (\fBAdvancedConfigurationAndPowerInterface\fP * acpi)"

.PP
Definition at line 100 of file apic\&.cpp\&.
.PP
.nf
101 : m_acpi(acpi),
102   m_madt(nullptr)
103 {
104 
105 }
.fi
.SS "IOAPIC::~IOAPIC ()"

.PP
Definition at line 107 of file apic\&.cpp\&.
.PP
.nf
107                 {
108 
109 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void IOAPIC::init ()"

.PP
Definition at line 111 of file apic\&.cpp\&.
.PP
.nf
111                   {
112 
113   // Get the information about the IO APIC
114   m_madt = (MADT*)m_acpi->find("APIC");
115   MADT_Item* io_apic_item = get_madt_item(1, 0);
116 
117   // Check if the IO APIC was found
118   ASSERT(io_apic_item == nullptr, "IO APIC not found")
119 
120 
121   // Get the IO APIC address
122   MADT_IOAPIC* io_apic = (MADT_IOAPIC*)io_apic_item;
123   m_address = io_apic->io_apic_address;
124 
125   // Map the IO APIC address to the higher half
126   m_address_high = (uint64_t)MemoryManager::to_higher_region(m_address);
127   _kprintf("IO APIC Address: phy=0x%x, virt=0x%x\n", m_address, m_address_high);
128   PhysicalMemoryManager::s_current_manager->map((physical_address_t*)m_address, (virtual_address_t*)m_address_high, Present | Write);
129 
130   // Get the IO APIC version and max redirection entry
131   m_version = read(0x01);
132   m_max_redirect_entry = (uint8_t)(m_version >> 16);
133 
134   // Log the IO APIC information
135   _kprintf("IO APIC Version: 0x%x\n", m_version);
136   _kprintf("IO APIC Max Redirection Entry: 0x%x\n", m_max_redirect_entry);
137 
138   // Get the source override item
139   MADT_Item* source_override_item = get_madt_item(2, m_override_array_size);
140 
141   // Loop through the source override items
142   uint32_t total_length = 0;
143   while (total_length < m_madt->header\&.length && m_override_array_size < 0x10){ // 0x10 is the max items
144 
145       // Increment the total length
146       total_length += source_override_item->length;
147 
148       // If there is an override, populate the array
149       if(source_override_item != nullptr && source_override_item->type == 2) {
150 
151           // Get the override and populate the array
152           Override *override = (Override *)(source_override_item + 1);
153           m_override_array[m_override_array_size]\&.bus = override->bus;
154           m_override_array[m_override_array_size]\&.source = override->source;
155           m_override_array[m_override_array_size]\&.global_system_interrupt =
156               override->global_system_interrupt;
157           m_override_array[m_override_array_size]\&.flags = override->flags;
158 
159           // Increment the override array size
160           m_override_array_size++;
161       }
162 
163       // Get the next item
164       source_override_item = get_madt_item(2, m_override_array_size);
165 
166       // If there is no next item then break
167       if(source_override_item == nullptr)
168           break;
169   }
170 
171   // Log how many overrides were found
172   _kprintf("IO APIC Source Overrides: 0x%x\n", m_override_array_size);
173 }
.fi
.PP
References _kprintf, ASSERT, MaxOS::hardwarecommunication::Override::bus, MaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find(), MaxOS::hardwarecommunication::Override::flags, MaxOS::hardwarecommunication::Override::global_system_interrupt, header, MaxOS::hardwarecommunication::MADT_IOAPIC::io_apic_address, MaxOS::hardwarecommunication::ACPISDTHeader::length, MaxOS::hardwarecommunication::MADT_Item::length, MaxOS::memory::Present, MaxOS::hardwarecommunication::Override::source, MaxOS::hardwarecommunication::MADT_Item::type, and MaxOS::memory::Write\&.
.PP
Referenced by MaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::AdvancedProgrammableInterruptController()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::hardwarecommunication::IOAPIC" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::hardwarecommunication::IOAPIC \- Handles the IO APIC in the system (one per system)  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <apic\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIOAPIC\fP (\fBAdvancedConfigurationAndPowerInterface\fP *acpi)"
.br
.RI "Construct a new IO APIC object\&. Maps the IO APIC registers and reads the \fBMADT\fP to get information about the IO APICs and interrupt source overrides\&. "
.ti -1c
.RI "uint32_t \fBread\fP (uint32_t reg) const"
.br
.RI "read a value from a IO Apic register "
.ti -1c
.RI "void \fBwrite\fP (uint32_t reg, uint32_t value) const"
.br
.RI "write a value to an IO Apic register "
.ti -1c
.RI "void \fBset_redirect\fP (\fBinterrupt_redirect_t\fP *redirect)"
.br
.RI "Redirect a system interrupt to a different IRQ\&. "
.ti -1c
.RI "void \fBset_redirect_mask\fP (uint8_t index, bool mask)"
.br
.RI "Enables/Disables an interrupt redirect by masking it\&. "
.ti -1c
.RI "\fBMADTEntry\fP * \fBget_madt_item\fP (\fBMADT_TYPE\fP type, uint8_t index)"
.br
.RI "Get an item in the \fBMADT\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Handles the IO APIC in the system (one per system) 
.PP
Definition at line \fB193\fP of file \fBapic\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IOAPIC::IOAPIC (\fBAdvancedConfigurationAndPowerInterface\fP * acpi)\fC [explicit]\fP"

.PP
Construct a new IO APIC object\&. Maps the IO APIC registers and reads the \fBMADT\fP to get information about the IO APICs and interrupt source overrides\&. 
.PP
\fBParameters\fP
.RS 4
\fIacpi\fP The ACPI interface to get the \fBMADT\fP from 
.RE
.PP

.PP
Definition at line \fB198\fP of file \fBapic\&.cpp\fP\&..PP
.nf
199 : m_acpi(acpi)
200 {
201 
202     // Get the information about the IO APIC
203     m_madt = (MADT*) m_acpi\->find("APIC");
204     MADTEntry* io_apic_item = get_madt_item(MADT_TYPE::IO_APIC, 0);
205 
206     // Get the IO APIC
207     auto* io_apic = (MADT_IO_APIC*) PhysicalMemoryManager::to_io_region((uint64_t) io_apic_item + sizeof(MADTEntry));
208     PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) io_apic_item, (virtual_address_t*) (io_apic \- sizeof(MADTEntry)), PRESENT | WRITE);
209 
210     // Map the IO APIC address to the higher half
211     m_address = io_apic\->io_apic_address;
212     m_address_high = (uint64_t) PhysicalMemoryManager::to_io_region(m_address);
213     PhysicalMemoryManager::s_current_manager\->map((physical_address_t*) m_address, (virtual_address_t*) m_address_high, PRESENT | WRITE);
214     Logger::DEBUG() << "IO APIC Address: phy=0x" << m_address << ", virt=0x" << m_address_high << "\\n";
215 
216     // Get the IO APIC version and max redirection entry
217     m_version = read(0x1);
218     m_max_redirect_entry = (uint8_t) (m_version >> 16);
219 
220     // Log the IO APIC information
221     Logger::DEBUG() << "IO APIC Version: 0x" << (uint64_t) (m_version & 0xFF) << "\\n";
222     Logger::DEBUG() << "IO APIC Max Redirection Entry: 0x" << (uint64_t) m_max_redirect_entry << "\\n";
223 
224     // Get the source override item
225     MADTEntry* source_override_item = get_madt_item(MADT_TYPE::IO_APIC, m_override_array_size);
226     uint32_t total_length = sizeof(MADT);
227     while (total_length < m_madt\->header\&.length && m_override_array_size < 0x10) { // 0x10 is the max items
228 
229         total_length += source_override_item\->length;
230 
231         // If there is an override, populate the array
232         if (source_override_item != nullptr && source_override_item\->type == 2) {
233 
234             // Get the override and populate the array
235             auto* override = (Override*) (source_override_item + 1);
236             m_override_array[m_override_array_size]\&.bus = override\->bus;
237             m_override_array[m_override_array_size]\&.source = override\->source;
238             m_override_array[m_override_array_size]\&.global_system_interrupt = override\->global_system_interrupt;
239             m_override_array[m_override_array_size]\&.flags = override\->flags;
240             m_override_array_size++;
241         }
242 
243         // Get the next item
244         source_override_item = get_madt_item(MADT_TYPE::IO_APIC, m_override_array_size);
245         if (source_override_item == nullptr)
246             break;
247     }
248 
249     Logger::DEBUG() << "IO APIC Source Overrides: 0x" << m_override_array_size << "\\n";
250 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::Override::bus\fP, \fBMaxOS::Logger::DEBUG()\fP, \fBMaxOS::hardwarecommunication::AdvancedConfigurationAndPowerInterface::find()\fP, \fBMaxOS::hardwarecommunication::Override::flags\fP, \fBget_madt_item()\fP, \fBMaxOS::hardwarecommunication::Override::global_system_interrupt\fP, \fBMaxOS::hardwarecommunication::MADTEntry::length\fP, \fBMaxOS::memory::PhysicalMemoryManager::map()\fP, \fBMaxOS::memory::PRESENT\fP, \fBread()\fP, \fBMaxOS::memory::PhysicalMemoryManager::s_current_manager\fP, \fBMaxOS::hardwarecommunication::Override::source\fP, \fBMaxOS::memory::PhysicalMemoryManager::to_io_region()\fP, \fBMaxOS::hardwarecommunication::MADTEntry::type\fP, and \fBMaxOS::memory::WRITE\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBMADTEntry\fP * IOAPIC::get_madt_item (\fBMADT_TYPE\fP type, uint8_t index)"

.PP
Get an item in the \fBMADT\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The type of item 
.br
\fIindex\fP The index of the item 
.RE
.PP
\fBReturns\fP
.RS 4
The item or null if not found 
.RE
.PP

.PP
Definition at line \fB261\fP of file \fBapic\&.cpp\fP\&..PP
.nf
261                                                               {
262 
263     // The item starts at the start of the MADT
264     auto* item = (MADTEntry*) ((uint64_t) m_madt + sizeof(MADT));
265     uint64_t total_length = 0;
266     uint8_t current_index = 0;
267 
268     // Loop through the items
269     while (total_length + sizeof(MADT) < m_madt\->header\&.length && current_index <= index) {
270 
271         // Correct type
272         if (item\->type == (uint8_t)type) {
273 
274             // Correct index means found
275             if (current_index == index)
276                 return item;
277 
278             // Right type wrong index so move on
279             current_index++;
280         }
281 
282         // Increment the total length
283         total_length += item\->length;
284         item = (MADTEntry*) ((uint64_t) item + item\->length);
285     }
286 
287     // No item found
288     return nullptr;
289 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::MADT::header\fP, \fBMaxOS::hardwarecommunication::ACPISDTHeader::length\fP, and \fBMaxOS::hardwarecommunication::MADTEntry::length\fP\&.
.PP
Referenced by \fBMaxOS::system::CPU::find_cores()\fP, and \fBIOAPIC()\fP\&.
.SS "uint32_t IOAPIC::read (uint32_t reg) const"

.PP
read a value from a IO Apic register 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to read from 
.RE
.PP
\fBReturns\fP
.RS 4
The value at the register 
.RE
.PP

.PP
Definition at line \fB297\fP of file \fBapic\&.cpp\fP\&..PP
.nf
297                                         {
298 
299     // Tell the APIC what register to read from
300     *(volatile uint32_t*) (m_address_high + 0x00) = reg;
301 
302     // Read the value
303     return *(volatile uint32_t*) (m_address_high + 0x10);
304 }
.fi

.PP
Referenced by \fBIOAPIC()\fP\&.
.SS "void IOAPIC::set_redirect (\fBinterrupt_redirect_t\fP * redirect)"

.PP
Redirect a system interrupt to a different IRQ\&. 
.PP
\fBParameters\fP
.RS 4
\fIredirect\fP The redirection entry 
.RE
.PP

.PP
Definition at line \fB365\fP of file \fBapic\&.cpp\fP\&..PP
.nf
365                                                         {
366 
367     // Create the redirection entry
368     RedirectionEntry entry = {};
369     entry\&.raw = redirect\->flags | (redirect\->interrupt & 0xFF);
370     entry\&.destination = redirect\->destination;
371     entry\&.mask = redirect\->mask;
372 
373     // Check if a global system interrupt is used
374     for (uint8_t i = 0; i < m_override_array_size; i++) {
375 
376         if (m_override_array[i]\&.source != redirect\->type)
377             continue;
378 
379         // Set the lower 4 bits of the pin
380         entry\&.pin_polarity = ((m_override_array[i]\&.flags & 0b11) == 2) ? 0b1 : 0b0;
381         entry\&.pin_polarity = (((m_override_array[i]\&.flags >> 2) & 0b11) == 2) ? 0b1 : 0b0;
382 
383         // Set the trigger mode
384         entry\&.trigger_mode = (((m_override_array[i]\&.flags >> 2) & 0b11) == 2);
385         break;
386 
387     }
388 
389     // Write the redirect
390     write_redirect(redirect\->index, &entry);
391 }
.fi

.PP
References \fBMaxOS::hardwarecommunication::InterruptRedirect::destination\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::flags\fP, \fBMaxOS::hardwarecommunication::Override::flags\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::index\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::interrupt\fP, \fBMaxOS::hardwarecommunication::InterruptRedirect::mask\fP, \fBMaxOS::hardwarecommunication::RedirectionEntry::raw\fP, and \fBMaxOS::hardwarecommunication::InterruptRedirect::type\fP\&.
.PP
Referenced by \fBMaxOS::hardwarecommunication::InterruptHandler::InterruptHandler()\fP\&.
.SS "void IOAPIC::set_redirect_mask (uint8_t index, bool mask)"

.PP
Enables/Disables an interrupt redirect by masking it\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The index of the redirect mask 
.br
\fImask\fP True = masked = disabled, False = unmasked = enabled 
.RE
.PP

.PP
Definition at line \fB399\fP of file \fBapic\&.cpp\fP\&..PP
.nf
399                                                        {
400 
401     // Read the current entry
402     RedirectionEntry entry = {};
403     read_redirect(index, &entry);
404 
405     // Set the mask
406     entry\&.mask = mask;
407     write_redirect(index, &entry);
408 }
.fi

.SS "void IOAPIC::write (uint32_t reg, uint32_t value) const"

.PP
write a value to an IO Apic register 
.PP
\fBParameters\fP
.RS 4
\fIreg\fP The register to write to 
.br
\fIvalue\fP The value to set the register to 
.RE
.PP

.PP
Definition at line \fB312\fP of file \fBapic\&.cpp\fP\&..PP
.nf
312                                                      {
313 
314     // Write the register
315     *(volatile uint32_t*) (m_address_high + 0x00) = reg;
316 
317     // Write the value
318     *(volatile uint32_t*) (m_address_high + 0x10) = value;
319 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::gui::Font" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::gui::Font \- A class that can be used to draw text\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <font\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFont\fP (\fBconst\fP \fBuint8_t\fP *\fBfont_data\fP)"
.br
.ti -1c
.RI "\fB~Font\fP ()"
.br
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdraw_text\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP *\fBcontext\fP, \fBstring\fP text)"
.br
.RI "write the entire text to the screen "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBdraw_text\fP (\fBint32_t\fP x, \fBint32_t\fP y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP *\fBcontext\fP, \fBstring\fP text, \fBcommon::Rectangle\fP< \fBint32_t\fP > \fBlimitArea\fP)"
.br
.RI "write the entire text to the screen "
.ti -1c
.RI "\fBvirtual\fP \fBint32_t\fP \fBget_text_height\fP (\fBstring\fP)"
.br
.RI "Get the height of the text\&. "
.ti -1c
.RI "\fBvirtual\fP \fBint32_t\fP \fBget_text_width\fP (\fBstring\fP)"
.br
.RI "Get the width of the text\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBis_bold\fP { false }"
.br
.ti -1c
.RI "bool \fBis_italic\fP { false }"
.br
.ti -1c
.RI "bool \fBis_underlined\fP { false }"
.br
.ti -1c
.RI "bool \fBis_strikethrough\fP { false }"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const uint8_t \fBpadding\fP = 3"
.br
.ti -1c
.RI "static const uint16_t \fBfont_height\fP = 8 + 2 * \fBpadding\fP"
.br
.ti -1c
.RI "static const uint16_t \fBfont_width\fP = 8"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBm_is_8_by_8\fP = { true }"
.br
.ti -1c
.RI "uint8_t \fBm_font8x8\fP [2048] = {0}"
.br
.in -1c
.SH "Detailed Description"
.PP 
A class that can be used to draw text\&. 
.PP
Definition at line \fB21\fP of file \fBfont\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Font::Font (\fBconst\fP \fBuint8_t\fP * font_data)"

.PP
Definition at line \fB11\fP of file \fBfont\&.cpp\fP\&..PP
.nf
11                                    {
12 
13     // Store the font data
14     for (int i = 0; i < 2048; ++i) {
15         m_font8x8[i] = font_data[i];
16     }
17 }
.fi

.PP
References \fBm_font8x8\fP\&.
.SS "Font::~Font ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP Font::draw_text (\fBint32_t\fP x, \fBint32_t\fP y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP * context, \fBstring\fP text)\fC [virtual]\fP"

.PP
write the entire text to the screen 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the text 
.br
\fIy\fP The y coordinate of the text 
.br
\fIcontext\fP The graphics context to draw the text on 
.br
\fItext\fP The text to draw 
.RE
.PP

.PP
Definition at line \fB28\fP of file \fBfont\&.cpp\fP\&..PP
.nf
30                                                                   {
31 
32     // Calculate the rectangle of the text
33     int32_t top = 0;
34     int32_t left = 0;
35     int32_t width = get_text_width(text);
36     int32_t height = get_text_height(text);
37 
38     // Create the rectangle
39     Rectangle<int32_t> text_area(left, top, width, height);
40 
41     // Draw the text
42     draw_text(x, y, foreground_colour, background_colour, context, text, text_area);
43 }
.fi

.PP
References \fBdraw_text()\fP, \fBget_text_height()\fP, and \fBget_text_width()\fP\&.
.PP
Referenced by \fBMaxOS::gui::widgets::Button::draw()\fP, \fBMaxOS::gui::widgets::InputBox::draw()\fP, \fBMaxOS::gui::widgets::Text::draw()\fP, \fBdraw_text()\fP, and \fBMaxOS::drivers::console::VESABootConsole::put_character()\fP\&.
.SS "\fBvoid\fP Font::draw_text (\fBint32_t\fP x, \fBint32_t\fP y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP * context, \fBstring\fP text, \fBcommon::Rectangle\fP< \fBint32_t\fP > limitArea)\fC [virtual]\fP"

.PP
write the entire text to the screen 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the text 
.br
\fIy\fP The y coordinate of the text 
.br
\fIcontext\fP The graphics context to draw the text on 
.br
\fItext\fP The text to draw 
.br
\fIlimitArea\fP The area of the text to draw 
.RE
.PP

.PP
Definition at line \fB55\fP of file \fBfont\&.cpp\fP\&..PP
.nf
58                                                          {
59 
60     // Convert the colours
61     uint32_t foreground = context\->colour_to_int(foreground_colour);
62     uint32_t background = context\->colour_to_int(background_colour);
63 
64     // Ensure the area is within the actual area of the text
65     if (limitArea\&.top < 0) {
66         limitArea\&.height += limitArea\&.top;
67         limitArea\&.top = 0;
68     }
69 
70     if (limitArea\&.left < 0) {
71         limitArea\&.width += limitArea\&.left;
72         limitArea\&.left = 0;
73     }
74 
75     // Clamp the height and width max
76     if (limitArea\&.top + limitArea\&.height > (int) get_text_height(text))
77         limitArea\&.height = get_text_height(text) \- limitArea\&.top;
78 
79     if (limitArea\&.left + limitArea\&.width > (int) get_text_width(text))
80         limitArea\&.width = get_text_width(text) \- limitArea\&.left;
81 
82     // Calculate limits
83     int32_t xLimit = limitArea\&.left + limitArea\&.width;
84     int32_t yLimit = limitArea\&.top + limitArea\&.height;
85 
86     // Draw the text from top to bottom
87     for (int yBitMapOffset = limitArea\&.top; yBitMapOffset < yLimit; yBitMapOffset++) {
88         for (int xBitMapOffset = limitArea\&.left; xBitMapOffset < xLimit; ++xBitMapOffset) {
89 
90             // If the y is the middle then add a strikethrough
91             if (is_strikethrough && yBitMapOffset == yLimit / 2) {
92 
93                 // Draw the pixel
94                 context\->putPixel(x + xBitMapOffset, y + yBitMapOffset, foreground);
95                 continue;
96             }
97 
98             // If the y is the bottom then add an underline
99             if (is_underlined && yBitMapOffset == yLimit \- 1) {
100 
101                 // Draw the pixel
102                 context\->putPixel(x + xBitMapOffset, y + yBitMapOffset, foreground);
103                 continue;
104             }
105 
106             //TODO: Bold, Italic when other fonts are working
107 
108             // Get the character
109             uint8_t character = text[xBitMapOffset / 8];
110 
111             // Check if this pixel  is set or not
112             bool set = m_font8x8[(uint16_t) character * 8 + yBitMapOffset] & (128 >> (xBitMapOffset % 8));
113 
114             // Draw the pixel
115             context\->putPixel(x + xBitMapOffset, y + yBitMapOffset, set ? foreground : background);
116 
117         }
118     }
119 }
.fi

.PP
References \fBget_text_height()\fP, \fBget_text_width()\fP, \fBMaxOS::common::Rectangle< Type >::height\fP, \fBis_strikethrough\fP, \fBis_underlined\fP, \fBMaxOS::common::Rectangle< Type >::left\fP, \fBm_font8x8\fP, \fBMaxOS::common::Rectangle< Type >::top\fP, and \fBMaxOS::common::Rectangle< Type >::width\fP\&.
.SS "\fBint32_t\fP Font::get_text_height (\fBstring\fP)\fC [virtual]\fP"

.PP
Get the height of the text\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP The text to get the height of 
.RE
.PP
\fBReturns\fP
.RS 4
The height of the text 
.RE
.PP

.PP
Definition at line \fB127\fP of file \fBfont\&.cpp\fP\&..PP
.nf
127                                     {
128 
129     return 8;
130 
131 }
.fi

.PP
Referenced by \fBdraw_text()\fP, and \fBdraw_text()\fP\&.
.SS "\fBint32_t\fP Font::get_text_width (\fBstring\fP text)\fC [virtual]\fP"

.PP
Get the width of the text\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP The text to get the width of 
.RE
.PP
\fBReturns\fP
.RS 4
The width of the text 
.RE
.PP

.PP
Definition at line \fB139\fP of file \fBfont\&.cpp\fP\&..PP
.nf
139                                         {
140 
141     return text\&.length() * 8;
142 }
.fi

.PP
References \fBMaxOS::String::length()\fP\&.
.PP
Referenced by \fBdraw_text()\fP, and \fBdraw_text()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "const uint16_t MaxOS::gui::Font::font_height = 8 + 2 * \fBpadding\fP\fC [static]\fP"

.PP
Definition at line \fB33\fP of file \fBfont\&.h\fP\&.
.PP
Referenced by \fBMaxOS::drivers::console::VESABootConsole::height()\fP, \fBMaxOS::drivers::console::VESABootConsole::put_character()\fP, and \fBMaxOS::drivers::console::VESABootConsole::scroll_up()\fP\&.
.SS "const uint16_t MaxOS::gui::Font::font_width = 8\fC [static]\fP"

.PP
Definition at line \fB34\fP of file \fBfont\&.h\fP\&.
.PP
Referenced by \fBMaxOS::drivers::console::VESABootConsole::scroll_up()\fP\&.
.SS "bool MaxOS::gui::Font::is_bold { false }"

.PP
Definition at line \fB36\fP of file \fBfont\&.h\fP\&..PP
.nf
36 { false };
.fi

.SS "bool MaxOS::gui::Font::is_italic { false }"

.PP
Definition at line \fB37\fP of file \fBfont\&.h\fP\&..PP
.nf
37 { false };
.fi

.SS "bool MaxOS::gui::Font::is_strikethrough { false }"

.PP
Definition at line \fB39\fP of file \fBfont\&.h\fP\&..PP
.nf
39 { false };
.fi

.PP
Referenced by \fBdraw_text()\fP\&.
.SS "bool MaxOS::gui::Font::is_underlined { false }"

.PP
Definition at line \fB38\fP of file \fBfont\&.h\fP\&..PP
.nf
38 { false };
.fi

.PP
Referenced by \fBdraw_text()\fP\&.
.SS "uint8_t MaxOS::gui::Font::m_font8x8[2048] = {0}\fC [protected]\fP"

.PP
Definition at line \fB24\fP of file \fBfont\&.h\fP\&..PP
.nf
24 {0};
.fi

.PP
Referenced by \fBdraw_text()\fP, and \fBFont()\fP\&.
.SS "bool MaxOS::gui::Font::m_is_8_by_8 = { true }\fC [protected]\fP"

.PP
Definition at line \fB23\fP of file \fBfont\&.h\fP\&..PP
.nf
23 { true };
.fi

.SS "const uint8_t MaxOS::gui::Font::padding = 3\fC [static]\fP"

.PP
Definition at line \fB32\fP of file \fBfont\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

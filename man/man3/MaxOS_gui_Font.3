.TH "MaxOS::gui::Font" 3 "Mon Jan 29 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::gui::Font \- A class that can be used to draw text\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <font\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFont\fP (uint8_t *font_data)"
.br
.ti -1c
.RI "\fB~Font\fP ()"
.br
.ti -1c
.RI "virtual void \fBdraw_text\fP (int32_t x, int32_t y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP *context, \fBstring\fP text)"
.br
.RI "write the entire text to the screen "
.ti -1c
.RI "virtual void \fBdraw_text\fP (int32_t x, int32_t y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP *context, \fBstring\fP text, \fBcommon::Rectangle\fP< int32_t > limitArea)"
.br
.RI "write the entire text to the screen "
.ti -1c
.RI "virtual uint32_t \fBget_text_height\fP (\fBstring\fP)"
.br
.RI "Get the height of the text\&. "
.ti -1c
.RI "virtual uint32_t \fBget_text_width\fP (\fBstring\fP)"
.br
.RI "Get the width of the text\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "uint16_t \fBfont_size\fP { 8 }"
.br
.ti -1c
.RI "bool \fBis_bold\fP { false }"
.br
.ti -1c
.RI "bool \fBis_italic\fP { false }"
.br
.ti -1c
.RI "bool \fBis_underlined\fP { false }"
.br
.ti -1c
.RI "bool \fBis_strikethrough\fP { false }"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBm_is_8_by_8\fP"
.br
.ti -1c
.RI "uint8_t \fBm_font8x8\fP [2048]"
.br
.in -1c
.SH "Detailed Description"
.PP 
A class that can be used to draw text\&. 
.PP
Definition at line 21 of file font\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Font::Font (uint8_t * font_data)"

.PP
Definition at line 11 of file font\&.cpp\&.
.PP
.nf
12 {
13 
14   // Store the font data
15   for (int i = 0; i < 2048; ++i) {
16         m_font8x8[i] = font_data[i];
17   }
18 }
.fi
.PP
References MaxOS::drivers::peripherals::i\&.
.SS "Font::~Font ()"

.PP
Definition at line 20 of file font\&.cpp\&.
.PP
.nf
20             {
21 
22 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Font::draw_text (int32_t x, int32_t y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP * context, \fBstring\fP text)\fC [virtual]\fP"

.PP
write the entire text to the screen 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the text 
.br
\fIy\fP The y coordinate of the text 
.br
\fIcontext\fP The graphics context to draw the text on 
.br
\fItext\fP The text to draw 
.RE
.PP

.PP
Definition at line 31 of file font\&.cpp\&.
.PP
.nf
33                                                                   {
34 
35     // Calculate the rectangle of the text
36     int32_t top = 0;
37     int32_t left = 0;
38     uint32_t width = get_text_width(text);
39     uint32_t height = get_text_height(text);
40 
41     // Create the rectangle
42     Rectangle<int32_t> text_area(left, top, width, height);
43 
44     // Draw the text
45     draw_text(x, y, foreground_colour, background_colour, context, text, text_area);
46 }
.fi
.PP
References MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.PP
Referenced by MaxOS::gui::widgets::Text::draw(), MaxOS::gui::widgets::InputBox::draw(), MaxOS::gui::widgets::Button::draw(), and MaxOS::drivers::console::VESABootConsole::put_character()\&.
.SS "void Font::draw_text (int32_t x, int32_t y, \fBcommon::Colour\fP foreground_colour, \fBcommon::Colour\fP background_colour, \fBcommon::GraphicsContext\fP * context, \fBstring\fP text, \fBcommon::Rectangle\fP< int32_t > limitArea)\fC [virtual]\fP"

.PP
write the entire text to the screen 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The x coordinate of the text 
.br
\fIy\fP The y coordinate of the text 
.br
\fIcontext\fP The graphics context to draw the text on 
.br
\fItext\fP The text to draw 
.br
\fIlimitArea\fP The area of the text to draw 
.RE
.PP

.PP
Definition at line 58 of file font\&.cpp\&.
.PP
.nf
62 {
63 
64 
65     // Convert the colours
66     uint32_t foreground = context->colour_to_int(foreground_colour);
67     uint32_t background = context->colour_to_int(background_colour);
68 
69     // Ensure the area is within the actual area of the text
70     if (limitArea\&.top < 0) {
71         limitArea\&.height += limitArea\&.top;
72         limitArea\&.top = 0;
73     }
74 
75     if (limitArea\&.left < 0) {
76         limitArea\&.width += limitArea\&.left;
77         limitArea\&.left = 0;
78     }
79 
80     // Clamp the height and width max
81     if (limitArea\&.top + limitArea\&.height > (int)get_text_height(text))
82         limitArea\&.height = get_text_height(text) - limitArea\&.top;
83 
84     if (limitArea\&.left + limitArea\&.width > (int)get_text_width(text))
85         limitArea\&.width = get_text_width(text) - limitArea\&.left;
86 
87 
88     // Calculate limits
89     int32_t xLimit = limitArea\&.left + limitArea\&.width;
90     int32_t yLimit = limitArea\&.top + limitArea\&.height;
91 
92     // Draw the text from top to bottom
93     for (int yBitMapOffset = limitArea\&.top; yBitMapOffset <yLimit; yBitMapOffset++){
94         for (int xBitMapOffset = limitArea\&.left; xBitMapOffset < xLimit; ++xBitMapOffset) {
95 
96             // If the y is the middle then add a strikethrough
97             if (is_strikethrough && yBitMapOffset == yLimit / 2) {
98 
99                 // Draw the pixel
100                 context -> putPixel(x + xBitMapOffset, y + yBitMapOffset, foreground);
101                 continue;
102             }
103 
104             // If the y is the bottom then add an underline
105             if (is_underlined && yBitMapOffset == yLimit - 1) {
106 
107                 // Draw the pixel
108                 context -> putPixel(x + xBitMapOffset, y + yBitMapOffset, foreground);
109                 continue;
110             }
111 
112             //TODO: Bold, Italic when other fonts are working
113 
114             // Get the character
115             uint8_t character = text[xBitMapOffset/8];
116 
117            // Check if this pixel  is set or not
118            bool set = m_font8x8[(uint16_t)character * 8 + yBitMapOffset] & (128 >> (xBitMapOffset % 8));
119 
120            // Draw the pixel
121            context -> putPixel(x + xBitMapOffset, y + yBitMapOffset, set ? foreground : background);
122 
123         }
124     }
125 }
.fi
.PP
References MaxOS::common::GraphicsContext::colour_to_int(), MaxOS::common::Rectangle< Type >::height, MaxOS::common::Rectangle< Type >::left, MaxOS::common::Rectangle< Type >::top, MaxOS::common::Rectangle< Type >::width, MaxOS::drivers::peripherals::x, and MaxOS::drivers::peripherals::y\&.
.SS "uint32_t Font::get_text_height (\fBstring\fP)\fC [virtual]\fP"

.PP
Get the height of the text\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP The text to get the height of 
.RE
.PP
\fBReturns\fP
.RS 4
The height of the text 
.RE
.PP

.PP
Definition at line 133 of file font\&.cpp\&.
.PP
.nf
133                                      {
134 
135     return 8;
136 
137 }
.fi
.SS "uint32_t Font::get_text_width (\fBstring\fP text)\fC [virtual]\fP"

.PP
Get the width of the text\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP The text to get the width of 
.RE
.PP
\fBReturns\fP
.RS 4
The width of the text 
.RE
.PP

.PP
Definition at line 145 of file font\&.cpp\&.
.PP
.nf
145                                          {
146     return text\&.length()*8;
147 }
.fi
.PP
References MaxOS::String::length()\&.
.SH "Member Data Documentation"
.PP 
.SS "uint16_t MaxOS::gui::Font::font_size { 8 }"

.PP
Definition at line 32 of file font\&.h\&.
.SS "bool MaxOS::gui::Font::is_bold { false }"

.PP
Definition at line 34 of file font\&.h\&.
.SS "bool MaxOS::gui::Font::is_italic { false }"

.PP
Definition at line 35 of file font\&.h\&.
.SS "bool MaxOS::gui::Font::is_strikethrough { false }"

.PP
Definition at line 37 of file font\&.h\&.
.SS "bool MaxOS::gui::Font::is_underlined { false }"

.PP
Definition at line 36 of file font\&.h\&.
.SS "uint8_t MaxOS::gui::Font::m_font8x8[2048]\fC [protected]\fP"

.PP
Definition at line 24 of file font\&.h\&.
.SS "bool MaxOS::gui::Font::m_is_8_by_8\fC [protected]\fP"

.PP
Definition at line 23 of file font\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

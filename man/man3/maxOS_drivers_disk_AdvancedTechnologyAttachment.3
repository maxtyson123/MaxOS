.TH "maxOS::drivers::disk::AdvancedTechnologyAttachment" 3 "Mon Jan 8 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
maxOS::drivers::disk::AdvancedTechnologyAttachment \- \fBDriver\fP for the ATA controller, handles the reading and writing of data to the hard drive\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ata\&.h>\fP
.PP
Inherits \fBmaxOS::drivers::Driver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAdvancedTechnologyAttachment\fP (uint16_t port_base, bool master, \fBcommon::OutputStream\fP *output_stream)"
.br
.ti -1c
.RI "\fB~AdvancedTechnologyAttachment\fP ()"
.br
.ti -1c
.RI "void \fBidentify\fP ()"
.br
.RI "Identify the ATA device\&. "
.ti -1c
.RI "void \fBread_28\fP (uint32_t sector, uint8_t *\fBdata\fP, int count)"
.br
.RI "read a sector from the ATA device "
.ti -1c
.RI "void \fBwrite_28\fP (uint32_t sector, uint8_t *\fBdata\fP, int count)"
.br
.RI "write to a sector on the ATA device "
.ti -1c
.RI "void \fBflush\fP ()"
.br
.RI "Flush the cache of the ATA device\&. "
.ti -1c
.RI "void \fBactivate\fP () final"
.br
.RI "Activate the ATA device\&. "
.ti -1c
.RI "\fBstring\fP \fBget_device_name\fP () final"
.br
.RI "Get the device name\&. "
.ti -1c
.RI "\fBstring\fP \fBget_vendor_name\fP () final"
.br
.RI "Get the vendor name\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBhardwarecommunication::Port16Bit\fP \fBm_data_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_error_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_sector_count_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_low_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_mid_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_LBA_high_Port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_device_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_command_port\fP"
.br
.ti -1c
.RI "\fBhardwarecommunication::Port8Bit\fP \fBm_control_port\fP"
.br
.ti -1c
.RI "bool \fBm_is_master\fP"
.br
.ti -1c
.RI "uint16_t \fBm_bytes_per_sector\fP { 512 }"
.br
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBata_message_stream\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
\fBDriver\fP for the ATA controller, handles the reading and writing of data to the hard drive\&. 
.PP
Definition at line 24 of file ata\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AdvancedTechnologyAttachment::AdvancedTechnologyAttachment (uint16_t port_base, bool master, \fBcommon::OutputStream\fP * output_stream)"

.PP
Definition at line 13 of file ata\&.cpp\&.
.PP
.nf
14 : Driver(output_stream),
15   m_data_port(port_base),
16   m_error_port(port_base + 1),
17   m_sector_count_port(port_base + 2),
18   m_LBA_low_port(port_base + 3),
19   m_LBA_mid_port(port_base + 4),
20   m_LBA_high_Port(port_base + 5),
21   m_device_port(port_base + 6),
22   m_command_port(port_base + 7),
23   m_control_port(port_base + 0x206),
24   m_is_master(master),
25   ata_message_stream(output_stream)
26 {
27 
28 }
.fi
.SS "AdvancedTechnologyAttachment::~AdvancedTechnologyAttachment ()"

.PP
Definition at line 30 of file ata\&.cpp\&.
.PP
.nf
30                                                             {
31 
32 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void AdvancedTechnologyAttachment::activate ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Activate the ATA device\&. 
.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 216 of file ata\&.cpp\&.
.PP
.nf
216                                             {
217   Driver::activate();
218 }
.fi
.PP
References maxOS::drivers::Driver::activate()\&.
.SS "void AdvancedTechnologyAttachment::flush ()"

.PP
Flush the cache of the ATA device\&. 
.PP
Definition at line 190 of file ata\&.cpp\&.
.PP
.nf
190                                          {
191 
192   // Select the device (master or slave)
193   m_device_port\&.write(m_is_master ? 0xE0 : 0xF0);
194 
195   // Send the flush command
196   m_command_port\&.write(0xE7);
197 
198   // Make sure the device is there
199   uint8_t status = m_command_port\&.read();
200   if(status == 0x00)
201     return;
202 
203 
204   // Wait for the device to be ready or for an error to occur
205   while (((status & 0x80) == 0x80) && ((status & 0x01) != 0x01))
206       status = m_command_port\&.read();
207 
208   if(status & 0x01)
209       return;
210 
211 }
.fi
.PP
References m_command_port, m_device_port, m_is_master, maxOS::hardwarecommunication::Port8Bit::read(), status, and maxOS::hardwarecommunication::Port8Bit::write()\&.
.SS "\fBstring\fP AdvancedTechnologyAttachment::get_device_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the device name\&. 
.PP
\fBReturns\fP
.RS 4
The name of the device 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 225 of file ata\&.cpp\&.
.PP
.nf
225                                                      {
226 
227     return "Advanced Technology Attachment";
228 
229 }
.fi
.SS "\fBstring\fP AdvancedTechnologyAttachment::get_vendor_name ()\fC [final]\fP, \fC [virtual]\fP"

.PP
Get the vendor name\&. 
.PP
\fBReturns\fP
.RS 4
The name of the vendor 
.RE
.PP

.PP
Reimplemented from \fBmaxOS::drivers::Driver\fP\&.
.PP
Definition at line 236 of file ata\&.cpp\&.
.PP
.nf
236                                                      {
237 
238     return "IDE";
239 }
.fi
.SS "void AdvancedTechnologyAttachment::identify ()"

.PP
Identify the ATA device\&. 
.PP
Definition at line 37 of file ata\&.cpp\&.
.PP
.nf
37                                             {
38 
39   // Select the device (master or slave)
40   m_device_port\&.write(m_is_master ? 0xA0 : 0xB0);
41 
42   // Reset the HOB (High Order Byte)
43   m_control_port\&.write(0);
44 
45   // Check if the master is present
46   m_device_port\&.write(0xA0);
47   uint8_t status = m_command_port\&.read();
48   if(status == 0xFF){
49     ata_message_stream-> write("Invalid Status");
50     return;
51   }
52 
53   // Select the device (master or slave)
54   m_device_port\&.write(m_is_master ? 0xA0 : 0xB0);
55 
56   // Clear the ports
57   m_sector_count_port\&.write(0);
58   m_LBA_low_port\&.write(0);
59   m_LBA_mid_port\&.write(0);
60   m_LBA_high_Port\&.write(0);
61 
62   // Send the identify command
63   m_command_port\&.write(0x0EC);
64 
65   // Check if the device is present
66   status = m_command_port\&.read();
67   if(status == 0x00)
68     return;
69 
70   // Wait for the device to be ready or for an error to occur
71   while (((status & 0x80) == 0x80)  && ((status & 0x01) != 0x01))
72     status = m_command_port\&.read();
73 
74   //Check for any errors
75   if(status & 0x01){
76     ata_message_stream-> write("ERROR");
77     return;
78   }
79 
80   // read the data and print it
81   for (uint16_t i = 0; i < 256; ++i) {
82       uint16_t data = m_data_port\&.read();
83       ata_message_stream-> write(" 0x");
84       ata_message_stream-> write_hex(data);
85   }
86 }
.fi
.PP
References ata_message_stream, data, maxOS::drivers::peripherals::i, m_command_port, m_control_port, m_data_port, m_device_port, m_is_master, m_LBA_high_Port, m_LBA_low_port, m_LBA_mid_port, m_sector_count_port, maxOS::hardwarecommunication::Port8Bit::read(), maxOS::hardwarecommunication::Port16Bit::read(), status, and maxOS::hardwarecommunication::Port8Bit::write()\&.
.SS "void AdvancedTechnologyAttachment::read_28 (uint32_t sector, uint8_t * data, int count)"

.PP
read a sector from the ATA device 
.PP
\fBParameters\fP
.RS 4
\fIsector\fP The sector to read 
.br
\fIdata\fP The data to read into 
.br
\fIcount\fP The amount of data to read from that sector 
.RE
.PP

.PP
Definition at line 95 of file ata\&.cpp\&.
.PP
.nf
96 {
97     // Don't allow reading more then a sector
98     if(sector & 0xF0000000 || count > m_bytes_per_sector)
99         return;
100 
101     // Select the device (master or slave) and reset it
102     m_device_port\&.write((m_is_master ? 0xE0 : 0xF0) |
103                         ((sector & 0x0F000000) >> 24));
104     m_error_port\&.write(0);
105     m_sector_count_port\&.write(1);
106 
107     // Split the sector into the ports
108     m_LBA_low_port\&.write(sector & 0x000000FF);
109     m_LBA_mid_port\&.write((sector & 0x0000FF00) >> 8);
110     m_LBA_high_Port\&.write((sector & 0x00FF0000) >> 16);
111 
112     // Send the read command
113     m_command_port\&.write(0x20);
114 
115     // Make sure the device is there
116     uint8_t status = m_command_port\&.read();
117     if(status == 0x00)
118       return;
119 
120     // Wait for the device to be ready or for an error to occur
121     while(((status & 0x80) == 0x80) && ((status & 0x01) != 0x01))
122         status = m_command_port\&.read();
123 
124     //Check for any errors
125     if(status & 0x01)
126         return;
127 
128     // read the data and store it in the array
129     for(uint16_t i = 0; i < count; i+= 2)
130     {
131         uint16_t read_data = m_data_port\&.read();
132 
133         data[i] = read_data & 0x00FF;
134 
135         // Place the next byte in the array if there is one
136         if(i+1 < count)
137             data[i+1] = (read_data >> 8) & 0x00FF;
138     }
139 
140     // read the remaining bytes
141     for(uint16_t i = count + (count % 2); i < m_bytes_per_sector; i+= 2)
142       m_data_port\&.read();
143 }
.fi
.PP
References data, maxOS::drivers::peripherals::i, m_bytes_per_sector, m_command_port, m_data_port, m_device_port, m_error_port, m_is_master, m_LBA_high_Port, m_LBA_low_port, m_LBA_mid_port, m_sector_count_port, maxOS::hardwarecommunication::Port8Bit::read(), maxOS::hardwarecommunication::Port16Bit::read(), status, and maxOS::hardwarecommunication::Port8Bit::write()\&.
.SS "void AdvancedTechnologyAttachment::write_28 (uint32_t sector, uint8_t * data, int count)"

.PP
write to a sector on the ATA device 
.PP
\fBParameters\fP
.RS 4
\fIsector\fP The sector to write to 
.br
\fIcount\fP The amount of data to write to that sector 
.RE
.PP

.PP
Definition at line 151 of file ata\&.cpp\&.
.PP
.nf
151                                                                                     {
152 
153     // Don't allow writing more then a sector
154     if(sector > 0x0FFFFFFF || count > m_bytes_per_sector)
155         return;
156 
157     // Select the device (master or slave) and reset it
158     m_device_port\&.write(m_is_master ? 0xE0
159                                     : 0xF0 | ((sector & 0x0F000000) >> 24));
160     m_error_port\&.write(0);
161     m_sector_count_port\&.write(1);
162 
163     // Split the sector into the ports
164     m_LBA_low_port\&.write(sector & 0x000000FF);
165     m_LBA_mid_port\&.write((sector & 0x0000FF00) >> 8);
166     m_LBA_high_Port\&.write((sector & 0x00FF0000) >> 16);
167 
168     // Send the write command
169     m_command_port\&.write(0x30);
170 
171     // write the data to the device
172     for (uint16_t i = 0; i < m_bytes_per_sector; i+= 2) {
173 
174         uint16_t  writeData = data[i];
175 
176         // Place the next byte in the array if there is one
177         if(i+1 < count)
178             writeData |= ((uint16_t)data[i+1]) << 8;
179 
180         m_data_port\&.write(writeData);
181     }
182 
183     // write the remaining bytes
184     for(int i = count + (count%2); i < m_bytes_per_sector; i += 2)
185       m_data_port\&.write(0x0000);
186 }
.fi
.PP
References data, maxOS::drivers::peripherals::i, m_bytes_per_sector, m_command_port, m_data_port, m_device_port, m_error_port, m_is_master, m_LBA_high_Port, m_LBA_low_port, m_LBA_mid_port, m_sector_count_port, maxOS::hardwarecommunication::Port8Bit::write(), and maxOS::hardwarecommunication::Port16Bit::write()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* maxOS::drivers::disk::AdvancedTechnologyAttachment::ata_message_stream\fC [protected]\fP"

.PP
Definition at line 39 of file ata\&.h\&.
.PP
Referenced by identify()\&.
.SS "uint16_t maxOS::drivers::disk::AdvancedTechnologyAttachment::m_bytes_per_sector { 512 }\fC [protected]\fP"

.PP
Definition at line 37 of file ata\&.h\&.
.PP
Referenced by read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_command_port\fC [protected]\fP"

.PP
Definition at line 34 of file ata\&.h\&.
.PP
Referenced by flush(), identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_control_port\fC [protected]\fP"

.PP
Definition at line 35 of file ata\&.h\&.
.PP
Referenced by identify()\&.
.SS "\fBhardwarecommunication::Port16Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_data_port\fC [protected]\fP"

.PP
Definition at line 27 of file ata\&.h\&.
.PP
Referenced by identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_device_port\fC [protected]\fP"

.PP
Definition at line 33 of file ata\&.h\&.
.PP
Referenced by flush(), identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_error_port\fC [protected]\fP"

.PP
Definition at line 28 of file ata\&.h\&.
.PP
Referenced by read_28(), and write_28()\&.
.SS "bool maxOS::drivers::disk::AdvancedTechnologyAttachment::m_is_master\fC [protected]\fP"

.PP
Definition at line 36 of file ata\&.h\&.
.PP
Referenced by flush(), identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_high_Port\fC [protected]\fP"

.PP
Definition at line 32 of file ata\&.h\&.
.PP
Referenced by identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_low_port\fC [protected]\fP"

.PP
Definition at line 30 of file ata\&.h\&.
.PP
Referenced by identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_LBA_mid_port\fC [protected]\fP"

.PP
Definition at line 31 of file ata\&.h\&.
.PP
Referenced by identify(), read_28(), and write_28()\&.
.SS "\fBhardwarecommunication::Port8Bit\fP maxOS::drivers::disk::AdvancedTechnologyAttachment::m_sector_count_port\fC [protected]\fP"

.PP
Definition at line 29 of file ata\&.h\&.
.PP
Referenced by identify(), read_28(), and write_28()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

.TH "MaxOS::net::TransmissionControlProtocolHandler" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::net::TransmissionControlProtocolHandler
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tcp\&.h>\fP
.PP
Inherits \fBMaxOS::net::InternetProtocolPayloadHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTransmissionControlProtocolHandler\fP (\fBInternetProtocolHandler\fP *\fBinternetProtocolHandler\fP, \fBcommon::OutputStream\fP *\fBerrorMessages\fP)"
.br
.ti -1c
.RI "\fB~TransmissionControlProtocolHandler\fP ()"
.br
.ti -1c
.RI "\fBbool\fP \fBhandleInternetProtocolPayload\fP (\fBInternetProtocolAddress\fP \fBsourceIP\fP, \fBInternetProtocolAddress\fP \fBdestinationIP\fP, \fBuint8_t\fP *\fBpayloadData\fP, \fBuint32_t\fP \fBsize\fP) \fBoverride\fP"
.br
.RI "Handle the TCP message (provider end) "
.ti -1c
.RI "\fBTransmissionControlProtocolSocket\fP * \fBConnect\fP (\fBInternetProtocolAddress\fP \fBip\fP, \fBTransmissionControlProtocolPort\fP \fBport\fP)"
.br
.RI "Connect to a remote host through the TCP protocol\&. "
.ti -1c
.RI "\fBvoid\fP \fBDisconnect\fP (\fBTransmissionControlProtocolSocket\fP *socket)"
.br
.RI "Begin the disconnect process\&. "
.ti -1c
.RI "\fBvirtual\fP \fBTransmissionControlProtocolSocket\fP * \fBListen\fP (\fBuint16_t\fP \fBport\fP)"
.br
.RI "Begin listening on a port\&. "
.ti -1c
.RI "\fBvirtual\fP \fBvoid\fP \fBBind\fP (\fBTransmissionControlProtocolSocket\fP *socket, \fBTransmissionControlProtocolPayloadHandler\fP *\fBhandler\fP)"
.br
.RI "Bind a data handler to this socket\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBTransmissionControlProtocolSocket\fP * \fBConnect\fP (\fBconst\fP \fBstring\fP &\fBinternetProtocolAddressAndPort\fP)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBsendTransmissionControlProtocolPacket\fP (\fBTransmissionControlProtocolSocket\fP *socket, \fBconst\fP \fBuint8_t\fP *\fBdata\fP, \fBuint16_t\fP \fBsize\fP, \fBuint16_t\fP \fBflags\fP=0)"
.br
.RI "Send a packet (Throught the provider) "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBcommon::OutputStream\fP * \fBerrorMessages\fP"
.br
.ti -1c
.RI "\fBcommon::Vector\fP< \fBTransmissionControlProtocolSocket\fP * > \fBsockets\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBTransmissionControlProtocolPort\fP \fBfreePorts\fP = 0x8000"
.br
.RI "\fBHandler\fP/// "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBTransmissionControlProtocolSocket\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB158\fP of file \fBtcp\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TransmissionControlProtocolHandler::TransmissionControlProtocolHandler (\fBInternetProtocolHandler\fP * internetProtocolHandler, \fBcommon::OutputStream\fP * errorMessages)"

.PP
Definition at line \fB123\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
125 : InternetProtocolPayloadHandler(internetProtocolHandler, 0x06)
126 {
127     this \-> errorMessages = errorMessages;
128     
129 }
.fi

.PP
References \fBerrorMessages\fP\&.
.SS "TransmissionControlProtocolHandler::~TransmissionControlProtocolHandler ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBvoid\fP TransmissionControlProtocolHandler::Bind (\fBTransmissionControlProtocolSocket\fP * socket, \fBTransmissionControlProtocolPayloadHandler\fP * handler)\fC [virtual]\fP"

.PP
Bind a data handler to this socket\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to bind the handler to 
.br
\fItransmissionControlProtocolHandler\fP The handler to bind 
.RE
.PP

.PP
Definition at line \fB542\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
543 {
544   socket\->connect_event_handler(handler);
545 }
.fi

.PP
References \fBMaxOS::common::EventManager< EventType >::connect_event_handler()\fP\&.
.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Connect (\fBconst\fP \fBstring\fP & internetProtocolAddressAndPort)\fC [static]\fP"

.PP
Definition at line \fB485\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
485                                                                                             {
486 
487   //TODO NEW STRING PARSEING
488 
489   return nullptr;
490 }
.fi

.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Connect (\fBInternetProtocolAddress\fP ip, \fBTransmissionControlProtocolPort\fP port)"

.PP
Connect to a remote host through the TCP protocol\&. 
.PP
\fBParameters\fP
.RS 4
\fIip\fP The IP of the remote host 
.br
\fIport\fP The port of the remote host 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that is connected to the remote host, 0 if it failed 
.RE
.PP

.PP
Definition at line \fB449\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
450 {
451     //Create a new socket
452     auto* socket = (TransmissionControlProtocolSocket*)MemoryManager::kmalloc(sizeof(TransmissionControlProtocolSocket));
453 
454     //If there is space for the socket
455     if(socket != nullptr)
456     {
457         //Set the socket
458         new (socket) TransmissionControlProtocolSocket(this);
459 
460         //Set local and remote addresses
461         socket \-> remotePort = port;
462         socket \-> remoteIP = ip;
463         socket \-> localPort = freePorts++;
464         socket \-> localIP = internetProtocolHandler \-> GetInternetProtocolAddress();
465 
466         //Convert into big endian
467         socket \-> remotePort = ((socket \-> remotePort & 0xFF00)>>8) | ((socket \-> remotePort & 0x00FF) << 8);
468         socket \-> localPort = ((socket \-> localPort & 0xFF00)>>8) | ((socket \-> localPort & 0x00FF) << 8);
469 
470         //Set the socket into the socket array and then set its state
471         sockets\&.push_back(socket);
472         socket \-> state = TCPSocketState::SYN_SENT;
473 
474         //Dummy sequence number
475         socket \-> sequenceNumber = 0xbeefcafe;
476 
477         //Send a sync packet
478         sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::SYN);
479     }
480 
481     return socket;
482 }
.fi

.PP
References \fBfreePorts\fP, \fBMaxOS::net::InternetProtocolPayloadHandler::internetProtocolHandler\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBsendTransmissionControlProtocolPacket()\fP, \fBsequenceNumber\fP, \fBsockets\fP, \fBstate\fP, \fBMaxOS::net::SYN\fP, \fBMaxOS::net::SYN_SENT\fP, and \fBTransmissionControlProtocolSocket\fP\&.
.SS "\fBvoid\fP TransmissionControlProtocolHandler::Disconnect (\fBTransmissionControlProtocolSocket\fP * socket)"

.PP
Begin the disconnect process\&. 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to disconnect 
.RE
.PP

.PP
Definition at line \fB497\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
498 {
499 
500     socket \-> state = TCPSocketState::FIN_WAIT1;                            //Begin fin wait sequence
501     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::FIN + (uint16_t)TCPFlag::ACK);            //Send FIN|ACK packet
502     socket \-> sequenceNumber++;                             //Increase the sequence number
503 }
.fi

.PP
References \fBMaxOS::net::ACK\fP, \fBMaxOS::net::FIN\fP, \fBMaxOS::net::FIN_WAIT1\fP, \fBsendTransmissionControlProtocolPacket()\fP, \fBsequenceNumber\fP, and \fBstate\fP\&.
.SS "\fBbool\fP TransmissionControlProtocolHandler::handleInternetProtocolPayload (\fBInternetProtocolAddress\fP sourceIP, \fBInternetProtocolAddress\fP destinationIP, \fBuint8_t\fP * payloadData, \fBuint32_t\fP size)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle the TCP message (provider end) 
.PP
\fBParameters\fP
.RS 4
\fIsrcIP_BE\fP The source IP address 
.br
\fIdstIP_BE\fP The destination IP address 
.br
\fIinternetprotocolPayload\fP The payload 
.br
\fIsize\fP The size of the payload 
.RE
.PP
\fBReturns\fP
.RS 4
True if data is to be sent back or false if not 
.RE
.PP

.PP
Reimplemented from \fBMaxOS::net::InternetProtocolPayloadHandler\fP\&.
.PP
Definition at line \fB157\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
158 {
159 
160     errorMessages \-> write("TCP: Handling TCP message\\n");
161 
162     //Check if the size is too small
163     if(size < 13)
164     {
165         return false;
166     }
167 
168     // If it's smaller than the header, return
169     if(size < 4*payloadData[12]/16)             // The lower 4 bits of the 13th byte is the header length
170     {
171         return false;
172     }
173 
174     //Get the header
175     auto* msg = (TransmissionControlProtocolHeader*)payloadData;
176 
177     //Get the connection values (convert to host endian)
178     uint16_t localPort = bigEndian16(msg \-> dstPort);
179     uint16_t remotePort = bigEndian16(msg \-> srcPort);
180 
181     //Create the socket
182     TransmissionControlProtocolSocket* socket = nullptr;
183 
184     for(auto & currentSocket : sockets)
185     {
186         if( currentSocket \-> localPort == localPort                               //Check if the local port is the same as the destination port
187         &&  currentSocket \-> localIP == destinationIP                                  //Check if the local IP is the same as the destination IP
188         &&  currentSocket \-> state == TCPSocketState::LISTEN                                           //Check if the socket is in the LISTEN state
189         && (((msg \-> flags) & ((uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::ACK)) == (uint16_t)TCPFlag::SYN))                                       //Check if the SYN flag is set (allow for acknoweldgement)
190         {
191             socket = currentSocket;
192         }
193         else if( currentSocket \-> localPort == localPort                          //Check if the local port is the same as the destination port
194              &&  currentSocket \-> localIP == destinationIP                             //Check if the local IP is the same as the destination IP
195              &&  currentSocket \-> remotePort == remotePort                         //Check if the remote port is the same as the source port
196              &&  currentSocket \-> remoteIP == destinationIP)                           //Check if the remote IP is the same as the source IP
197         {
198             socket = currentSocket;
199         }
200     }
201 
202 
203     bool reset = false;
204 
205     //Check if the socket is found and if the socket wants to reset
206     if(socket != nullptr && msg \-> flags & (uint16_t)TCPFlag::RST)
207     {
208         socket \-> state = TCPSocketState::CLOSED;
209         socket \-> Disconnected();
210     }
211 
212     //Check if the socket is found and if the socket is not closed
213     if(socket != nullptr && socket \-> state != TCPSocketState::CLOSED)
214     {
215         switch((msg \-> flags) & ((uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::ACK | (uint16_t)TCPFlag::FIN))
216         {
217             /*
218              * Example for explanation:
219              * socket \-> state = SYN_RECEIVED;                                                  //The state of the socket, e\&.g\&. recieved, or established\&. This is used to know how to handle the socket
220              * socket \-> remotePort = msg \-> srcPort;                                           //The remote port, e\&.g\&. the port of the server
221              * socket \-> remoteIP = srcIP_BE;                                                   //The remote IP, e\&.g\&. the IP of the server
222              * socket \-> acknowledgementNumber = bigEndian32( msg \-> sequenceNumber ) + 1;      //The acknowledgement number, the number used to keep track of what has been received, this is just incremented by 1 each time
223              * socket \-> sequenceNumber = 0xbeefcafe;                                           //The sequence number, the number of the next set that is to be sent but in this case sequence isn't enabled so just set it to anything
224              * Send(socket, 0,0, SYN|ACK);                                                      //The response command, genneraly has to have the acknoledgement flag set
225              * socket \-> sequenceNumber++;                                                      //Increment the sequence number
226              *
227              */
228 
229             case (uint16_t)TCPFlag::SYN:
230                 if(socket \-> state == TCPSocketState::LISTEN)
231                 {
232                     socket \-> state = TCPSocketState::SYN_RECEIVED;
233                     socket \-> remotePort = msg \-> srcPort;
234                     socket \-> remoteIP = sourceIP;
235                     socket \-> acknowledgementNumber = bigEndian32( msg \-> sequenceNumber ) + 1;
236                     socket \-> sequenceNumber = 0xbeefcafe;
237                     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::ACK);
238                     socket \-> sequenceNumber++;
239                 }
240                 else
241                     reset = true;
242                 break;
243 
244 
245             case (uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::ACK:
246                 if(socket \-> state == TCPSocketState::SYN_SENT)
247                 {
248                     socket \-> state = TCPSocketState::ESTABLISHED;
249                     socket \-> acknowledgementNumber = bigEndian32( msg \-> sequenceNumber ) + 1;
250                     socket \-> sequenceNumber++;
251                     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::ACK);
252                 }
253                 else
254                     reset = true;
255                 break;
256 
257 
258             case (uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::FIN:
259             case (uint16_t)TCPFlag::SYN | (uint16_t)TCPFlag::FIN | (uint16_t)TCPFlag::ACK:
260                 reset = true;
261                 break;
262 
263 
264             case (uint16_t)TCPFlag::FIN:
265             case (uint16_t)TCPFlag::FIN | (uint16_t)TCPFlag::ACK:
266                 if(socket \-> state == TCPSocketState::ESTABLISHED)
267                 {
268                     socket \-> state = TCPSocketState::CLOSE_WAIT;
269                     socket \-> acknowledgementNumber++;
270                     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::ACK);
271                     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::FIN | (uint16_t)TCPFlag::ACK);
272                     socket \-> Disconnected();
273                 }
274                 else if(socket \-> state == TCPSocketState::CLOSE_WAIT)
275                 {
276                     socket \-> state = TCPSocketState::CLOSED;
277                 }
278                 else if(socket \-> state == TCPSocketState::FIN_WAIT1 || socket \-> state == TCPSocketState::FIN_WAIT2)
279                 {
280                     socket \-> state = TCPSocketState::CLOSED;
281                     socket \-> acknowledgementNumber++;
282                     sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::ACK);
283                     socket \-> Disconnected();
284                 }
285                 else
286                     reset = true;
287                 break;
288 
289 
290             case (uint16_t)TCPFlag::ACK:
291                 if(socket \-> state == TCPSocketState::SYN_RECEIVED)
292                 {
293                     socket \-> state = TCPSocketState::ESTABLISHED;
294                     socket \-> Connected();
295                     return false;
296                 }
297                 else if(socket \-> state == TCPSocketState::FIN_WAIT1)
298                 {
299                     socket \-> state = TCPSocketState::FIN_WAIT2;
300                     return false;
301                 }
302                 else if(socket \-> state == TCPSocketState::CLOSE_WAIT)
303                 {
304                     socket \-> state = TCPSocketState::CLOSED;
305                     break;
306                 }
307 
308                 if(msg \-> flags == (uint16_t)TCPFlag::ACK)
309                     break;
310 
311                 // no break, because of piggybacking
312                 [[fallthrough]];
313 
314             default:
315 
316                 //By default handle the data
317 
318                 if(bigEndian32(msg \-> sequenceNumber) == socket \-> acknowledgementNumber)
319                 {
320 
321                     reset = !(socket \-> handleTransmissionControlProtocolPayload(payloadData + msg \-> headerSize32*4,size \- msg \-> headerSize32*4));
322                     if(!reset)
323                     {
324                         uint32_t x = 0;                                                                      //The number of bytes to send back
325                         for(uint32_t i = msg \-> headerSize32*4; i < size; i++)                          //Loop through the data
326                             if(payloadData[i] != 0)                                                     //Check if the data is not 0
327                                 x = i;                                                                  //Set the number of bytes to send back to the current index
328                         socket \-> acknowledgementNumber += x \- msg \-> headerSize32*4 + 1;               //Increment the acknowledgement number by the number of bytes to send back
329                         sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::ACK);                                          //Send the acknowledgement
330                     }
331                 }
332                 else
333                 {
334                     // data in wrong order
335                     reset = true;
336                 }
337 
338         }
339     }
340 
341 
342 
343     if(reset)                                                                       //If the socket is to be reset
344     {
345         if(socket != nullptr)                                                             //If the socket exists then send a reset flag
346         {
347             sendTransmissionControlProtocolPacket(socket, nullptr,0, (uint16_t)TCPFlag::RST);
348         }
349         else                                                                        //If it doesn't exist then create a new socket and send a reset flag
350         {
351             TransmissionControlProtocolSocket new_socket(this);                     //Create a new socket
352             new_socket\&.remotePort = msg \-> srcPort;                                         //Set the remote port
353             new_socket\&.remoteIP = sourceIP;                                                 //Set the remote IP
354             new_socket\&.localPort = msg \-> dstPort;                                                  //Set the local port
355             new_socket\&.localIP = destinationIP;                                                     //Set the local IP
356             new_socket\&.sequenceNumber = bigEndian32(msg \-> acknowledgementNumber);              //Set the sequence number
357             new_socket\&.acknowledgementNumber = bigEndian32(msg \-> sequenceNumber) + 1;          //Set the acknowledgement number
358             sendTransmissionControlProtocolPacket(&new_socket, nullptr,0, (uint16_t)TCPFlag::RST);          //Send the reset flag
359         }
360     }
361 
362 
363     errorMessages \->write("TCP: Handled packet\\n");
364 
365     if(socket != nullptr && socket \-> state == TCPSocketState::CLOSED)                                        //If the socket is closed then remove it from the list
366     {
367         sockets\&.erase(socket);
368         return true;
369     }
370 
371 
372 
373     return false;
374 }
.fi

.PP
References \fBMaxOS::net::ACK\fP, \fBacknowledgementNumber\fP, \fBbigEndian16()\fP, \fBbigEndian32()\fP, \fBMaxOS::net::CLOSE_WAIT\fP, \fBMaxOS::net::CLOSED\fP, \fBdestinationIP\fP, \fBdstPort\fP, \fBerrorMessages\fP, \fBMaxOS::net::ESTABLISHED\fP, \fBMaxOS::net::FIN\fP, \fBMaxOS::net::FIN_WAIT1\fP, \fBMaxOS::net::FIN_WAIT2\fP, \fBflags\fP, \fBheaderSize32\fP, \fBMaxOS::net::LISTEN\fP, \fBMaxOS::net::RST\fP, \fBsendTransmissionControlProtocolPacket()\fP, \fBsequenceNumber\fP, \fBsize\fP, \fBsockets\fP, \fBsourceIP\fP, \fBsrcPort\fP, \fBstate\fP, \fBMaxOS::net::SYN\fP, \fBMaxOS::net::SYN_RECEIVED\fP, \fBMaxOS::net::SYN_SENT\fP, \fBMaxOS::common::OutputStream::write()\fP, and \fBwrite\fP\&.
.SS "\fBTransmissionControlProtocolSocket\fP * TransmissionControlProtocolHandler::Listen (\fBuint16_t\fP port)\fC [virtual]\fP"

.PP
Begin listening on a port\&. 
.PP
\fBParameters\fP
.RS 4
\fIport\fP The port to listen on 
.RE
.PP
\fBReturns\fP
.RS 4
The socket that will handle the connection 
.RE
.PP

.PP
Definition at line \fB511\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
512 {
513     //Create a new socket
514     auto* socket = (TransmissionControlProtocolSocket*)MemoryManager::kmalloc(sizeof(TransmissionControlProtocolSocket));
515 
516     //If there is space for the socket
517     if(socket != nullptr)
518     {
519         //Set the socket
520         new (socket) TransmissionControlProtocolSocket(this);
521 
522         //Configure the socket
523         socket \-> state = TCPSocketState::LISTEN;
524         socket \-> localIP = internetProtocolHandler \-> GetInternetProtocolAddress();
525         socket \-> localPort = ((port & 0xFF00)>>8) | ((port & 0x00FF) << 8);
526 
527         //Add the socket to the socket array
528         sockets\&.push_back(socket);
529     }
530 
531     //Return the socket
532     return socket;
533 }
.fi

.PP
References \fBMaxOS::net::InternetProtocolPayloadHandler::internetProtocolHandler\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBMaxOS::net::LISTEN\fP, \fBsockets\fP, \fBstate\fP, and \fBTransmissionControlProtocolSocket\fP\&.
.SS "\fBvoid\fP TransmissionControlProtocolHandler::sendTransmissionControlProtocolPacket (\fBTransmissionControlProtocolSocket\fP * socket, \fBconst\fP \fBuint8_t\fP * data, \fBuint16_t\fP size, \fBuint16_t\fP flags = \fC0\fP)\fC [protected]\fP"

.PP
Send a packet (Throught the provider) 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket to send the packet from 
.br
\fIdata\fP The data to send 
.br
\fIsize\fP The size of the data 
.br
\fIflags\fP The flags to send 
.RE
.PP

.PP
Definition at line \fB384\fP of file \fBtcp\&.cpp\fP\&..PP
.nf
385 {
386     //Get the total size of the packet and the packet with the pseudo header
387     uint16_t totalLength = size + sizeof(TransmissionControlProtocolHeader);
388     uint16_t lengthInclPHdr = totalLength + sizeof(TransmissionControlProtocolPseudoHeader);
389 
390     //Create a buffer for the packet
391     auto* buffer = (uint8_t*)MemoryManager::kmalloc(lengthInclPHdr);
392     uint8_t* buffer2 = buffer + sizeof(TransmissionControlProtocolHeader) + sizeof(TransmissionControlProtocolPseudoHeader);
393 
394     //Create the headers
395     auto* phdr = (TransmissionControlProtocolPseudoHeader*)buffer;
396     auto* msg = (TransmissionControlProtocolHeader*)(buffer + sizeof(TransmissionControlProtocolPseudoHeader));
397 
398     //Size is translated into 32bit
399     msg \-> headerSize32 = sizeof(TransmissionControlProtocolHeader)/4;
400 
401     //Set the ports
402     msg \-> srcPort = bigEndian16(socket \-> localPort);
403     msg \-> dstPort = bigEndian16(socket \-> remotePort);
404 
405     //Set TCP related data
406     msg \-> acknowledgementNumber = bigEndian32( socket \-> acknowledgementNumber );
407     msg \-> sequenceNumber = bigEndian32( socket \-> sequenceNumber );
408     msg \-> reserved = 0;
409     msg \-> flags = flags;
410     msg \-> windowSize = 0xFFFF;
411     msg \-> urgentPtr = 0;
412 
413     //Through the options allow for the MSS to be set
414     msg \-> options = ((flags & (uint16_t)TCPFlag::SYN) != 0) ? 0xB4050402 : 0;
415 
416     //Increase the sequence number
417     socket \-> sequenceNumber += size;
418 
419     // Check if the data is not null
420     if(data != nullptr)
421     {
422             //Copy the data into the buffer
423             for(int i = 0; i < size; i++)
424             buffer2[i] = data[i];
425     }
426 
427     //Set the pseudo header
428     phdr \-> srcIP = socket \-> localIP;
429     phdr \-> dstIP = socket \-> remoteIP;
430     phdr \-> protocol = 0x0600;
431     phdr \-> totalLength = ((totalLength & 0x00FF) << 8) | ((totalLength & 0xFF00) >> 8);
432 
433     //Calculate the checksum
434     msg \-> checksum = 0;
435     msg \-> checksum = InternetProtocolHandler::Checksum((uint16_t*)buffer, lengthInclPHdr);
436 
437 
438     //Send and then free the data
439     Send(socket \-> remoteIP, (uint8_t*)msg, totalLength);
440     MemoryManager::kfree(buffer);
441 }
.fi

.PP
References \fBacknowledgementNumber\fP, \fBbigEndian16()\fP, \fBbigEndian32()\fP, \fBchecksum\fP, \fBMaxOS::net::InternetProtocolHandler::Checksum()\fP, \fBdata\fP, \fBdstIP\fP, \fBdstPort\fP, \fBflags\fP, \fBheaderSize32\fP, \fBMaxOS::memory::MemoryManager::kfree()\fP, \fBMaxOS::memory::MemoryManager::kmalloc()\fP, \fBoptions\fP, \fBprotocol\fP, \fBreserved\fP, \fBMaxOS::net::InternetProtocolPayloadHandler::Send()\fP, \fBsequenceNumber\fP, \fBsize\fP, \fBsrcIP\fP, \fBsrcPort\fP, \fBMaxOS::net::SYN\fP, \fBtotalLength\fP, \fBurgentPtr\fP, and \fBwindowSize\fP\&.
.PP
Referenced by \fBConnect()\fP, \fBDisconnect()\fP, and \fBhandleInternetProtocolPayload()\fP\&.
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBTransmissionControlProtocolSocket\fP\fC [friend]\fP"

.PP
Definition at line \fB160\fP of file \fBtcp\&.h\fP\&.
.PP
Referenced by \fBConnect()\fP, and \fBListen()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBcommon::OutputStream\fP* MaxOS::net::TransmissionControlProtocolHandler::errorMessages\fC [protected]\fP"

.PP
Definition at line \fB162\fP of file \fBtcp\&.h\fP\&.
.PP
Referenced by \fBhandleInternetProtocolPayload()\fP, and \fBTransmissionControlProtocolHandler()\fP\&.
.SS "\fBTransmissionControlProtocolPort\fP TransmissionControlProtocolHandler::freePorts = 0x8000\fC [static]\fP, \fC [protected]\fP"

.PP
\fBHandler\fP/// 
.PP
Definition at line \fB165\fP of file \fBtcp\&.h\fP\&.
.PP
Referenced by \fBConnect()\fP\&.
.SS "\fBcommon::Vector\fP<\fBTransmissionControlProtocolSocket\fP*> MaxOS::net::TransmissionControlProtocolHandler::sockets\fC [protected]\fP"

.PP
Definition at line \fB163\fP of file \fBtcp\&.h\fP\&.
.PP
Referenced by \fBConnect()\fP, \fBhandleInternetProtocolPayload()\fP, and \fBListen()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

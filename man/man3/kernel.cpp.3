.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/kernel.cpp" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/kernel.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <common/version\&.h>\fP
.br
\fC#include <common/kprint\&.h>\fP
.br
\fC#include <hardwarecommunication/interrupts\&.h>\fP
.br
\fC#include <hardwarecommunication/pci\&.h>\fP
.br
\fC#include <hardwarecommunication/acpi\&.h>\fP
.br
\fC#include <hardwarecommunication/apic\&.h>\fP
.br
\fC#include <drivers/disk/ata\&.h>\fP
.br
\fC#include <drivers/console/console\&.h>\fP
.br
\fC#include <drivers/console/serial\&.h>\fP
.br
\fC#include <drivers/console/textmode\&.h>\fP
.br
\fC#include <drivers/console/vesaboot\&.h>\fP
.br
\fC#include <drivers/driver\&.h>\fP
.br
\fC#include <drivers/ethernet/amd_am79c973\&.h>\fP
.br
\fC#include <drivers/peripherals/keyboard\&.h>\fP
.br
\fC#include <drivers/peripherals/mouse\&.h>\fP
.br
\fC#include <drivers/video/vesa\&.h>\fP
.br
\fC#include <drivers/video/video\&.h>\fP
.br
\fC#include <gui/desktop\&.h>\fP
.br
\fC#include <gui/window\&.h>\fP
.br
\fC#include <gui/widgets/text\&.h>\fP
.br
\fC#include <gui/widgets/button\&.h>\fP
.br
\fC#include <gui/widgets/inputbox\&.h>\fP
.br
\fC#include <net/ethernetframe\&.h>\fP
.br
\fC#include <net/arp\&.h>\fP
.br
\fC#include <net/ipv4\&.h>\fP
.br
\fC#include <net/icmp\&.h>\fP
.br
\fC#include <net/udp\&.h>\fP
.br
\fC#include <net/tcp\&.h>\fP
.br
\fC#include <system/process\&.h>\fP
.br
\fC#include <system/cpu\&.h>\fP
.br
\fC#include <system/syscalls\&.h>\fP
.br
\fC#include <memory/memorymanagement\&.h>\fP
.br
\fC#include <system/multithreading\&.h>\fP
.br
\fC#include <memory/physical\&.h>\fP
.br
\fC#include <memory/virtual\&.h>\fP
.br
\fC#include <filesystem/msdospart\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBlog\fP(x)   out = x; cout << out; cout << (string)' ' * (sub_boot_width \- \fBout\&.length\fP() \- 6) << tick << '\\n';"
.br
.ti -1c
.RI "#define \fBheader\fP(x)   cout << '\\n\\n' << ANSI_COLOURS[FG_White] << '[' << string(x)\&.center(sub_boot_width \- 2) << ']\\n' << ANSI_COLOURS[Reset];"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBconstructor\fP) ()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcallConstructors\fP ()"
.br
.ti -1c
.RI "void \fBkernelMain\fP (unsigned long addr, unsigned long magic)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBconstructor\fP \fBstart_ctors\fP"
.br
.ti -1c
.RI "\fBconstructor\fP \fBend_ctors\fP"
.br
.ti -1c
.RI "volatile uint64_t \fBp4_table\fP [512]"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define header(x)   cout << '\\n\\n' << ANSI_COLOURS[FG_White] << '[' << string(x)\&.center(sub_boot_width \- 2) << ']\\n' << ANSI_COLOURS[Reset];"

.SS "#define log(x)   out = x; cout << out; cout << (string)' ' * (sub_boot_width \- \fBout\&.length\fP() \- 6) << tick << '\\n';"

.SH "Typedef Documentation"
.PP 
.SS "typedef void(* constructor) ()"

.PP
Definition at line 73 of file kernel\&.cpp\&.
.SH "Function Documentation"
.PP 
.SS "void callConstructors ()"

.PP
Definition at line 78 of file kernel\&.cpp\&.
.PP
.nf
79 {
80     for(constructor* i = &start_ctors; i != &end_ctors; i++)        //Iterate over all constructors
81         (*i)();                                                     //Call the constructor
82 }
.fi
.PP
References end_ctors, MaxOS::drivers::peripherals::i, and start_ctors\&.
.SS "void kernelMain (unsigned long addr, unsigned long magic)"

.PP
Definition at line 85 of file kernel\&.cpp\&.
.PP
.nf
86 {
87     // Initialise the serial console
88     SerialConsole serialConsole;
89 
90     // Confirm the bootloader
91     ASSERT(magic == MULTIBOOT2_BOOTLOADER_MAGIC, "Multiboot2 Bootloader Not Detected");
92 
93     // Make the multiboot header
94     Multiboot multiboot(addr);
95     _kprintf("-= MaxOS booted =-\n");
96 
97     InterruptManager interrupts;
98     _kprintf("-= IDT set up =-\n");
99 
100     uint32_t mbi_size = *(uint32_t *) (addr + MemoryManager::s_higher_half_kernel_offset);
101     PhysicalMemoryManager pmm(addr + mbi_size, &multiboot, p4_table);
102     _kprintf("-= Physical Memory Manager set up =-\n");
103 
104     VirtualMemoryManager vmm(true);
105     _kprintf("-= Virtual Memory Manager set up =-\n");
106 
107     // Initialise the VESA Driver
108     VideoElectronicsStandardsAssociation vesa(multiboot\&.get_framebuffer());
109     VideoDriver* videoDriver = (VideoDriver*)&vesa;
110     videoDriver->set_mode((int)multiboot\&.get_framebuffer()->common\&.framebuffer_width,
111                           (int)multiboot\&.get_framebuffer()->common\&.framebuffer_height,
112                           (int)multiboot\&.get_framebuffer()->common\&.framebuffer_bpp);
113 
114 
115     // Initialise the memory manager
116     MemoryManager memoryManager(&vmm);
117     _kprintf("-= Memory Manager set up =-\n");
118 
119     // Initialise Console
120     VESABootConsole console(&vesa);
121     console\&.clear();
122     console\&.print_logo();
123 
124     // Create a stream for the console
125     ConsoleArea mainConsoleArea(&console, 0, 0, console\&.width(), console\&.height(), ConsoleColour::DarkGrey, ConsoleColour::Black);
126     ConsoleStream cout(&mainConsoleArea);
127 
128     // Header constants
129     const string tick = (string)"[ " + ANSI_COLOURS[FG_Green] + "OK" + ANSI_COLOURS[Reset] + " ]";
130     const string boot_title = string("Kernel Boot Sequence - MaxOS v") + string(VERSION_STRING) + " [build " + string(BUILD_NUMBER) + "]";
131     const int boot_width = boot_title\&.length() + 20;
132     const int sub_boot_width = boot_width;
133 
134     // Print helpers
135     string out = "";
136     #define log(x) out = x; cout << out; cout << (string)" " * (sub_boot_width - out\&.length() - 6) << tick << "\n";
137     #define header(x) cout << "\n\n" << ANSI_COLOURS[FG_White] << "[" << string(x)\&.center(sub_boot_width - 2) << "]\n" << ANSI_COLOURS[Reset];
138 
139     // Print the header
140     cout << ANSI_COLOURS[FG_Blue] << (string)"=" * boot_width << "\n";
141     cout << ANSI_COLOURS[FG_Cyan] << boot_title\&.center(boot_width) << "\n";
142     cout << ANSI_COLOURS[FG_Blue] << (string)"=" * boot_width << "\n";
143 
144     // Stuff done earlier
145     header("Initialising System Components")
146     log("Set Up Serial Console");
147     log("Parsed Multiboot");
148     log("Set Up Paging");
149     log("Set Up Interrupt Manager");
150     log("Set Up Physical Memory Manager");
151     log("Set Up Virtual Memory Manager");
152     log("Set Up Memory Manager (Kernel)");
153     log("Set Up Video Driver");
154 
155     ThreadManager threadManager;
156     log("Set Up Thread Manager");
157 
158     SyscallHandler syscalls(&interrupts, 0x80);                               //Instantiate the function
159     log("Set Up Syscalls");
160 
161     DriverManager driverManager;
162     header("Initialising Hardware")
163 
164     AdvancedConfigurationAndPowerInterface acpi(&multiboot);
165     log("Set Up ACPI");
166 
167     AdvancedProgrammableInterruptController apic(&acpi);
168     interrupts\&.set_apic(apic\&.get_local_apic());
169     log("Set Up APIC");
170 
171 
172     // Keyboard
173     KeyboardDriver keyboard(&interrupts);
174     KeyboardInterpreterEN_US keyboardInterpreter;
175     keyboard\&.connect_input_stream_event_handler(&keyboardInterpreter);
176     driverManager\&.add_driver(&keyboard);
177     interrupt_redirect_t keyboardRedirect = {
178         \&.type = 0x1,
179         \&.index = 0x12,
180         \&.interrupt = 0x21,
181         \&.destination = 0x00,
182         \&.flags = 0x00,
183         \&.mask = false,
184     };
185     apic\&.get_io_apic() -> set_redirect(&keyboardRedirect);
186     log("Set Up Keyboard");
187 
188     // Mouse
189     MouseDriver mouse(&interrupts);
190     driverManager\&.add_driver(&mouse);
191     interrupt_redirect_t mouseRedirect = {
192         \&.type = 0xC,
193         \&.index = 0x28,
194         \&.interrupt = 0x2C,
195         \&.destination = 0x00,
196         \&.flags = 0x00,
197         \&.mask = false,
198     };
199     apic\&.get_io_apic() -> set_redirect(&mouseRedirect);
200     log("Set Up Mouse");
201 
202 
203     // Clock
204     Clock kernelClock(&interrupts, &apic, 1);
205     driverManager\&.add_driver(&kernelClock);
206     log("Set Up Clock");
207 
208     // Driver Selectors
209     Vector<DriverSelector*> driverSelectors;
210 
211     //PCI
212     PeripheralComponentInterconnectController PCIController;
213     driverSelectors\&.push_back(&PCIController);
214     log("Set Up PCI");
215 
216     header("Device Management")
217 
218     // Find the drivers
219     cout << "Finding Drivers" << ANSI_COLOURS[FG_White];
220     for(Vector<DriverSelector*>::iterator selector = driverSelectors\&.begin(); selector != driverSelectors\&.end(); selector++)
221     {
222       cout << "\&.";
223       (*selector)->select_drivers(&driverManager, &interrupts);
224     }
225     cout << ANSI_COLOURS[Reset] << (string)"\&."*(boot_width - driverSelectors\&.size() - 15 - 9) << (string)"[ " + ANSI_COLOURS[FG_Green] + "FOUND" + ANSI_COLOURS[Reset] + " ]" << "\n";
226 
227 
228     // Resetting devices
229     cout << "Resetting Devices" << ANSI_COLOURS[FG_White];
230     uint32_t resetWaitTime = 0;
231     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
232     {
233       cout << "\&.";
234       uint32_t waitTime = (*driver)->reset();
235 
236       // If the wait time is longer than the current longest wait time, set it as the new longest wait time
237       if(waitTime > resetWaitTime)
238         resetWaitTime = waitTime;
239     }
240     cout << ANSI_COLOURS[Reset] << (string)"\&."*(boot_width - driverManager\&.drivers\&.size() - 17 - 9) << (string)"[ " + ANSI_COLOURS[FG_Green] + "RESET" + ANSI_COLOURS[Reset] + " ]" << "\n";
241 
242 
243     // Interrupts
244     interrupts\&.activate();
245     log("Activating Interrupts");
246 
247     // Post interupt activation
248     kernelClock\&.calibrate();
249     kernelClock\&.delay(resetWaitTime);
250     Time now = kernelClock\&.get_time();
251     cout << "TIME: " << now\&.hour << ":" << now\&.minute << ":" << now\&.second << "\n";
252 
253     header("Finalisation")
254 
255     // Initialise the drivers
256     cout <<  "Initialising Devices" << ANSI_COLOURS[FG_White];
257     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
258     {
259       cout << "\&.";
260       (*driver)->initialise();
261     }
262     cout << ANSI_COLOURS[Reset] << (string)"\&."*(boot_width - driverManager\&.drivers\&.size() - 20 - 15) << (string)"[ " + ANSI_COLOURS[FG_Green] + "INITIALISED" + ANSI_COLOURS[Reset] + " ]" << "\n";
263 
264 
265     // activate the drivers
266     cout << "Activating Devices" << ANSI_COLOURS[FG_White];
267     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
268     {
269       cout << "\&.";
270       (*driver)->activate();
271     }
272     cout << ANSI_COLOURS[Reset] << (string)"\&."*(boot_width - driverManager\&.drivers\&.size() - 18 - 13) << (string)"[ " + ANSI_COLOURS[FG_Green] + "ACTIVATED" + ANSI_COLOURS[Reset] + " ]" << "\n";
273 
274 
275     // Print the footer
276     cout << "\n\n";
277     cout << ANSI_COLOURS[FG_Blue] << (string)"-" * boot_width << "\n";
278     cout << ANSI_COLOURS[FG_Cyan] << string(" -- Kernel Ready --")\&.center(boot_width) << "\n";
279     cout << ANSI_COLOURS[FG_Blue] << (string)"-" * boot_width << "\n";
280 
281     // Wait
282     while (true);
283 
284 }
.fi
.PP
References _kprintf, MaxOS::hardwarecommunication::InterruptManager::activate(), MaxOS::drivers::DriverManager::add_driver(), MaxOS::common::ANSI_COLOURS, ASSERT, MaxOS::common::Vector< Type >::begin(), MaxOS::common::Black, MaxOS::drivers::clock::Clock::calibrate(), MaxOS::String::center(), MaxOS::drivers::console::Console::clear(), multiboot_tag_framebuffer::common, MaxOS::common::GenericInputStream::connect_input_stream_event_handler(), MaxOS::common::DarkGrey, MaxOS::drivers::clock::Clock::delay(), MaxOS::drivers::DriverManager::drivers, MaxOS::common::Vector< Type >::end(), MaxOS::common::FG_Blue, MaxOS::common::FG_Cyan, MaxOS::common::FG_Green, MaxOS::common::FG_White, multiboot_tag_framebuffer_common::framebuffer_bpp, multiboot_tag_framebuffer_common::framebuffer_height, multiboot_tag_framebuffer_common::framebuffer_width, MaxOS::system::Multiboot::get_framebuffer(), MaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::get_io_apic(), MaxOS::hardwarecommunication::AdvancedProgrammableInterruptController::get_local_apic(), MaxOS::drivers::clock::Clock::get_time(), header, MaxOS::drivers::console::VESABootConsole::height(), MaxOS::common::Time::hour, MaxOS::String::length(), log, MaxOS::common::Time::minute, MULTIBOOT2_BOOTLOADER_MAGIC, p4_table, MaxOS::drivers::console::VESABootConsole::print_logo(), MaxOS::common::Vector< Type >::push_back(), MaxOS::common::Reset, MaxOS::common::Time::second, MaxOS::hardwarecommunication::InterruptManager::set_apic(), MaxOS::drivers::video::VideoDriver::set_mode(), MaxOS::common::Vector< Type >::size(), MaxOS::hardwarecommunication::InterruptRedirect::type, and MaxOS::drivers::console::VESABootConsole::width()\&.
.SH "Variable Documentation"
.PP 
.SS "\fBconstructor\fP end_ctors"

.PP
Definition at line 77 of file kernel\&.cpp\&.
.PP
Referenced by callConstructors()\&.
.SS "volatile uint64_t p4_table[512]"

.PP
Referenced by kernelMain()\&.
.SS "\fBconstructor\fP start_ctors"

.PP
Definition at line 76 of file kernel\&.cpp\&.
.PP
Referenced by callConstructors()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

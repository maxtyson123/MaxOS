.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/kernel.cpp" 3 "Mon Jan 8 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/kernel.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <common/version\&.h>\fP
.br
\fC#include <hardwarecommunication/interrupts\&.h>\fP
.br
\fC#include <hardwarecommunication/pci\&.h>\fP
.br
\fC#include 'drivers/disk/ata\&.h'\fP
.br
\fC#include <drivers/console/console\&.h>\fP
.br
\fC#include <drivers/console/textmode\&.h>\fP
.br
\fC#include <drivers/console/vesaboot\&.h>\fP
.br
\fC#include <drivers/driver\&.h>\fP
.br
\fC#include <drivers/ethernet/amd_am79c973\&.h>\fP
.br
\fC#include <drivers/peripherals/keyboard\&.h>\fP
.br
\fC#include <drivers/peripherals/mouse\&.h>\fP
.br
\fC#include <drivers/video/vesa\&.h>\fP
.br
\fC#include <drivers/video/video\&.h>\fP
.br
\fC#include <gui/desktop\&.h>\fP
.br
\fC#include <gui/window\&.h>\fP
.br
\fC#include <gui/widgets/text\&.h>\fP
.br
\fC#include <gui/widgets/button\&.h>\fP
.br
\fC#include <gui/widgets/inputbox\&.h>\fP
.br
\fC#include <net/ethernetframe\&.h>\fP
.br
\fC#include <net/arp\&.h>\fP
.br
\fC#include <net/ipv4\&.h>\fP
.br
\fC#include <net/icmp\&.h>\fP
.br
\fC#include <net/udp\&.h>\fP
.br
\fC#include <net/tcp\&.h>\fP
.br
\fC#include <system/process\&.h>\fP
.br
\fC#include <system/gdt\&.h>\fP
.br
\fC#include <system/syscalls\&.h>\fP
.br
\fC#include <memory/memorymanagement\&.h>\fP
.br
\fC#include <system/multithreading\&.h>\fP
.br
\fC#include <filesystem/msdospart\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBGUI\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBconstructor\fP) ()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcallConstructors\fP ()"
.br
.ti -1c
.RI "bool \fBcheck_multiboot_flag\fP (uint32_t \fBflags\fP, uint32_t bit)"
.br
.ti -1c
.RI "void \fBprint_boot_header\fP (\fBConsole\fP *console)"
.br
.ti -1c
.RI "void \fBkernelMain\fP (const \fBmultiboot_info\fP &multibootHeader, uint32_t multiboot_magic)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBconstructor\fP \fBstart_ctors\fP"
.br
.ti -1c
.RI "\fBconstructor\fP \fBend_ctors\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define GUI"

.SH "Typedef Documentation"
.PP 
.SS "typedef void(* constructor) ()"

.PP
Definition at line 65 of file kernel\&.cpp\&.
.SH "Function Documentation"
.PP 
.SS "void callConstructors ()"

.PP
Definition at line 70 of file kernel\&.cpp\&.
.PP
.nf
71 {
72     for(constructor* i = &start_ctors; i != &end_ctors; i++)        //Iterate over all constructors
73         (*i)();                                                     //Call the constructor
74 }
.fi
.PP
References end_ctors, maxOS::drivers::peripherals::i, and start_ctors\&.
.SS "bool check_multiboot_flag (uint32_t flags, uint32_t bit)"

.PP
Definition at line 77 of file kernel\&.cpp\&.
.PP
.nf
78 {
79     return (flags & (1 << bit)) > 0;
80 }
.fi
.PP
References flags\&.
.SS "void kernelMain (const \fBmultiboot_info\fP & multibootHeader, uint32_t multiboot_magic)"

.PP
Definition at line 104 of file kernel\&.cpp\&.
.PP
.nf
105 {
106 
107     // Get the multiboot info structure
108     Multiboot multiboot((multiboot_info_t*)&multibootHeader, multiboot_magic);
109 
110     // Set up the memory manager
111     MemoryManager memoryManager(multiboot\&.get_boot_info());
112 
113     // Initialise the VESA Driver
114     VideoElectronicsStandardsAssociation vesa(multiboot\&.get_boot_info());
115     VideoDriver* videoDriver = (VideoDriver*)&vesa;
116     videoDriver->set_mode((int)multiboot\&.get_boot_info() -> framebuffer_width,
117                           (int)multiboot\&.get_boot_info() -> framebuffer_height,
118                           (int)multiboot\&.get_boot_info() -> framebuffer_bpp);
119 
120     // Initialise Console
121     VESABootConsole console(&vesa);
122     console\&.clear();
123     console\&.print_logo();
124 
125     // Create a stream for the console
126     ConsoleArea mainConsoleArea(&console, 0, 1, console\&.width(), console\&.height(), ConsoleColour::DarkGrey, ConsoleColour::Black);
127     ConsoleStream cout(&mainConsoleArea);
128 
129     // Print the header
130     print_boot_header(&console);
131 
132     // Print the build info
133     cout << "BUILD INFO: " << VERSION_NAME << " on " << BUILD_DATE\&.year << "-" << BUILD_DATE\&.month << "-" << BUILD_DATE\&.day << " at " << BUILD_DATE\&.hour << ":" << BUILD_DATE\&.minute << ":" << BUILD_DATE\&.second << " " << " (commit " << GIT_REVISION << " on " << GIT_BRANCH << " by " << GIT_AUTHOR << ")\n";
134 
135     // Check the multiboot flags
136     cout << "Checking Multiboot Flags";
137     if(!multiboot\&.check_flags(&cout))
138         asm("hlt");
139     cout << "[ DONE ]\n";
140 
141     // Where the areas should start
142     cout\&.set_cursor(cout\&.m_cursor_x, cout\&.m_cursor_y + 1); //Move the cursor down one (so the header is not overwritten
143     uint32_t areaStart = cout\&.m_cursor_y;
144 
145     // Make the system setup stream
146     ConsoleArea systemSetupHeader(&console, 0, areaStart, console\&.width(), 1, ConsoleColour::LightGrey, ConsoleColour::Black);
147     ConsoleStream systemSetupHeaderStream(&systemSetupHeader);
148     systemSetupHeaderStream << "Setting up system";
149 
150     //Setup GDT
151     GlobalDescriptorTable gdt(multibootHeader);
152     cout << "-- Set Up GDT\n";
153     systemSetupHeaderStream << "\&.";
154 
155     // Print that the memory has been set up
156     cout << "-- Set Up Memory Management\n";
157     systemSetupHeaderStream << "\&.";
158 
159     ThreadManager threadManager;
160     cout << "-- Set Up Thread Management\n";
161     systemSetupHeaderStream << "\&.";
162 
163     InterruptManager interrupts(0x20, &gdt, &threadManager, &cout);            //Instantiate the function
164     cout << "-- Set Up Interrupts\n";
165     systemSetupHeaderStream << "\&.";
166 
167     SyscallHandler syscalls(&interrupts, 0x80);                               //Instantiate the function
168     cout << "-- Set Up System Calls\n";
169     systemSetupHeaderStream << "\&.";
170 
171     cout << "\n";
172     systemSetupHeaderStream << "[ DONE ]";
173 
174     // Make the device setup stream
175     ConsoleArea deviceSetupHeader(&console, 0, cout\&.m_cursor_y, console\&.width(), 1, ConsoleColour::LightGrey, ConsoleColour::Black);
176     ConsoleStream deviceSetupHeaderStream(&deviceSetupHeader);
177     deviceSetupHeaderStream << "Setting up devices";
178     
179     DriverManager driverManager;
180 
181     //Keyboard
182     KeyboardDriver keyboard(&interrupts);
183     KeyboardInterpreterEN_US keyboardInterpreter;
184     keyboard\&.connect_input_stream_event_handler(&keyboardInterpreter);
185     driverManager\&.add_driver(&keyboard);
186     cout << "-- Set Up Keyboard\n";
187     deviceSetupHeaderStream << "\&.";
188 
189     //Mouse
190     MouseDriver mouse(&interrupts);
191     driverManager\&.add_driver(&mouse);
192     cout << "-- Set Up Mouse\n";
193     deviceSetupHeaderStream << "\&.";
194 
195     //Clock
196     Clock kernelClock(&interrupts, 1);
197     driverManager\&.add_driver(&kernelClock);
198     cout << "-- Set Up Clock\n";
199     deviceSetupHeaderStream << "\&.";
200 
201     //Driver Selectors
202     Vector<DriverSelector*> driverSelectors;
203 
204     //Make the stream on the side for the PCI
205     ConsoleArea pciConsoleArea(&console, console\&.width() - 45, areaStart+1, 45, console\&.height()/2, ConsoleColour::DarkGrey, ConsoleColour::Black);
206     ConsoleStream pciConsoleStream(&pciConsoleArea);
207     console\&.put_string(console\&.width() - 45, areaStart, "                 PCI Devices                 ", ConsoleColour::LightGrey, ConsoleColour::Black);
208     
209     //PCI
210     PeripheralComponentInterconnectController PCIController(&pciConsoleStream);
211     driverSelectors\&.push_back(&PCIController);
212     cout << "-- Set Up PCI\n";
213     deviceSetupHeaderStream << "\&.";
214 
215     //USB
216     //UniversalSerialBusController USBController(&nullStream);
217     //driverSelectors\&.pushBack(&USBController);
218     //cout << "-- Set Up USB\n";
219     //deviceSetupHeaderStream << "\&.";
220 
221     // Find the drivers
222     cout << "-- Finding Drivers";
223     for(Vector<DriverSelector*>::iterator selector = driverSelectors\&.begin(); selector != driverSelectors\&.end(); selector++)
224     {
225         cout << "\&.";
226         (*selector)->select_drivers(&driverManager, &interrupts);
227     }
228     cout << " Found\n";
229     deviceSetupHeaderStream << "\&.";
230 
231     cout << "\n";
232     deviceSetupHeaderStream << "[ DONE ]";
233 
234     // Make the activation stream
235     ConsoleArea activationHeader(&console, 0, cout\&.m_cursor_y, console\&.width(), 1, ConsoleColour::LightGrey, ConsoleColour::Black);
236     ConsoleStream activationHeaderStream(&activationHeader);
237     activationHeaderStream << "Initializing Hardware";
238 
239     // Resetting devices
240     cout << "-- Resetting Devices";
241     uint32_t resetWaitTime = 0;
242     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
243     {
244         cout << "\&.";
245         uint32_t waitTime = (*driver)->reset();
246 
247         // If the wait time is longer than the current longest wait time, set it as the new longest wait time
248         if(waitTime > resetWaitTime)
249             resetWaitTime = waitTime;
250     }
251     cout << " Reset\n";
252     activationHeaderStream << "\&.";
253 
254     // Interrupts
255     interrupts\&.activate();
256     kernelClock\&.delay(resetWaitTime);                                            //Wait for the devices to reset (has to be done after interrupts are activated otherwise the clock interrupt wont trigger)
257     cout << "-- Activated Interrupts\n";
258     activationHeaderStream << "\&.";
259 
260     // Initialise the drivers
261     cout << "-- Initializing Devices";
262     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
263     {
264         cout << "\&.";
265         (*driver)->initialise();
266     }
267     cout << " Initialised\n";
268     activationHeaderStream << "\&.";
269 
270     // activate the drivers
271     cout << "-- Activating Devices";
272     for(Vector<Driver*>::iterator driver = driverManager\&.drivers\&.begin(); driver != driverManager\&.drivers\&.end(); driver++)
273     {
274         cout << "\&.";
275         (*driver)->activate();
276     }
277     cout << " Activated\n";
278     activationHeaderStream << "\&.";
279 
280     cout << "\n";
281     activationHeaderStream << "[ DONE ]";
282 
283     // Make the network setup stream
284     ConsoleArea networkSetupHeader(&console, 0, cout\&.m_cursor_y, console\&.width(), 1, ConsoleColour::LightGrey, ConsoleColour::Black);
285     ConsoleStream networkSetupHeaderStream(&networkSetupHeader);
286     networkSetupHeaderStream << "Setting up network";
287 
288     // Make the stream on the side for the network
289     ConsoleArea networkConsoleArea(&console, console\&.width() - 40, 2 + console\&.height()/2, 45,
290         console\&.height()/2, ConsoleColour::DarkGrey, ConsoleColour::Black);
291     ConsoleStream networkConsoleStream(&networkConsoleArea);
292     console\&.put_string(console\&.width() - 40, 1 + console\&.height() / 2,
293                        "                 Network                    ",
294                        ConsoleColour::LightGrey, ConsoleColour::Black);
295 
296     // Get the driver
297     EthernetDriver* ethernetDriver = (EthernetDriver*)driverManager\&.drivers[4];
298     ethernetDriver->m_driver_message_stream = &networkConsoleStream;
299     cout << "Got Ethernet Driver: " << ethernetDriver->get_device_name() << "\n";
300     networkSetupHeaderStream << "\&.";
301 
302     // Ethernet Frame Handler
303     EthernetFrameHandler ethernetFrameHandler(ethernetDriver, &networkConsoleStream);
304     cout << "-- Set Up Ethernet Frame Handler\n";
305     networkSetupHeaderStream << "\&.";
306 
307     // IPv4 (using qemu's default network settings)
308     SubnetMask subnetMask = InternetProtocolHandler::CreateSubnetMask(255, 255, 255, 0);
309     InternetProtocolAddress defaultGateway = InternetProtocolHandler::CreateInternetProtocolAddress(10, 0, 2, 2);
310     InternetProtocolAddress ipAddress = InternetProtocolHandler::CreateInternetProtocolAddress(10, 0, 2, 15);
311     InternetProtocolHandler internetProtocolHandler(&ethernetFrameHandler, ipAddress, defaultGateway, subnetMask, &networkConsoleStream);
312     cout << "-- Set Up IPv4\n";
313     networkSetupHeaderStream << "\&.";
314 
315     // ARP
316     AddressResolutionProtocol arp(&ethernetFrameHandler, &internetProtocolHandler, &networkConsoleStream);
317     cout << "-- Set Up ARP\n";
318     networkSetupHeaderStream << "\&.";
319 
320     // ICMP
321     InternetControlMessageProtocol icmp(&internetProtocolHandler, &networkConsoleStream);
322     cout << "-- Set Up ICMP\n";
323     networkSetupHeaderStream << "\&.";
324 
325     // TCP
326     TransmissionControlProtocolHandler tcp(&internetProtocolHandler, &networkConsoleStream);
327     cout << "-- Set Up TCP\n";
328     networkSetupHeaderStream << "\&.";
329 
330     // UDP
331     UserDatagramProtocolHandler udp(&internetProtocolHandler, &networkConsoleStream);
332     cout << "-- Set Up UDP\n";
333     networkSetupHeaderStream << "\&.";
334     cout << "\n";
335     networkSetupHeaderStream << "[ DONE ]";
336 
337 #define GUI
338 #ifdef GUI
339     Desktop desktop(videoDriver);
340     mouse\&.connect_event_handler(&desktop);
341     keyboardInterpreter\&.connect_event_handler(&desktop);
342     kernelClock\&.connect_event_handler(&desktop);
343 
344     Window testWindow(150,10, 200, 150, "Test Window");
345     widgets::InputBox testInputBox(10, 10, 150, 20, "test");
346 
347     class InputBoxStream : public widgets::InputBoxEventHandler
348     {
349         ConsoleStream* stream;
350         public:
351         InputBoxStream(ConsoleStream* stream)
352         {
353             this->stream = stream;
354         }
355         ~InputBoxStream()
356         {
357             this->stream = nullptr;
358         }
359 
360         void on_input_box_text_changed(string newText)
361         {
362             *stream << "Input Box Changed: " << newText << "\n";
363         }
364     };
365     InputBoxStream inputBoxStream(&cout);
366     testInputBox\&.connect_event_handler(&inputBoxStream);
367     testWindow\&.add_child(&testInputBox);
368     desktop\&.add_child(&testWindow);
369 
370     Window testWindow2(350,100, 200, 150, "Test Window 2");
371     desktop\&.add_child(&testWindow2);
372 
373 #endif
374 
375     // Wait
376     while (true);
377 
378 }
.fi
.PP
References maxOS::hardwarecommunication::InterruptManager::activate(), maxOS::gui::Desktop::add_child(), maxOS::gui::Window::add_child(), maxOS::drivers::DriverManager::add_driver(), maxOS::common::Vector< Type >::begin(), maxOS::drivers::console::Black, maxOS::system::Multiboot::check_flags(), maxOS::drivers::console::Console::clear(), maxOS::common::EventManager< EventType >::connect_event_handler(), maxOS::common::GenericInputStream::connect_input_stream_event_handler(), maxOS::drivers::console::DarkGrey, maxOS::drivers::clock::Clock::delay(), maxOS::drivers::DriverManager::drivers, maxOS::common::Vector< Type >::end(), maxOS::system::Multiboot::get_boot_info(), maxOS::drivers::Driver::get_device_name(), maxOS::drivers::console::VESABootConsole::height(), maxOS::drivers::console::LightGrey, maxOS::drivers::console::ConsoleStream::m_cursor_x, maxOS::drivers::console::ConsoleStream::m_cursor_y, maxOS::drivers::Driver::m_driver_message_stream, print_boot_header(), maxOS::drivers::console::VESABootConsole::print_logo(), maxOS::common::Vector< Type >::push_back(), maxOS::drivers::console::Console::put_string(), maxOS::drivers::console::ConsoleStream::set_cursor(), maxOS::drivers::video::VideoDriver::set_mode(), and maxOS::drivers::console::VESABootConsole::width()\&.
.SS "void print_boot_header (\fBConsole\fP * console)"

.PP
Definition at line 82 of file kernel\&.cpp\&.
.PP
.nf
82                                         {
83 
84   // Make the header
85   ConsoleArea consoleHeader(console, 0, 0, console -> width(), 1, ConsoleColour::Blue, ConsoleColour::LightGrey);
86   ConsoleStream headerStream(&consoleHeader);
87 
88   // Calculate the header
89   string header = string("MaxOS v") + string(VERSION_STRING) + " [build " + string(BUILD_NUMBER) + "]";
90   int headerPadding = (console -> width() - header\&.length()) / 2;
91 
92   // Print the headers
93   for(int i = 0; i < headerPadding; i++)
94         headerStream << " ";
95 
96   headerStream << header;
97 
98   for (int i1 = 0; i1 < headerPadding; ++i1) {
99         headerStream << " ";
100   }
101 
102 }
.fi
.PP
References maxOS::drivers::console::Blue, maxOS::drivers::peripherals::i, maxOS::String::length(), and maxOS::drivers::console::LightGrey\&.
.PP
Referenced by kernelMain()\&.
.SH "Variable Documentation"
.PP 
.SS "\fBconstructor\fP end_ctors"

.PP
Definition at line 69 of file kernel\&.cpp\&.
.PP
Referenced by callConstructors()\&.
.SS "\fBconstructor\fP start_ctors"

.PP
Definition at line 68 of file kernel\&.cpp\&.
.PP
Referenced by callConstructors()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

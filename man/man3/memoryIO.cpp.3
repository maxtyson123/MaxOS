.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/memory/memoryIO.cpp" 3 "Version 0.3" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/memory/memoryIO.cpp \- Implementation of memory-mapped I/O operations\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <memory/memoryIO\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBmemcpy\fP (void *destination, const void *source, uint64_t num)"
.br
.RI "Copies a block of memory from one location to another\&. "
.ti -1c
.RI "void * \fBmemset\fP (void *ptr, unsigned char value, uint64_t num)"
.br
.RI "Fills a block of memory with a specified value\&. "
.ti -1c
.RI "void * \fBmemset\fP (void *ptr, uint32_t value, uint64_t num)"
.br
.RI "Fills a block of memory with a specified value\&. "
.ti -1c
.RI "void * \fBmemmove\fP (void *destination, const void *source, uint64_t num)"
.br
.RI "Copies a block of memory from one location to another\&. "
.ti -1c
.RI "int \fBmemcmp\fP (const void *ptr1, const void *ptr2, uint64_t num)"
.br
.RI "Compares two blocks of memory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Implementation of memory-mapped I/O operations\&. 


.PP
\fBDate\fP
.RS 4
29th November 2022 
.RE
.PP
\fBAuthor\fP
.RS 4
Max Tyson 
.RE
.PP

.PP
Definition in file \fBmemoryIO\&.cpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "int memcmp (const void * ptr1, const void * ptr2, uint64_t num)"

.PP
Compares two blocks of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr1\fP The m_first_memory_chunk block of memory 
.br
\fIptr2\fP The second block of memory 
.br
\fInum\fP The number of bytes to compare 
.RE
.PP
\fBReturns\fP
.RS 4
0 if the blocks of memory are equal, -1 if ptr1 < ptr2, 1 if ptr1 > ptr2 
.RE
.PP

.PP
Definition at line \fB265\fP of file \fBmemoryIO\&.cpp\fP\&..PP
.nf
265                                                              {
266 
267     // Make sure the pointers exist
268     if (ptr1 == nullptr || ptr2 == nullptr)
269         return 0;
270 
271     const auto* p1 = (const unsigned char*) ptr1;
272     const auto* p2 = (const unsigned char*) ptr2;
273     for (size_t i = 0; i < num; i++) {
274         if (p1[i] < p2[i])
275             return \-1;
276         if (p1[i] > p2[i])
277             return 1;
278     }
279     return 0;
280 }
.fi

.SS "void * memcpy (void * destination, const void * source, uint64_t num)"

.PP
Copies a block of memory from one location to another\&. 
.PP
\fBSee also\fP
.RS 4
https://wiki.osdev.org/Meaty_Skeleton#memcpy.28.29
.RE
.PP
\fBParameters\fP
.RS 4
\fIdestination\fP The destination to copy to 
.br
\fIsource\fP The source to copy from 
.br
\fInum\fP The number of bytes to copy 
.RE
.PP
\fBReturns\fP
.RS 4
The destination 
.RE
.PP

.PP
Definition at line \fB165\fP of file \fBmemoryIO\&.cpp\fP\&..PP
.nf
165                                                                   {
166 
167     // Make sure the source and destination are not the same
168     if (destination == source)
169         return destination;
170 
171     // Make sure they exist
172     if (destination == nullptr || source == nullptr)
173         return destination;
174 
175     // Get the source and destination
176     auto* dst = (unsigned char*) destination;
177     const auto* src = (const unsigned char*) source;
178 
179     // Copy the data
180     for (size_t i = 0; i < num; i++)
181         dst[i] = src[i];
182 
183     // Usefully for easier code writing
184     return destination;
185 }
.fi

.PP
Referenced by \fBMaxOS::common::Buffer::copy_from()\fP, \fBMaxOS::common::Buffer::copy_from()\fP, \fBMaxOS::common::Buffer::copy_to()\fP, \fBMaxOS::common::Buffer::copy_to()\fP, \fBMaxOS::processes::SharedMessageEndpoint::read()\fP, \fBMaxOS::common::Buffer::resize()\fP, and \fBMaxOS::processes::Thread::Thread()\fP\&.
.SS "void * memmove (void * destination, const void * source, uint64_t num)"

.PP
Copies a block of memory from one location to another\&. 
.PP
\fBParameters\fP
.RS 4
\fIdestination\fP The destination to copy to 
.br
\fIsource\fP The source to copy from 
.br
\fInum\fP The number of bytes to copy 
.RE
.PP
\fBReturns\fP
.RS 4
The destination 
.RE
.PP

.PP
Definition at line \fB235\fP of file \fBmemoryIO\&.cpp\fP\&..PP
.nf
235                                                                    {
236 
237     // Make sure the source and destination are not the same
238     if (destination == source)
239         return destination;
240 
241     // Make sure they exist
242     if (destination == nullptr || source == nullptr)
243         return destination;
244 
245     auto* dst = (unsigned char*) destination;
246     const auto* src = (const unsigned char*) source;
247     if (dst < src) {
248         for (size_t i = 0; i < num; i++)
249             dst[i] = src[i];
250     } else {
251         for (size_t i = num; i != 0; i\-\-)
252             dst[i \- 1] = src[i \- 1];
253     }
254     return destination;
255 }
.fi

.PP
Referenced by \fBMaxOS::drivers::console::VESABootConsole::scroll_up()\fP\&.
.SS "void * memset (void * ptr, uint32_t value, uint64_t num)"

.PP
Fills a block of memory with a specified value\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP The pointer to the block of memory 
.br
\fIvalue\fP The value to fill the block of memory with 
.br
\fInum\fP The number of bytes to fill 
.RE
.PP
\fBReturns\fP
.RS 4
The pointer to the block of memory 
.RE
.PP

.PP
Definition at line \fB215\fP of file \fBmemoryIO\&.cpp\fP\&..PP
.nf
215                                                       {
216 
217     // Make sure the pointer exists
218     if (ptr == nullptr)
219         return ptr;
220 
221     auto* dst = (uint32_t*) ptr;
222     for (size_t i = 0; i < num; i++)
223         dst[i] = value;
224     return ptr;
225 }
.fi

.PP
Referenced by \fBMaxOS::common::Buffer::clear()\fP, \fBMaxOS::common::Buffer::full()\fP, and \fBMaxOS::drivers::console::VESABootConsole::print_logo()\fP\&.
.SS "void * memset (void * ptr, unsigned char value, uint64_t num)"

.PP
Fills a block of memory with a specified value\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP The pointer to the block of memory 
.br
\fIvalue\fP The value to fill the block of memory with 
.br
\fInum\fP The number of bytes to fill 
.RE
.PP
\fBReturns\fP
.RS 4
The pointer to the block of memory 
.RE
.PP

.PP
Definition at line \fB195\fP of file \fBmemoryIO\&.cpp\fP\&..PP
.nf
195                                                            {
196 
197     // Make sure the pointer exists
198     if (ptr == nullptr)
199         return ptr;
200 
201     auto* dst = (unsigned char*) ptr;
202     for (size_t i = 0; i < num; i++)
203         dst[i] = (unsigned char) value;
204     return ptr;
205 }
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

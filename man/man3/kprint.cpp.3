.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp" 3 "Sun Oct 13 2024" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <common/kprint\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBitoa\fP (int \fBbase\fP, uint64_t number)"
.br
.RI "Converts integer to string\&. "
.ti -1c
.RI "int \fBstrlen\fP (const char *str)"
.br
.RI "Gets the length of a string\&. "
.ti -1c
.RI "void \fBpre_kprintf\fP (const char *file, int line, const char *func, uint8_t \fBtype\fP)"
.br
.ti -1c
.RI "void \fB_kprintf_internal\fP (uint8_t \fBtype\fP, const char *file, int line, const char *func, const char *format,\&.\&.\&.)"
.br
.RI "Prints a formatted string to the serial output\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void _kprintf_internal (uint8_t type, const char * file, int line, const char * func, const char * format,  \&.\&.\&.)"

.PP
Prints a formatted string to the serial output\&. ARGUMENTS:
.IP "\(bu" 2
d for decimal
.IP "\(bu" 2
x for hex
.IP "\(bu" 2
u for unsigned decimal
.IP "\(bu" 2
s for string
.PP
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The formatted string 
.br
\fI\&.\&.\&.\fP The data to pass into the string 
.RE
.PP

.PP
Definition at line 155 of file kprint\&.cpp\&.
.PP
.nf
156 {
157 
158   // Print the header
159   pre_kprintf(file, line,func, type);
160 
161   // Create a pointer to the data
162   va_list parameters;
163   va_start(parameters, format);
164 
165   // Loop through the format string
166   for (; *format != '\0'; format++)
167   {
168 
169     // If it is not a %, print the character
170     if (*format != '%')
171     {
172       putchar(*format);
173       continue;
174     }
175 
176     // Move to the next character
177     format++;
178 
179     switch (*format)
180     {
181       case 'd':
182       {
183         // Print a decimal
184         int number = va_arg (parameters, int);
185         char* str = itoa(10, number);
186         for (int i = 0; i < strlen(str); i++)
187           putchar(str[i]);
188         break;
189       }
190       case 'x':
191       {
192         // Print a hex
193         uint64_t  number = va_arg (parameters, uint64_t );
194         char* str = itoa(16, number);
195         for (int i = 0; i < strlen(str); i++)
196           putchar(str[i]);
197         break;
198       }
199       case 's':
200       {
201         // Print a string
202         char* str = va_arg (parameters, char*);
203         for (int i = 0; i < strlen(str); i++)
204           putchar(str[i]);
205         break;
206       }
207     }
208   }
209 }
.fi
.PP
References pre_kprintf(), and type\&.
.SS "char* itoa (int base, uint64_t number)"

.PP
Converts integer to string\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to store the converted string 
.br
\fIbase\fP The base of the number (10 for decimal, 16 for hex) 
.br
\fInumber\fP The number to convert 
.RE
.PP

.PP
Definition at line 17 of file kprint\&.cpp\&.
.PP
.nf
18 {
19     static char buffer[50] = {0};
20     int i = 49;
21     bool isNegative = false;
22 
23     if (number == 0)
24     {
25         buffer[i] = '0';
26         return &buffer[i];
27     }
28 
29     if (number < 0 && base == 10)
30     {
31         isNegative = true;
32         number = -number;
33     }
34 
35     for (; number && i; --i, number /= base)
36         buffer[i] = "0123456789ABCDEF"[number % base];
37 
38     if (isNegative)
39     {
40         buffer[i] = '-';
41         return &buffer[i];
42     }
43 
44     return &buffer[i + 1];
45 }
.fi
.PP
References base, and MaxOS::drivers::peripherals::i\&.
.SS "void pre_kprintf (const char * file, int line, const char * func, uint8_t type)"
@ brief Prints a debug prefix (in yellow) to the serial output 
.PP
Definition at line 77 of file kprint\&.cpp\&.
.PP
.nf
78 {
79 
80   // Print the  colour
81   char* colour = "---------";
82   switch (type) {
83 
84     // Log (yellow)
85     case 0:
86       colour = "\033[1;33m";
87       break;
88 
89     // Assert (red)
90     case 3:
91       colour = "\033[1;31m";
92       break;
93   }
94 
95   for (int i = 0; i < strlen(colour); i++)
96     putchar(colour[i]);
97 
98   putchar('[');
99 
100   // File Output
101   if(type == 0){
102 
103     // Print the file (but not the path)
104     const char* file_str = file;
105     for (int i = strlen(file) - 1; i >= 0; i--)
106     {
107       if (file[i] == '/')
108       {
109         file_str = &file[i + 1];
110         break;
111       }
112     }\
113     for (int j = 0; j < strlen(file_str); j++)
114       putchar(file_str[j]);
115     putchar(':');
116 
117     // Print the line
118     const char* line_str = itoa(10, line);
119     for (int i = 0; i < strlen(line_str); i++)
120       putchar(line_str[i]);
121   }else{
122 
123     // Print the text
124     const char* text = "FATAL ERROR IN {";
125     for (int i = 0; i < strlen(text); i++)
126       putchar(text[i]);
127 
128     // Print the function
129     for (int i = 0; i < strlen(func); i++)
130       putchar(func[i]);
131 
132     putchar('}');
133   }
134 
135 
136   // Print the kernel footer
137   const char* footer = "] \033[0m";
138   for (int i = 0; i < strlen(footer); i++)
139     putchar(footer[i]);
140 
141 }
.fi
.PP
References MaxOS::drivers::peripherals::i, strlen(), and type\&.
.PP
Referenced by _kprintf_internal()\&.
.SS "int strlen (const char * str)"

.PP
Gets the length of a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to get the length of 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line 53 of file kprint\&.cpp\&.
.PP
.nf
54 {
55    int len = 0;
56    for (; str[len] != '\0'; len++);
57    return len;
58 }
.fi
.PP
Referenced by pre_kprintf()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

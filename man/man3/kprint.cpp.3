.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp" 3 "Sat Mar 29 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <common/kprint\&.h>\fP
.br
\fC#include <drivers/console/console\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBitoa\fP (int \fBbase\fP, uint64_t number)"
.br
.RI "Converts integer to string\&. "
.ti -1c
.RI "int \fBstrlen\fP (const char *str)"
.br
.RI "Gets the length of a string\&. "
.ti -1c
.RI "void \fBpre_kprintf\fP (const char *file, int line, const char *func, uint8_t \fBtype\fP)"
.br
.ti -1c
.RI "void \fB_kprintf_internal\fP (uint8_t \fBtype\fP, const char *file, int line, const char *func, const char *format,\&.\&.\&.)"
.br
.RI "Prints a formatted string to the serial output\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBConsoleStream\fP * \fBactive_stream\fP"
.br
.ti -1c
.RI "\fBSpinlock\fP \fBkprintf_lock\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void _kprintf_internal (uint8_t type, const char * file, int line, const char * func, const char * format,  \&.\&.\&.)"

.PP
Prints a formatted string to the serial output\&. ARGUMENTS:
.IP "\(bu" 2
d for decimal
.IP "\(bu" 2
x for hex
.IP "\(bu" 2
u for unsigned decimal
.IP "\(bu" 2
s for string
.PP
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The formatted string 
.br
\fI\&.\&.\&.\fP The data to pass into the string 
.RE
.PP

.PP
Definition at line 170 of file kprint\&.cpp\&.
.PP
.nf
171 {
172 
173   // wait for the lock
174   kprintf_lock\&.lock();
175 
176   // Create a pointer to the data
177   va_list parameters;
178   va_start(parameters, format);
179 
180   // Print the header if the first two are not %h
181   if(*format != '%' && *(format + 1) != 'h')
182     pre_kprintf(file, line,func, type);
183 
184 
185   // Loop through the format string
186   for (; *format != '\0'; format++)
187   {
188 
189     // If it is not a %, print the character
190     if (*format != '%')
191     {
192       putchar(*format, type == 2);
193       continue;
194     }
195 
196     // Move to the next character
197     format++;
198 
199     switch (*format)
200     {
201       case 'd':
202       {
203         // Print a decimal
204         int number = va_arg (parameters, int);
205         char* str = itoa(10, number);
206         for (int i = 0; i < strlen(str); i++)
207           putchar(str[i], type == 2);
208         break;
209       }
210       case 'x':
211       {
212         // Print a hex
213         uint64_t  number = va_arg (parameters, uint64_t );
214         char* str = itoa(16, number);
215         for (int i = 0; i < strlen(str); i++)
216           putchar(str[i], type == 2);
217         break;
218       }
219       case 's':
220       {
221         // Print a string
222         char* str = va_arg (parameters, char*);
223         for (int i = 0; i < strlen(str); i++)
224           putchar(str[i], type == 2);
225         break;
226       }
227     }
228   }
229 
230   kprintf_lock\&.unlock();
231 
232   // If it is type 3 panic
233   if(type == 3)
234      CPU::PANIC("Check the serial output for more information");
235 }
.fi
.PP
References kprintf_lock, MaxOS::common::Spinlock::lock(), pre_kprintf(), and type\&.
.SS "char* itoa (int base, uint64_t number)"

.PP
Converts integer to string\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to store the converted string 
.br
\fIbase\fP The base of the number (10 for decimal, 16 for hex) 
.br
\fInumber\fP The number to convert 
.RE
.PP

.PP
Definition at line 19 of file kprint\&.cpp\&.
.PP
.nf
20 {
21     static char buffer[50] = {0};
22     int i = 49;
23     bool isNegative = false;
24 
25     if (number == 0)
26     {
27         buffer[i] = '0';
28         return &buffer[i];
29     }
30 
31     //TODO: Handle negatives but then using an int64_t means we cant print higher half addresses in hex
32 
33     for (; number && i; --i, number /= base)
34         buffer[i] = "0123456789ABCDEF"[number % base];
35 
36     if (isNegative)
37     {
38         buffer[i] = '-';
39         return &buffer[i];
40     }
41 
42     return &buffer[i + 1];
43 }
.fi
.PP
References base, and MaxOS::drivers::peripherals::i\&.
.SS "void pre_kprintf (const char * file, int line, const char * func, uint8_t type)"
@ brief Prints a debug prefix (in yellow) to the serial output 
.PP
Definition at line 86 of file kprint\&.cpp\&.
.PP
.nf
87 {
88 
89   // Print the  colour
90   const char* colour = "---------";
91   switch (type) {
92 
93     // Log (yellow)
94     case 0:
95       colour = "\033[1;33m";
96       break;
97 
98     // Assert, Panic (red)
99     case 2:
100     case 3:
101       colour = "\033[0;31m";
102       break;
103 
104     default:
105       break;
106   }
107 
108   for (int i = 0; i < strlen(colour); i++)
109     putchar(colour[i]);
110 
111   putchar('[', type == 2);
112 
113   // File Output
114   if(type == 0){
115 
116     // Print the file (but not the path)
117     const char* file_str = file;
118     for (int i = strlen(file) - 1; i >= 0; i--)
119     {
120       if (file[i] == '/')
121       {
122         file_str = &file[i + 1];
123         break;
124       }
125     }\
126     for (int j = 0; j < strlen(file_str); j++)
127       putchar(file_str[j], type == 2);
128     putchar(':', type == 2);
129 
130     // Print the line
131     const char* line_str = itoa(10, line);
132     for (int i = 0; i < strlen(line_str); i++)
133       putchar(line_str[i], type == 2);
134   }else if(type == 3){
135 
136     // Print the text
137     const char* text = "FATAL ERROR IN {";
138     for (int i = 0; i < strlen(text); i++)
139       putchar(text[i], type == 2);
140 
141     // Print the function
142     for (int i = 0; i < strlen(func); i++)
143       putchar(func[i], type == 2);
144 
145     putchar('}', type == 2);
146   }
147 
148 
149   // Print the kernel footer
150   const char* footer = "] \033[0m";
151   for (int i = 0; i < strlen(footer); i++)
152     putchar(footer[i], type == 2);
153 
154 }
.fi
.PP
References MaxOS::drivers::peripherals::i, strlen(), and type\&.
.PP
Referenced by _kprintf_internal()\&.
.SS "int strlen (const char * str)"

.PP
Gets the length of a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to get the length of 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line 51 of file kprint\&.cpp\&.
.PP
.nf
52 {
53    int len = 0;
54    for (; str[len] != '\0'; len++);
55    return len;
56 }
.fi
.PP
Referenced by pre_kprintf()\&.
.SH "Variable Documentation"
.PP 
.SS "\fBConsoleStream\fP* active_stream"

.PP
Definition at line 91 of file kernel\&.cpp\&.
.PP
Referenced by kernelMain()\&.
.SS "\fBSpinlock\fP kprintf_lock"

.PP
Definition at line 156 of file kprint\&.cpp\&.
.PP
Referenced by _kprintf_internal()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

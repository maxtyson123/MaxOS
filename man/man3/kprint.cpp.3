.TH "/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp" 3 "Tue Feb 25 2025" "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/runner/work/MaxOS/MaxOS/kernel/src/common/kprint.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <common/kprint\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBitoa\fP (int \fBbase\fP, uint64_t number)"
.br
.RI "Converts integer to string\&. "
.ti -1c
.RI "int \fBstrlen\fP (const char *str)"
.br
.RI "Gets the length of a string\&. "
.ti -1c
.RI "void \fBpre_kprintf\fP (const char *file, int line, const char *func, uint8_t \fBtype\fP)"
.br
.ti -1c
.RI "void \fB_kprintf_internal\fP (uint8_t \fBtype\fP, const char *file, int line, const char *func, const char *format,\&.\&.\&.)"
.br
.RI "Prints a formatted string to the serial output\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void _kprintf_internal (uint8_t type, const char * file, int line, const char * func, const char * format,  \&.\&.\&.)"

.PP
Prints a formatted string to the serial output\&. ARGUMENTS:
.IP "\(bu" 2
d for decimal
.IP "\(bu" 2
x for hex
.IP "\(bu" 2
u for unsigned decimal
.IP "\(bu" 2
s for string
.PP
.PP
\fBParameters\fP
.RS 4
\fIformat\fP The formatted string 
.br
\fI\&.\&.\&.\fP The data to pass into the string 
.RE
.PP

.PP
Definition at line 157 of file kprint\&.cpp\&.
.PP
.nf
158 {
159   // Create a pointer to the data
160   va_list parameters;
161   va_start(parameters, format);
162 
163   // Print the header
164   if(*format != '\h')
165     pre_kprintf(file, line,func, type);
166   else
167     format++;
168 
169 
170   // Loop through the format string
171   for (; *format != '\0'; format++)
172   {
173 
174     // If it is not a %, print the character
175     if (*format != '%')
176     {
177       putchar(*format);
178       continue;
179     }
180 
181     // Move to the next character
182     format++;
183 
184     switch (*format)
185     {
186       case 'd':
187       {
188         // Print a decimal
189         int number = va_arg (parameters, int);
190         char* str = itoa(10, number);
191         for (int i = 0; i < strlen(str); i++)
192           putchar(str[i]);
193         break;
194       }
195       case 'x':
196       {
197         // Print a hex
198         uint64_t  number = va_arg (parameters, uint64_t );
199         char* str = itoa(16, number);
200         for (int i = 0; i < strlen(str); i++)
201           putchar(str[i]);
202         break;
203       }
204       case 's':
205       {
206         // Print a string
207         char* str = va_arg (parameters, char*);
208         for (int i = 0; i < strlen(str); i++)
209           putchar(str[i]);
210         break;
211       }
212     }
213   }
214 
215 
216   // If it is type 3 panic
217   if(type == 3)
218      CPU::PANIC("Check the serial output for more information");
219 
220 }
.fi
.PP
References pre_kprintf(), and type\&.
.SS "char* itoa (int base, uint64_t number)"

.PP
Converts integer to string\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP The buffer to store the converted string 
.br
\fIbase\fP The base of the number (10 for decimal, 16 for hex) 
.br
\fInumber\fP The number to convert 
.RE
.PP

.PP
Definition at line 18 of file kprint\&.cpp\&.
.PP
.nf
19 {
20     static char buffer[50] = {0};
21     int i = 49;
22     bool isNegative = false;
23 
24     if (number == 0)
25     {
26         buffer[i] = '0';
27         return &buffer[i];
28     }
29 
30     if (number < 0 && base == 10)
31     {
32         isNegative = true;
33         number = -number;
34     }
35 
36     for (; number && i; --i, number /= base)
37         buffer[i] = "0123456789ABCDEF"[number % base];
38 
39     if (isNegative)
40     {
41         buffer[i] = '-';
42         return &buffer[i];
43     }
44 
45     return &buffer[i + 1];
46 }
.fi
.PP
References base, and MaxOS::drivers::peripherals::i\&.
.SS "void pre_kprintf (const char * file, int line, const char * func, uint8_t type)"
@ brief Prints a debug prefix (in yellow) to the serial output 
.PP
Definition at line 78 of file kprint\&.cpp\&.
.PP
.nf
79 {
80 
81   // Print the  colour
82   char* colour = "---------";
83   switch (type) {
84 
85     // Log (yellow)
86     case 0:
87       colour = "\033[1;33m";
88       break;
89 
90     // Assert, Panic (red)
91     case 2:
92     case 3:
93       colour = "\033[1;31m";
94       break;
95   }
96 
97   for (int i = 0; i < strlen(colour); i++)
98     putchar(colour[i]);
99 
100   putchar('[');
101 
102   // File Output
103   if(type == 0){
104 
105     // Print the file (but not the path)
106     const char* file_str = file;
107     for (int i = strlen(file) - 1; i >= 0; i--)
108     {
109       if (file[i] == '/')
110       {
111         file_str = &file[i + 1];
112         break;
113       }
114     }\
115     for (int j = 0; j < strlen(file_str); j++)
116       putchar(file_str[j]);
117     putchar(':');
118 
119     // Print the line
120     const char* line_str = itoa(10, line);
121     for (int i = 0; i < strlen(line_str); i++)
122       putchar(line_str[i]);
123   }else if(type == 3){
124 
125     // Print the text
126     const char* text = "FATAL ERROR IN {";
127     for (int i = 0; i < strlen(text); i++)
128       putchar(text[i]);
129 
130     // Print the function
131     for (int i = 0; i < strlen(func); i++)
132       putchar(func[i]);
133 
134     putchar('}');
135   }
136 
137 
138   // Print the kernel footer
139   const char* footer = "] \033[0m";
140   for (int i = 0; i < strlen(footer); i++)
141     putchar(footer[i]);
142 
143 }
.fi
.PP
References MaxOS::drivers::peripherals::i, strlen(), and type\&.
.PP
Referenced by _kprintf_internal()\&.
.SS "int strlen (const char * str)"

.PP
Gets the length of a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to get the length of 
.RE
.PP
\fBReturns\fP
.RS 4
The length of the string 
.RE
.PP

.PP
Definition at line 54 of file kprint\&.cpp\&.
.PP
.nf
55 {
56    int len = 0;
57    for (; str[len] != '\0'; len++);
58    return len;
59 }
.fi
.PP
Referenced by pre_kprintf()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

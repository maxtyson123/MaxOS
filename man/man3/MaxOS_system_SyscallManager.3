.TH "MaxOS::system::SyscallManager" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::system::SyscallManager \- Provides an API for userspace applications to interact with the kernel\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <syscalls\&.h>\fP
.PP
Inherits \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSyscallManager\fP ()"
.br
.ti -1c
.RI "\fB~SyscallManager\fP ()"
.br
.ti -1c
.RI "\fBcpu_status_t\fP * \fBhandle_interrupt\fP (\fBcpu_status_t\fP *\fBesp\fP) \fBfinal\fP"
.br
.RI "Loads the args from the registers and delegates the syscall to the relevant handler if defined\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_syscall_handler\fP (::syscore::SyscallType \fBsyscall\fP, \fBsyscall_func_t\fP \fBhandler\fP)"
.br
.RI "Loads a syscall handler into the manager\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_syscall_handler\fP (::syscore::SyscallType \fBsyscall\fP)"
.br
.RI "Removes a syscall handler from the manager\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_close_process\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_klog\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_allocate_memory\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to free a block of memory\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_free_memory\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to free a block of memory\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_create\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to create a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_open\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to open a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_close\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_write\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to write to a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_read\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to read from a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_yield\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to yield the current process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_sleep\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to sleep the current process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_close\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a thread\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBsyscall_func_t\fP \fBm_syscall_handlers\fP [256] = {}"
.br
.ti -1c
.RI "\fBsyscall_args_t\fP * \fBm_current_args\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides an API for userspace applications to interact with the kernel\&. 
.PP
Definition at line \fB42\fP of file \fBsyscalls\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SyscallManager::SyscallManager ()"

.PP
Definition at line \fB17\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
18 : InterruptHandler(0x80)
19 {
20 
21     // Clear the args
22     Logger::INFO() << "Setting up Syscalls \\n";
23     m_current_args = new syscall_args_t;
24 
25     // Register the handlers
26     set_syscall_handler(SyscallType::CLOSE_PROCESS, syscall_close_process);
27     set_syscall_handler(SyscallType::KLOG, syscall_klog);
28     set_syscall_handler(SyscallType::ALLOCATE_MEMORY, syscall_allocate_memory);
29     set_syscall_handler(SyscallType::FREE_MEMORY, syscall_free_memory);
30     set_syscall_handler(SyscallType::RESOURCE_CREATE, syscall_resource_create);
31     set_syscall_handler(SyscallType::RESOURCE_OPEN, syscall_resource_open);
32     set_syscall_handler(SyscallType::RESOURCE_CLOSE, syscall_resource_close);
33     set_syscall_handler(SyscallType::RESOURCE_WRITE, syscall_resource_write);
34     set_syscall_handler(SyscallType::RESOURCE_READ, syscall_resource_read);
35     set_syscall_handler(SyscallType::THREAD_YIELD, syscall_thread_yield);
36     set_syscall_handler(SyscallType::THREAD_SLEEP, syscall_thread_sleep);
37     set_syscall_handler(SyscallType::THREAD_CLOSE, syscall_thread_close);
38 
39 }
.fi

.PP
References \fBLogger::INFO()\fP, \fBm_current_args\fP, \fBset_syscall_handler()\fP, \fBsyscall_allocate_memory()\fP, \fBsyscall_close_process()\fP, \fBsyscall_free_memory()\fP, \fBsyscall_klog()\fP, \fBsyscall_resource_close()\fP, \fBsyscall_resource_create()\fP, \fBsyscall_resource_open()\fP, \fBsyscall_resource_read()\fP, \fBsyscall_resource_write()\fP, \fBsyscall_thread_close()\fP, \fBsyscall_thread_sleep()\fP, and \fBsyscall_thread_yield()\fP\&.
.SS "SyscallManager::~SyscallManager ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBcpu_status_t\fP * SyscallManager::handle_interrupt (\fBcpu_status_t\fP * status)\fC [final]\fP"

.PP
Loads the args from the registers and delegates the syscall to the relevant handler if defined\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The cpu state 
.RE
.PP
\fBReturns\fP
.RS 4
The cpu state (may be modified with return value in RAX or a new state by the handler) 
.RE
.PP

.PP
Definition at line \fB49\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
49                                                                    {
50 
51     // Get the args from the cpu state
52     m_current_args\->arg0 = status\->rdi;
53     m_current_args\->arg1 = status\->rsi;
54     m_current_args\->arg2 = status\->rdx;
55     m_current_args\->arg3 = status\->r10;
56     m_current_args\->arg4 = status\->r8;
57     m_current_args\->arg5 = status\->r9;
58     m_current_args\->return_value = 0;
59     m_current_args\->return_state = status;
60 
61     // Call the handler
62     uint64_t syscall = status\->rax;
63     if (m_syscall_handlers[syscall] != nullptr)
64         m_current_args = m_syscall_handlers[syscall](m_current_args);
65     else
66         Logger::ERROR() << "Syscall " << syscall << " not found\\n";
67 
68     // If there is a specific return state, use that
69     if (m_current_args\->return_state != status)
70         return m_current_args\->return_state;
71 
72     // Update the cpu state
73     status\->rdi = m_current_args\->arg0;
74     status\->rsi = m_current_args\->arg1;
75     status\->rdx = m_current_args\->arg2;
76     status\->r10 = m_current_args\->arg3;
77     status\->r8 = m_current_args\->arg4;
78     status\->r9 = m_current_args\->arg5;
79     status\->rax = m_current_args\->return_value;
80 
81 
82     // Return the status
83     return status;
84 }
.fi

.PP
References \fBMaxOS::system::SyscallArguments::arg0\fP, \fBMaxOS::system::SyscallArguments::arg1\fP, \fBMaxOS::system::SyscallArguments::arg2\fP, \fBMaxOS::system::SyscallArguments::arg3\fP, \fBMaxOS::system::SyscallArguments::arg4\fP, \fBMaxOS::system::SyscallArguments::arg5\fP, \fBLogger::ERROR()\fP, \fBm_current_args\fP, \fBm_syscall_handlers\fP, \fBMaxOS::system::SyscallArguments::return_state\fP, \fBMaxOS::system::SyscallArguments::return_value\fP, and \fBstatus\fP\&.
.SS "\fBvoid\fP SyscallManager::remove_syscall_handler (::syscore::SyscallType syscall)"

.PP
Removes a syscall handler from the manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIsyscall\fP The syscall ID number 
.RE
.PP

.PP
Definition at line \fB102\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
102                                                                {
103 
104     m_syscall_handlers[(uint8_t) syscall] = nullptr;
105 }
.fi

.PP
References \fBm_syscall_handlers\fP\&.
.SS "\fBvoid\fP SyscallManager::set_syscall_handler (::syscore::SyscallType syscall, \fBsyscall_func_t\fP handler)"

.PP
Loads a syscall handler into the manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIsyscall\fP The syscall ID number 
.br
\fIhandler\fP The handler to set 
.RE
.PP

.PP
Definition at line \fB92\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
92                                                                                     {
93 
94     m_syscall_handlers[(uint8_t) syscall] = handler;
95 }
.fi

.PP
References \fBm_syscall_handlers\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_allocate_memory (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to free a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = size 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the memory block or null if failed 
.RE
.PP

.PP
Definition at line \fB151\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
151                                                                             {
152 
153     // Malloc the memory
154     size_t size = args\->arg0;
155     void* address = MemoryManager::malloc(size);
156 
157     // Return the address
158     args\->return_value = (uint64_t)address;
159     return args;
160 }
.fi

.PP
References \fBaddress\fP, \fBMaxOS::memory::MemoryManager::malloc()\fP, and \fBsize\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_close_process (\fBsystem::syscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = pid Arg1 = exit code 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB114\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
114                                                                                 {
115 
116     // Get the args
117     uint64_t pid = args\->arg0;
118     int exit_code = (int) args\->arg1;
119 
120     // Close the process
121     Process* process = pid == 0 ? Scheduler::current_process() : Scheduler::get_process(pid);
122     Scheduler::system_scheduler()\->remove_process(process);
123 
124     // Schedule the next process
125     cpu_status_t* next_process = Scheduler::system_scheduler()\->schedule_next(args\->return_state);
126     args\->return_state = next_process;
127 
128     // Done
129     return args;
130 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_process()\fP, \fBMaxOS::processes::Scheduler::get_process()\fP, and \fBMaxOS::processes::Scheduler::system_scheduler()\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_free_memory (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to free a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = address 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB168\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
168                                                                         {
169 
170     // Free the memory
171     void* address = (void*) args\->arg0;
172     MemoryManager::free(address);
173 
174     return args;
175 }
.fi

.PP
References \fBaddress\fP, and \fBMaxOS::memory::MemoryManager::free()\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_klog (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
Definition at line \fB132\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
132                                                                  {
133 
134     char* message = (char*) args\->arg0;
135 
136     // If the first two characters are %h then no header
137     if (message[0] == '%' && message[1] == 'h')
138         Logger::Out() << message + 2;
139     else
140         Logger::INFO() << ANSI_COLOURS[FG_Blue] << "(" << Scheduler::current_process()\->name\&.c_str() << ":" << Scheduler::current_thread()\->tid << "): " << ANSI_COLOURS[Reset] << message;
141 
142     return args;
143 }
.fi

.PP
References \fBMaxOS::common::ANSI_COLOURS\fP, \fBMaxOS::processes::Scheduler::current_process()\fP, \fBMaxOS::processes::Scheduler::current_thread()\fP, \fBMaxOS::common::FG_Blue\fP, \fBLogger::INFO()\fP, \fBLogger::Out()\fP, and \fBMaxOS::common::Reset\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_close (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB222\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
222                                                                            {
223 
224     // Parse params
225     auto handle = (uint64_t )args\->arg0;
226     auto flags  = (size_t)args\->arg1;
227 
228     // Close the resource
229     Scheduler::current_process()\->resource_manager\&.close_resource(handle, flags);
230     return args;
231 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_process()\fP, and \fBflags\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_create (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to create a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = ResourceType Arg1 = Name Arg2 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
1 if resource was created sucessfully, 0 otherwise 
.RE
.PP

.PP
Definition at line \fB183\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
183                                                                             {
184 
185     // Parse params
186     auto type   = (ResourceType)args\->arg0;
187     auto name   = (char*)args\->arg1;
188     auto flags  = (size_t)args\->arg2;
189 
190     // Try to create the resource
191     auto resource = GlobalResourceRegistry::get_registry(type)\->create_resource(name, flags);
192 
193     // Handle response
194     args\->return_value = resource ? 1 : 0;
195     return args;
196 }
.fi

.PP
References \fBflags\fP, \fBMaxOS::processes::GlobalResourceRegistry::get_registry()\fP, \fBname\fP, and \fBtype\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_open (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to open a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = ResourceType Arg1 = Name Arg2 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The handle of the resource or 0 if failed 
.RE
.PP

.PP
Definition at line \fB204\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
204                                                                           {
205 
206     // Parse params
207     auto type   = (ResourceType)args\->arg0;
208     auto name   = (char*)args\->arg1;
209     auto flags  = (size_t)args\->arg2;
210 
211     // Open the resource
212     args\->return_value = Scheduler::current_process()\->resource_manager\&.open_resource(type, name, flags);
213     return args;
214 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_process()\fP, \fBflags\fP, \fBname\fP, and \fBtype\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_read (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to read from a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Buffer Arg2 = Size Arg3 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes read or 0 if failed 
.RE
.PP

.PP
Definition at line \fB265\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
265                                                                           {
266 
267     // Parse params
268     auto handle = (uint64_t )args\->arg0;
269     auto buffer = (void*)args\->arg1;
270     auto size   = (size_t)args\->arg2;
271     auto flags  = (size_t)args\->arg3;
272 
273     // Open the resource
274     auto resource = Scheduler::current_process()\->resource_manager\&.get_resource(handle);
275     if(!resource){
276         args\->return_value = 0;
277         return args;
278     }
279 
280     // Write to the resource
281     args\->return_value = resource\->read(buffer,size,flags);
282     return args;
283 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_process()\fP, \fBflags\fP, and \fBsize\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_write (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to write to a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Buffer Arg2 = Size Arg3 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes written or 0 if failed 
.RE
.PP

.PP
Definition at line \fB239\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
239                                                                            {
240 
241     // Parse params
242     auto handle = (uint64_t )args\->arg0;
243     auto buffer = (void*)args\->arg1;
244     auto size   = (size_t)args\->arg2;
245     auto flags  = (size_t)args\->arg3;
246 
247     // Open the resource
248     auto resource = Scheduler::current_process()\->resource_manager\&.get_resource(handle);
249     if(!resource){
250         args\->return_value = 0;
251         return args;
252     }
253 
254     // Write to the resource
255     args\->return_value = resource\->write(buffer,size,flags);
256     return args;
257 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_process()\fP, \fBflags\fP, and \fBsize\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_close (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a thread\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = tid Arg1 = exit code 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB329\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
329                                                                          {
330 
331     // Get the args
332     uint64_t tid = args\->arg0;
333     int exit_code = (int) args\->arg1;
334 
335     // Get the thread if it is 0 then it is the current thread
336     Thread* thread = tid == 0 ? Scheduler::current_thread() : Scheduler::get_thread(tid);
337 
338     // Close the thread
339     Scheduler::get_process(thread\->parent_pid)\->remove_thread(tid);
340 
341     // Schedule the next thread
342     cpu_status_t* next_thread = Scheduler::system_scheduler()\->schedule_next(args\->return_state);
343     args\->return_state = next_thread;
344 
345     // Done
346     return args;
347 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_thread()\fP, \fBMaxOS::processes::Scheduler::get_process()\fP, \fBMaxOS::processes::Scheduler::get_thread()\fP, and \fBMaxOS::processes::Scheduler::system_scheduler()\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_sleep (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to sleep the current process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = milliseconds 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB307\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
307                                                                          {
308 
309     // Get the milliseconds
310     size_t milliseconds = args\->arg0;
311 
312     // Store the updated state in the thread as the scheduler will not have the updated state when switching to the next thread
313     Scheduler::current_thread()\->execution_state = args\->return_state;
314 
315     // Sleep the thread
316     cpu_status_t* next_thread = Scheduler::current_thread()\->sleep(milliseconds);
317     args\->return_state = next_thread;
318 
319     // Done
320     return args;
321 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_thread()\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_yield (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to yield the current process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Nothing 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB291\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
291                                                                          {
292 
293     // Yield
294     Scheduler::current_thread()\->execution_state = args\->return_state;
295     cpu_status_t* next_process = Scheduler::system_scheduler()\->yield();
296     args\->return_state = next_process;
297 
298     return args;
299 }
.fi

.PP
References \fBMaxOS::processes::Scheduler::current_thread()\fP, and \fBMaxOS::processes::Scheduler::system_scheduler()\fP\&.
.PP
Referenced by \fBSyscallManager()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBsyscall_args_t\fP* MaxOS::system::SyscallManager::m_current_args\fC [protected]\fP"

.PP
Definition at line \fB46\fP of file \fBsyscalls\&.h\fP\&.
.PP
Referenced by \fBhandle_interrupt()\fP, and \fBSyscallManager()\fP\&.
.SS "\fBsyscall_func_t\fP MaxOS::system::SyscallManager::m_syscall_handlers[256] = {}\fC [protected]\fP"

.PP
Definition at line \fB45\fP of file \fBsyscalls\&.h\fP\&..PP
.nf
45 {};
.fi

.PP
Referenced by \fBhandle_interrupt()\fP, \fBremove_syscall_handler()\fP, and \fBset_syscall_handler()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.

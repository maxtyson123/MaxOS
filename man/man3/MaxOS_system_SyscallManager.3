.TH "MaxOS::system::SyscallManager" 3 "Version 0.1" "Max OS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MaxOS::system::SyscallManager \- Provides an API for userspace applications to interact with the kernel\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <syscalls\&.h>\fP
.PP
Inherits \fBMaxOS::hardwarecommunication::InterruptHandler\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcpu_status_t\fP * \fBhandle_interrupt\fP (\fBcpu_status_t\fP *\fBesp\fP) \fBfinal\fP"
.br
.RI "Loads the args from the registers and delegates the syscall to the relevant handler if defined\&. "
.ti -1c
.RI "\fBvoid\fP \fBset_syscall_handler\fP (::syscore::SyscallType \fBsyscall\fP, \fBsyscall_func_t\fP \fBhandler\fP)"
.br
.RI "Loads a syscall handler into the manager\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_syscall_handler\fP (::syscore::SyscallType \fBsyscall\fP)"
.br
.RI "Removes a syscall handler from the manager\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_close_process\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_klog\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to log a message to the kernel log\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_allocate_memory\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to free a block of memory\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_free_memory\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to free a block of memory\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_create\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to create a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_open\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to open a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_close\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_write\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to write to a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_resource_read\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to read from a resource\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_yield\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to yield the current process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_sleep\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to sleep the current process\&. "
.ti -1c
.RI "\fBstatic\fP \fBsyscall_args_t\fP * \fBsyscall_thread_close\fP (\fBsyscall_args_t\fP *\fBargs\fP)"
.br
.RI "System call to close a thread\&. "
.in -1c
.SH "Detailed Description"
.PP 
Provides an API for userspace applications to interact with the kernel\&. 


.PP
\fBTodo\fP
.RS 4
Very c style, should be made class based that automatically registers 
.RE
.PP

.PP
Definition at line \fB53\fP of file \fBsyscalls\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SyscallManager::SyscallManager ()"

.PP
Definition at line \fB21\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
22 : InterruptHandler(0x80)
23 {
24 
25     // Register the handlers
26     Logger::INFO() << "Setting up Syscalls \\n";
27     set_syscall_handler(SyscallType::CLOSE_PROCESS, syscall_close_process);
28     set_syscall_handler(SyscallType::KLOG, syscall_klog);
29     set_syscall_handler(SyscallType::ALLOCATE_MEMORY, syscall_allocate_memory);
30     set_syscall_handler(SyscallType::FREE_MEMORY, syscall_free_memory);
31     set_syscall_handler(SyscallType::RESOURCE_CREATE, syscall_resource_create);
32     set_syscall_handler(SyscallType::RESOURCE_OPEN, syscall_resource_open);
33     set_syscall_handler(SyscallType::RESOURCE_CLOSE, syscall_resource_close);
34     set_syscall_handler(SyscallType::RESOURCE_WRITE, syscall_resource_write);
35     set_syscall_handler(SyscallType::RESOURCE_READ, syscall_resource_read);
36     set_syscall_handler(SyscallType::THREAD_YIELD, syscall_thread_yield);
37     set_syscall_handler(SyscallType::THREAD_SLEEP, syscall_thread_sleep);
38     set_syscall_handler(SyscallType::THREAD_CLOSE, syscall_thread_close);
39 
40 }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBcpu_status_t\fP * SyscallManager::handle_interrupt (\fBcpu_status_t\fP * status)\fC [final]\fP"

.PP
Loads the args from the registers and delegates the syscall to the relevant handler if defined\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP The cpu state 
.RE
.PP
\fBReturns\fP
.RS 4
The cpu state (may be modified with return value in RAX or a new state by the handler) 
.RE
.PP

.PP
Definition at line \fB50\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
50                                                                    {
51 
52     // Get the args from the cpu state
53     syscall_args_t args;
54     args\&.arg0 = status\->rdi;
55     args\&.arg1 = status\->rsi;
56     args\&.arg2 = status\->rdx;
57     args\&.arg3 = status\->r10;
58     args\&.arg4 = status\->r8;
59     args\&.arg5 = status\->r9;
60     args\&.return_value = 0;
61     args\&.return_state = status;
62 
63     // Call the handler
64     uint64_t syscall = status\->rax;
65     if (m_syscall_handlers[syscall] != nullptr)
66         args = *(m_syscall_handlers[syscall](&args));
67     else
68         Logger::ERROR() << "Syscall " << syscall << " not found\\n";
69 
70     // If there is a specific return state, use that
71     if (args\&.return_state != status)
72         return args\&.return_state;
73 
74     // Update the cpu state
75     status\->rdi = args\&.arg0;
76     status\->rsi = args\&.arg1;
77     status\->rdx = args\&.arg2;
78     status\->r10 = args\&.arg3;
79     status\->r8 = args\&.arg4;
80     status\->r9 = args\&.arg5;
81     status\->rax = args\&.return_value;
82 
83     // Return the status
84     return status;
85 }
.fi

.PP
References \fBLogger::ERROR()\fP\&.
.SS "\fBvoid\fP SyscallManager::remove_syscall_handler (::syscore::SyscallType syscall)"

.PP
Removes a syscall handler from the manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIsyscall\fP The syscall ID number 
.RE
.PP

.PP
Definition at line \fB103\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
103                                                                {
104 
105     m_syscall_handlers[(uint8_t) syscall] = nullptr;
106 }
.fi

.SS "\fBvoid\fP SyscallManager::set_syscall_handler (::syscore::SyscallType syscall, \fBsyscall_func_t\fP handler)"

.PP
Loads a syscall handler into the manager\&. 
.PP
\fBParameters\fP
.RS 4
\fIsyscall\fP The syscall ID number 
.br
\fIhandler\fP The handler to set 
.RE
.PP

.PP
Definition at line \fB93\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
93                                                                                     {
94 
95     m_syscall_handlers[(uint8_t) syscall] = handler;
96 }
.fi

.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_allocate_memory (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to free a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = size 
.RE
.PP
\fBReturns\fP
.RS 4
The address of the memory block or null if failed 
.RE
.PP

.PP
Definition at line \fB162\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
162                                                                             {
163 
164     // Malloc the memory
165     size_t size = args\->arg0;
166     void* address = MemoryManager::malloc(size);
167 
168     // Return the address
169     args\->return_value = (uint64_t)address;
170     return args;
171 }
.fi

.PP
References \fBMaxOS::memory::MemoryManager::malloc()\fP, and \fBsize\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_close_process (\fBsystem::syscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = pid Arg1 = exit code 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB115\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
115                                                                                 {
116 
117     // Get the args
118     uint64_t pid = args\->arg0;
119     int exit_code = (int) args\->arg1;
120 
121     // Close the process
122     Process* process = pid == 0 ? GlobalScheduler::current_process() : GlobalScheduler::get_process(pid);
123     GlobalScheduler::system_scheduler()\->remove_process(process);
124 
125     // Schedule the next process
126     cpu_status_t* next_process = GlobalScheduler::core_scheduler()\->schedule_next(args\->return_state);
127     args\->return_state = next_process;
128 
129     // Done
130     return args;
131 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::core_scheduler()\fP, \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBMaxOS::processes::GlobalScheduler::get_process()\fP, and \fBMaxOS::processes::GlobalScheduler::system_scheduler()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_free_memory (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to free a block of memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = address 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB179\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
179                                                                         {
180 
181     // Free the memory
182     void* address = (void*) args\->arg0;
183     MemoryManager::free(address);
184 
185     return args;
186 }
.fi

.PP
References \fBMaxOS::memory::MemoryManager::free()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_klog (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to log a message to the kernel log\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = message 
.RE
.PP
\fBReturns\fP
.RS 4
The same args structure 
.RE
.PP

.PP
Definition at line \fB139\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
139                                                                  {
140 
141     s_lock\&.lock();
142 
143     char* message = (char*) args\->arg0;
144 
145     // If the first two characters are %h then no header
146     if (message[0] == '%' && message[1] == 'h')
147         Logger::Out() << message + 2;
148     else
149         Logger::INFO() << message;
150 
151     s_lock\&.unlock();
152 
153     return args;
154 }
.fi

.PP
References \fBLogger::INFO()\fP, and \fBLogger::Out()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_close (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB233\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
233                                                                            {
234 
235     // Parse params
236     auto handle = (uint64_t )args\->arg0;
237     auto flags  = (size_t)args\->arg1;
238 
239     // Close the resource
240     GlobalScheduler::current_process()\->resource_manager\&.close_resource(handle, flags);
241     return args;
242 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP, and \fBflags\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_create (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to create a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = ResourceType Arg1 = Name Arg2 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
1 if resource was created sucessfully, 0 otherwise 
.RE
.PP

.PP
Definition at line \fB194\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
194                                                                             {
195 
196     // Parse params
197     auto type   = (ResourceType)args\->arg0;
198     auto name   = (char*)args\->arg1;
199     auto flags  = (size_t)args\->arg2;
200 
201     // Try to create the resource
202     auto resource = GlobalResourceRegistry::get_registry(type)\->create_resource(name, flags);
203 
204     // Handle response
205     args\->return_value = resource ? 1 : 0;
206     return args;
207 }
.fi

.PP
References \fBflags\fP, \fBMaxOS::processes::GlobalResourceRegistry::get_registry()\fP, \fBname\fP, and \fBtype\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_open (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to open a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = ResourceType Arg1 = Name Arg2 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The handle of the resource or 0 if failed 
.RE
.PP

.PP
Definition at line \fB215\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
215                                                                           {
216 
217     // Parse params
218     auto type   = (ResourceType)args\->arg0;
219     auto name   = (char*)args\->arg1;
220     auto flags  = (size_t)args\->arg2;
221 
222     // Open the resource
223     args\->return_value = GlobalScheduler::current_process()\->resource_manager\&.open_resource(type, name, flags);
224     return args;
225 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBflags\fP, \fBname\fP, and \fBtype\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_read (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to read from a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Buffer Arg2 = Size Arg3 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes read or 0 if failed 
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
276                                                                           {
277 
278     // Parse params
279     auto handle = (uint64_t )args\->arg0;
280     auto buffer = (void*)args\->arg1;
281     auto size   = (size_t)args\->arg2;
282     auto flags  = (size_t)args\->arg3;
283 
284     // Open the resource
285     auto resource = GlobalScheduler::current_process()\->resource_manager\&.get_resource(handle);
286     if(!resource){
287         args\->return_value = 0;
288         return args;
289     }
290 
291     // Write to the resource
292     args\->return_value = resource\->read(buffer,size,flags);
293     return args;
294 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBflags\fP, and \fBsize\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_resource_write (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to write to a resource\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = Handle Arg1 = Buffer Arg2 = Size Arg3 = Flags 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes written or 0 if failed 
.RE
.PP

.PP
Definition at line \fB250\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
250                                                                            {
251 
252     // Parse params
253     auto handle = (uint64_t )args\->arg0;
254     auto buffer = (void*)args\->arg1;
255     auto size   = (size_t)args\->arg2;
256     auto flags  = (size_t)args\->arg3;
257 
258     // Open the resource
259     auto resource = GlobalScheduler::current_process()\->resource_manager\&.get_resource(handle);
260     if(!resource){
261         args\->return_value = 0;
262         return args;
263     }
264 
265     // Write to the resource
266     args\->return_value = resource\->write(buffer,size,flags);
267     return args;
268 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_process()\fP, \fBflags\fP, and \fBsize\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_close (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to close a thread\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = tid Arg1 = exit code 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB335\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
335                                                                          {
336 
337     // Get the args
338     uint64_t tid = args\->arg0;
339     int exit_code = (int) args\->arg1;
340 
341     // Get the thread if it is 0 then it is the current thread
342     Thread* thread = tid == 0 ? GlobalScheduler::current_thread() : GlobalScheduler::get_thread(tid);
343     thread\->thread_state = ThreadState::STOPPED;
344 
345     // Schedule the next thread
346     if(tid == 0){
347         cpu_status_t* next_thread = GlobalScheduler::core_scheduler()\->schedule_next(args\->return_state);
348         args\->return_state = next_thread;
349     }
350 
351     // Done
352     return args;
353 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::core_scheduler()\fP, \fBMaxOS::processes::GlobalScheduler::current_thread()\fP, and \fBMaxOS::processes::GlobalScheduler::get_thread()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_sleep (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to sleep the current process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Arg0 = milliseconds 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB316\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
316                                                                          {
317 
318     // Get the milliseconds
319     size_t milliseconds = args\->arg0;
320 
321     // Sleep the thread
322     GlobalScheduler::current_thread()\->sleep(milliseconds);
323     args\->return_state = GlobalScheduler::yield(args\->return_state);
324 
325     // Done
326     return args;
327 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::current_thread()\fP, and \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.
.SS "\fBsyscall_args_t\fP * SyscallManager::syscall_thread_yield (\fBsyscall_args_t\fP * args)\fC [static]\fP"

.PP
System call to yield the current process\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Nothing 
.RE
.PP
\fBReturns\fP
.RS 4
Nothing 
.RE
.PP

.PP
Definition at line \fB302\fP of file \fBsyscalls\&.cpp\fP\&..PP
.nf
302                                                                          {
303 
304     // Yield
305     args\->return_state = GlobalScheduler::yield(args\->return_state);
306 
307     return args;
308 }
.fi

.PP
References \fBMaxOS::processes::GlobalScheduler::yield()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Max OS from the source code\&.
